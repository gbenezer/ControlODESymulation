---
title: "Anatomy of a Symbolic System"
subtitle: "Stochastic Batch Reactors"
author: "Gil Benezer"
date: today
format:
  html:
    toc: true
    toc-depth: 5
    code-fold: show
    code-tools: true
    theme: cosmo
execute:
  eval: true
  cache: true
  warning: false
---

This tutorial introduces the anatomy of a symbolic control system using a **stochastic batch reactor** as a worked example. A batch reactor is a closed chemical system where reactants $A$ and $B$ undergo sequential reactions governed by Arrhenius kinetics, with temperature controlled via external heating $Q$.

## System Overview

The system demonstrates key `cdesym` concepts:

- **State variables**: Concentrations $(C_A, C_B)$ and temperature $(T)$
- **Control input**: Heat input $(Q)$
- **Drift dynamics**: Deterministic reaction rates and heat transfer
- **Diffusion dynamics**: Additive noise on each state, representing measurement or process uncertainty

The reaction sequence $A \to B \to C$ follows first-order Arrhenius kinetics:

$$
\begin{aligned}
r_1 &= k_1 \cdot C_A \cdot \exp(-E_1/T) \\
r_2 &= k_2 \cdot C_B \cdot \exp(-E_2/T)
\end{aligned}
$$

The deterministic dynamics are:

$$
\begin{aligned}
\frac{dC_A}{dt} &= -r_1 \\
\frac{dC_B}{dt} &= r_1 - r_2 \\
\frac{dT}{dt} &= Q - \alpha(T - T_{\text{amb}})
\end{aligned}
$$

::: {.callout-note collapse="true"}
## Itô vs Stratonovich SDEs

The stochastic formulation in this example uses an **Itô SDE** of the form:

$$dX_t = f(X_t, u_t)\,dt + g(X_t)\,dW_t$$

where $W_t$ is a Wiener process (Brownian motion). The key distinction from **Stratonovich SDEs** lies in how the stochastic integral is defined:

| Property | Itô | Stratonovich |
|----------|-----|--------------|
| **Evaluation point** | Left endpoint of interval | Midpoint of interval |
| **Martingale property** | Yes (integral is a martingale) | No |
| **Chain rule** | Requires **Itô's lemma** with correction term | Standard chain rule applies |
| **Typical use** | Finance, control theory, probability | Physics, systems with colored noise limits |

**Itô's lemma** for a function $Y_t = h(X_t)$ includes an extra term:

$$dY_t = h'(X_t)\,dX_t + \frac{1}{2}h''(X_t)\,g(X_t)^2\,dt$$

The second term (absent in ordinary calculus) arises because Brownian paths have infinite quadratic variation.

**When the distinction matters**: For **state-dependent (multiplicative) noise** like $g(X_t) = \sigma X_t$, the two interpretations give different results. For **additive noise** where $g$ is constant, they coincide. This tutorial uses additive noise, so the choice is moot here—but understanding the difference is essential when modeling state-dependent noise.
:::

## Noise Structure

The stochastic batch reactor extends the deterministic model with additive process noise:

$$
\begin{aligned}
dC_A &= (-r_1)\,dt + \sigma_A\,dW_A \\
dC_B &= (r_1 - r_2)\,dt + \sigma_B\,dW_B \\
dT &= (Q - \alpha(T - T_{\text{amb}}))\,dt + \sigma_T\,dW_T
\end{aligned}
$$

Three independent Wiener processes model distinct physical noise sources: feed variability ($\sigma_A$, $\sigma_B$) and heat transfer fluctuations ($\sigma_T$). Trajectories fluctuate around the deterministic equilibrium with standard deviation growing as $\sqrt{t}$.

## What This Tutorial Covers

We define two equilibria:

1. **Complete conversion** (stable): All reactants consumed, temperature at ambient
2. **Initial setpoint** (unstable): Starting conditions for batch operation

The tutorial walks through defining `_f_sym` (drift), `diffusion_expr` (noise structure), how to define optional `_h_sym` (output map) and output variables if needed, then covers equilibrium setup and trajectory visualization.

## System Definition

The full system definition is as follows:
```{python}
from typing import Optional

import numpy as np
import sympy as sp

from cdesym import ContinuousStochasticSystem

class ContinuousStochasticBatchReactor(ContinuousStochasticSystem):
    def define_system(
        self,
        k1_val: float = 0.5,
        k2_val: float = 0.3,
        E1_val: float = 1000.0,
        E2_val: float = 1500.0,
        alpha_val: float = 0.1,
        T_amb_val: float = 300.0,
        sigma_A: float = 0.01,
        sigma_B: float = 0.01,
        sigma_T: float = 1.0,
        C_A0: Optional[float] = None,
        T0: Optional[float] = None,
    ):
        # Store initial conditions
        self.C_A0 = C_A0
        self.T0 = T0

        # State and control variables
        C_A, C_B, T = sp.symbols("C_A C_B T", real=True, positive=True)
        Q = sp.symbols("Q", real=True)

        # Deterministic Parameters (kinetics and heat transfer)
        k1, k2, E1, E2, alpha, T_amb = sp.symbols(
            "k1 k2 E1 E2 alpha T_amb",
            real=True,
            positive=True,
        )

        # Stochastic Parameters (noise intensities)
        sigma_A_sym = sp.symbols("sigma_A", real=True, positive=True)
        sigma_B_sym = sp.symbols("sigma_B", real=True, positive=True)
        sigma_T_sym = sp.symbols("sigma_T", real=True, positive=True)

        self.parameters = {
            k1: k1_val,
            k2: k2_val,
            E1: E1_val,
            E2: E2_val,
            alpha: alpha_val,
            T_amb: T_amb_val,
            sigma_A_sym: sigma_A,
            sigma_B_sym: sigma_B,
            sigma_T_sym: sigma_T,
        }

        self.state_vars = [C_A, C_B, T]
        self.control_vars = [Q]
        self.output_vars = []
        self.order = 1

        # Reaction rates (Arrhenius kinetics)
        r1 = k1 * C_A * sp.exp(-E1 / T)
        r2 = k2 * C_B * sp.exp(-E2 / T)

        # DRIFT (Deterministic part - same as deterministic reactor)
        dC_A_dt = -r1
        dC_B_dt = r1 - r2
        dT_dt = Q - alpha * (T - T_amb)

        self._f_sym = sp.Matrix([dC_A_dt, dC_B_dt, dT_dt])

        # DIFFUSION (Stochastic part - additive noise)
        # Diagonal matrix: three independent Wiener processes
        self.diffusion_expr = sp.Matrix(
            [
                [sigma_A_sym, 0, 0],
                [0, sigma_B_sym, 0],
                [0, 0, sigma_T_sym],
            ],
        )

        # Itô SDE interpretation
        self.sde_type = "ito"

        # Output: Full state measurement (with potential noise in practice)
        # technically optional
        self._h_sym = sp.Matrix([C_A, C_B, T])

    def setup_equilibria(self):
        # Get parameters
        T_amb = self.parameters[sp.symbols("T_amb")]

        # Complete conversion equilibrium (deterministic part)
        self.add_equilibrium(
            "complete",
            x_eq=np.array([0.0, 0.0, T_amb]),
            u_eq=np.array([0.0]),
            verify=True,
            stability="stable",
            notes="Equilibrium of deterministic part (drift). Stochastic trajectories "
            "fluctuate around this point with variance growing over time.",
        )

        # Initial condition (if provided)
        if self.C_A0 is not None and self.T0 is not None:
            alpha = self.parameters[sp.symbols("alpha")]
            Q_init = alpha * (self.T0 - T_amb)

            self.add_equilibrium(
                "initial",
                x_eq=np.array([self.C_A0, 0.0, self.T0]),
                u_eq=np.array([Q_init]),
                verify=False,
                stability="unstable",
                notes="Initial state setpoint (deterministic part). Stochastic trajectories "
                "will fluctuate with std ~ [σ_A·√t, σ_B·√t, σ_T·√t].",
            )
            self.set_default_equilibrium("initial")
        else:
            self.set_default_equilibrium("complete")
```

The first step in system construction is to subclass the proper symbolic system and create the define_system method signature.

```python
class ContinuousStochasticBatchReactor(ContinuousStochasticSystem):
    def define_system(
        self,
        k1_val: float = 0.5,
        k2_val: float = 0.3,
        E1_val: float = 1000.0,
        E2_val: float = 1500.0,
        alpha_val: float = 0.1,
        T_amb_val: float = 300.0,
        sigma_A: float = 0.01,
        sigma_B: float = 0.01,
        sigma_T: float = 1.0,
        C_A0: Optional[float] = None,
        T0: Optional[float] = None,
    ):
```

More often than not, the only arguments to this function will be the `self` argument and parameter values. It is not necessary to add type hints or default values, but it is recommended for debug purposes.

The next step in system definition is to define the (deterministic) symbolic variables to be used and place them in the proper fields.
The main limitation currently is that it is not possible to explicitly define a symbolic variable for time. If it is heavily requested, we can implement it as a future feature.

```python
# State and control variables
C_A, C_B, T = sp.symbols("C_A C_B T", real=True, positive=True)
Q = sp.symbols("Q", real=True)

# Deterministic Parameters (kinetics and heat transfer)
k1, k2, E1, E2, alpha, T_amb = sp.symbols(
    "k1 k2 E1 E2 alpha T_amb",
    real=True,
    positive=True,
)

# Stochastic Parameters (noise intensities)
sigma_A_sym = sp.symbols("sigma_A", real=True, positive=True)
sigma_B_sym = sp.symbols("sigma_B", real=True, positive=True)
sigma_T_sym = sp.symbols("sigma_T", real=True, positive=True)

self.parameters = {
    k1: k1_val,
    k2: k2_val,
    E1: E1_val,
    E2: E2_val,
    alpha: alpha_val,
    T_amb: T_amb_val,
    sigma_A_sym: sigma_A,
    sigma_B_sym: sigma_B,
    sigma_T_sym: sigma_T,
}

self.state_vars = [C_A, C_B, T]
self.control_vars = [Q]
self.output_vars = []
```

The necessary symbolic variables include:
    - State variables
    - Control variables
    - Parameter variables

::: {.callout-warning}
## Output Variables and the Output Map

There are two related but distinct concepts for system outputs:

- **`self.output_vars`**: A list of symbolic variables representing *computed outputs*—quantities derived from state variables but not states themselves. For example, if your states are position and velocity, an output variable might be kinetic energy. Do **not** add state variables to this list.

- **`self._h_sym`**: The *output map* $y = h(x)$, a symbolic column vector defining what the system actually outputs. This can include:
  - State variables (for full or partial state observation)
  - Output variables (computed quantities)
  - Any symbolic expression of states

**Defaults**: `self.output_vars = []` (no computed outputs) and `self._h_sym = state vector` (full state observability).

**Example**: For a system with states $[x, v]$ and a computed output $E = \frac{1}{2}mv^2$:

- `self.output_vars = [E]`
- `self._h_sym = sp.Matrix([x, E])` outputs position and energy (but not velocity)
:::

::: {.callout-warning}
## Autonomous Systems
To specify that a system is autonomous and has no control variables, you must pass an empty list to the self.control_vars field. 
:::

::: {.callout-important}
## Parameter Dictionary Keys Must Be Symbolic Variables
A common mistake is to set the dictionary keys for self.parameters as strings, but for proper symbolic substitution and code generation, the keys must be SymPy Symbolic variables.
:::

The final required step in system definition is to relate symbolic variables for the definition of the system (and possibly observation) dynamics.

```python
# Reaction rates (Arrhenius kinetics)
r1 = k1 * C_A * sp.exp(-E1 / T)
r2 = k2 * C_B * sp.exp(-E2 / T)

# DRIFT (Deterministic part - same as deterministic reactor)
dC_A_dt = -r1
dC_B_dt = r1 - r2
dT_dt = Q - alpha * (T - T_amb)

self._f_sym = sp.Matrix([dC_A_dt, dC_B_dt, dT_dt])

# DIFFUSION (Stochastic part - additive noise)
# Diagonal matrix: three independent Wiener processes
self.diffusion_expr = sp.Matrix(
    [
        [sigma_A_sym, 0, 0],
        [0, sigma_B_sym, 0],
        [0, 0, sigma_T_sym],
    ],
)
```

::: {.callout-note}
## Diffusion Matrix Structure

The diffusion matrix $G$ has dimensions $(n_{\text{states}} \times n_{\text{Wiener}})$, where each column corresponds to an independent Wiener process and each row to a state variable. The stochastic term in the SDE is $G\,dW_t$ where $dW_t$ is a vector of independent Wiener increments.

**Why a matrix, not a vector?** A vector would only allow one noise source affecting all states with fixed relative magnitudes. The matrix form enables:

- **Diagonal matrices** (as above): Each state has its own independent noise source. The $i$-th Wiener process affects only the $i$-th state.

- **Off-diagonal elements**: Represent *correlated noise*—when a single physical noise source affects multiple states. For example, if temperature fluctuations also induced concentration measurement errors:
  ```python
  self.diffusion_expr = sp.Matrix([
      [sigma_A_sym, 0, sigma_AT],  # C_A affected by W_A and W_T
      [0, sigma_B_sym, 0],
      [0, 0, sigma_T_sym],
  ])
  ```

- **Non-square matrices**: You can have fewer Wiener processes than states (correlated noise) or more (redundant noise sources for modeling flexibility).

**Dimensions expected**: For $n$ state variables and $m$ independent Wiener processes, `diffusion_expr` should be an $n \times m$ SymPy Matrix.
:::

```python
# Output: Full state measurement (with potential noise in practice)
# technically optional
self._h_sym = sp.Matrix([C_A, C_B, T])
```

::: {.callout-note}
## Pure Diffusion Systems
To define purely stochastic systems with only diffusion terms and no drift terms, self._f_sym must be defined as a symbolic column vector of zero elements with the same dimensionality as the number of state variables.
:::

## Required vs Optional System Definition Elements

Understanding what's required versus optional helps you define systems efficiently while maintaining clarity. Here's the complete breakdown:

::: {.callout-important}
## Required Elements

Every `define_system()` method **must** define:

1. **`self.state_vars`**: List of state variable symbols
   ```python
   self.state_vars = [C_A, C_B, T]
   ```

2. **`self.control_vars`**: List of control variable symbols (empty list `[]` for autonomous systems)
   ```python
   self.control_vars = [Q]  # or [] for autonomous
   ```

3. **`self.parameters`**: Dictionary mapping symbolic parameters to numerical values
   ```python
   self.parameters = {k1: 0.5, k2: 0.3, ...}
   ```

4. **`self._f_sym`**: Symbolic expression for system dynamics (drift for SDEs)
   ```python
   self._f_sym = sp.Matrix([dC_A_dt, dC_B_dt, dT_dt])
   ```

5. **`self.diffusion_expr`** (stochastic systems only): Diffusion matrix for SDE noise structure
   ```python
   self.diffusion_expr = sp.Matrix([[sigma_A, 0, 0], ...])
   ```
:::

::: {.callout-tip}
## Optional Elements with Sensible Defaults

These fields have **automatic defaults** if not specified:

### `self.output_vars` (default: `[]`)
List of computed output symbols (not states). Leave empty if you only observe states.
```python
self.output_vars = []  # Default - no computed outputs
```

### `self._h_sym` (default: full state vector)
Output map $y = h(x)$. If not specified, defaults to observing all states.
```python
# Explicitly set (same as default for our reactor):
self._h_sym = sp.Matrix([C_A, C_B, T])

# If omitted, framework uses: self._h_sym = sp.Matrix(self.state_vars)
```

### `self.order` (default: `1`)
System order defines how you represent system dynamics. Nearly all systems use `order=1` (first-order state-space form). See the detailed explanation below for when higher-order forms are useful.
```python
self.order = 1  # Default - first-order state-space form
```

### `self.sde_type` (default: `"ito"`)
For stochastic systems, specifies SDE interpretation.
```python
self.sde_type = "ito"  # Default
# Alternative: self.sde_type = "stratonovich"
```
:::

::: {.callout-tip}
## Optional Methods

### `setup_equilibria()`
If defined, automatically called after system initialization to add equilibria. Useful when equilibria depend on system parameters.

```python
def setup_equilibria(self):
    # Add parameter-dependent equilibria
    T_amb = self.parameters[sp.symbols("T_amb")]
    self.add_equilibrium("complete", x_eq=np.array([0.0, 0.0, T_amb]), ...)
```

If not defined, only the origin equilibrium is added by default.

### Custom Methods and Fields
You can add any additional methods or fields that don't conflict with base class names:
```python
def define_system(self, ...):
    # ... standard setup ...
    
    # Custom fields for your application
    self.C_A0 = C_A0  # Store initial condition
    self.reaction_pathway = "A->B->C"
    
def compute_conversion_rate(self, C_A_current):
    """Custom method for domain-specific calculations."""
    return (self.C_A0 - C_A_current) / self.C_A0
```
:::

For our batch reactor, we **explicitly set** most optional fields for documentation purposes, but only `self.order` and `self.sde_type` are redundant (they match defaults).
:::

### Understanding System Order in Detail

::: {.callout-note collapse="true"}
## System Order: First-Order vs Higher-Order Forms

The `self.order` field specifies how you represent the system dynamics. There are two mathematically equivalent ways to define systems:

### First-Order State-Space Form (order=1, **default**)

The system is written in first-order form where `self._f_sym` returns **all** time derivatives.

**Example: Second-order pendulum** with states $x = [\theta, \dot{\theta}]$

```python
self.state_vars = [theta, theta_dot]  # Both position and velocity
self._f_sym = sp.Matrix([
    theta_dot,                          # d(theta)/dt
    -(g/L)*sp.sin(theta) - (b/m)*theta_dot + u/m  # d(theta_dot)/dt
])
self.order = 1  # Returns ALL derivatives [d(theta)/dt, d(theta_dot)/dt]
```

This is the **standard state-space form** used in control theory. For an $n$-th order physical system with generalized coordinate $q$, the state is:

$$x = [q, \dot{q}, \ddot{q}, \ldots, q^{(n-1)}]$$

and `self._f_sym` returns the full derivative vector:

$$\frac{dx}{dt} = [\dot{q}, \ddot{q}, \ldots, q^{(n)}]$$

### Higher-Order Form (order=n)

The system is written in higher-order form where `self._f_sym` returns **only the highest** derivative.

**Example: Same pendulum** with `order=2`

```python
self.state_vars = [theta, theta_dot]  # Still both variables
self._f_sym = sp.Matrix([
    -(g/L)*sp.sin(theta) - (b/m)*theta_dot + u/m  # ONLY d²(theta)/dt²
])
self.order = 2  # Returns ONLY highest derivative d²(theta)/dt²
```

The state vector is the same $x = [\theta, \dot{\theta}]$, but `self._f_sym` only returns $\ddot{\theta}$. The framework **automatically constructs** the full first-order representation during linearization by adding the kinematic relationships:

$$\frac{d\theta}{dt} = \dot{\theta}, \quad \frac{d\dot{\theta}}{dt} = \ddot{\theta}$$

### When to Use Each Form

- **First-order (order=1)**: 
  - **Use this for most systems** - it's explicit and standard
  - Required when dynamics aren't naturally hierarchical
  - Example: Our batch reactor has independent first derivatives for $C_A$, $C_B$, and $T$

- **Higher-order (order=n)**:
  - Natural for mechanical systems (position → velocity → acceleration)
  - More compact when you have $\ddot{q} = f(q, \dot{q}, u)$ form
  - Example: Robotics, where you directly compute joint accelerations

### Requirements

- For `order=n > 1`: The number of states must be divisible by `n` (i.e., `nx % n == 0`)
- State variables should be ordered as $[q_1, \ldots, q_m, \dot{q}_1, \ldots, \dot{q}_m, \ldots]$ for proper automatic construction
- The framework handles all conversions transparently during linearization

### This Tutorial

Our batch reactor uses **order=1** (default) because the three state variables $(C_A, C_B, T)$ have independent first-order dynamics—there's no natural hierarchy to exploit.
:::

## Equilibrium Setup Example

Our reactor's `setup_equilibria()` method demonstrates how to define parameter-dependent equilibria: 

```python
def setup_equilibria(self):
    # Get parameters
    T_amb = self.parameters[sp.symbols("T_amb")]

    # Complete conversion equilibrium (deterministic part)
    self.add_equilibrium(
        "complete",
        x_eq=np.array([0.0, 0.0, T_amb]),
        u_eq=np.array([0.0]),
        verify=True,
        stability="stable",
        notes="Equilibrium of deterministic part (drift). Stochastic trajectories "
        "fluctuate around this point with variance growing over time.",
    )

    # Initial condition (if provided)
    if self.C_A0 is not None and self.T0 is not None:
        alpha = self.parameters[sp.symbols("alpha")]
        Q_init = alpha * (self.T0 - T_amb)

        self.add_equilibrium(
            "initial",
            x_eq=np.array([self.C_A0, 0.0, self.T0]),
            u_eq=np.array([Q_init]),
            verify=False,
            stability="unstable",
            notes="Initial state setpoint (deterministic part). Stochastic trajectories "
            "will fluctuate with std ~ [σ_A·√t, σ_B·√t, σ_T·√t].",
        )
        self.set_default_equilibrium("initial")
    else:
        self.set_default_equilibrium("complete")
```

## Summary: Building Your System

To define a symbolic system in ControlDESymulation:

**Minimum viable system:**
```python
def define_system(self):
    # 1. Define symbolic variables
    x = sp.symbols('x')
    u = sp.symbols('u')
    
    # 2. Set required fields
    self.state_vars = [x]
    self.control_vars = [u]  # or [] for autonomous
    self.parameters = {}     # or {param: value}
    self._f_sym = sp.Matrix([...])  # Your dynamics
    
    # 3. For stochastic systems, add:
    # self.diffusion_expr = sp.Matrix([...])
```

**Well-documented system (recommended):**
```python
def define_system(self, param1=1.0, param2=2.0):
    # 1. Define all symbolic variables
    x, y = sp.symbols('x y')
    u = sp.symbols('u')
    p1, p2 = sp.symbols('p1 p2', positive=True)
    
    # 2. Set required fields
    self.state_vars = [x, y]
    self.control_vars = [u]
    self.parameters = {p1: param1, p2: param2}
    self._f_sym = sp.Matrix([...])
    
    # 3. Explicitly set optional fields for clarity
    self.output_vars = []           # No computed outputs
    self._h_sym = sp.Matrix([x, y]) # Observe full state
    self.order = 1                  # First-order form
    
    # 4. For stochastic systems:
    # self.diffusion_expr = sp.Matrix([...])
    # self.sde_type = "ito"  # or "stratonovich"

def setup_equilibria(self):
    # Optional: Add parameter-dependent equilibria
    self.add_equilibrium("my_equilibrium", x_eq=..., u_eq=...)
```

The reactor example in this tutorial follows the well-documented approach.

TODO: go over basic trajectory and phase plotting
