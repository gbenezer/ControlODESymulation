---
title: "ControlDESymulation Numerical Integration Framework Architecture"
subtitle: "ControlDESymulation Architecture Documentation"
author: "Gil Benezer"
date: today
format:
  html:
    toc: true
    code-fold: show
    code-tools: true
execute:
  eval: true      # Execute all code blocks
  cache: true     # Cache results
  warning: false  # Suppress warnings
---

## Overview {#sec-overview}

The numerical integration framework provides **multi-backend**, **multi-method** support for integrating both **deterministic ODEs** and **stochastic SDEs**. The framework consists of **13 core files** organized into a clean 2-track architecture: deterministic and stochastic.

## Architecture Tracks {#sec-architecture-tracks}

```
Track 1: Deterministic ODE Integration
├── IntegratorBase (abstract)
├── IntegratorFactory (creates integrators)
├── Backend-Specific Implementations:
│   ├── ScipyIntegrator (NumPy)
│   ├── TorchDiffEqIntegrator (PyTorch)
│   ├── DiffraxIntegrator (JAX)
│   └── DiffEqPyIntegrator (Julia)
└── FixedStepIntegrators (RK4, Euler, Midpoint)

Track 2: Stochastic SDE Integration
├── SDEIntegratorBase (extends IntegratorBase)
├── SDEIntegratorFactory (creates SDE integrators)
├── Backend-Specific Implementations:
│   ├── TorchSDEIntegrator (PyTorch)
│   ├── DiffraxSDEIntegrator (JAX)
│   └── DiffEqPySDEIntegrator (Julia)
└── CustomBrownianPath (custom noise support)
```

## File Breakdown {#sec-file-breakdown}

### Track 1: Deterministic ODE Integration {#sec-track-1-deterministic-ode-integration}

#### IntegratorBase {#sec-integratorbase}
**File:** `integrator_base.py` (512 lines)

**Purpose:** Abstract base class for all numerical integrators

**Key Features:**

- Defines unified interface for all integrators
- StepMode enum (FIXED vs ADAPTIVE)
- Performance statistics tracking
- TypedDict-based IntegrationResult

**Abstract Methods:**

- step(x, u, dt) → x_next                            # Single integration step
- integrate(x0, u_func, t_span) → IntegrationResult  # Multi-step
- name: str                                          # Integrator identifier

**Attributes:**

- system: ContinuousSystemBase     # System to integrate
- dt: float                        # Time step (or initial guess)
- step_mode: StepMode              # FIXED or ADAPTIVE
- backend: Backend                 # 'numpy', 'torch', 'jax'
- rtol, atol: float                # Error tolerances (adaptive)
- _stats: dict                     # Performance tracking

---

#### IntegratorFactory {#sec-integratorfactory}
**File:** `integrator_factory.py` (1,267 lines)

**Purpose:** Factory for creating appropriate integrators

**Key Features:**

- Automatic backend/method selection
- Method-to-backend routing
- Use case-specific helpers
- Comprehensive method registry

**Available Backends:**

- **NumPy:** scipy, DiffEqPy (Julia), manual methods
- **PyTorch:** torchdiffeq
- **JAX:** diffrax

**Factory Methods:**

```{python}
#| label: setup-imports
#| output: false
#| echo: false

# Setup for all code examples in this document
import numpy as np
import torch
import jax
import jax.numpy as jnp
from diffeqpy import de
from cdesym import (
    ContinuousSymbolicSystem,
    Pendulum,
    IntegratorFactory,
    ContinuousStochasticSystem,
    SDEIntegratorFactory,
    OrnsteinUhlenbeck,
)
SEED = 42

# Create system (e.g., pendulum)
system = Pendulum(m_val=1.0, l_val=0.5)

# Create initial conditions
x0_pendulum_numpy = np.array([1.0, 0.0])
x0_pendulum_torch = torch.tensor([1.0, 0.0])
x0_pendulum_jax = jnp.array([1.0, 0.0])

# Create control function (required for integrate)
# NOTE:
# must have the signature u(t, x) -> u
# Integration of autonomous systems require None output
# Integration of non-autonomous systems in open loop manner requires
# 1D zero output
u_func = lambda t, x: np.zeros(1)

# Create SDE system (e.g., Ornstein-Uhlenbeck)
sde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)

# get number of noise variables
nw = sde_system.nw

# Create SDE initial conditions
x0_sde_numpy = np.array([0.5])
x0_sde_torch = torch.tensor([0.5])
x0_sde_jax = jnp.array([0.5])

# same u_func will work for SDE
```

**Method Registry:**

| Method | Backend | Type | Best For |
|--------|---------|------|----------|
| LSODA | NumPy (scipy) | Adaptive | General (auto-stiffness) |
| RK45 | NumPy (scipy) | Adaptive | Non-stiff ODEs |
| Radau | NumPy (scipy) | Adaptive | Stiff ODEs |
| BDF | NumPy (scipy) | Adaptive | Very stiff ODEs |
| Tsit5 | NumPy (Julia) | Adaptive | High performance |
| Vern9 | NumPy (Julia) | Adaptive | High accuracy |
| Rodas5 | NumPy (Julia) | Adaptive | Stiff (Rosenbrock) |
| dopri5 | PyTorch/JAX | Adaptive | Neural ODEs |
| dopri8 | PyTorch/JAX | Adaptive | High accuracy |
| tsit5 | JAX (diffrax) | Adaptive | Optimization |
| euler | Any | Fixed | Educational |
| rk4 | Any | Fixed | Simple systems |

---

#### ScipyIntegrator {#sec-scipyintegrator}
**File:** `scipy_integrator.py** (~620 lines estimate)

**Purpose:** Adaptive integration using scipy.integrate.solve_ivp

**Supported Methods:**

- **RK45** (default): Dormand-Prince 5(4) - general purpose
- **RK23**: Bogacki-Shampine 3(2) - fast, low accuracy
- **DOP853**: Dormand-Prince 8(5,3) - high accuracy
- **Radau**: Implicit RK - stiff systems
- **BDF**: Backward differentiation - very stiff
- **LSODA**: Auto stiffness detection

**Key Features:**

- Professional-grade adaptive stepping
- Error control (rtol/atol)
- Dense output (interpolation)
- Event detection
- Both controlled and autonomous systems

**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.scipy_integrator import ScipyIntegrator
integrator = ScipyIntegrator(
    system,
    method='RK45',
    rtol=1e-6,
    atol=1e-8
)
result = integrator.integrate(x0_pendulum_numpy, u_func, t_span=(0, 10))
```

---

#### TorchDiffEqIntegrator {#sec-torchdiffeqintegrator}
**File:** `torchdiffeq_integrator.py` (estimated ~800 lines)

**Purpose:** PyTorch integration with GPU acceleration and autograd

**Supported Methods:**

- **dopri5**: Dormand-Prince 5(4)
- **dopri8**: Dormand-Prince 8
- **adaptive_heun**: Heun's method
- **bosh3**: Bogacki-Shampine 3
- **fehlberg2**: Fehlberg 2(1)
- **explicit_adams**, **implicit_adams**: Multi-step methods

**Key Features:**

- GPU acceleration
- Automatic differentiation
- Adjoint method for memory efficiency
- Neural ODE support

**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.torchdiffeq_integrator import TorchDiffEqIntegrator
integrator = TorchDiffEqIntegrator(
    system,
    method='dopri5',
    backend='torch',
    device='cuda:0'
)
result = integrator.integrate(x0_pendulum_torch, u_func, t_span=(0, 10))
```

---

#### DiffraxIntegrator {#sec-diffraxintegrator}
**File:** `diffrax_integrator.py` (estimated ~700 lines)

**Purpose:** JAX integration with XLA compilation and autograd

**Supported Methods:**

- **tsit5**: Tsitouras 5(4) - recommended
- **dopri5**: Dormand-Prince 5(4)
- **dopri8**: Dormand-Prince 8
- **heun**: Heun's method
- **ralston**: Ralston's method
- **reversible_heun**: Reversible Heun

**Key Features:**

- XLA compilation
- JAX transformations (jit, vmap, grad)
- Efficient for optimization
- Functional programming style

**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.diffrax_integrator import DiffraxIntegrator
integrator = DiffraxIntegrator(
    system,
    method='tsit5',
    backend='jax'
)
result = integrator.integrate(x0_pendulum_jax, u_func, t_span=(0, 10))
```

---

#### DiffEqPyIntegrator {#sec-diffeqpyintegrator}
**File:** `diffeqpy_integrator.py` (estimated ~900 lines)

**Purpose:** Julia's DifferentialEquations.jl via Python bindings

**Supported Methods:**

Extensive Julia solver ecosystem:

- **Explicit RK:** Tsit5, Vern6, Vern7, Vern8, Vern9, DP5, DP8
- **Rosenbrock:** Rosenbrock23, Rosenbrock32, Rodas4, Rodas5
- **BDF:** TRBDF2, KenCarp3, KenCarp4, KenCarp5
- **Radau:** RadauIIA5
- **Stabilized:** ROCK2, ROCK4
- **Symplectic:** VelocityVerlet, SymplecticEuler
- **Auto-switching:** AutoTsit5(Rosenbrock23()), AutoVern7(Rodas5())

**Key Features:**

- Highest performance
- Automatic stiffness detection
- Extensive method library
- Production-grade reliability

**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.diffeqpy_integrator import DiffEqPyIntegrator
integrator = DiffEqPyIntegrator(
    system,
    algorithm='Vern9',
    backend='numpy',
    reltol=1e-12,
    abstol=1e-14
)
result = integrator.integrate(x0_pendulum_numpy, u_func, t_span=(0, 10))
```

---

#### FixedStepIntegrators {#sec-fixedstepintegrators}
**File:** `fixed_step_integrators.py` (estimated ~600 lines)

**Purpose:** Manual implementation of fixed-step methods

**Supported Methods:**

- **euler**: Forward Euler (order 1)
- **midpoint**: Midpoint method (order 2)
- **rk4**: Runge-Kutta 4 (order 4)

**Key Features:**

- Backend-agnostic (NumPy, PyTorch, JAX)
- Simple, transparent implementations
- Educational value
- Constant time step

**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.fixed_step_integrators import RK4Integrator
integrator = RK4Integrator(
    system,
    dt=0.01,
    backend='numpy'
)
result = integrator.integrate(x0_pendulum_numpy, u_func, t_span=(0, 10))
```

---

### Track 2: Stochastic SDE Integration {#sec-track-2-stochastic-sde-integration}

#### SDEIntegratorBase {#sec-sdeintegratorbase}
**File:** `sde_integrator_base.py` (1,080 lines)

**Purpose:** Abstract base for SDE integrators

**Mathematical Form:**
```
dx = f(x, u, t)dt + g(x, u, t)dW
```
where:

- f: Drift (deterministic)
- g: Diffusion (stochastic intensity)
- dW: Brownian motion increments

**Key Differences from ODE:**

- Random noise generation
- Weak vs strong convergence
- Noise structure exploitation
- Monte Carlo simulation support
- Itô vs Stratonovich interpretation

**Abstract Methods:**

- step(x, u, dt, dW) → x_next      # Single SDE step with noise
- integrate(x0, u_func, t_span) → SDEIntegrationResult
- integrate_monte_carlo(x0, u_func, t_span, n_paths) → SDEIntegrationResult

---

#### SDEIntegratorFactory {#sec-sdeintegratorfactory}
**File:** `sde_integrator_factory.py` (estimated ~1,000 lines)

**Purpose:** Factory for creating SDE integrators

**Factory Methods:**
```{python}
#| output: false
#| execute: false
# create(sde_system, backend, method, dt, **options) → SDEIntegratorBase
# auto(sde_system, backend=None) → SDEIntegratorBase
# for_monte_carlo(sde_system, n_paths) → SDEIntegratorBase
```

**Available Methods:**

| Method | Backend | Convergence | Noise Type |
|--------|---------|-------------|------------|
| euler-maruyama | NumPy/PyTorch/JAX | Strong (0.5) | General |
| milstein | NumPy | Strong (1.0) | Diagonal |
| heun | PyTorch/JAX | Strong (1.0) | Additive |
| srk | PyTorch | Strong | General |
| reversible_heun | PyTorch | Strong | Additive |

---

#### TorchSDEIntegrator {#sec-torchsdeintegrator}
**File:** `torchsde_integrator.py` (estimated ~800 lines)

**Purpose:** PyTorch SDE integration with torchsde

**Supported Methods:**

- **euler**: Euler-Maruyama (strong order 0.5)
- **heun**: Heun's method (strong order 1.0 for additive)
- **srk**: Stochastic Runge-Kutta
- **reversible_heun**: Reversible Heun (strong order 1.0)

**Key Features:**

- GPU acceleration
- Adaptive stepping
- Noise structure exploitation
- Adjoint method for gradients

**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.stochastic.torchsde_integrator import TorchSDEIntegrator
integrator = TorchSDEIntegrator(
    sde_system,
    method='adaptive_heun',
    dt=0.01,
    backend='torch'
)
result = integrator.integrate(x0_sde_torch, u_func, t_span=(0, 10))
```

---

#### DiffraxSDEIntegrator {#sec-diffraxsdeintegrator}
**File:** `diffrax_sde_integrator.py` (estimated ~750 lines)

**Purpose:** JAX SDE integration with diffrax

**Supported Methods:**

- **euler**: Euler-Maruyama
- **heun**: Heun's method
- **reversible_heun**: Reversible Heun

**Key Features:**

- JAX transformations
- XLA compilation
- Custom noise support
- Efficient for optimization

**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.stochastic.diffrax_sde_integrator import DiffraxSDEIntegrator
integrator = DiffraxSDEIntegrator(
    sde_system,
    method='euler',
    dt=0.01,
    backend='jax',
    seed=SEED
)
result = integrator.integrate(x0_sde_jax, u_func, t_span=(0, 10))
```

---

#### DiffEqPySDEIntegrator {#sec-diffeqpysdeintegrator}
**File:** `diffeqpy_sde_integrator.py` (estimated ~850 lines)

**Purpose:** Julia SDE solvers via DiffEqPy

**Supported Methods:**

- Euler-Maruyama variants
- Milstein
- Stochastic Rosenbrock
- Advanced Julia SDE methods

**Key Features:**

- Production-grade SDE solvers
- Automatic noise structure detection
- High-performance algorithms


**Example:**
```{python}
#| output: false
from cdesym.systems.base.numerical_integration.stochastic.diffeqpy_sde_integrator import DiffEqPySDEIntegrator
integrator = DiffEqPySDEIntegrator(
    sde_system,
    method='EM',
    dt=0.01,
    backend='numpy',
    seed=SEED
)
result = integrator.integrate(x0_sde_numpy, u_func, t_span=(0, 10))
```

---

#### CustomBrownianPath {#sec-custombrownianpath}
**File:** `custom_brownian.py` (160 lines)

**Purpose:** Custom Brownian motion for deterministic testing

**Key Features:**

- User-provided noise increments
- Diffrax AbstractPath interface
- Deterministic testing support
- Custom noise patterns

**Example:**
```{python}
#| output: false
# Zero noise for testing
import jax.numpy as jnp
from jax import random
key = random.key(SEED)

from cdesym.systems.base.numerical_integration.stochastic.custom_brownian import (
    CustomBrownianPath, create_custom_or_random_brownian
)
dW = jnp.zeros(1)
brownian = CustomBrownianPath(0.0, 0.01, dW)

# Or random noise
brownian = create_custom_or_random_brownian(
    key, 0.0, 0.01, shape=(nw,), dW=None
)
```

---

## Design Principles {#sec-design-principles}

### 1. Backend Abstraction {#sec-1-backend-abstraction}

All integrators work across backends:

- **NumPy:** CPU, scipy, Julia integration
- **PyTorch:** GPU, autograd, neural ODEs
- **JAX:** XLA, functional, optimization

### 2. Factory Pattern {#sec-2-factory-pattern}

IntegratorFactory and SDEIntegratorFactory provide:

- Automatic method selection
- Backend-specific routing
- Convenience constructors
- Use case optimization

### 3. Unified Result Types {#sec-3-unified-result-types}

All integrators return TypedDict results:

- **IntegrationResult** for ODEs
- **SDEIntegrationResult** for SDEs
- Consistent fields across backends
- Optional fields for extra diagnostics

### 4. Composition Not Inheritance {#sec-4-composition-not-inheritance}

- Integrators compose with systems
- No deep inheritance hierarchies
- Clear separation of concerns
- Easy to extend

### 5. Performance Tracking {#sec-5-performance-tracking}
Built-in statistics:
```{python}
#| output: false
#| evaluate: false
# integrator._stats = {
#     'total_fev': int,      # Function evaluations
#     'total_steps': int,    # Integration steps
#     'total_time': float,   # Computation time
# }
```

## Integration Result Types {#sec-integration-result-types}

### IntegrationResult (ODE) {#sec-integrationresult-ode}
```{python}
#| output: false
#| execute: false
# {
#     't': array,              # Time points (T,)
#     'x': array,              # States (T, nx) - time-major
#     'success': bool,         # Integration succeeded
#     'message': str,          # Status message
#     'nfev': int,             # Function evaluations
#     'nsteps': int,           # Steps taken
#     'integration_time': float,  # Wall time (seconds)
#     'solver': str,           # Integrator name
    
#     # Optional (adaptive methods):
#     'njev': int,             # Jacobian evaluations
#     'nlu': int,              # LU decompositions
#     'status': int,           # Solver status code
#     'sol': object,           # Dense output (if requested)
#     'dense_output': bool,    # Dense output available
# }
```

### SDEIntegrationResult (SDE) {#sec-sdeintegrationresult-sde}
```{python}
#| output: false
#| execute: false
# {
#     # All IntegrationResult fields, plus:
#     'diffusion_evals': int,     # Diffusion function calls
#     'noise_samples': array,     # Brownian increments used
#     'n_paths': int,             # Number of trajectories
#     'convergence_type': str,    # 'strong' or 'weak'
#     'sde_type': str,            # 'ito' or 'stratonovich'
#     'noise_type': str,          # 'additive', 'multiplicative', etc.
    
#     # For Monte Carlo (n_paths > 1):
#     'x': array,                 # (n_paths, T, nx)
#     'statistics': dict,         # mean, std, quantiles
# }
```

## Usage Examples {#sec-usage-examples}

### Example 1: Simple ODE Integration (NumPy) {#sec-example-1-simple-ode-integration-numpy}
```{python}
#| output: false
# Create integrator automatically
integrator = IntegratorFactory.auto(system)

# Integrate
result = integrator.integrate(
    x0=np.array([0.1, 0.0]),
    u_func=lambda t, x: np.zeros(1),
    t_span=(0.0, 10.0)
)

print(f"Method: {result['solver']}")
print(f"Steps: {result['nsteps']}")
print(f"Success: {result['success']}")
```

### Example 2: High-Accuracy Julia Integration {#sec-example-3-high-accuracy-julia-integration}
```{python}
#| output: false
from cdesym import ContinuousSymbolicSystem, IntegratorFactory

# Create Julia integrator with high accuracy
integrator = IntegratorFactory.for_julia(
    system,
    algorithm='Vern9',  # 9th order
    reltol=1e-12,
    abstol=1e-14
)

result = integrator.integrate(x0_pendulum_numpy, u_func, t_span=(0, 100))
print(f"Accurate to {result['nfev']} function evaluations")
```

### Example 3: Stochastic SDE Integration {#sec-example-4-stochastic-sde-integration}
```{python}
#| output: false
# Create SDE integrator
integrator = SDEIntegratorFactory.create(
    sde_system,
    backend='torch',
    method='adaptive_heun',
    dt=0.01,
    seed=SEED
)

# Single trajectory
result = integrator.integrate(x0_sde_torch, u_func, t_span=(0, 10))
# Integrators do not return noise type, only sde_system.integrate() would
# print(f"Noise type: {result['noise_type']}")
print(f"SDE type: {result['sde_type']}")

# typical UI (also demonstrating temporary backend switching)
with sde_system.use_backend('torch'):
    result = sde_system.integrate(
        x0=x0_sde_torch,
        method='adaptive_heun',
        dt=0.01,
        seed=SEED
    )

print(f"Noise type: {result['noise_type']}")
print(f"SDE type: {result['sde_type']}")
```

### Example 4: Monte Carlo SDE Simulation {#sec-example-5-monte-carlo-sde-simulation}
```{python}
#| output: false
# Multiple trajectories for uncertainty quantification
result = integrator.integrate_monte_carlo(
    x0=np.array([1.0]),
    u_func=lambda t, x: np.zeros(1),
    t_span=(0, 10),
    n_paths=1000
)

# Get statistics

from cdesym.systems.base.numerical_integration.stochastic import get_trajectory_statistics
stats = get_trajectory_statistics(result)

print(f"Mean at t=10: {stats['mean'][-1]}")
print(f"Std at t=10: {stats['std'][-1]}")
print(f"95% CI: [{stats['q25'][-1]}, {stats['q75'][-1]}]")
```

### Example 5: Custom Noise (Deterministic Testing) {#sec-example-6-custom-noise-deterministic-testing}
```{python}
#| output: false
import jax.numpy as jnp
from cdesym.systems.base.numerical_integration.stochastic.custom_brownian import (
    CustomBrownianPath
)

# Zero noise for deterministic testing
# NOTE: For integrate(), provide ONE dW that spans the ENTIRE integration
# This is different from step() which uses per-step dW
dW = jnp.zeros((nw,))
brownian = CustomBrownianPath(0.0, 1.0, dW)  # t0=0, t1=1 matching t_span

# need an integrator in JAX for this
integrator = SDEIntegratorFactory.create(
    sde_system,
    backend='jax',
    method='Heun',  # Use 'Euler' not 'Heun' (check available methods)
    dt=0.01,
    seed=SEED
)

# Use in integration with custom Brownian path
result = integrator.integrate(
    x0_sde_jax, 
    u_func, 
    t_span=(0, 1),
    brownian_path=brownian  # Pass the custom path
)
```

**Important notes for custom Brownian paths:**

1. **Time span matching**: The `CustomBrownianPath(t0, t1, dW)` should have `t0` and `t1` matching your integration `t_span`
2. **Single dW for entire integration**: Unlike `step()` where you provide per-step `dW`, for `integrate()` you provide ONE `dW` representing the entire interval
3. **Diffrax handles interpolation**: Diffrax will internally query the Brownian path at different times using the `evaluate()` method

## Integrator Selection Guide {#sec-integrator-selection-guide}

### By Use Case {#sec-by-use-case}

| Use Case | Recommended Integrator | Reason |
|----------|----------------------|---------|
| General ODE | `IntegratorFactory.for_production(system)` | LSODA auto-stiffness |
| Neural ODE | `IntegratorFactory.for_neural_ode(system)` | TorchDiffEq adjoint |
| Optimization | `IntegratorFactory.for_optimization(system)` | Diffrax JAX |
| High Accuracy | `IntegratorFactory.for_julia(system, 'Vern9')` | Julia 9th order |
| Stiff ODE | `ScipyIntegrator(system, method='BDF')` | Implicit BDF |
| Simple ODE | `RK4Integrator(system, dt=0.01)` | Classic RK4 |
| SDE (general) | `SDEIntegratorFactory.auto(sde_system)` | Best for noise type |
| Monte Carlo | `SDEIntegratorFactory.for_monte_carlo(...)` | Parallelized |

### By Backend {#sec-by-backend}

| Backend | ODE Integrator | SDE Integrator |
|---------|---------------|----------------|
| NumPy | ScipyIntegrator, DiffEqPyIntegrator | (limited support) |
| PyTorch | TorchDiffEqIntegrator | TorchSDEIntegrator |
| JAX | DiffraxIntegrator | DiffraxSDEIntegrator |

### By System Properties {#sec-by-system-properties}

| System Type | Best Integrator |
|-------------|-----------------|
| Non-stiff | RK45, Tsit5, dopri5 |
| Stiff | BDF, Radau, Rodas5 |
| High accuracy | Vern9, DOP853 |
| Real-time | RK4, euler (fixed-step) |
| Additive noise SDE | Heun (strong order 1.0) |
| General SDE | Euler-Maruyama |

## Key Strengths {#sec-key-strengths}

1. **Multi-Backend Support** - Seamless NumPy/PyTorch/JAX switching
2. **Extensive Method Library** - 40+ integration methods
3. **Factory Pattern** - Automatic method selection
4. **Type Safety** - TypedDict results with IDE support
5. **Performance** - GPU acceleration, XLA compilation, Julia performance
6. **Flexibility** - Fixed and adaptive stepping
7. **Stochastic Support** - Full SDE integration framework
8. **Noise Structure** - Exploits additive/diagonal/scalar noise
9. **Monte Carlo** - Built-in multi-trajectory simulation
10. **Testing** - Custom noise for deterministic testing

This framework enables state-of-the-art numerical integration for control theory and machine learning applications!
