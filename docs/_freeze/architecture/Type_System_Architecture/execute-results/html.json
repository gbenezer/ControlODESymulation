{
  "hash": "92712e23fdceb49484bb1dbfbd814559",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Type System Architecture\"\nsubtitle: \"Foundational Types and Structured Results\"\nauthor: \"Gil Benezer\"\ndate: today\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    code-fold: show\n    code-tools: true\n    theme: cosmo\nexecute:\n  eval: true\n  cache: true\n  warning: false\n---\n\n## Overview {#sec-overview}\n\nThe **Type System** is the **foundational layer (Layer 0)** that provides semantic types, structured results, and type-safe interfaces for the entire framework. It consists of **8 focused modules** defining over **200 type aliases** and **structured dictionaries**.\n\n::: {.callout-important}\n## Internal Framework - Not for Direct Use\n\n**This documentation describes internal framework types.** Users should NOT directly reference or manipulate these types except through system methods. The type system is an internal implementation detail that provides:\n\n- Type safety through static checking\n- IDE autocomplete support\n- Clear documentation of expected types\n- Backend-agnostic interfaces\n```python\n# ✓ CORRECT: Types work transparently through system methods\nsystem = Pendulum()\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n# result is IntegrationResult (TypedDict) - IDE knows fields available\n\nA, B = system.linearize(x_eq, u_eq)\n# A is StateMatrix, B is InputMatrix - types guide usage\n\n# ✗ INCORRECT: No need to import or reference types directly\nfrom cdesym.types.core import StateVector, ControlVector\nx: StateVector = np.array([1.0, 0.0])  # Unnecessary annotation\n```\n\nThe type system enables type checking and IDE support while remaining invisible during normal use. This documentation is provided for framework developers and advanced users implementing custom components.\n:::\n\n\n\n## Architecture Philosophy {#sec-architecture-philosophy}\n\n**Type-Driven Design** - Types are not just annotations—they are architecture.\n\nThe type system enables:\n\n1. **Semantic Clarity** - Names convey mathematical meaning (`StateVector`, not `ArrayLike`)\n2. **Type Safety** - Static checking via mypy/pyright catches errors before runtime\n3. **IDE Support** - Autocomplete knows `result['t']` exists and is `TimePoints`\n4. **Backend Agnosticism** - Same types work with NumPy/PyTorch/JAX\n5. **Structured Results** - TypedDict for dictionaries (not plain `dict`)\n6. **Self-Documentation** - Type signatures encode mathematical constraints\n\n**Example comparison:**\n\n::: {#ex-type-comparison .cell execution_count=2}\n``` {.python .cell-code}\n# ✗ Bad: Unclear types and semantics\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# ✓ Good: Clear semantics and constraints\ndef good(x: StateVector, u: ControlVector) -> StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u\n```\n:::\n\n\n## Framework Layers {#sec-framework-layers}\n```\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│  (UI Framework, Delegation Layer, Integration Framework)   │\n└─────────────────────┬──────────────────────────────────────┘\n                      │ uses types from\n                      ↓\n┌────────────────────────────────────────────────────────────┐\n│                    TYPE SYSTEM (Layer 0)                   │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  FOUNDATIONAL TYPES                                  │  │\n│  │  • core.py           - Vectors, matrices             │  │\n│  │  • backends.py       - Backend enums, configs        │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  DOMAIN TYPES                                        │  │\n│  │  • trajectories.py   - Time series results           │  │\n│  │  • linearization.py  - Jacobian tuples               │  │\n│  │  • symbolic.py       - SymPy types                   │  │\n│  │  • control_classical.py - Control design results     │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  STRUCTURAL TYPES                                    │  │\n│  │  • protocols.py      - Abstract interfaces           │  │\n│  │  • utilities.py      - Helper types, guards          │  │\n│  └──────────────────────────────────────────────────────┘  │\n└────────────────────────────────────────────────────────────┘\n```\n\n## Foundational Types {#sec-foundational-types}\n\n### core.py: Fundamental Building Blocks {#sec-corepy}\n\n**File:** `core.py`\n\nThe `core` module provides fundamental building blocks for all other types in the framework. These types establish semantic clarity and backend agnosticism throughout the library.\n\n**Key categories:**\n\n#### Multi-Backend Arrays (20+ types)\n\nBackend-agnostic array types that work transparently with NumPy, PyTorch, and JAX:\n```python\nArrayLike = Union[np.ndarray, torch.Tensor, jnp.ndarray]\nNumpyArray = np.ndarray\nTorchTensor = torch.Tensor\nJaxArray = jnp.ndarray\nScalarLike = Union[float, int, np.number, torch.Tensor, jnp.ndarray]\nIntegerLike = Union[int, np.integer]\n```\n\n**Usage in framework:**\n\n::: {#ex-multi-backend .cell execution_count=3}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Same function works with all backends\nx_np = np.array([1.0, 0.0])      # NumPy\nx_torch = torch.tensor([1.0, 0.0])  # PyTorch\nx_jax = jnp.array([1.0, 0.0])    # JAX\n\n# Backend detected automatically - no type errors\ndx_np = system(x_np, np.zeros(1))\ndx_torch = system(x_torch, torch.zeros(1))\ndx_jax = system(x_jax, jnp.zeros(1))\n\nprint(\"✓ Backend-agnostic type system\")\n```\n:::\n\n\n#### Semantic Vector Types (15+ types)\n\nVector types that convey mathematical meaning:\n```python\nStateVector         # x ∈ ℝⁿˣ - System state\nControlVector       # u ∈ ℝⁿᵘ - Control input\nOutputVector        # y ∈ ℝⁿʸ - Measured output\nNoiseVector         # w ∈ ℝⁿʷ - Stochastic noise\nEquilibriumState    # x_eq - Equilibrium state\nEquilibriumControl  # u_eq - Equilibrium control\nTimeDerivative      # dx/dt - State derivative\nStateIncrement      # δx - State deviation\nControlIncrement    # δu - Control deviation\n```\n\n**Why semantic types matter:**\n\n::: {#ex-semantic-types .cell execution_count=4}\n``` {.python .cell-code}\n# ✗ Unclear what arrays represent\ndef compute(arr1, arr2, arr3):\n    return arr1 @ arr2 + arr3\n\n# ✓ Clear mathematical meaning\ndef compute_control(x: StateVector, K: GainMatrix, u_ff: ControlVector) -> ControlVector:\n    \"\"\"State feedback with feedforward: u = -K*x + u_ff\"\"\"\n    return -K @ x + u_ff\n```\n:::\n\n\n#### Matrix Types (30+ types)\n\nMatrix types organized by mathematical purpose:\n\n**Dynamics matrices:**\n```python\nStateMatrix         # A ∈ ℝⁿˣˣⁿˣ - ∂f/∂x\nInputMatrix         # B ∈ ℝⁿˣˣⁿᵘ - ∂f/∂u  \nDiffusionMatrix     # G ∈ ℝⁿˣˣⁿʷ - Noise intensity\n```\n\n**Observation matrices:**\n```python\nOutputMatrix        # C ∈ ℝⁿʸˣⁿˣ - ∂h/∂x\nFeedthroughMatrix   # D ∈ ℝⁿʸˣⁿᵘ - Direct feedthrough\n```\n\n**Control matrices:**\n```python\nGainMatrix          # K ∈ ℝⁿᵘˣⁿˣ - Feedback gain\nCostMatrix          # Q ∈ ℝⁿˣˣⁿˣ - State cost\nControlCostMatrix   # R ∈ ℝⁿᵘˣⁿᵘ - Control cost\n```\n\n**Stochastic matrices:**\n```python\nCovarianceMatrix    # P ∈ ℝⁿˣˣⁿˣ - Covariance\nProcessNoiseMatrix  # Q ∈ ℝⁿˣˣⁿˣ - Process noise cov\nMeasurementNoiseMatrix  # R ∈ ℝⁿʸˣⁿʸ - Measurement noise cov\n```\n\n**Special matrices:**\n```python\nIdentityMatrix      # I ∈ ℝⁿˣⁿ\nZeroMatrix         # 0 ∈ ℝᵐˣⁿ\nGramianMatrix      # Controllability/observability gramian\nControllabilityMatrix  # [B AB A²B ... Aⁿ⁻¹B]\nObservabilityMatrix    # [C; CA; CA²; ...; CAⁿ⁻¹]\n```\n\n#### Function Signatures (10+ types)\n\nCallable types that define function interfaces:\n```python\nDynamicsFunction    # (x, u) → dx/dt\nOutputFunction      # (x) → y\nControlPolicy       # (t, x) → u\nCostFunction        # (x, u) → scalar\nObserverFunction    # (y, u) → x_hat\n```\n\n**Usage example:**\n\n::: {#ex-function-types .cell execution_count=5}\n``` {.python .cell-code}\nfrom cdesym.types import StateVector, ControlVector\n# Function signature guides implementation\ndef simulate_with_controller(\n    system: Callable[[StateVector, ControlVector], StateVector],  # DynamicsFunction\n    controller: Callable[[float, StateVector], ControlVector],    # ControlPolicy\n    x0: StateVector,\n    t_span: Tuple[float, float]\n) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Type signatures document the contract.\"\"\"\n    # Implementation here\n    pass\n\nprint(\"✓ Function types document interfaces\")\n```\n:::\n\n\n#### System Properties (15+ types)\n\nTypes for system dimensions and properties:\n```python\nStateDimension      # nx - Number of states\nControlDimension    # nu - Number of controls\nOutputDimension     # ny - Number of outputs\nNoiseDimension      # nw - Number of Wiener processes\nSystemOrder         # order - Differential order\n\nEquilibriumPoint    # (x_eq, u_eq) - Tuple\nEquilibriumName     # str - Named equilibrium\n```\n\n### backends.py: Backend Configuration {#sec-backendspy}\n\n**File:** `backends.py`\n\nThe `backends` module defines backend selection, device management, and method specification types.\n\n**Key categories:**\n\n#### Backend Types\n```python\nBackend = Literal[\"numpy\", \"torch\", \"jax\"]\nDevice = str  # 'cpu', 'cuda:0', 'mps', 'tpu'\n\nclass BackendConfig(TypedDict, total=False):\n    backend: Backend\n    device: Optional[Device]\n    dtype: Optional[str]  # 'float32', 'float64'\n```\n\n**Usage in framework:**\n\n::: {#ex-backend-config .cell execution_count=6}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Backend configuration handled internally\nprint(f\"Default backend: {system.backend.default_backend}\")\nprint(f\"Default device: {system.backend.preferred_device}\")\n\n# Users interact through simple methods\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\nwith system.use_backend('torch'):\n    print(f\"Temporary backend: {system.backend.default_backend}\")\n```\n:::\n\n\n#### Integration Methods\n```python\nIntegrationMethod = str  # 'RK45', 'dopri5', 'tsit5', etc.\n\n# Specific categories\nOdeMethod = str          # Deterministic methods\nSdeMethod = str          # Stochastic methods\nFixedStepMethod = str    # Fixed-step methods\nAdaptiveMethod = str     # Adaptive methods\n```\n\n#### Discretization Methods\n```python\nDiscretizationMethod = Literal[\n    \"exact\",      # Matrix exponential\n    \"euler\",      # Forward Euler\n    \"tustin\",     # Bilinear transform\n    \"backward\",   # Backward Euler\n    \"matched\",    # Zero-order hold\n]\n```\n\n#### SDE Types\n```python\nSDEType = Literal[\"ito\", \"stratonovich\"]\n\nclass NoiseType(Enum):\n    ADDITIVE = \"additive\"\n    MULTIPLICATIVE = \"multiplicative\"\n    MULTIPLICATIVE_DIAGONAL = \"multiplicative_diagonal\"\n    MULTIPLICATIVE_SCALAR = \"multiplicative_scalar\"\n    MULTIPLICATIVE_GENERAL = \"multiplicative_general\"\n    UNKNOWN = \"unknown\"\n\nclass ConvergenceType(Enum):\n    STRONG = \"strong\"  # Pathwise convergence\n    WEAK = \"weak\"      # Distribution convergence\n```\n\n#### System Configuration\n```python\nclass SystemConfig(TypedDict, total=False):\n    \"\"\"Complete system configuration.\"\"\"\n    nx: int              # State dimension\n    nu: int              # Control dimension\n    ny: int              # Output dimension\n    nw: int              # Noise dimension\n    order: int           # System order\n    dt: Optional[float]  # Time step (discrete)\n    backend: Backend\n    device: Device\n```\n\n## Domain Types {#sec-domain-types}\n\n### trajectories.py: Time Series Results {#sec-trajectoriespy}\n\n**File:** `trajectories.py`\n\nThe `trajectories` module defines types for time series data and simulation results.\n\n**Key categories:**\n\n#### Trajectory Types\n```python\nStateTrajectory = ArrayLike      # (T, nx) or (T, batch, nx)\nControlSequence = ArrayLike      # (T, nu) or (T, batch, nu)\nOutputSequence = ArrayLike       # (T, ny)\nNoiseSequence = ArrayLike        # (T, nw)\n```\n\n**Convention: Time-major ordering** - All trajectories use `(T, ...)` format where `T` is the first dimension.\n\n#### Time Types\n```python\nTimePoints = ArrayLike           # (T,) - Time grid\nTimeSpan = Tuple[float, float]   # (t0, tf) - Interval\nTimeStep = float                 # dt - Step size\n```\n\n#### Integration Results (TypedDict)\n\n**Deterministic ODE Integration:**\n```python\nclass IntegrationResult(TypedDict, total=False):\n    \"\"\"ODE integration result.\"\"\"\n    t: TimePoints              # Time points\n    x: StateTrajectory         # State trajectory (T, nx)\n    success: bool              # Integration succeeded\n    message: str               # Status message\n    nfev: int                  # Function evaluations\n    nsteps: int                # Integration steps\n    integration_time: float    # Wall time (seconds)\n    solver: str                # Integrator name\n    \n    # Optional fields (adaptive methods)\n    njev: int                  # Jacobian evaluations\n    nlu: int                   # LU decompositions\n    status: int                # Solver status code\n    sol: Any                   # Dense output object\n    dense_output: bool         # Dense output available\n```\n\n**Stochastic SDE Integration:**\n```python\nclass SDEIntegrationResult(TypedDict, total=False):\n    \"\"\"SDE integration result (extends IntegrationResult).\"\"\"\n    # All IntegrationResult fields, plus:\n    diffusion_evals: int       # Diffusion function calls\n    noise_samples: NoiseVector # Brownian increments used\n    n_paths: int               # Number of trajectories\n    convergence_type: str      # 'strong' or 'weak'\n    sde_type: str              # 'ito' or 'stratonovich'\n    noise_type: str            # Noise structure\n```\n\n**Batch Simulation:**\n```python\nclass BatchSimulationResult(TypedDict):\n    \"\"\"Batched simulation result.\"\"\"\n    t: TimePoints                    # (T,)\n    x: StateTrajectory               # (T, batch, nx)\n    u: ControlSequence               # (T, batch, nu)\n    batch_size: int\n    statistics: Dict[str, ArrayLike] # Mean, std, etc.\n```\n\n**Why TypedDict:**\n\n::: {#ex-typeddict-benefits .cell execution_count=7}\n``` {.python .cell-code}\nsystem = Pendulum()\nx0 = np.array([1.0, 0.0])\n\n# TypedDict result provides IDE support\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n\n# IDE knows these fields exist and their types\nt = result['t']              # TimePoints\nx = result['x']              # StateTrajectory\nsuccess = result['success']  # bool\nsolver = result['solver']    # str\n\nprint(f\"Integration {'succeeded' if success else 'failed'}\")\nprint(f\"Solver: {solver}\")\n```\n:::\n\n\n### linearization.py: Jacobian Types {#sec-linearizationpy}\n\n**File:** `linearization.py`\n\nThe `linearization` module defines return types for linearization operations.\n\n**Mathematical forms:**\n\n**Continuous systems:**\n\n$$\\delta\\dot{x} = A\\delta x + B\\delta u$$\n\nwhere:\n\n$$A = \\frac{\\partial f}{\\partial x}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_x}$$\n\n$$B = \\frac{\\partial f}{\\partial u}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_u}$$\n\n**Discrete systems:**\n\n$$\\delta x[k+1] = A_d\\delta x[k] + B_d\\delta u[k]$$\n\n**Type definitions:**\n\n#### Basic Linearization\n```python\nDeterministicLinearization = Tuple[StateMatrix, InputMatrix]\n# Returns: (A, B) where\n#   A = ∂f/∂x - State Jacobian\n#   B = ∂f/∂u - Control Jacobian\n\nStochasticLinearization = Tuple[StateMatrix, InputMatrix, DiffusionMatrix]\n# Returns: (A, B, G) where\n#   A = ∂f/∂x\n#   B = ∂f/∂u  \n#   G = ∂g/∂x or g(x_eq) - Diffusion\n\nLinearizationResult = Union[DeterministicLinearization, StochasticLinearization]\n# Polymorphic: works with both\n```\n\n#### Output Linearization\n```python\nObservationLinearization = Tuple[OutputMatrix, FeedthroughMatrix]\n# Returns: (C, D) where\n#   C = ∂h/∂x - Output Jacobian\n#   D = ∂h/∂u - Feedthrough (usually 0)\n```\n\n#### Full State-Space\n```python\nFullLinearization = Tuple[StateMatrix, InputMatrix, OutputMatrix, FeedthroughMatrix]\n# Returns: (A, B, C, D)\n\nFullStochasticLinearization = Tuple[\n    StateMatrix, InputMatrix, DiffusionMatrix, OutputMatrix, FeedthroughMatrix\n]\n# Returns: (A, B, G, C, D)\n```\n\n**Usage example:**\n\n::: {#ex-linearization-types .cell execution_count=8}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Type annotation guides usage\nA, B = system.linearize(x_eq, u_eq)  # DeterministicLinearization\n\n# Natural tuple unpacking\nprint(f\"A shape: {A.shape}\")  # (nx, nx)\nprint(f\"B shape: {B.shape}\")  # (nx, nu)\n```\n:::\n\n\n### symbolic.py: SymPy Integration {#sec-symbolicpy}\n\n**File:** `symbolic.py`\n\nThe `symbolic` module provides types for SymPy symbolic expressions.\n\n**Key categories:**\n\n#### Symbolic Variables\n```python\nSymbolicVariable = sp.Symbol        # Single variable\nSymbolicVector = sp.Matrix          # Vector of symbols\nSymbolicMatrix = sp.Matrix          # Matrix expression\nSymbolicExpression = sp.Expr        # General expression\n```\n\n#### System Components\n```python\nDynamicsExpression = sp.Matrix      # f(x, u) symbolic\nOutputExpression = sp.Matrix        # h(x) symbolic\nDiffusionExpression = sp.Matrix     # g(x, u) symbolic\nParameterDict = Dict[sp.Symbol, float]  # Parameter values\n```\n\n#### Jacobian Expressions\n```python\nJacobianExpression = sp.Matrix      # ∂f/∂x symbolic\nHessianExpression = sp.Matrix       # ∂²f/∂x² symbolic\nGradientExpression = sp.Matrix      # ∇f symbolic\n```\n\n**Usage in framework:**\n\n::: {#ex-symbolic-types .cell execution_count=9}\n``` {.python .cell-code}\n# Define custom system using symbolic types\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        # SymbolicVariable\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        # SymbolicVector\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        \n        # DynamicsExpression (SymbolicMatrix)\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\n        \n        # ParameterDict\n        m_sym, k_sym = sp.symbols('m k', positive=True)\n        self.parameters = {m_sym: m, k_sym: k}\n        \n        self.order = 1\n\nsystem = MySystem()\nprint(\"✓ Symbolic types guide system definition\")\n```\n:::\n\n\n### control_classical.py: Control Design Results {#sec-controlclassicalpy}\n\n**File:** `control_classical.py`\n\nThe `control_classical` module provides TypedDict results for classical control theory operations.\n\n**Key categories:**\n\n#### System Analysis Results\n\n**Stability Analysis:**\n```python\nclass StabilityInfo(TypedDict):\n    \"\"\"Stability analysis result.\n    \n    Stability Criteria:\n    - Continuous: All Re(λ) < 0 (left half-plane)\n    - Discrete: All |λ| < 1 (inside unit circle)\n    \"\"\"\n    eigenvalues: np.ndarray          # Complex eigenvalues\n    magnitudes: np.ndarray           # |λ| values\n    max_magnitude: float             # Spectral radius\n    spectral_radius: float           # Same as max_magnitude\n    is_stable: bool                  # Asymptotically stable\n    is_marginally_stable: bool       # On stability boundary\n    is_unstable: bool                # Unstable\n```\n\n**Controllability:**\n```python\nclass ControllabilityInfo(TypedDict, total=False):\n    \"\"\"Controllability analysis result.\n    \n    Test: rank(C) = nx where C = [B AB A²B ... Aⁿ⁻¹B]\n    \"\"\"\n    controllability_matrix: ControllabilityMatrix  # (nx, nx*nu)\n    rank: int                        # Rank of C\n    is_controllable: bool            # rank == nx\n    uncontrollable_modes: Optional[np.ndarray]  # Eigenvalues\n```\n\n**Observability:**\n```python\nclass ObservabilityInfo(TypedDict, total=False):\n    \"\"\"Observability analysis result.\n    \n    Test: rank(O) = nx where O = [C; CA; CA²; ...; CAⁿ⁻¹]\n    \"\"\"\n    observability_matrix: ObservabilityMatrix  # (nx*ny, nx)\n    rank: int                        # Rank of O\n    is_observable: bool              # rank == nx\n    unobservable_modes: Optional[np.ndarray]  # Eigenvalues\n```\n\n#### Control Design Results\n\n**LQR Controller:**\n```python\nclass LQRResult(TypedDict):\n    \"\"\"Linear Quadratic Regulator result.\n    \n    Minimizes: J = ∫(x'Qx + u'Ru)dt  (continuous)\n               J = Σ(x'Qx + u'Ru)     (discrete)\n    \n    Control law: u = -Kx\n    \"\"\"\n    gain: GainMatrix                 # Feedback gain K (nu, nx)\n    cost_to_go: CovarianceMatrix     # Riccati solution P (nx, nx)\n    closed_loop_eigenvalues: np.ndarray  # eig(A - BK)\n    stability_margin: float          # Phase/gain margin\n```\n\n**Kalman Filter:**\n```python\nclass KalmanFilterResult(TypedDict):\n    \"\"\"Kalman Filter (optimal estimator) result.\n    \n    System:\n        x[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0,Q)\n        y[k] = Cx[k] + v[k],            v ~ N(0,R)\n    \n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    gain: GainMatrix                 # Kalman gain L (nx, ny)\n    error_covariance: CovarianceMatrix  # Error cov P (nx, nx)\n    innovation_covariance: CovarianceMatrix  # Innovation S (ny, ny)\n    observer_eigenvalues: np.ndarray  # eig(A - LC)\n```\n\n**LQG Controller:**\n```python\nclass LQGResult(TypedDict):\n    \"\"\"Linear Quadratic Gaussian controller result.\n    \n    Combines LQR (optimal control) + Kalman (optimal estimation)\n    via separation principle.\n    \n    Controller: u = -Kx̂\n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    control_gain: GainMatrix         # LQR gain K (nu, nx)\n    estimator_gain: GainMatrix       # Kalman gain L (nx, ny)\n    control_cost_to_go: CovarianceMatrix  # Controller Riccati P\n    estimation_error_covariance: CovarianceMatrix  # Estimator Riccati P\n    separation_verified: bool        # Separation principle holds\n    closed_loop_stable: bool         # Overall stability\n    controller_eigenvalues: np.ndarray  # eig(A - BK)\n    estimator_eigenvalues: np.ndarray   # eig(A - LC)\n```\n\n**Pole Placement:**\n```python\nclass PolePlacementResult(TypedDict):\n    \"\"\"Pole placement (eigenvalue assignment) result.\n    \n    Design K such that eig(A - BK) = desired poles\n    \"\"\"\n    gain: GainMatrix                 # State feedback gain K\n    desired_poles: np.ndarray        # Desired eigenvalues\n    achieved_poles: np.ndarray       # Actual eig(A - BK)\n    is_controllable: bool            # Arbitrary placement possible\n```\n\n**Luenberger Observer:**\n```python\nclass LuenbergerObserverResult(TypedDict):\n    \"\"\"Luenberger observer (deterministic estimator) result.\n    \n    Observer: x̂̇ = Ax̂ + Bu + L(y - Cx̂)\n    Error dynamics: ė = (A - LC)e\n    \"\"\"\n    gain: GainMatrix                 # Observer gain L (nx, ny)\n    desired_poles: np.ndarray        # Desired observer poles\n    achieved_poles: np.ndarray       # Actual eig(A - LC)\n    is_observable: bool              # Arbitrary placement possible\n```\n\n**Usage example:**\n\n::: {#ex-control-results .cell execution_count=10}\n``` {.python .cell-code}\n# Stability analysis (TypedDict provides structure)\nstability: StabilityInfo = system.control.analyze_stability(A, system_type='continuous')\nif stability['is_stable']:\n    print(f\"Stable with spectral radius {stability['spectral_radius']:.3f}\")\n\n# LQR design (clear result structure)\nlqr: LQRResult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\nclosed_loop_eigs = lqr['controller_eigenvalues']\n\n# Kalman filter (all fields documented)\nkalman: KalmanFilterResult = system.control.design_kalman(\n    A, C, Q_process, R_measurement, system_type='discrete'\n)\nL = kalman['gain']\n\n# LQG controller (separation principle results)\nlqg: LQGResult = system.control.design_lqg(\n    A, B, C, Q, R, Q_process, R_measurement, system_type='discrete'\n)\nK = lqg['controller_gain']\nL = lqg['estimator_gain']\n```\n:::\n\n\n## Structural Types {#sec-structural-types}\n\n### protocols.py: Abstract Interfaces {#sec-protocolspy}\n\n**File:** `protocols.py`\n\nThe `protocols` module defines abstract interfaces via Protocol (structural typing).\n\n**Key categories:**\n\n#### System Protocols\n```python\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Abstract interface for dynamical systems.\"\"\"\n    @property\n    def nx(self) -> int: ...\n    @property\n    def nu(self) -> int: ...\n    def __call__(self, x: StateVector, u: ControlVector) -> StateVector: ...\n\nclass ContinuousSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Continuous-time system interface.\"\"\"\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable,\n        t_span: TimeSpan\n    ) -> IntegrationResult: ...\n\nclass DiscreteSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Discrete-time system interface.\"\"\"\n    @property\n    def dt(self) -> float: ...\n    def step(self, x: StateVector, u: ControlVector) -> StateVector: ...\n\nclass StochasticSystemProtocol(Protocol):\n    \"\"\"Stochastic system interface.\"\"\"\n    @property\n    def nw(self) -> int: ...\n    def drift(self, x: StateVector, u: ControlVector) -> StateVector: ...\n    def diffusion(self, x: StateVector, u: ControlVector) -> DiffusionMatrix: ...\n```\n\n#### Controller Protocols\n```python\nclass ControllerProtocol(Protocol):\n    \"\"\"Controller interface.\"\"\"\n    def compute_control(self, x: StateVector) -> ControlVector: ...\n\nclass FeedbackControllerProtocol(ControllerProtocol, Protocol):\n    \"\"\"Linear feedback controller.\"\"\"\n    @property\n    def K(self) -> GainMatrix: ...\n```\n\n#### Observer Protocols\n```python\nclass ObserverProtocol(Protocol):\n    \"\"\"State observer interface.\"\"\"\n    def observe(self, x: StateVector) -> OutputVector: ...\n    def estimate(self, y: OutputVector, u: ControlVector) -> StateVector: ...\n```\n\n**Why Protocol:**\n\n::: {#ex-protocol-benefits .cell execution_count=11}\n``` {.python .cell-code}\n# No inheritance needed - structural typing\nclass MyCustomSystem:\n    @property\n    def nx(self) -> int:\n        return 2\n    \n    @property  \n    def nu(self) -> int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -> StateVector:\n        return x + u\n\n# Satisfies protocol structurally (duck typing with type safety)\nsystem: DynamicalSystemProtocol = MyCustomSystem()  # ✓ Type checker approves!\n```\n:::\n\n\n### utilities.py: Helper Types {#sec-utilitiespy}\n\n**File:** `utilities.py`\n\nThe `utilities` module provides helper types, type guards, and performance tracking.\n\n**Key categories:**\n\n#### Type Guards\n```python\ndef is_numpy(arr: ArrayLike) -> bool:\n    \"\"\"Check if array is NumPy.\"\"\"\n    return isinstance(arr, np.ndarray)\n\ndef is_torch(arr: ArrayLike) -> bool:\n    \"\"\"Check if array is PyTorch.\"\"\"\n    return hasattr(arr, '__module__') and 'torch' in arr.__module__\n\ndef is_jax(arr: ArrayLike) -> bool:\n    \"\"\"Check if array is JAX.\"\"\"\n    return hasattr(arr, '__module__') and 'jax' in arr.__module__\n```\n\n#### Shape Utilities\n```python\ndef is_batched(arr: ArrayLike, expected_dims: int = 1) -> bool:\n    \"\"\"Check if array is batched.\"\"\"\n    return arr.ndim > expected_dims\n\ndef get_batch_size(arr: ArrayLike) -> Optional[int]:\n    \"\"\"Get batch size if batched.\"\"\"\n    return arr.shape[0] if is_batched(arr) else None\n\ndef get_state_dim(x: StateVector) -> int:\n    \"\"\"Get state dimension.\"\"\"\n    return x.shape[-1] if x.ndim > 0 else 1\n```\n\n#### Performance Types\n```python\nclass ExecutionStats(TypedDict):\n    \"\"\"Performance statistics.\"\"\"\n    count: int              # Number of calls\n    total_time: float       # Total time (seconds)\n    avg_time: float         # Average time\n    min_time: float         # Fastest call\n    max_time: float         # Slowest call\n```\n\n#### Validation Types\n```python\nclass ValidationResult(TypedDict):\n    \"\"\"Validation result.\"\"\"\n    valid: bool\n    errors: List[str]\n    warnings: List[str]\n    info: Dict[str, Any]\n```\n\n## Design Principles {#sec-design-principles}\n\n### 1. Semantic Over Structural {#sec-principle-semantic}\n\n**Principle:** Names convey mathematical meaning, not implementation details.\n\n::: {#ex-semantic-principle .cell execution_count=12}\n``` {.python .cell-code}\n# ✗ Structural (what it is)\ndef compute(arr1: np.ndarray, arr2: np.ndarray) -> np.ndarray:\n    return arr1 @ arr2\n\n# ✓ Semantic (what it means)\ndef compute_control(x: StateVector, K: GainMatrix) -> ControlVector:\n    \"\"\"u = -Kx\"\"\"\n    return -K @ x\n```\n:::\n\n\n### 2. Backend Agnosticism {#sec-principle-backend}\n\n**Principle:** Same types work with NumPy/PyTorch/JAX.\n\n::: {#ex-backend-principle .cell execution_count=13}\n``` {.python .cell-code}\n# Same function signature works for all backends\ndef dynamics(x: StateVector, u: ControlVector) -> StateVector:\n    # Works with NumPy, PyTorch, JAX\n    return x + u  # Backend detected from input\n\n# Works with all backends\ndx_np = dynamics(np.array([1.0, 0.0]), np.array([0.0]))\ndx_torch = dynamics(torch.tensor([1.0, 0.0]), torch.tensor([0.0]))\ndx_jax = dynamics(jnp.array([1.0, 0.0]), jnp.array([0.0]))\n\nprint(\"✓ Backend-agnostic types\")\n```\n:::\n\n\n### 3. TypedDict for Structured Results {#sec-principle-typeddict}\n\n**Principle:** Never return plain dictionaries—use TypedDict for structure and safety.\n\n::: {#ex-typeddict-principle .cell execution_count=14}\n``` {.python .cell-code}\n# ✗ Plain dict (no IDE support, no type checking)\ndef integrate() -> dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# ✓ TypedDict (type-safe, self-documenting)\ndef integrate() -> IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\n```\n:::\n\n\n### 4. Optional Fields with total=False {#sec-principle-optional}\n\n**Principle:** Use `total=False` for optional fields in TypedDict.\n```python\nclass IntegrationResult(TypedDict, total=False):\n    # Required fields (always present)\n    t: TimePoints\n    x: StateTrajectory\n    success: bool\n    \n    # Optional fields (may not be present)\n    njev: int  # Only adaptive methods\n    sol: Any   # Dense output (optional)\n```\n\n### 5. Polymorphic Types via Union {#sec-principle-polymorphic}\n\n**Principle:** Use Union for polymorphic return types.\n```python\nLinearizationResult = Union[\n    Tuple[StateMatrix, InputMatrix],           # Deterministic\n    Tuple[StateMatrix, InputMatrix, DiffusionMatrix]  # Stochastic\n]\n\n# Single function handles both\ndef analyze(result: LinearizationResult):\n    A, B = result[0], result[1]\n    if len(result) == 3:\n        G = result[2]  # Stochastic\n```\n\n### 6. Protocol for Interfaces {#sec-principle-protocol}\n\n**Principle:** Define interfaces via Protocol (structural typing) not inheritance.\n\n::: {#ex-protocol-principle .cell execution_count=15}\n``` {.python .cell-code}\n# No inheritance needed - structural typing\nclass MySystem:\n    @property\n    def nx(self) -> int:\n        return 2\n    \n    def __call__(self, x: StateVector, u: ControlVector) -> StateVector:\n        return x + u\n\n# Satisfies DynamicalSystemProtocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # ✓ Type checker approves!\n```\n:::\n\n\n## Usage Throughout Framework {#sec-usage-throughout-framework}\n\n### In UI Framework {#sec-usage-ui-framework}\n```python\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __call__(\n        self, \n        x: StateVector, \n        u: Optional[ControlVector] = None\n    ) -> StateVector:\n        \"\"\"Evaluate dynamics (types guide implementation).\"\"\"\n        return self._dynamics.evaluate(x, u, backend=self.backend.default_backend)\n    \n    def linearize(\n        self,\n        x_eq: EquilibriumState,\n        u_eq: EquilibriumControl,\n        backend: Backend = \"numpy\"\n    ) -> DeterministicLinearization:\n        \"\"\"Compute linearization (return type documents structure).\"\"\"\n        return self._linearization.linearize_continuous(x_eq, u_eq, backend)\n```\n\n### In Delegation Layer {#sec-usage-delegation-layer}\n```python\nclass DynamicsEvaluator:\n    def evaluate(\n        self,\n        x: StateVector,\n        u: Optional[ControlVector],\n        backend: Backend\n    ) -> StateVector:\n        \"\"\"Evaluate forward dynamics (types ensure correctness).\"\"\"\n        f_func: DynamicsFunction = self.code_gen.generate_dynamics(backend)\n        return f_func(x, u)\n    \n    def get_stats(self) -> ExecutionStats:\n        \"\"\"Get performance statistics (TypedDict result).\"\"\"\n        return {\n            'count': self._call_count,\n            'total_time': self._total_time,\n            'avg_time': self._total_time / self._call_count,\n            'min_time': self._min_time,\n            'max_time': self._max_time\n        }\n```\n\n### In Integration Framework {#sec-usage-integration-framework}\n```python\nclass ScipyIntegrator(IntegratorBase):\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable[[ScalarLike, StateVector], Optional[ControlVector]],\n        t_span: TimeSpan,\n        t_eval: Optional[TimePoints] = None\n    ) -> IntegrationResult:\n        \"\"\"Integrate using scipy (TypedDict ensures complete result).\"\"\"\n        # ... implementation ...\n        \n        result: IntegrationResult = {\n            't': sol.t,\n            'x': sol.y.T,\n            'success': sol.success,\n            'message': sol.message,\n            'nfev': sol.nfev,\n            'nsteps': sol.nfev,\n            'integration_time': elapsed,\n            'solver': self.name\n        }\n        \n        # Optional fields (type system allows this)\n        if hasattr(sol, 'njev'):\n            result['njev'] = sol.njev\n        \n        return result\n```\n\n## Type Statistics {#sec-type-statistics}\n\n### Type Distribution\n\n| Category | Count | Examples |\n|----------|-------|----------|\n| Vector Types | 15+ | StateVector, ControlVector, OutputVector |\n| Matrix Types | 30+ | StateMatrix, GainMatrix, CovarianceMatrix |\n| Function Types | 10+ | DynamicsFunction, ControlPolicy |\n| Backend Types | 20+ | Backend, Device, NoiseType |\n| Trajectory Types | 15+ | StateTrajectory, IntegrationResult |\n| Linearization Types | 15+ | DeterministicLinearization |\n| Symbolic Types | 10+ | SymbolicExpression, DynamicsExpression |\n| Protocol Types | 20+ | DynamicalSystemProtocol |\n| Utility Types | 20+ | ExecutionStats, ValidationResult |\n| TypedDict Results | 15+ | IntegrationResult, LQRResult, StabilityInfo |\n| **TOTAL** | **200+** | **Complete type system** |\n\n## Key Strengths {#sec-key-strengths}\n\n::: {.callout-tip}\n## Type System Benefits\n\n1. **Semantic Clarity** - Names convey mathematical meaning\n2. **Type Safety** - Static checking prevents errors\n3. **IDE Support** - Autocomplete and inline documentation\n4. **Backend Agnostic** - Works with NumPy/PyTorch/JAX transparently\n5. **Structured Results** - TypedDict not plain dict\n6. **Self-Documenting** - Types encode constraints and invariants\n7. **Composition** - Types compose naturally\n8. **Extensible** - Easy to add new types\n9. **Consistent** - Same conventions throughout framework\n10. **Testable** - Type-driven testing patterns\n:::\n\n## Summary\n\nThe type system is the **foundational layer** that enables clean, type-safe architecture throughout ControlDESymulation. By providing semantic types, structured results, and protocol-based interfaces, it supports:\n\n- **Type-driven development** - Types guide implementation\n- **Static verification** - Catch errors before runtime\n- **Multi-backend support** - Transparent backend switching\n- **Clear contracts** - Function signatures document expectations\n- **Maintainability** - Types make code self-documenting\n\n**The type system is infrastructure—users benefit from it without needing to understand it.** This documentation is provided for framework developers and advanced users who need to understand the internal type architecture.\n\n",
    "supporting": [
      "Type_System_Architecture_files"
    ],
    "filters": [],
    "includes": {}
  }
}