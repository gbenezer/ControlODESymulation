{
  "hash": "1a6edbebb921518b48a7888d199a75cd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Visualization Framework Architecture\"\nsubtitle: \"Interactive, Publication-Ready Plotting for Dynamical Systems\"\nauthor: \"Gil Benezer\"\ndate: today\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    code-fold: show\n    code-tools: true\nexecute:\n  eval: true\n  cache: true\n  warning: false\n---\n\n## Overview {#sec-overview}\n\nThe **Visualization Framework** provides interactive, publication-ready plotting for dynamical systems analysis. It consists of **4 core modules** organized into a **2-layer architecture**: centralized theming + specialized plotters.\n\n::: {.callout-note}\n## Framework Components\n\n- **Theming Layer**: Centralized colors, styles, and themes\n- **Plotter Layer**: Specialized visualization classes\n  - `TrajectoryPlotter` - Time-domain plots\n  - `PhasePortraitPlotter` - State-space plots\n  - `ControlPlotter` - Control analysis plots\n:::\n\n::: {.callout-important}\n## User Interface\n\n**Users should NOT directly instantiate plotter classes.** Instead, access plotters through system properties:\n\n```python\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)  # TrajectoryPlotter\nfig = system.phase_plotter.plot_2d(x)       # PhasePortraitPlotter\nfig = system.control_plotter.plot_eigenvalue_map(eigs)  # ControlPlotter\n\n# ❌ INCORRECT: Direct instantiation (not recommended)\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nplotter = TrajectoryPlotter()  # Don't do this!\nfig = plotter.plot_trajectory(t, x)\n```\n\nThe system properties automatically configure plotters with the correct backend and provide a consistent interface. Direct instantiation is only needed for framework development or advanced customization.\n:::\n\n\n\n## Architecture Philosophy {#sec-architecture-philosophy}\n\n**Themeable Interactive Visualization** - The visualization framework enables:\n\n1. **Interactive Plots** - Plotly-based with zoom, pan, hover tooltips\n2. **Centralized Theming** - Consistent colors and styles across all plots\n3. **Backend Agnostic** - Works with NumPy, PyTorch, JAX seamlessly\n4. **Specialized Plotters** - Dedicated classes for different visualization types\n5. **Publication Ready** - High-quality output for papers and presentations\n6. **System Integration** - Clean `system.plotter` and `system.control_plotter` APIs\n7. **Accessible Design** - Colorblind-safe palettes available\n\n## Framework Layers {#sec-framework-layers}\n\n```\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│         (ContinuousSystemBase, DiscreteSystemBase)         │\n│                                                            │\n│  system.plotter          ──────► TrajectoryPlotter         │\n│  system.phase_plotter    ──────► PhasePortraitPlotter      │\n│  system.control_plotter  ──────► ControlPlotter            │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ use theming from\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   THEMING LAYER                            │\n│                   themes.py                                │\n│                                                            │\n│  ColorSchemes:            PlotThemes:                      │\n│  • PLOTLY                • DEFAULT                         │\n│  • D3                    • PUBLICATION                     │\n│  • COLORBLIND_SAFE       • DARK                            │\n│  • TABLEAU                                                 │\n│  • SEQUENTIAL_BLUE                                         │\n│  • DIVERGING_RED_BLUE                                      │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ used by\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   PLOTTER LAYER                            │\n│                                                            │\n│  TrajectoryPlotter, PhasePortraitPlotter, ControlPlotter   │\n└────────────────────────────────────────────────────────────┘\n```\n\n## Theming Layer {#sec-theming-layer}\n\n### Color Schemes {#sec-color-schemes}\n\nThe framework provides several built-in color schemes optimized for different purposes:\n\n::: {#demo-color-schemes .cell execution_count=2}\n``` {.python .cell-code}\n# Demonstrate different color schemes\nschemes = {\n    'Plotly (Default)': ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A'],\n    'Colorblind Safe': ['#0173B2', '#DE8F05', '#029E73', '#CC78BC', '#CA9161'],\n    'Tableau': ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F'],\n}\n\nfig = make_subplots(\n    rows=len(schemes), cols=1,\n    subplot_titles=list(schemes.keys()),\n    vertical_spacing=0.15\n)\n\nfor i, (name, colors) in enumerate(schemes.items(), 1):\n    for j, color in enumerate(colors):\n        fig.add_trace(\n            go.Bar(x=[j], y=[1], marker_color=color, showlegend=False),\n            row=i, col=1\n        )\n    fig.update_xaxes(title_text=\"Color Index\", row=i, col=1)\n    fig.update_yaxes(showticklabels=False, row=i, col=1)\n\nfig.update_layout(height=400, title_text=\"Color Scheme Comparison\")\nfig\n```\n:::\n\n\n### Plot Themes {#sec-plot-themes}\n\nThree built-in themes provide different visual styles:\n\n| Theme | Use Case | Features |\n|-------|----------|----------|\n| `default` | Interactive exploration | Plotly default, colorful |\n| `publication` | Papers, presentations | Clean, high-contrast, serif fonts |\n| `dark` | Presentations, demos | Dark background, reduced eye strain |\n\n## TrajectoryPlotter: Time-Domain Visualization {#sec-trajectory-plotter}\n\n::: {.callout-tip}\n## Integration Methods for Visualization\n\nFor visualization purposes, **use `simulate()`** instead of `integrate()`:\n\n- `simulate()` returns **regular time grids** (uniform spacing) - ideal for plotting\n- `integrate()` returns **adaptive time points** (variable spacing) - can create uneven plots\n\n```python\n# ✓ RECOMMENDED for plotting: Regular time grid\nresult = system.simulate(x0, controller, t_span=(0, 10), dt=0.01)\nfig = system.plotter.plot_trajectory(result['time'], result['states'])\n\n# ⚠️ Works but may have uneven time spacing: Adaptive grid\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='RK45')\n# Or use t_eval for regular grid:\nresult = system.integrate(x0, u=None, t_span=(0, 10), t_eval=np.linspace(0, 10, 1001))\nfig = system.plotter.plot_trajectory(result['t'], result['x'])\n```\n\n**Why this matters:**\n- Adaptive methods choose time points based on error control (dense where dynamics change, sparse where smooth)\n- This can create visually uneven plots with more points in some regions\n- Regular grids ensure uniform visual appearance\n- For comparison plots, all trajectories **must** have same time grid\n:::\n\n### Basic Trajectory Plot {#sec-basic-trajectory}\n\nThe most common visualization: state variables vs time.\n\n::: {#demo-trajectory-basic .cell execution_count=3}\n``` {.python .cell-code}\n# Simulate pendulum with regular time grid (recommended for plotting)\nx0 = np.array([0.5, 0.0])\nresult = system.simulate(x0, controller=None, t_span=(0, 10), dt=0.01)\n\n# Plot using system's built-in plotter\nfig = system.plotter.plot_trajectory(\n    result['time'],\n    result['states'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title='Pendulum Dynamics'\n)\nfig\n```\n:::\n\n\n::: {.callout-note}\n## Why `simulate()` for Plotting\n\nThis example uses `simulate()` rather than `integrate()` because:\n- **Regular time grid** (uniform dt=0.01) makes for smooth, evenly-spaced plots\n- **Time-major output** `result['states']` is (T, nx) - natural for plotting\n- **Reconstructed controls** available if controller provided\n\nFor comparison, `integrate()` returns adaptive time points that may create visually uneven plots.\n:::\n\n### Batched Trajectories (Monte Carlo) {#sec-batched-trajectories}\n\nAutomatically handles multiple trajectories with mean ± std visualization. This example uses the **stochastic pendulum** to show genuine stochastic dynamics:\n\n::: {#demo-trajectory-batch .cell execution_count=4}\n``` {.python .cell-code}\n# Use stochastic pendulum with additive noise\n# σ = 0.3 gives moderate noise (visible but not overwhelming)\n\n# Switch to torch backend for SDE integration (required for euler method)\nstochastic_system.set_default_backend('torch')\n\n# Run Monte Carlo simulation\nn_trials = 20\nx0 = np.array([0.5, 0.0])  # Start from same initial condition\n\nresults = []\nfor i in range(n_trials):\n    # Each trajectory gets different random noise realization\n    result = stochastic_system.integrate(\n        x0, \n        u=None, \n        t_span=(0, 10),\n        method='euler',\n        dt=0.01,\n        seed=i  # Different seed for each trial\n    )\n    # Convert torch tensor to numpy\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    results.append(x_np)\n\n# Stack into batch\nx_batch = np.stack(results)  # (n_trials, T, nx)\n\n# Plot automatically shows mean ± std\nfig = stochastic_system.plotter.plot_trajectory(\n    result['t'],\n    x_batch,\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title=f'Stochastic Pendulum Monte Carlo (n={n_trials}, σ=0.3)',\n    show_std=True\n)\nfig\n```\n:::\n\n\n::: {.callout-note}\n## Stochastic vs Deterministic Monte Carlo\n\nThis example demonstrates **genuine stochastic dynamics** from the SDE:\n\n$dx = f(x, u)dt + g(x, u)dW$\n\nThe trajectory variability comes from **random Brownian forcing**, not just different initial conditions. Each trajectory experiences different noise realizations $dW(t)$, showing how randomness affects the system's evolution.\n\nFor comparison, a deterministic Monte Carlo (like the previous example) shows variability only from initial condition uncertainty, not from dynamic randomness.\n:::\n\n\n### State and Control Together {#sec-state-control}\n\nVisualize both states and control inputs:\n\n::: {#demo-state-control .cell execution_count=5}\n``` {.python .cell-code}\n# Simple proportional controller\ndef controller(x, t):\n    K = np.array([[-2.0, -1.0]])\n    return -K @ x\n\n# Simulate with controller\nfrom cdesym.systems.base.core.continuous_system_base import ContinuousSystemBase\nresult = system.simulate(x0, controller=controller, t_span=(0, 10), dt=0.01)\n\n# Plot states and controls\nfig = system.plotter.plot_state_and_control(\n    result['time'],\n    result['states'],\n    result['controls'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    control_names=['Torque (N⋅m)']\n)\nfig\n```\n:::\n\n\n### Comparing Multiple Designs {#sec-comparing-designs}\n\nCompare different control strategies:\n\n::: {#demo-comparison .cell execution_count=6}\n``` {.python .cell-code}\n# Simulate with different controllers\n# Note: All must use same time grid for comparison\ncontrollers = {\n    'P (K=1)': lambda x, t: np.array([-1.0 * x[0] - 0.5 * x[1]]),\n    'P (K=5)': lambda x, t: np.array([-5.0 * x[0] - 2.0 * x[1]]),\n    'No Control': None\n}\n\n# Use common dt for all simulations\ndt = 0.01\ntrajectories = {}\nt_common = np.arange(0, 10 + dt, dt)\n\nfor name, ctrl in controllers.items():\n    # Use simulate() to ensure regular time grid\n    result = system.simulate(x0, controller=ctrl, t_span=(0, 10), dt=dt)\n    trajectories[name] = result['states']\n\n# Compare trajectories (all have same time grid)\nfig = system.plotter.plot_comparison(\n    t_common,\n    trajectories,\n    state_names=['θ (rad)', 'ω (rad/s)']\n)\nfig\n```\n:::\n\n\n::: {.callout-important}\n## Regular Time Grids Required for Comparison\n\nWhen comparing multiple trajectories, **all must use the same time grid**. Use `simulate()` with the same `dt` for all runs, or use `integrate()` with the same `t_eval` array.\n\n```python\n# ✓ CORRECT: Same time grid\nfor name, ctrl in controllers.items():\n    result = system.simulate(x0, controller=ctrl, t_span=(0, 10), dt=0.01)\n    \n# ❌ WRONG: Different adaptive grids\nfor name, ctrl in controllers.items():\n    result = system.integrate(x0, u=ctrl, t_span=(0, 10))\n    # Different number of time points! Cannot compare directly.\n```\n:::\n\n## PhasePortraitPlotter: State-Space Visualization {#sec-phase-portrait}\n\n### 2D Phase Portrait {#sec-2d-phase}\n\nVisualize dynamics in state space:\n\n::: {#demo-phase-2d .cell execution_count=7}\n``` {.python .cell-code}\n# Simulate from multiple initial conditions (use simulate for regular grids)\ninitial_conditions = [\n    np.array([0.3, 0.0]),\n    np.array([1.0, 0.0]),\n    np.array([1.5, 0.5]),\n]\n\ntrajectories = []\nfor x0_i in initial_conditions:\n    result = system.simulate(x0_i, controller=None, t_span=(0, 15), dt=0.01)\n    trajectories.append(result['states'])\n\nx_all = np.stack(trajectories)  # (n_traj, T, nx)\n\n# Plot phase portrait\nfig = system.phase_plotter.plot_2d(\n    x_all,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    equilibria=[np.array([0, 0])],\n    show_direction=True\n)\nfig\n```\n:::\n\n\n### With Vector Field {#sec-vector-field}\n\nAdd vector field to show dynamics everywhere:\n\n::: {#demo-phase-vectorfield .cell execution_count=8}\n``` {.python .cell-code}\n# Define vector field function\ndef pendulum_field(theta, omega):\n    \"\"\"Compute derivatives at any point in phase space.\"\"\"\n    x = np.array([theta, omega])\n    dx = system(x, u=np.zeros(1))\n    return dx[0], dx[1]\n\n# Plot with vector field\nfig = system.phase_plotter.plot_2d(\n    x_all,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    vector_field=pendulum_field,\n    equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n    show_direction=True\n)\nfig\n```\n:::\n\n\n## ControlPlotter: Control Analysis {#sec-control-plotter}\n\n### Eigenvalue Map {#sec-eigenvalue-map}\n\nVisualize closed-loop stability with comparison:\n\n::: {#demo-eigenvalue-map .cell execution_count=9}\n``` {.python .cell-code}\n# Get linearization at origin\nx_eq, u_eq = system.get_equilibrium('origin')\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\nlqr_result = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Plot eigenvalues using dictionary format (recommended for comparison)\neigenvalues_ol = np.linalg.eigvals(A)\neigenvalues_cl = lqr_result['closed_loop_eigenvalues']\n\neigenvalue_sets = {\n    'Open-loop': eigenvalues_ol,\n    'Closed-loop (LQR)': eigenvalues_cl,\n}\n\nfig = system.control_plotter.plot_eigenvalue_map(\n    eigenvalue_sets,\n    system_type='continuous',\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\nfig\n```\n:::\n\n\n::: {.callout-tip}\n## Comparing Eigenvalue Sets\n\nThe `plot_eigenvalue_map()` method supports multiple input formats:\n\n**Dictionary format (recommended for comparison):**\n```python\neigenvalue_sets = {\n    'Open-loop': eigs_ol,\n    'Closed-loop (LQR)': eigs_cl,\n}\nfig = system.control_plotter.plot_eigenvalue_map(eigenvalue_sets)\n```\n\n**Concatenated with per-eigenvalue labels:**\n```python\neigs_all = np.concatenate([eigs_ol, eigs_cl])\nlabels = ['Open-loop'] * len(eigs_ol) + ['Closed-loop'] * len(eigs_cl)\nfig = system.control_plotter.plot_eigenvalue_map(eigs_all, labels=labels)\n```\n\n**Single set:**\n```python\nfig = system.control_plotter.plot_eigenvalue_map(eigs_cl, labels='LQR')\n```\n\nEach set gets a unique color and marker symbol for easy distinction!\n:::\n\n## Stochastic System Visualization {#sec-stochastic-viz}\n\n### Comparing Noise Levels {#sec-noise-comparison}\n\nVisualize impact of different noise intensities:\n\n::: {#demo-noise-comparison .cell execution_count=10}\n``` {.python .cell-code}\n# Create systems with different noise levels\nnoise_levels = [0.1, 0.3, 0.5]\ntrajectories_noise = {}\n\n# Use common time grid for comparison\ndt = 0.01\nt_common = np.arange(0, 15 + dt, dt)\n\nfor sigma in noise_levels:\n    sys_i = ContinuousStochasticPendulum(g=9.81, L=1.0, b=0.5, sigma=sigma)\n    sys_i.set_default_backend('torch')\n    x0 = np.array([0.3, 0.0])\n    \n    result = sys_i.integrate(\n        x0, u=None, t_span=(0, 15), \n        method='euler', dt=dt, seed=42\n    )\n    \n    # Convert to numpy for plotting\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    trajectories_noise[f'σ={sigma}'] = x_np\n\n# Compare trajectories (pass t and trajectories separately)\nfig = stochastic_system.plotter.plot_comparison(\n    t_common,\n    trajectories_noise,\n    state_names=['θ (rad)', 'ω (rad/s)']\n)\nfig.update_layout(title='Effect of Noise Intensity on Stochastic Pendulum')\nfig\n```\n:::\n\n\n::: {.callout-tip}\n## Noise Impact\n\nNotice how increasing noise intensity ($\\sigma$):\n\n- Creates larger amplitude fluctuations\n- Can induce transitions over energy barriers\n- Affects regularity of oscillations\n- Changes effective damping behavior\n\nAt moderate noise levels, the system exhibits **stochastic resonance** - an optimal noise level that actually enhances response to periodic forcing.\n:::\n\n### Stochastic Phase Portrait {#sec-stochastic-phase}\n\nPhase portraits reveal noise-induced behavior:\n\n::: {#demo-stochastic-phase .cell execution_count=11}\n``` {.python .cell-code}\n# Switch to torch for SDE integration\nstochastic_system.set_default_backend('torch')\n\n# Multiple stochastic trajectories from same initial condition\nn_trajectories = 5\nstochastic_trajectories = []\n\nfor i in range(n_trajectories):\n    result = stochastic_system.integrate(\n        np.array([0.5, 0.0]),\n        u=None,\n        t_span=(0, 20),\n        method='euler',\n        dt=0.01,\n        seed=i\n    )\n    # Convert to numpy\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    stochastic_trajectories.append(x_np)\n\nx_stochastic = np.stack(stochastic_trajectories)\n\n# Reset backend\nstochastic_system.set_default_backend('numpy')\n\n# Plot stochastic phase portrait\nfig = stochastic_system.phase_plotter.plot_2d(\n    x_stochastic,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    equilibria=[np.array([0, 0])],\n    show_direction=True\n)\nfig.update_layout(title='Stochastic Pendulum Phase Portrait (Same IC, Different Noise)')\nfig\n```\n:::\n\n\n::: {.callout-note}\n## Stochastic vs Deterministic Phase Portraits\n\nUnlike deterministic systems where each initial condition produces one unique trajectory, stochastic systems produce a **cloud of possible trajectories** from the same initial condition. This visualization shows:\n\n- **Trajectory spreading** due to random forcing\n- **Noise-induced wandering** in phase space\n- **Probabilistic barrier crossing** (not deterministic separatrix)\n- **Effective diffusion** in state space\n\nThe phase portrait becomes a probability distribution rather than a single curve!\n:::\n\n## ControlPlotter: Control Analysis {#sec-control-plotter-continued}\n\n### Gain Comparison {#sec-gain-comparison}\n\nCompare feedback gains for different designs:\n\n::: {#demo-gain-comparison .cell execution_count=12}\n``` {.python .cell-code}\n# Design LQR with different Q weights\nQ_values = [1, 10, 100]\ngains = {}\nfor q in Q_values:\n    Q_i = q * np.diag([10, 1])\n    result = system.control.design_lqr(A, B, Q_i, R, system_type='continuous')\n    gains[f'Q={q}'] = result['gain']\n\n# Plot gain comparison\nfig = system.control_plotter.plot_gain_comparison(\n    gains,\n    labels=['θ', 'ω']\n)\nfig\n```\n:::\n\n\n### Step Response {#sec-step-response}\n\nAnalyze closed-loop performance:\n\n::: {#demo-step-response .cell execution_count=13}\n``` {.python .cell-code}\n# Create closed-loop system\nfrom scipy import signal\n\n# Output: measure angle only\nC = np.array([[1, 0]])\nD = np.zeros((1, 1))\n\n# Closed-loop dynamics\nA_cl = A - B @ lqr_result['gain']\nsys_cl = signal.StateSpace(A_cl, B, C, D)\n\n# Step response\nt_step = np.linspace(0, 5, 500)\nt_out, y_out = signal.step(sys_cl, T=t_step)\n\n# Plot with metrics\nfig = system.control_plotter.plot_step_response(\n    t_out,\n    y_out.squeeze(),\n    reference=1.0,\n    show_metrics=True\n)\nfig\n```\n:::\n\n\n## Publication-Ready Output {#sec-publication-ready}\n\n### Publication Theme {#sec-pub-theme}\n\nSwitch to publication theme for papers:\n\n::: {#demo-publication-theme .cell execution_count=14}\n``` {.python .cell-code}\n# Get a fresh result for this example\nx0_pub = np.array([0.5, 0.0])\nresult_pub = system.simulate(x0_pub, controller=None, t_span=(0, 10), dt=0.01)\n\n# Same trajectory, publication theme\nfig = system.plotter.plot_trajectory(\n    result_pub['time'],\n    result_pub['states'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title='Pendulum Dynamics',\n    theme='publication',\n    color_scheme='colorblind_safe'\n)\nfig\n```\n:::\n\n\n### Exporting Figures {#sec-exporting}\n\nPlotly figures can be exported in multiple formats:\n\n```python\n# Export as HTML (interactive)\nfig.write_html('pendulum_trajectory.html')\n\n# Export as static image (requires kaleido)\nfig.write_image('pendulum_trajectory.pdf', width=800, height=600)\nfig.write_image('pendulum_trajectory.png', width=800, height=600, scale=2)\n\n# Export as SVG (vector graphics)\nfig.write_image('pendulum_trajectory.svg')\n```\n\n## Design Patterns {#sec-design-patterns}\n\n### Pattern 1: Centralized Theming {#sec-pattern-theming}\n\nAll plotters use centralized themes:\n\n```python\n# ❌ BAD: Hardcoded colors\nclass BadPlotter:\n    def plot(self):\n        fig.add_trace(go.Scatter(line=dict(color='#1f77b4')))\n\n# ✓ GOOD: Centralized theming\nclass GoodPlotter:\n    def plot(self, color_scheme='plotly', theme='default'):\n        colors = ColorSchemes.get_colors(color_scheme)\n        fig.add_trace(go.Scatter(line=dict(color=colors[0])))\n        fig = PlotThemes.apply_theme(fig, theme)\n```\n\n### Pattern 2: Backend Agnostic {#sec-pattern-backend}\n\nAutomatically converts PyTorch/JAX to NumPy:\n\n```python\ndef plot_trajectory(self, t, x):\n    # Convert to NumPy for Plotly\n    t_np = self._to_numpy(t)\n    x_np = self._to_numpy(x)\n    \n    # Plot with Plotly (requires NumPy)\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=t_np, y=x_np[:, 0]))\n    return fig\n\ndef _to_numpy(self, arr):\n    if hasattr(arr, 'cpu'):  # PyTorch\n        return arr.cpu().numpy()\n    elif hasattr(arr, '__array__'):  # JAX\n        return np.array(arr)\n    return arr\n```\n\n### Pattern 3: Adaptive Layouts {#sec-pattern-adaptive}\n\nOptimal subplot arrangements:\n\n```python\ndef _determine_subplot_layout(self, n_plots: int) -> Tuple[int, int]:\n    \"\"\"\n    Determine optimal subplot grid.\n    \n    1-2 plots: (n, 1) vertical\n    3-4 plots: (2, 2) square\n    5-6 plots: (2, 3)\n    7-9 plots: (3, 3)\n    \"\"\"\n    if n_plots <= 2:\n        return n_plots, 1\n    elif n_plots <= 4:\n        return 2, 2\n    else:\n        cols = int(np.ceil(np.sqrt(n_plots)))\n        rows = int(np.ceil(n_plots / cols))\n        return rows, cols\n```\n\n### Pattern 4: Batch Detection {#sec-pattern-batch}\n\nAutomatically detect and process batched data:\n\n```python\ndef _process_batch(self, x: np.ndarray):\n    if x.ndim == 3:  # (n_batch, T, nx)\n        return np.mean(x, axis=0), np.std(x, axis=0), True\n    elif x.ndim == 2:  # (T, nx)\n        return x, None, False\n    else:\n        raise ValueError(f\"Invalid shape: {x.shape}\")\n```\n\n## Integration with Systems {#sec-integration}\n\n### Property-Based Access (Recommended) {#sec-property-access}\n\nAll systems provide plotter properties for convenient access:\n\n```python\n# ✓ Access via system properties (recommended)\nsystem.plotter           # TrajectoryPlotter instance\nsystem.phase_plotter     # PhasePortraitPlotter instance\nsystem.control_plotter   # ControlPlotter instance\n\n# Convenience method\nsystem.plot(result)      # Quick trajectory plot\n```\n\n::: {.callout-warning}\n## Do Not Instantiate Plotters Directly\n\nPlotters are **internal framework components** that should be accessed through system properties, not instantiated directly:\n\n```python\n# ❌ WRONG: Direct instantiation\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nfrom cdesym.visualization.phase_portrait import PhasePortraitPlotter\nfrom cdesym.visualization.control_plots import ControlPlotter\n\nplotter = TrajectoryPlotter(backend='numpy')  # Don't do this!\nphase = PhasePortraitPlotter(backend='numpy')  # Don't do this!\ncontrol = ControlPlotter(backend='numpy')      # Don't do this!\n\n# ✓ CORRECT: Access via system\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)\nfig = system.phase_plotter.plot_2d(x)\nfig = system.control_plotter.plot_eigenvalue_map(eigs)\n```\n\nThe system automatically creates and configures plotters with the correct backend. Direct instantiation is only needed for:\n- Framework development\n- Testing plotter components in isolation\n- Advanced customization outside the system context\n:::\n\n### Typical Workflow {#sec-typical-workflow}\n\n```python\n# 1. Create system\nsystem = Pendulum()\n\n# 2. Simulate\nresult = system.simulate(x0, controller, t_span=(0, 10))\n\n# 3. Visualize (plotters accessed through system)\nfig = system.plotter.plot_trajectory(\n    result['time'],\n    result['states'],\n    theme='publication'\n)\nfig\n```\n\n## Available Plot Types {#sec-plot-types}\n\n### Summary Table {#sec-plot-summary}\n\n| Plotter | Method | Purpose |\n|---------|--------|---------|\n| **TrajectoryPlotter** | | |\n| | `plot_trajectory()` | States vs time |\n| | `plot_state_and_control()` | States + controls |\n| | `plot_comparison()` | Compare multiple runs |\n| **PhasePortraitPlotter** | | |\n| | `plot_2d()` | 2D phase portrait |\n| | `plot_3d()` | 3D phase portrait |\n| | `plot_limit_cycle()` | Periodic orbits |\n| **ControlPlotter** | | |\n| | `plot_eigenvalue_map()` | Stability analysis |\n| | `plot_gain_comparison()` | Compare gains |\n| | `plot_step_response()` | Step response metrics |\n| | `plot_impulse_response()` | Impulse response |\n| | `plot_frequency_response()` | Bode plots |\n| | `plot_nyquist()` | Nyquist diagram |\n| | `plot_root_locus()` | Root locus |\n| | `plot_controllability_gramian()` | Gramian heatmap |\n| | `plot_observability_gramian()` | Gramian heatmap |\n| | `plot_riccati_convergence()` | Solver convergence |\n\n## Key Strengths {#sec-key-strengths}\n\n::: {.callout-tip}\n## Framework Advantages\n\n1. **Centralized Theming** - Single source of truth for colors/styles\n2. **Backend Agnostic** - NumPy/PyTorch/JAX transparent\n3. **Interactive** - Plotly-based with zoom, pan, hover\n4. **Publication Ready** - Professional defaults and themes\n5. **Accessible** - Colorblind-safe palettes\n6. **Specialized Plotters** - Right tool for each visualization type\n7. **System Integration** - Clean `system.plotter` APIs\n8. **Adaptive Layouts** - Optimal subplot arrangements\n9. **Batch Support** - Monte Carlo visualization automatic\n10. **Comprehensive** - 16+ plot types covering all needs\n:::\n\n## Summary\n\nThe visualization framework provides **publication-quality interactive plotting** seamlessly integrated with ControlDESymulation's dynamical systems. All plots are:\n\n- ✅ Interactive with Plotly\n- ✅ Themeable for different contexts\n- ✅ Backend-agnostic\n- ✅ Automatically adaptive\n- ✅ Publication-ready\n\n::: {.callout-important}\n## Usage Reminder\n\nAccess visualization through system properties:\n\n```python\nsystem.plotter           # Time-domain plots\nsystem.phase_plotter     # Phase space plots\nsystem.control_plotter   # Control analysis plots\n```\n\n**Do not directly instantiate** `TrajectoryPlotter`, `PhasePortraitPlotter`, or `ControlPlotter` classes—the system handles this automatically with proper configuration.\n:::\n\n",
    "supporting": [
      "Visualization_Framework_Architecture_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script type=\"text/javascript\">\nwindow.PlotlyConfig = {MathJaxConfig: 'local'};\nif (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: \"STIX-Web\"}});}\n</script>\n<script type=\"module\">import \"https://cdn.plot.ly/plotly-3.3.0.min\"</script>\n\n"
      ]
    }
  }
}