{
  "hash": "4585836b23541995c1154f798b17fa3e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Control Framework Architecture\"\nsubtitle: \"Classical Control Theory for Analysis and Synthesis\"\nauthor: \"Gil Benezer\"\ndate: today\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    code-fold: show\n    code-tools: true\n    theme: cosmo\nexecute:\n  eval: true\n  cache: true\n  warning: false\n---\n\n## Overview {#sec-overview}\n\nThe **Control Framework** provides classical control theory algorithms for analysis and synthesis of dynamical systems. It consists of **3 core modules** organized into a clean **2-layer architecture**: pure stateless functions and thin composition wrappers.\n\n::: {.callout-note}\n## Framework Components\n\n**Pure Function Layer:** `classical_control_functions.py` - Stateless control algorithms  \n**Composition Layer:** `control_synthesis.py`, `system_analysis.py` - System integration  \n**Type Layer:** `control_classical.py` - TypedDict result definitions\n:::\n\n::: {.callout-important}\n## User Interaction Model\n\n**Users interact with the control framework through system properties:**\n```python\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\n\n# Control design\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\n\n# System analysis\nstability = system.analysis.stability(A, system_type='continuous')\ncontrollability = system.analysis.controllability(A, B)\n\n# ✗ INCORRECT: Direct function imports (not recommended)\nfrom cdesym.control.classical_control_functions import design_lqr\nlqr = design_lqr(A, B, Q, R, system_type='continuous')\n```\n\nThe system properties (`system.control`, `system.analysis`) automatically handle backend management and provide a consistent interface. Direct function calls are possible but bypass the system's backend configuration.\n:::\n\n\n\n## Architecture Philosophy {#sec-architecture-philosophy}\n\n**Functional Design with Composition** - The control framework achieves:\n\n1. **Pure Functions** - Stateless algorithms like scipy (design_lqr, analyze_stability)\n2. **Thin Wrappers** - Minimal composition layer for system integration\n3. **Type Safety** - TypedDict results for all algorithms\n4. **Backend Consistency** - Automatic backend handling from parent system\n5. **Separation of Concerns** - Analysis vs synthesis clearly separated\n6. **Mathematical Rigor** - Implements classical control theory correctly\n7. **Clean Integration** - Natural `system.control` and `system.analysis` APIs\n\n**Design principle:** Control algorithms are **pure functions** that work like scipy—take matrices in, return structured results. Thin wrapper classes provide system integration without adding business logic.\n\n## Framework Layers {#sec-framework-layers}\n```\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│              (ContinuousSystemBase, DiscreteSystemBase)    │\n│                                                            │\n│  system.control   ─────► ControlSynthesis                 │\n│  system.analysis  ─────► SystemAnalysis                   │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ delegates to\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│              PURE FUNCTION LAYER                           │\n│          classical_control_functions.py                    │\n│                                                            │\n│  Control Design:          System Analysis:                 │\n│  • design_lqr()          • analyze_stability()             │\n│  • design_kalman()       • analyze_controllability()       │\n│  • design_lqg()          • analyze_observability()         │\n│                                                            │\n│  All functions are stateless, pure, backend-agnostic       │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ returns\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   TYPE LAYER                               │\n│             control_classical.py                           │\n│                                                            │\n│  • LQRResult           • StabilityInfo                     │\n│  • KalmanFilterResult  • ControllabilityInfo               │\n│  • LQGResult           • ObservabilityInfo                 │\n└────────────────────────────────────────────────────────────┘\n```\n\n## Pure Function Layer {#sec-pure-function-layer}\n\n### classical_control_functions.py: Stateless Algorithms {#sec-classical-control-functions}\n\n**File:** `classical_control_functions.py`\n\nThe pure function layer provides stateless control algorithms that work like scipy—take matrices in, return structured TypedDict results.\n\n**Design philosophy:**\n\n- **Pure functions** - No side effects, no state\n- **Backend agnostic** - Internal conversion to/from NumPy for scipy\n- **Mathematical correctness** - Rigorous implementation of control theory\n- **Comprehensive validation** - Dimension checks, positive-definiteness\n- **Clear error handling** - Actionable exceptions for infeasible problems\n\n**Key categories:**\n\n### Control Design Functions {#sec-control-design}\n\n#### LQR Controller Design\n\n**Mathematical background:**\n\n**Continuous-time LQR:**\n\n$$J = \\int_0^\\infty (x'Qx + u'Ru + 2x'Nu) dt$$\n\n**Algebraic Riccati Equation (ARE):**\n\n$$A'P + PA - PBR^{-1}B'P + Q - N'R^{-1}N = 0$$\n\n**Optimal gain:**\n\n$$K = R^{-1}(B'P + N')$$\n\n**Discrete-time LQR:**\n\n$$J = \\sum_{k=0}^\\infty (x[k]'Qx[k] + u[k]'Ru[k] + 2x[k]'Nu[k])$$\n\n**Discrete ARE:**\n\n$$P = A'PA - (A'PB + N)(R + B'PB)^{-1}(B'PA + N') + Q$$\n\n**Optimal gain:**\n\n$$K = (R + B'PB)^{-1}(B'PA + N')$$\n\n**Function signature:**\n```python\ndef design_lqr(\n    A: StateMatrix,\n    B: InputMatrix,\n    Q: StateMatrix,\n    R: InputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -> LQRResult:\n    \"\"\"\n    Design Linear Quadratic Regulator (LQR) controller.\n    \n    Unified interface for continuous and discrete LQR.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    Q : StateMatrix\n        State cost matrix (nx, nx), Q ≥ 0, (Q,A) detectable\n    R : InputMatrix\n        Control cost matrix (nu, nu), R > 0\n    N : InputMatrix, optional\n        Cross-coupling matrix (nx, nu)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    LQRResult\n        gain : Optimal feedback gain K (nu, nx)\n        cost_to_go : Riccati solution P (nx, nx)\n        closed_loop_eigenvalues : eig(A - BK)\n        stability_margin : Stability robustness measure\n    \n    Raises\n    ------\n    ValueError\n        If Q, R dimensions incompatible or conditions violated\n    LinAlgError\n        If Riccati equation has no stabilizing solution\n    \"\"\"\n```\n\n**Usage example:**\n\n::: {#ex-lqr-design .cell execution_count=2}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Linearize at upright equilibrium\nx_eq = np.array([np.pi, 0.0])\nu_eq = np.array([0.0])\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])   # Penalize angle more than velocity\nR = np.array([[0.1]])   # Small control cost\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Extract results\nK = lqr['gain']\nP = lqr['cost_to_go']\neigs = lqr['controller_eigenvalues']\n\nprint(f\"LQR gain shape: {K.shape}\")\nprint(f\"Closed-loop stable: {np.all(np.real(eigs) < 0)}\")\n```\n:::\n\n\n#### Kalman Filter Design\n\n**Mathematical background:**\n\n**System model:**\n\n$$x[k+1] = Ax[k] + Bu[k] + w[k], \\quad w \\sim \\mathcal{N}(0, Q)$$\n\n$$y[k] = Cx[k] + v[k], \\quad v \\sim \\mathcal{N}(0, R)$$\n\n**Estimator dynamics:**\n\n$$\\hat{x}[k+1] = A\\hat{x}[k] + Bu[k] + L(y[k] - C\\hat{x}[k])$$\n\n**Optimal gain:**\n\n$$L = APC'(CPC' + R)^{-1}$$\n\n**Error covariance Riccati equation:**\n\n$$P = A(P - PC'(CPC' + R)^{-1}CP)A' + Q$$\n\n**Function signature:**\n```python\ndef design_kalman_filter(\n    A: StateMatrix,\n    C: OutputMatrix,\n    Q: StateMatrix,\n    R: OutputMatrix,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -> KalmanFilterResult:\n    \"\"\"\n    Design Kalman filter for optimal state estimation.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    Q : StateMatrix\n        Process noise covariance (nx, nx), Q ≥ 0\n    R : OutputMatrix\n        Measurement noise covariance (ny, ny), R > 0\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    KalmanFilterResult\n        gain : Kalman gain L (nx, ny)\n        error_covariance : Steady-state P (nx, nx)\n        innovation_covariance : S = CPC' + R (ny, ny)\n        observer_eigenvalues : eig(A - LC)\n    \"\"\"\n```\n\n**Usage example:**\n\n::: {#ex-kalman-design .cell execution_count=3}\n``` {.python .cell-code}\n# Define measurement model (measure angle only)\nC = np.array([[1, 0]])\n\n# Define noise covariances\nQ_process = 0.01 * np.eye(2)      # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# Extract results\nL = kalman['gain']\nP = kalman['estimation_error_covariance']\nestimator_eigs = kalman['estimator_eigenvalues']\n\nprint(f\"Kalman gain shape: {L.shape}\")\nprint(f\"Observer stable: {np.all(np.real(estimator_eigs) < 0)}\")\n```\n:::\n\n\n#### LQG Controller Design\n\n**Mathematical background:**\n\n**Separation principle:**\n\n1. Design LQR assuming full state feedback: $u = -Kx$\n2. Design Kalman filter for state estimation\n3. Combine via certainty equivalence: $u = -K\\hat{x}$\n\n**Closed-loop system:**\n\n$$\\begin{bmatrix} x[k+1] \\\\ e[k+1] \\end{bmatrix} = \\begin{bmatrix} A - BK & BK \\\\ 0 & A - LC \\end{bmatrix} \\begin{bmatrix} x[k] \\\\ e[k] \\end{bmatrix} + \\begin{bmatrix} w[k] \\\\ w[k] - Lv[k] \\end{bmatrix}$$\n\n**Eigenvalues:**\n\n- Controller poles: $\\text{eig}(A - BK)$\n- Observer poles: $\\text{eig}(A - LC)$\n- Combined: $\\text{eig}(A - BK) \\cup \\text{eig}(A - LC)$\n\n**Function signature:**\n```python\ndef design_lqg(\n    A: StateMatrix,\n    B: InputMatrix,\n    C: OutputMatrix,\n    Q_state: StateMatrix,\n    R_control: InputMatrix,\n    Q_process: StateMatrix,\n    R_measurement: OutputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -> LQGResult:\n    \"\"\"\n    Design Linear Quadratic Gaussian (LQG) controller.\n    \n    Combines LQR (optimal control) with Kalman filter (optimal estimation)\n    via the separation principle.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    Q_state : StateMatrix\n        LQR state cost (nx, nx)\n    R_control : InputMatrix\n        LQR control cost (nu, nu)\n    Q_process : StateMatrix\n        Process noise covariance (nx, nx)\n    R_measurement : OutputMatrix\n        Measurement noise covariance (ny, ny)\n    N : InputMatrix, optional\n        Cross-coupling (nx, nu)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    LQGResult\n        control_gain : LQR gain K (nu, nx)\n        estimator_gain : Kalman gain L (nx, ny)\n        control_cost_to_go : Controller Riccati P_c\n        estimation_error_covariance : Estimator Riccati P_e\n        separation_verified : bool\n        closed_loop_stable : bool\n        controller_eigenvalues : eig(A - BK)\n        estimator_eigenvalues : eig(A - LC)\n    \"\"\"\n```\n\n**Usage example:**\n\n::: {#ex-lqg-design .cell execution_count=4}\n``` {.python .cell-code}\n# Design LQG controller\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state=np.diag([10, 1]),\n    R_control=np.array([[0.1]]),\n    Q_process=0.01*np.eye(2),\n    R_measurement=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Extract both gains\nK_control = lqg['control_gain']\nL_estimator = lqg['estimator_gain']\n\nprint(f\"LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"Separation verified: {lqg['separation_verified']}\")\nprint(f\"Controller poles: {lqg['controller_eigenvalues']}\")\nprint(f\"Observer poles: {lqg['estimator_eigenvalues']}\")\n```\n:::\n\n\n### System Analysis Functions {#sec-system-analysis}\n\n#### Stability Analysis\n\n**Mathematical background:**\n\n**Continuous-time stability criteria:**\n- **Asymptotically stable:** All $\\text{Re}(\\lambda) < 0$ (left half-plane)\n- **Marginally stable:** $\\max \\text{Re}(\\lambda) \\approx 0$\n- **Unstable:** Any $\\text{Re}(\\lambda) > 0$\n\n**Discrete-time stability criteria:**\n- **Asymptotically stable:** All $|\\lambda| < 1$ (inside unit circle)\n- **Marginally stable:** $\\max |\\lambda| \\approx 1$\n- **Unstable:** Any $|\\lambda| > 1$\n\n**Function signature:**\n```python\ndef analyze_stability(\n    A: StateMatrix,\n    system_type: str = \"continuous\",\n    backend: Backend = \"numpy\"\n) -> StabilityInfo:\n    \"\"\"\n    Analyze system stability via eigenvalue placement.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    StabilityInfo\n        eigenvalues : Complex eigenvalues of A\n        magnitudes : |λ| for each eigenvalue\n        max_magnitude : max |λ| (spectral radius)\n        spectral_radius : Same as max_magnitude\n        is_stable : Asymptotic stability\n        is_marginally_stable : On boundary\n        is_unstable : At least one unstable mode\n    \"\"\"\n```\n\n**Usage example:**\n\n::: {#ex-stability-analysis .cell execution_count=5}\n``` {.python .cell-code}\n# Analyze open-loop stability\nstability_ol = system.analysis.stability(A, system_type='continuous')\n\nprint(f\"Open-loop stable: {stability_ol['is_stable']}\")\nprint(f\"Spectral radius: {stability_ol['spectral_radius']:.3f}\")\nprint(f\"Eigenvalues: {stability_ol['eigenvalues']}\")\n\n# Analyze closed-loop stability (with LQR)\nA_cl = A - B @ K\nstability_cl = system.analysis.stability(A_cl, system_type='continuous')\n\nprint(f\"\\nClosed-loop stable: {stability_cl['is_stable']}\")\nprint(f\"Spectral radius: {stability_cl['spectral_radius']:.3f}\")\n```\n:::\n\n\n#### Controllability Analysis\n\n**Mathematical background:**\n\n**Controllability test:**\n\n$$\\text{rank}(\\mathcal{C}) = n_x \\quad \\text{where} \\quad \\mathcal{C} = [B, AB, A^2B, \\ldots, A^{n_x-1}B]$$\n\n**Interpretation:**\n- **Controllable:** All states can be driven to any value in finite time\n- **Uncontrollable:** Some states cannot be influenced by control\n\n**Function signature:**\n```python\ndef analyze_controllability(\n    A: StateMatrix,\n    B: InputMatrix,\n    backend: Backend = \"numpy\"\n) -> ControllabilityInfo:\n    \"\"\"\n    Test system controllability via rank condition.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    ControllabilityInfo\n        controllability_matrix : C = [B AB ... A^(n-1)B] (nx, nx*nu)\n        rank : Rank of controllability matrix\n        is_controllable : rank == nx\n        uncontrollable_modes : Eigenvalues of uncontrollable subsystem\n    \"\"\"\n```\n\n**Usage example:**\n\n::: {#ex-controllability-analysis .cell execution_count=6}\n``` {.python .cell-code}\n# Check controllability\nctrl = system.analysis.controllability(A, B)\n\nprint(f\"Controllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif ctrl['is_controllable']:\n    print(\"✓ Can design LQR controller\")\nelse:\n    print(\"✗ Cannot design LQR - system not controllable\")\n    if ctrl.get('uncontrollable_modes') is not None:\n        print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n```\n:::\n\n\n#### Observability Analysis\n\n**Mathematical background:**\n\n**Observability test:**\n\n$$\\text{rank}(\\mathcal{O}) = n_x \\quad \\text{where} \\quad \\mathcal{O} = \\begin{bmatrix} C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n_x-1} \\end{bmatrix}$$\n\n**Interpretation:**\n- **Observable:** Initial state can be determined from output measurements\n- **Unobservable:** Some states hidden from measurements\n\n**Function signature:**\n```python\ndef analyze_observability(\n    A: StateMatrix,\n    C: OutputMatrix,\n    backend: Backend = \"numpy\"\n) -> ObservabilityInfo:\n    \"\"\"\n    Test system observability via rank condition.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    ObservabilityInfo\n        observability_matrix : O = [C; CA; ...] (nx*ny, nx)\n        rank : Rank of observability matrix\n        is_observable : rank == nx\n        unobservable_modes : Eigenvalues of unobservable subsystem\n    \"\"\"\n```\n\n**Usage example:**\n\n::: {#ex-observability-analysis .cell execution_count=7}\n``` {.python .cell-code}\n# Check observability\nobs = system.analysis.observability(A, C)\n\nprint(f\"Observable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n    if obs.get('unobservable_modes') is not None:\n        print(f\"Unobservable modes: {obs['unobservable_modes']}\")\n\n# Check minimal realization\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"\\n✓ System is minimal (controllable and observable)\")\n    print(\"✓ Can design LQG controller\")\n```\n:::\n\n\n## Composition Wrapper Layer {#sec-composition-wrapper-layer}\n\n### ControlSynthesis: Control Design Wrapper {#sec-control-synthesis}\n\n**File:** `control_synthesis.py`\n\nThe `ControlSynthesis` class provides a thin wrapper for control design algorithms, integrating them with the system's backend configuration.\n\n**Design philosophy:**\n\n- **Composition not inheritance** - Utility composed by system, not inherited\n- **No state** - Only stores backend setting from parent system\n- **No caching** - Delegates immediately to pure functions\n- **Clean API** - Methods match control theory terminology\n\n**Architecture:**\n```python\nclass ControlSynthesis:\n    \"\"\"\n    Control synthesis wrapper for system composition.\n    \n    Thin wrapper that routes to pure control design functions while\n    maintaining backend consistency with parent system.\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def design_lqr(self, A, B, Q, R, N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqr()\"\"\"\n        from cdesym.control.classical_control_functions import design_lqr\n        return design_lqr(A, B, Q, R, N, system_type, self.backend)\n    \n    def design_kalman(self, A, C, Q, R, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_kalman_filter()\"\"\"\n        from cdesym.control.classical_control_functions import design_kalman_filter\n        return design_kalman_filter(A, C, Q, R, system_type, self.backend)\n    \n    def design_lqg(self, A, B, C, Q_state, R_control, Q_process, R_measurement, \n                   N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqg()\"\"\"\n        from cdesym.control.classical_control_functions import design_lqg\n        return design_lqg(A, B, C, Q_state, R_control, Q_process, R_measurement, \n                         N, system_type, self.backend)\n```\n\n**System integration:**\n```python\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef control(self) -> ControlSynthesis:\n    \"\"\"Access control synthesis utilities.\"\"\"\n    if not hasattr(self, '_control_synthesis'):\n        from cdesym.control.control_synthesis import ControlSynthesis\n        self._control_synthesis = ControlSynthesis(backend=self.backend.default_backend)\n    return self._control_synthesis\n```\n\n### SystemAnalysis: System Analysis Wrapper {#sec-system-analysis-wrapper}\n\n**File:** `system_analysis.py`\n\nThe `SystemAnalysis` class provides a thin wrapper for system analysis algorithms, identical in design to `ControlSynthesis`.\n\n**Architecture:**\n```python\nclass SystemAnalysis:\n    \"\"\"\n    System analysis wrapper for composition.\n    \n    Thin wrapper that routes to pure system analysis functions while\n    maintaining backend consistency with parent system.\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def stability(self, A, system_type='continuous'):\n        \"\"\"Route to classical_control_functions.analyze_stability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_stability\n        return analyze_stability(A, system_type, self.backend)\n    \n    def controllability(self, A, B):\n        \"\"\"Route to classical_control_functions.analyze_controllability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_controllability\n        return analyze_controllability(A, B, self.backend)\n    \n    def observability(self, A, C):\n        \"\"\"Route to classical_control_functions.analyze_observability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_observability\n        return analyze_observability(A, C, self.backend)\n```\n\n**System integration:**\n```python\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef analysis(self) -> SystemAnalysis:\n    \"\"\"Access system analysis utilities.\"\"\"\n    if not hasattr(self, '_system_analysis'):\n        from cdesym.control.system_analysis import SystemAnalysis\n        self._system_analysis = SystemAnalysis(backend=self.backend.default_backend)\n    return self._system_analysis\n```\n\n## Design Patterns {#sec-design-patterns}\n\n### Pattern 1: Pure Functions + Thin Wrappers {#sec-pattern-pure-functions}\n\n**Principle:** Separate stateless algorithms from system integration.\n\n::: {#ex-pattern-separation .cell execution_count=8}\n``` {.python .cell-code}\n# ✗ ANTI-PATTERN: Methods on system class (violates SRP)\nclass ContinuousSystemBase:\n    def design_lqr(self, Q, R):\n        # LQR implementation mixed with system concerns\n        pass\n\n# ✓ GOOD PATTERN: Pure function + composition\n\n# Pure function (classical_control_functions.py)\ndef design_lqr(A, B, Q, R, system_type, backend):\n    \"\"\"Stateless, testable, reusable.\"\"\"\n    # Focus solely on LQR algorithm\n    return LQRResult(...)\n\n# Thin wrapper (control_synthesis.py)\nclass ControlSynthesis:\n    def design_lqr(self, A, B, Q, R, system_type):\n        return design_lqr(A, B, Q, R, system_type, self.backend)\n\n# System integration (continuous_system_base.py)\n@property\ndef control(self) -> ControlSynthesis:\n    return ControlSynthesis(backend=self.backend.default_backend)\n```\n:::\n\n\n**Benefits:**\n\n- ✓ Single responsibility per component\n- ✓ Easy unit testing of pure functions\n- ✓ Reusable algorithms outside system context\n- ✓ Maintainability through isolation\n\n### Pattern 2: Backend Agnosticism {#sec-pattern-backend-agnostic}\n\n**Principle:** Convert to NumPy for scipy, then back to original backend.\n```python\ndef design_lqr(..., backend: Backend):\n    \"\"\"Works with NumPy, PyTorch, JAX transparently.\"\"\"\n    \n    # Convert to NumPy for scipy\n    A_np = _to_numpy(A, backend)\n    B_np = _to_numpy(B, backend)\n    Q_np = _to_numpy(Q, backend)\n    R_np = _to_numpy(R, backend)\n    \n    # Solve in NumPy (scipy.linalg)\n    P = solve_continuous_are(A_np, B_np, Q_np, R_np)\n    K = np.linalg.solve(R_np, B_np.T @ P)\n    \n    # Convert back to original backend\n    K_result = _from_numpy(K, backend)\n    P_result = _from_numpy(P, backend)\n    \n    return LQRResult(gain=K_result, cost_to_go=P_result, ...)\n```\n\n### Pattern 3: TypedDict Results {#sec-pattern-typeddict-results}\n\n**Principle:** Structured results with type safety and IDE support.\n\n::: {#ex-pattern-typeddict .cell execution_count=9}\n``` {.python .cell-code}\n# All functions return structured TypedDict\nresult: LQRResult = design_lqr(A, B, Q, R, system_type='continuous')\n\n# IDE autocomplete knows all fields\nK = result['gain']                    # ✓ Valid\nP = result['cost_to_go']              # ✓ Valid\neigs = result['controller_eigenvalues']  # ✓ Valid\nbad = result['nonexistent_key']       # ✗ Type error!\n\n# Type checking prevents errors\ndef apply_control(result: LQRResult) -> np.ndarray:\n    return result['gain']  # ✓ Type checker verifies\n```\n:::\n\n\n### Pattern 4: Unified Continuous/Discrete Interface {#sec-pattern-unified-interface}\n\n**Principle:** Single function handles both continuous and discrete cases.\n```python\ndef design_lqr(A, B, Q, R, N=None, system_type='discrete', backend='numpy'):\n    \"\"\"Unified interface - system_type selects algorithm.\"\"\"\n    \n    if system_type == 'continuous':\n        # Continuous-time algebraic Riccati equation\n        P = solve_continuous_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R, B.T @ P)\n    elif system_type == 'discrete':\n        # Discrete-time algebraic Riccati equation\n        P = solve_discrete_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R + B.T @ P @ B, B.T @ P @ A)\n    else:\n        raise ValueError(f\"Invalid system_type: {system_type}\")\n    \n    # Rest of implementation identical\n    closed_loop_eigs = np.linalg.eigvals(A - B @ K)\n    \n    return LQRResult(gain=K, cost_to_go=P, ...)\n```\n\n**Benefits:**\n\n- ✓ Single function for both cases\n- ✓ Less code duplication\n- ✓ Consistent API across system types\n- ✓ Easier maintenance\n\n## Usage Workflows {#sec-usage-workflows}\n\n### Workflow 1: LQR Controller Design {#sec-workflow-lqr}\n\n**Complete workflow from linearization to closed-loop simulation:**\n\n::: {#ex-workflow-lqr .cell execution_count=10}\n``` {.python .cell-code}\n# 1. Create system\nsystem = Pendulum(m_val=1.0, l_val=0.5, g_val=9.81, beta_val=0.1)\n\n# 2. Define equilibrium (upright position)\nx_eq = np.array([np.pi, 0])  # [theta, omega]\nu_eq = np.zeros(1)\n\n# 3. Linearize at equilibrium\nA, B = system.linearize(x_eq, u_eq)\n\n# 4. Design LQR controller\nQ = np.diag([10, 1])   # Penalize angle more than velocity\nR = np.array([[0.1]])   # Small control cost\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# 5. Extract and verify\nK = lqr['gain']\neigs = lqr['controller_eigenvalues']\n\nprint(f\"✓ LQR gain: {K}\")\nprint(f\"✓ Closed-loop stable: {np.all(np.real(eigs) < 0)}\")\n\n# 6. Implement controller\ndef lqr_controller(t, x):\n    return -K @ (x - x_eq)\n\n# 7. Simulate (closed-loop)\nresult = system.simulate(\n    x0=np.array([np.pi + 0.2, 0]),  # Start near upright\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\nprint(f\"✓ Simulation complete: {len(result['time'])} time points\")\n```\n:::\n\n\n### Workflow 2: Kalman Filter Design {#sec-workflow-kalman}\n\n**Observer design for partial state measurements:**\n\n::: {#ex-workflow-kalman .cell execution_count=11}\n``` {.python .cell-code}\n# 1. Same system and linearization\nA, B = system.linearize(x_eq, u_eq)\n\n# 2. Define measurement model (measure angle only)\nC = np.array([[1, 0]])  # Observe theta, not omega\n\n# 3. Define noise covariances\nQ_process = 0.01 * np.eye(2)      # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# 4. Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 5. Extract gain\nL = kalman['gain']\nobserver_eigs = kalman['estimator_eigenvalues']\n\nprint(f\"✓ Kalman gain: {L}\")\nprint(f\"✓ Observer stable: {np.all(np.real(observer_eigs) < 0)}\")\n\n# 6. Implement estimator\nx_hat = np.zeros(2)\ndt = 0.01\nN = 1000\n\nfor k in range(N):\n    # Prediction\n    x_hat_pred = A @ x_hat * dt + x_hat + B @ u[k] * dt\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + np.random.randn() * np.sqrt(0.1)\n    innovation = y_meas - C @ x_hat_pred\n    x_hat = x_hat_pred + L @ innovation * dt\n```\n:::\n\n\n### Workflow 3: LQG Controller Design {#sec-workflow-lqg}\n\n**Combined optimal control and estimation:**\n\n::: {#ex-workflow-lqg .cell execution_count=12}\n``` {.python .cell-code}\n# 1. Define all matrices\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Partial state measurement\n\n# 2. Design weights\nQ_state = np.diag([10, 1])        # LQR state cost\nR_control = np.array([[0.1]])      # LQR control cost\nQ_process = 0.01 * np.eye(2)      # Kalman process noise\nR_measurement = np.array([[0.1]])  # Kalman measurement noise\n\n# 3. Design LQG\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state, R_control,\n    Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 4. Extract both gains\nK = lqg['controller_gain']\nL = lqg['estimator_gain']\n\nprint(f\"✓ LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"✓ Separation verified: {lqg['separation_verified']}\")\n\n# 5. Implement LQG controller\nx_hat = np.zeros(2)\ndt = 0.01\n\nfor k in range(N):\n    # Control (certainty equivalence)\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Prediction\n    x_hat = A @ x_hat * dt + x_hat + B @ u[k] * dt\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + measurement_noise[k]\n    innovation = y_meas - C @ x_hat\n    x_hat = x_hat + L @ innovation * dt\n```\n:::\n\n\n### Workflow 4: System Analysis {#sec-workflow-analysis}\n\n**Complete system analysis before controller design:**\n\n::: {#ex-workflow-analysis .cell execution_count=13}\n``` {.python .cell-code}\n# 1. Linearize system\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])\n\n# 2. Check stability\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Open-loop stable: {stability['is_stable']}\")\nprint(f\"Eigenvalues: {stability['eigenvalues']}\")\nprint(f\"Spectral radius: {stability['spectral_radius']:.3f}\")\n\n# 3. Check controllability\nctrl = system.analysis.controllability(A, B)\nprint(f\"\\nControllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif not ctrl['is_controllable']:\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 4. Check observability\nobs = system.analysis.observability(A, C)\nprint(f\"\\nObservable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\n# 5. Verify conditions for control design\nif ctrl['is_controllable']:\n    print(\"\\n✓ Can design LQR controller\")\nelse:\n    print(\"\\n✗ Cannot design LQR - system not controllable\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"✓ System is minimal - can design LQG controller\")\n```\n:::\n\n\n## Key Strengths {#sec-key-strengths}\n\n::: {.callout-tip}\n## Control Framework Advantages\n\n1. **Pure Functional Core** - Stateless algorithms, easy to test and reuse\n2. **Thin Wrappers** - Minimal composition layer with no business logic\n3. **Type Safety** - TypedDict results throughout with IDE support\n4. **Backend Agnostic** - NumPy/PyTorch/JAX transparency\n5. **Separation of Concerns** - Analysis vs synthesis clearly separated\n6. **Mathematical Rigor** - Correct implementation of classical control theory\n7. **Clean Integration** - Natural `system.control` and `system.analysis` APIs\n8. **Unified Interface** - Single function for continuous/discrete cases\n9. **Comprehensive** - LQR, Kalman, LQG, stability, controllability, observability\n10. **Scipy-like** - Familiar API for control engineers\n:::\n\n## Summary\n\nThe Control Framework provides **production-quality classical control theory algorithms** through a clean two-layer architecture:\n\n- **Pure Function Layer** provides stateless, testable algorithms\n- **Composition Layer** integrates algorithms with system backend management\n- **Type Layer** ensures type safety with structured TypedDict results\n\nUsers interact through intuitive system properties (`system.control`, `system.analysis`) that automatically handle backend management and provide consistent interfaces across continuous and discrete systems.\n\n**The framework implements classical control theory correctly while maintaining clean software architecture and comprehensive type safety.**\n\n",
    "supporting": [
      "Control_Framework_Architecture_files"
    ],
    "filters": [],
    "includes": {}
  }
}