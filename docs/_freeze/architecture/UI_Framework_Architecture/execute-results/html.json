{
  "hash": "c1b9aa01e1f09d0387f9dc300db0f410",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"UI Framework Architecture\"\nsubtitle: \"User-Facing System Classes and Symbolic System Definition\"\nauthor: \"Gil Benezer\"\ndate: today\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    code-fold: show\n    code-tools: true\n    theme: cosmo\nexecute:\n  eval: true\n  cache: true\n  warning: false\n---\n\n## Overview {#sec-overview}\n\nThe **UI (User Interface) Framework** is Layer 3 of the architecture, consisting of **8 core files** organized into a **4-layer hierarchy** that provides the user-facing API for defining and working with dynamical systems. This layer eliminates approximately **1,800 lines of code duplication** while maintaining clean separation of concerns.\n\n::: {.callout-note}\n## Framework Components\n\n**Layer 0:** `SymbolicSystemBase` - Time-domain agnostic foundation  \n**Layer 1:** `ContinuousSystemBase`, `DiscreteSystemBase` - Time-domain interfaces  \n**Layer 2:** `ContinuousSymbolicSystem`, `DiscreteSymbolicSystem` - Concrete implementations  \n**Layer 3:** `ContinuousStochasticSystem`, `DiscreteStochasticSystem` - Stochastic extensions  \n**Special:** `DiscretizedSystem` - Continuous → discrete conversion\n:::\n\n::: {.callout-important}\n## User Interaction Model\n\n**Most users interact with the UI framework at two levels:**\n```python\n# Level 1: Use built-in systems (simplest)\nfrom cdesym import Pendulum, CartPole, VanDerPol\n\nsystem = Pendulum()\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\n\n# Level 2: Define custom systems (subclass framework)\nfrom cdesym import ContinuousSymbolicSystem\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n```\n\n**Users should NOT:**\n- Directly instantiate internal utilities (BackendManager, CodeGenerator, etc.)\n- Access private attributes (those starting with `_`)\n- Override methods other than `define_system()` and `print_equations()`\n\nThe framework automatically composes internal components and exposes functionality through clean public methods. This documentation describes the internal architecture for framework developers.\n:::\n\n\n\n## Architecture Philosophy {#sec-architecture-philosophy}\n\n**Layered Composition with Strategic Inheritance** - The UI framework achieves:\n\n1. **Zero Code Duplication** - Shared functionality lives in exactly one place\n2. **Clean Separation** - Each layer has a single, focused responsibility\n3. **Progressive Complexity** - Simple systems inherit from basic layers\n4. **Type Safety** - Comprehensive type annotations throughout\n5. **Extensibility** - Clear extension points via `define_system()`\n6. **Backend Agnosticism** - Multi-backend support transparent to users\n\nThe architecture uses **cooperative multiple inheritance** strategically at Layer 2 to combine symbolic machinery with time-domain interfaces, avoiding the duplication that would occur with composition alone.\n\n## Architecture Layers {#sec-architecture-layers}\n```\n┌─────────────────────────────────────────────────────────────┐\n│  Layer 0: SymbolicSystemBase (time-domain agnostic)         │\n│  • Symbolic variables and parameters                        │\n│  • Code generation and backend management                   │\n│  • Equilibrium handling and configuration                   │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n          ┌──────────┴──────────┐\n          │                     │\n┌─────────▼────────┐  ┌─────────▼─────────┐\n│  Layer 1:        │  │  Layer 1:         │\n│  Continuous      │  │  Discrete         │\n│  SystemBase      │  │  SystemBase       │\n│  • dx/dt = f     │  │  • x[k+1] = f     │\n│  • integrate()   │  │  • step()         │\n│  • linearize()   │  │  • simulate()     │\n└─────────┬────────┘  └─────────┬─────────┘\n          │                     │\n    ┌─────┴─────┐         ┌─────┴─────┐\n    │           │         │           │\n┌───▼────┐  ┌───▼────┐ ┌─▼──────┐ ┌──▼──────┐\n│Layer 2:│  │Layer 3:│ │Layer 2:│ │Layer 3: │\n│Cont.   │  │Cont.   │ │Disc.   │ │Disc.    │\n│Symbolic│  │Stoch.  │ │Symbolic│ │Stoch.   │\n│System  │  │System  │ │System  │ │System   │\n└────────┘  └────────┘ └────────┘ └─────────┘\n```\n\n## Layer 0: Foundation {#sec-layer-0}\n\n### SymbolicSystemBase: Time-Agnostic Foundation {#sec-symbolicsystembase}\n\n**File:** `symbolic_system_base.py`\n\nThe `SymbolicSystemBase` provides all symbolic manipulation and backend management functionality, making **no assumptions about continuous vs discrete time**.\n\n**Core responsibilities:**\n\n- **Symbolic variable management** - State, control, and output variables\n- **Parameter handling** - Symbolic parameters with numeric values\n- **Code generation** - Symbolic → numerical via CodeGenerator\n- **Backend management** - NumPy/PyTorch/JAX switching via BackendManager\n- **Equilibrium management** - Named equilibria via EquilibriumHandler\n- **Configuration persistence** - Save/load system definitions\n- **Validation** - Symbolic system validation via SymbolicValidator\n\n**Key design patterns:**\n\n- **Composition** - Delegates to specialized utilities\n- **Template Method** - `__init__` orchestrates: define → validate → initialize\n- **Abstract Methods** - Forces subclasses to implement `define_system()`\n\n**What Layer 0 does NOT provide:**\n\n- Forward dynamics evaluation (`__call__`, `step`)\n- Time integration (`integrate`, `simulate`)\n- Linearization computation\n- These are time-domain specific and live in Layer 1\n\n**Internal composition (users never access these directly):**\n\n::: {#ex-layer0-composition .cell execution_count=2}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Internal utilities (composed automatically)\nbackend_mgr = system.backend           # BackendManager\ncode_gen = system._code_gen            # CodeGenerator\nequilibria = system.equilibria         # EquilibriumHandler\nvalidator = system._validator          # SymbolicValidator\n\nprint(\"✓ Layer 0 composes internal utilities transparently\")\n```\n:::\n\n\n**User-facing Layer 0 methods:**\n\n::: {#ex-layer0-methods .cell execution_count=3}\n``` {.python .cell-code}\n# Backend management\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\n# Equilibrium management\nsystem.add_equilibrium('origin', x_eq=np.zeros(2), u_eq=np.zeros(1))\nx_eq, u_eq = system.get_equilibrium('origin')\nequilibria_list = system.list_equilibria()\n\n# Configuration\n# config = system.save_config('pendulum_config.json')\n# system_loaded = Pendulum.load_config('pendulum_config.json')\n\nprint(f\"System order: {system.order}\")\nprint(f\"State dimension: {system.nx}\")\nprint(f\"Control dimension: {system.nu}\")\n```\n:::\n\n\n**Abstract methods subclasses must implement:**\n```python\n@abstractmethod\ndef define_system(self, **params):\n    \"\"\"Define symbolic system components.\n    \n    Must set:\n    - self.state_vars: List[sp.Symbol]\n    - self.control_vars: List[sp.Symbol]\n    - self._f_sym: sp.Matrix (dynamics)\n    - self.parameters: Dict[sp.Symbol, float]\n    - self.order: int\n    \"\"\"\n    pass\n\n@abstractmethod\ndef print_equations(self, simplify: bool = True):\n    \"\"\"Print system equations in readable form.\"\"\"\n    pass\n```\n\n## Layer 1: Time-Domain Interfaces {#sec-layer-1}\n\n### ContinuousSystemBase: Continuous-Time Interface {#sec-continuoussystembase}\n\n**File:** `continuous_system_base.py`\n\nThe `ContinuousSystemBase` defines the abstract interface for continuous-time systems described by ODEs.\n\n**Mathematical form:**\n\n$$\\frac{dx}{dt} = f(x, u, t)$$\n\n**Core responsibilities:**\n\n- **Dynamics evaluation** - Abstract `__call__(x, u)` for forward dynamics\n- **Numerical integration** - Abstract `integrate()` with multi-method support\n- **Linearization** - Abstract `linearize()` for Jacobian computation\n- **High-level simulation** - Concrete `simulate()` with controller support\n\n**Abstract methods (Layer 2 implements):**\n```python\n@abstractmethod\ndef __call__(\n    self, \n    x: StateVector, \n    u: Optional[ControlVector] = None\n) -> StateVector:\n    \"\"\"Evaluate dx/dt = f(x, u).\"\"\"\n    pass\n\n@abstractmethod\ndef integrate(\n    self,\n    x0: StateVector,\n    u: Optional[Union[ControlVector, Callable]] = None,\n    t_span: TimeSpan = (0, 10),\n    **kwargs\n) -> IntegrationResult:\n    \"\"\"Integrate system over time span.\"\"\"\n    pass\n\n@abstractmethod\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -> Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute A = ∂f/∂x, B = ∂f/∂u.\"\"\"\n    pass\n```\n\n**Concrete method (provided by Layer 1):**\n```python\ndef simulate(\n    self,\n    x0: StateVector,\n    controller: Optional[Callable[[float, StateVector], ControlVector]] = None,\n    t_span: TimeSpan = (0, 10),\n    dt: float = 0.01,\n    **kwargs\n) -> Dict[str, np.ndarray]:\n    \"\"\"High-level simulation with regular time grid.\n    \n    Returns\n    -------\n    dict with keys:\n        'time': Regular time points (T,)\n        'states': State trajectory (T, nx)\n        'controls': Control sequence (T, nu)\n    \"\"\"\n```\n\n**Usage example:**\n\n::: {#ex-continuous-system .cell execution_count=4}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Evaluate dynamics (Layer 1 interface)\nx = np.array([0.5, 0.0])\nu = np.array([0.0])\ndx = system(x, u)\nprint(f\"State derivative: {dx}\")\n\n# Integrate (adaptive time grid)\nresult = system.integrate(x, u=None, t_span=(0, 5), method='RK45')\nprint(f\"Integration steps: {result['nsteps']}\")\n\n# Simulate (regular time grid - better for plotting)\nsim_result = system.simulate(x, controller=None, t_span=(0, 5), dt=0.01)\nprint(f\"Simulation time points: {len(sim_result['time'])}\")\n\n# Linearize\nx_eq, u_eq = system.get_equilibrium('origin')\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix: {A.shape}\")\n```\n:::\n\n\n**Key features:**\n\n- Flexible control input (None, arrays, or callable controllers)\n- Multi-backend integration support (scipy, Julia, PyTorch, JAX)\n- Dense output and adaptive stepping available\n- Comprehensive solver diagnostics\n\n### DiscreteSystemBase: Discrete-Time Interface {#sec-discretesystembase}\n\n**File:** `discrete_system_base.py`\n\nThe `DiscreteSystemBase` defines the abstract interface for discrete-time systems.\n\n**Mathematical form:**\n\n$$x[k+1] = f(x[k], u[k], k)$$\n\n**Core responsibilities:**\n\n- **Single step** - Abstract `step(x, u)` for one time step\n- **Multi-step simulation** - Abstract `simulate()` for trajectories\n- **Linearization** - Abstract `linearize()` for discrete Jacobians\n- **Sampling properties** - Concrete `dt` property and `sampling_frequency`\n\n**Abstract property (must implement):**\n```python\n@property\n@abstractmethod\ndef dt(self) -> float:\n    \"\"\"Sampling period [seconds].\"\"\"\n    pass\n```\n\n**Abstract methods (Layer 2 implements):**\n```python\n@abstractmethod\ndef step(\n    self,\n    x: StateVector,\n    u: Optional[ControlVector] = None,\n    k: int = 0\n) -> StateVector:\n    \"\"\"Single time step: x[k] → x[k+1].\"\"\"\n    pass\n\n@abstractmethod\ndef simulate(\n    self,\n    x0: StateVector,\n    u_sequence: Optional[ControlSequence] = None,\n    n_steps: int = 100,\n    **kwargs\n) -> Dict[str, np.ndarray]:\n    \"\"\"Multi-step simulation.\"\"\"\n    pass\n\n@abstractmethod\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -> Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute Ad = ∂f/∂x, Bd = ∂f/∂u (discrete Jacobians).\"\"\"\n    pass\n```\n\n**Concrete properties (provided by Layer 1):**\n```python\n@property\ndef sampling_frequency(self) -> float:\n    \"\"\"Sampling frequency [Hz].\"\"\"\n    return 1.0 / self.dt\n```\n\n**Key conventions:**\n\n- **Time-major ordering** - Arrays are (n_steps, nx), not (nx, n_steps)\n- **Control sequences** - Pre-computed controls or None for autonomous systems\n- **State feedback** - `rollout()` method for policy-based simulation\n\n## Layer 2: Concrete Symbolic Implementations {#sec-layer-2}\n\n### ContinuousSymbolicSystem: Symbolic + Continuous {#sec-continuoussymbolicsystem}\n\n**File:** `continuous_symbolic_system.py`\n\n**Inheritance:** `SymbolicSystemBase + ContinuousSystemBase` (cooperative multiple inheritance)\n\nThe `ContinuousSymbolicSystem` combines symbolic machinery (Layer 0) with continuous-time execution (Layer 1).\n\n**Key internal components (automatically composed):**\n\n- **DynamicsEvaluator** - Evaluates dx/dt = f(x, u)\n- **LinearizationEngine** - Computes A = ∂f/∂x, B = ∂f/∂u\n- **ObservationEngine** - Evaluates y = h(x), C = ∂h/∂x\n- **IntegratorFactory** - Creates appropriate ODE solvers\n\n**Implemented methods (Layer 1 abstractions):**\n```python\ndef __call__(\n    self, \n    x: StateVector, \n    u: Optional[ControlVector] = None\n) -> StateVector:\n    \"\"\"Evaluate dx/dt = f(x, u) using DynamicsEvaluator.\"\"\"\n    return self._dynamics.evaluate(x, u, backend=self.backend.default_backend)\n\ndef integrate(\n    self,\n    x0: StateVector,\n    u: Optional[Union[ControlVector, Callable]] = None,\n    t_span: TimeSpan = (0, 10),\n    method: Optional[str] = None,\n    **kwargs\n) -> IntegrationResult:\n    \"\"\"Integrate using IntegratorFactory.\"\"\"\n    # Creates appropriate integrator and delegates\n\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -> Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute Jacobians using LinearizationEngine.\"\"\"\n    return self._linearization.linearize_continuous(x_eq, u_eq)\n```\n\n**User subclass pattern:**\n\n::: {#ex-continuous-symbolic .cell execution_count=5}\n``` {.python .cell-code}\nclass SpringMassDamper(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0, c=0.5):\n        \"\"\"Define mass-spring-damper system.\"\"\"\n        # Symbolic variables\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n        \n        # System definition\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            v,\n            (-k_sym*x - c_sym*v + u)/m_sym\n        ])\n        self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Mass-Spring-Damper Equations:\")\n        print(\"  dx/dt = v\")\n        print(\"  dv/dt = (-k*x - c*v + u)/m\")\n\n# Use the system\nsystem = SpringMassDamper(m=2.0, k=5.0)\nx0 = np.array([1.0, 0.0])\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\nprint(f\"✓ Custom continuous symbolic system\")\n```\n:::\n\n\n### DiscreteSymbolicSystem: Symbolic + Discrete {#sec-discretesymbolicsystem}\n\n**File:** `discrete_symbolic_system.py`\n\n**Inheritance:** `SymbolicSystemBase + DiscreteSystemBase` (cooperative multiple inheritance)\n\nThe `DiscreteSymbolicSystem` combines symbolic machinery with discrete-time execution.\n\n**Key internal components:**\n\n- **DynamicsEvaluator** - Evaluates x[k+1] = f(x[k], u[k])\n- **LinearizationEngine** - Computes Ad = ∂f/∂x, Bd = ∂f/∂u\n- **ObservationEngine** - Evaluates y[k] = h(x[k])\n\n**Critical requirement:**\n\n::: {.callout-important}\n## Required: Set `self._dt`\n\nDiscrete systems **must** set `self._dt` in `define_system()`. This is the sampling period that defines the discrete-time grid.\n:::\n\n**User subclass pattern:**\n\n::: {#ex-discrete-symbolic .cell execution_count=6}\n``` {.python .cell-code}\nclass DiscreteLinearSystem(DiscreteSymbolicSystem):\n    def define_system(self, a=0.9, b=0.1, dt=0.01):\n        \"\"\"Define discrete linear system.\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        a_sym, b_sym = sp.symbols('a b', real=True)\n        \n        # System definition\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([a_sym*x + b_sym*u])\n        self.parameters = {a_sym: a, b_sym: b}\n        self._dt = dt  # REQUIRED for discrete systems!\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Discrete Linear System:\")\n        print(f\"  x[k+1] = a*x[k] + b*u[k]\")\n        print(f\"  dt = {self._dt}s\")\n\n# Use the system\nsystem = DiscreteLinearSystem(a=0.95, dt=0.1)\nx0 = np.array([1.0])\nresult = system.simulate(x0, u_sequence=None, n_steps=50)\nprint(f\"✓ Custom discrete symbolic system\")\n```\n:::\n\n\n## Layer 3: Stochastic Extensions {#sec-layer-3}\n\n### ContinuousStochasticSystem: SDE Support {#sec-continuousstochasticsystem}\n\n**File:** `continuous_stochastic_system.py`\n\n**Inheritance:** `ContinuousSymbolicSystem` (single inheritance - extends deterministic)\n\nThe `ContinuousStochasticSystem` adds stochastic differential equation (SDE) support to continuous systems.\n\n**Mathematical form:**\n\n$$dx = f(x, u, t)dt + g(x, u, t)dW$$\n\nwhere:\n- $f(x, u, t)$ - Drift (inherited from parent)\n- $g(x, u, t)$ - Diffusion matrix (added here)\n- $dW$ - Brownian motion increments\n\n**Additional internal components:**\n\n- **DiffusionHandler** - Generates and caches diffusion functions\n- **NoiseCharacterizer** - Automatic noise structure analysis\n- **SDEValidator** - SDE-specific validation\n- **SDEIntegratorFactory** - Stochastic integration methods\n\n**Noise structure types (auto-detected):**\n\n| Type | Structure | Meaning |\n|------|-----------|---------|\n| ADDITIVE | $g(x,u,t) = \\text{constant}$ | Noise intensity independent of state |\n| MULTIPLICATIVE | $g$ depends on state | State-dependent noise |\n| DIAGONAL | $g$ is diagonal matrix | Independent noise channels |\n| SCALAR | Single Wiener process | $n_w = 1$ |\n| GENERAL | Full matrix coupling | Correlated noise |\n\n**Additional user-facing methods:**\n```python\ndef drift(self, x: StateVector, u: ControlVector) -> StateVector:\n    \"\"\"Evaluate drift term f(x, u).\"\"\"\n    \ndef diffusion(self, x: StateVector, u: ControlVector) -> DiffusionMatrix:\n    \"\"\"Evaluate diffusion term g(x, u).\"\"\"\n\ndef is_additive_noise(self) -> bool:\n    \"\"\"Check if noise is additive (state-independent).\"\"\"\n\ndef recommend_solvers(self, backend: Backend) -> List[str]:\n    \"\"\"Recommend integration methods based on noise structure.\"\"\"\n```\n\n**User subclass pattern:**\n\n::: {#ex-stochastic-system .cell execution_count=7}\n``` {.python .cell-code}\nclass OrnsteinUhlenbeck(ContinuousStochasticSystem):\n    def define_system(self, alpha=1.0, sigma=0.5):\n        \"\"\"Define Ornstein-Uhlenbeck process: dx = -α*x*dt + σ*dW\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        alpha_sym, sigma_sym = sp.symbols('alpha sigma', positive=True)\n        \n        # Drift (deterministic part)\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n        self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion (stochastic part)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'  # or 'stratonovich'\n    \n    def print_equations(self, simplify=True):\n        print(\"Ornstein-Uhlenbeck Process:\")\n        print(\"  dx = -α*x*dt + σ*dW\")\n\n# Use the stochastic system\nsystem = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nprint(f\"Additive noise: {system.is_additive_noise()}\")\nprint(f\"Noise dimension: {system.nw}\")\n\n# Integrate SDE\nx0 = np.array([1.0])\nresult = system.integrate(\n    x0, u=None, t_span=(0, 10), \n    method='EM',  # Euler-Maruyama for SDEs\n    dt=0.01\n)\nprint(f\"✓ Stochastic system integration\")\n```\n:::\n\n\n### DiscreteStochasticSystem: Discrete SDE Support {#sec-discretestochasticsystem}\n\n**File:** `discrete_stochastic_system.py`\n\n**Inheritance:** `DiscreteSymbolicSystem` (single inheritance)\n\nThe `DiscreteStochasticSystem` adds stochastic difference equation support.\n\n**Mathematical form:**\n\n$$x[k+1] = f(x[k], u[k]) + g(x[k], u[k]) \\cdot w[k]$$\n\nwhere:\n- $f(x[k], u[k])$ - Deterministic dynamics\n- $g(x[k], u[k])$ - Diffusion matrix\n- $w[k]$ - Discrete-time noise\n\nSimilar structure to continuous stochastic but for discrete-time systems.\n\n## Special System: DiscretizedSystem {#sec-special-system}\n\n### DiscretizedSystem: Continuous → Discrete Conversion {#sec-discretizedsystem}\n\n**File:** `discretized_system.py`\n\nThe `DiscretizedSystem` creates discrete-time approximations from continuous systems.\n\n**Discretization methods:**\n\n| Method | Order | Description |\n|--------|-------|-------------|\n| `exact` | N/A | Matrix exponential (linear systems only) |\n| `euler` | 1 | Forward Euler approximation |\n| `rk4` | 4 | Fourth-order Runge-Kutta |\n| `tustin` | 2 | Bilinear (Tustin) transform |\n| `backward` | 1 | Backward Euler (implicit) |\n| `matched` | N/A | Zero-order hold |\n\n**Usage example:**\n\n::: {#ex-discretized-system .cell execution_count=8}\n``` {.python .cell-code}\n# Start with continuous system\ncontinuous_system = Pendulum()\n\n# Create discrete approximation\nfrom cdesym.systems.base.core.discretized_system import DiscretizedSystem\n\ndiscrete_system = DiscretizedSystem(\n    continuous_system,\n    dt=0.01,\n    method='rk4'\n)\n\n# Use as discrete system\nx_next = discrete_system.step(x, u)\nresult = discrete_system.simulate(x0, u_sequence=None, n_steps=100)\n```\n:::\n\n\n**Key features:**\n\n- Multiple discretization methods available\n- Preserves symbolic structure when possible\n- Handles deterministic and stochastic systems\n- Automatic validation of discretization accuracy\n\n## Design Principles {#sec-design-principles}\n\n### 1. Cooperative Multiple Inheritance {#sec-principle-inheritance}\n\n**Where used:** Layer 2 (ContinuousSymbolicSystem, DiscreteSymbolicSystem)\n\n**Why:** Combines symbolic machinery (Layer 0) with time-domain interface (Layer 1) without code duplication.\n```python\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __init__(self, *args, **kwargs):\n        # Python's MRO ensures correct initialization order\n        super().__init__(*args, **kwargs)\n```\n\n**Benefit:** Users get both symbolic capabilities and continuous-time interface in one class.\n\n### 2. Composition Over Inheritance {#sec-principle-composition}\n\n**Internal utilities composed, not inherited:**\n```python\nclass SymbolicSystemBase:\n    def __init__(self):\n        # Compose specialized utilities\n        self.backend = BackendManager()\n        self._code_gen = CodeGenerator(self, self.backend)\n        self.equilibria = EquilibriumHandler(self.nx, self.nu)\n        self._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\n        # etc.\n```\n\n**Benefit:** Single responsibility, testability, flexibility.\n\n### 3. Template Method Pattern {#sec-principle-template}\n\n**Base class orchestrates, subclass fills details:**\n```python\nclass SymbolicSystemBase:\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\n```\n\n**Benefit:** Consistent initialization, clear extension point.\n\n### 4. Separation of Concerns {#sec-principle-separation}\n\nEach layer has a single, focused responsibility:\n\n- **Layer 0:** Symbolic manipulation (time-agnostic)\n- **Layer 1:** Time-domain semantics (abstract interfaces)\n- **Layer 2:** Concrete execution (symbolic + time-domain)\n- **Layer 3:** Specialized extensions (stochastic)\n\n### 5. Zero Code Duplication {#sec-principle-zero-duplication}\n\n**Before refactoring:** ~1,800 lines duplicated between continuous and discrete systems\n\n**After refactoring:** All shared functionality in SymbolicSystemBase\n\n**Eliminated duplication:**\n- Parameter handling\n- Backend management\n- Code generation\n- Symbolic validation\n- Equilibrium management\n- Configuration persistence\n\n## System Properties {#sec-system-properties}\n\n### Automatic Properties (All Systems) {#sec-automatic-properties}\n\nAll systems automatically provide these properties:\n\n::: {#ex-system-properties .cell execution_count=9}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Dimensions\nprint(f\"State dimension (nx): {system.nx}\")\nprint(f\"Control dimension (nu): {system.nu}\")\nprint(f\"Output dimension (ny): {system.ny}\")\nprint(f\"Physical dimension (nq): {system.nq}\")\nprint(f\"System order: {system.order}\")\n\n# Backend\nprint(f\"Default backend: {system.backend.default_backend}\")\nprint(f\"Device: {system.backend.preferred_device}\")\n```\n:::\n\n\n### Discrete-Only Properties {#sec-discrete-properties}\n```python\n# Discrete systems only\ndt: float                    # Sampling period [s]\nsampling_frequency: float    # 1/dt [Hz]\n```\n\n### Stochastic-Only Properties {#sec-stochastic-properties}\n```python\n# Stochastic systems only\nnw: int                      # Number of Wiener processes\nis_additive_noise() -> bool  # Noise structure check\nis_multiplicative_noise() -> bool\n```\n\n## Backend Support {#sec-backend-support}\n\nAll systems support multi-backend execution transparently:\n\n| Backend | Execution | Best For |\n|---------|-----------|----------|\n| **NumPy** | CPU | General purpose, maximum compatibility |\n| **PyTorch** | CPU/GPU | Neural networks, GPU acceleration, automatic differentiation |\n| **JAX** | CPU/GPU/TPU | Optimization, XLA compilation, functional programming |\n| **Julia** (via DiffEqPy) | CPU | High-performance ODE/SDE solvers |\n\n**Switching backends:**\n\n::: {#ex-backend-switching .cell execution_count=10}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# NumPy (default)\nx_np = np.array([1.0, 0.0])\ndx_np = system(x_np, np.zeros(1))\n\n# Temporary PyTorch\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    dx_torch = system(x_torch, torch.zeros(1))\n    print(f\"PyTorch result type: {type(dx_torch)}\")\n\n# Permanent switch\nsystem.set_default_backend('jax')\nx_jax = jnp.array([1.0, 0.0])\ndx_jax = system(x_jax, jnp.zeros(1))\n\nprint(\"✓ Backend switching is transparent\")\n```\n:::\n\n\n## Integration Methods {#sec-integration-methods}\n\n### Continuous Systems (ODE Solvers) {#sec-ode-solvers}\n\n| Backend | Methods | Examples |\n|---------|---------|----------|\n| **scipy** | Adaptive | RK45, RK23, DOP853, Radau, BDF, LSODA |\n| **Julia (DiffEqPy)** | Adaptive | Tsit5, Vern7, Vern9, Rodas5, AutoTsit5 |\n| **JAX (diffrax)** | Adaptive | dopri5, tsit5, heun |\n| **PyTorch (torchdiffeq)** | Adaptive | dopri5, adaptive_heun |\n| **Fixed-step** | All backends | euler, rk4, midpoint |\n\n### Stochastic Systems (SDE Solvers) {#sec-sde-solvers}\n\n| Backend | Methods | Convergence |\n|---------|---------|-------------|\n| **torchsde** | euler, milstein, srk | Strong 0.5-1.0 |\n| **diffrax** | euler, heun | Strong 0.5-1.0 |\n| **Julia (DiffEqPy)** | EM, milstein, etc. | Strong/Weak |\n\n## Usage Examples {#sec-usage-examples}\n\n### Example 1: Pendulum (Continuous) {#sec-ex-pendulum}\n\n::: {#ex-pendulum-full .cell execution_count=11}\n``` {.python .cell-code}\nclass SimplePendulum(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, l=0.5, g=9.81, b=0.1):\n        \"\"\"Simple pendulum with damping.\"\"\"\n        # Symbolic variables\n        theta, omega = sp.symbols('theta omega', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, l_sym, g_sym, b_sym = sp.symbols('m l g b', positive=True)\n        \n        # System definition\n        self.state_vars = [theta, omega]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            omega,\n            -(g_sym/l_sym)*sp.sin(theta) - (b_sym/(m_sym*l_sym**2))*omega + u/(m_sym*l_sym**2)\n        ])\n        self.parameters = {m_sym: m, l_sym: l, g_sym: g, b_sym: b}\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Simple Pendulum Equations:\")\n        print(\"  dθ/dt = ω\")\n        print(\"  dω/dt = -(g/l)sin(θ) - (b/ml²)ω + u/(ml²)\")\n\n# Create and use\npendulum = SimplePendulum(m=0.5, l=0.3)\nx0 = np.array([0.1, 0.0])\n\n# Evaluate dynamics\ndx = pendulum(x0, np.zeros(1))\nprint(f\"State derivative: {dx}\")\n\n# Integrate\nresult = pendulum.integrate(x0, u=None, t_span=(0, 5), method='RK45')\nprint(f\"Integration successful: {result['success']}\")\n\n# Linearize\nA, B = pendulum.linearize(np.zeros(2), np.zeros(1))\nprint(f\"Linearization: A shape {A.shape}, B shape {B.shape}\")\n```\n:::\n\n\n### Example 2: Linear System (Discrete) {#sec-ex-discrete-linear}\n\n::: {#ex-discrete-full .cell execution_count=12}\n``` {.python .cell-code}\nclass DiscreteDoubleIntegrator(DiscreteSymbolicSystem):\n    def define_system(self, dt=0.01):\n        \"\"\"Discrete double integrator.\"\"\"\n        # Symbolic variables\n        p, v = sp.symbols('p v', real=True)\n        u = sp.symbols('u', real=True)\n        dt_sym = sp.symbols('dt', positive=True)\n        \n        # Discrete dynamics (Euler approximation)\n        self.state_vars = [p, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            p + dt_sym * v,\n            v + dt_sym * u\n        ])\n        self.parameters = {dt_sym: dt}\n        self._dt = dt  # REQUIRED!\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Discrete Double Integrator:\")\n        print(\"  p[k+1] = p[k] + dt*v[k]\")\n        print(\"  v[k+1] = v[k] + dt*u[k]\")\n\n# Create and use\nsystem = DiscreteDoubleIntegrator(dt=0.1)\nx0 = np.array([0.0, 0.0])\n\n# Single step\nx_next = system.step(x0, np.array([1.0]))\nprint(f\"Next state: {x_next}\")\n\n# Simulate\nresult = system.simulate(x0, u_sequence=None, n_steps=50)\nprint(f\"Simulation shape: {result['states'].shape}\")\n\n# Linearize\nAd, Bd = system.linearize(np.zeros(2), np.zeros(1))\nprint(f\"Discrete linearization: Ad shape {Ad.shape}\")\n```\n:::\n\n\n### Example 3: Stochastic Process {#sec-ex-stochastic}\n\n::: {#ex-stochastic-full .cell execution_count=13}\n``` {.python .cell-code}\nclass BrownianMotion(ContinuousStochasticSystem):\n    def define_system(self, mu=0.0, sigma=1.0):\n        \"\"\"Standard Brownian motion with drift.\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        mu_sym, sigma_sym = sp.symbols('mu sigma', real=True)\n        \n        # Drift term\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[mu_sym + u]])\n        self.parameters = {mu_sym: mu, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion term (additive noise)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'\n    \n    def print_equations(self, simplify=True):\n        print(\"Brownian Motion with Drift:\")\n        print(\"  dx = μ*dt + σ*dW\")\n\n# Create and use\nbrownian = BrownianMotion(mu=0.1, sigma=0.5)\n\n# Check noise properties\nprint(f\"Additive noise: {brownian.is_additive_noise()}\")\nprint(f\"Noise dimension: {brownian.nw}\")\n\n# Drift and diffusion evaluation\nx = np.array([0.5])\nf = brownian.drift(x, np.zeros(1))\ng = brownian.diffusion(x, np.zeros(1))\nprint(f\"Drift: {f}, Diffusion: {g}\")\n\n# Integrate SDE\nx0 = np.array([0.0])\nresult = brownian.integrate(\n    x0, u=None, t_span=(0, 10),\n    method='EM', dt=0.01\n)\nprint(f\"SDE integration complete: {result['success']}\")\n```\n:::\n\n\n## Key Strengths {#sec-key-strengths}\n\n::: {.callout-tip}\n## UI Framework Advantages\n\n1. **Clean Separation** - Each layer has single responsibility\n2. **Zero Duplication** - Symbolic machinery shared across all systems\n3. **Type Safety** - Comprehensive TypedDict definitions throughout\n4. **Backend Flexibility** - Seamless NumPy/PyTorch/JAX/Julia switching\n5. **Extensibility** - Easy to add new system types via `define_system()`\n6. **Mathematical Rigor** - Proper handling of ODEs, SDEs, difference equations\n7. **Performance** - Multi-backend support enables GPU acceleration\n8. **User-Friendly** - Simple subclass pattern for custom systems\n9. **Documentation** - Extensive docstrings with mathematical notation\n10. **Production-Quality** - Professional software engineering practices\n:::\n\n## Summary\n\nThe UI Framework provides a **clean, layered architecture** for defining and working with dynamical systems:\n\n- **Layer 0** provides time-agnostic symbolic foundations\n- **Layer 1** defines abstract time-domain interfaces\n- **Layer 2** combines symbolic + time-domain into concrete systems\n- **Layer 3** extends with stochastic capabilities\n\nUsers interact primarily at **Layers 2 and 3** by subclassing `ContinuousSymbolicSystem`, `DiscreteSymbolicSystem`, or their stochastic variants. The framework handles all internal complexity transparently, providing a simple `define_system()` extension point while delivering production-grade functionality.\n\n**The architecture eliminates ~1,800 lines of code duplication while maintaining clean separation of concerns and type safety throughout.**\n\n",
    "supporting": [
      "UI_Framework_Architecture_files"
    ],
    "filters": [],
    "includes": {}
  }
}