{
  "hash": "610f115c133647b71fdb4cefaef36eb3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"ControlDESymulation Delegation Layer Architecture\"\nsubtitle: \"Internal Support Framework for System Components\"\nauthor: \"Gil Benezer\"\ndate: today\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    code-fold: show\n    code-tools: true\n    theme: cosmo\nexecute:\n  eval: true\n  cache: true\n  warning: false\n---\n\n## Overview {#sec-overview}\n\nThe **Delegation Layer** (also called the **Support Framework**) provides **specialized internal services** to the UI framework through **composition rather than inheritance**. This layer consists of **11 focused utility classes** totaling ~7,200 lines that handle backend management, code generation, dynamics evaluation, and stochastic analysis.\n\n::: {.callout-important}\n## Internal Framework - Not for Direct Use\n\n**This documentation describes internal framework components.** Users should NOT directly instantiate or interact with these classes. The delegation layer is an internal implementation detail accessed through the high-level system interface:\n\n```python\n# ❌ INCORRECT: Direct delegation layer access\ncode_gen = CodeGenerator(system)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n\n# ✓ CORRECT: Use system interface (delegation happens automatically)\nsystem = Pendulum()\ndx = system(x, u)  # DynamicsEvaluator called internally\nA, B = system.linearize(x_eq, u_eq)  # LinearizationEngine called internally\n```\n\nThe system classes (e.g., `ContinuousSymbolicSystem`) automatically compose these utilities and expose their functionality through clean, user-facing APIs. This documentation is provided for framework developers and advanced users who need to understand the internal architecture.\n:::\n\n\n\n## Architecture Philosophy {#sec-architecture-philosophy}\n\n### Composition Over Inheritance\n\nInstead of creating deep inheritance hierarchies, the UI framework composes these specialized utilities as private attributes. This internal composition is transparent to users:\n\n::: {#ex-composition-internal .cell execution_count=2}\n``` {.python .cell-code}\n# Internal framework structure (users never access these directly)\nbackend_manager = continuous_pendulum.backend  # BackendManager\ncode_generator = continuous_pendulum._code_gen  # CodeGenerator\ndynamics_evaluator = continuous_pendulum._dynamics  # DynamicsEvaluator\nlinearization_engine = continuous_pendulum._linearization  # LinearizationEngine\nobservation_engine = continuous_pendulum._observation  # ObservationEngine\nequilibrium_handler = continuous_pendulum.equilibria  # EquilibriumHandler\n\n# Stochastic systems add additional handlers\ndiffusion_handler = langevin.diffusion_handler  # DiffusionHandler\n\nprint(\"✓ Framework internally composed - users interact with system methods only\")\n```\n:::\n\n\n### Design Benefits\n\nThis architecture provides:\n\n- **Single Responsibility** - Each class does one thing well\n- **Reusability** - Utilities can be composed by different system types\n- **Testability** - Each component tested in isolation\n- **Flexibility** - Easy to swap implementations internally\n- **Clarity** - Clear separation of concerns\n- **Encapsulation** - Internal complexity hidden from users\n\n## Architecture Layers {#sec-architecture-layers}\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     UI FRAMEWORK                             │\n│  (SymbolicSystemBase, ContinuousSymbolicSystem, etc.)        │\n│                                                              │\n│  User-facing methods that delegate to utilities:            │\n│  • system(x, u) → delegates to DynamicsEvaluator            │\n│  • system.linearize() → delegates to LinearizationEngine    │\n│  • system.set_default_backend() → delegates to BackendMgr   │\n└────────────────────┬────────────────────────────────────────┘\n                     │ uses (composition)\n                     ↓\n┌─────────────────────────────────────────────────────────────┐\n│                  DELEGATION LAYER (Internal)                │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  CORE UTILITIES (Universal)                         │  │\n│  │  • BackendManager      - Multi-backend support      │  │\n│  │  • CodeGenerator       - Symbolic → numerical       │  │\n│  │  • EquilibriumHandler  - Equilibrium management     │  │\n│  │  • SymbolicValidator   - System validation          │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  DETERMINISTIC EVALUATION (ODE Systems)             │  │\n│  │  • DynamicsEvaluator    - Forward dynamics          │  │\n│  │  • LinearizationEngine  - Jacobian computation      │  │\n│  │  • ObservationEngine    - Output evaluation         │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  STOCHASTIC SUPPORT (SDE Systems)                   │  │\n│  │  • DiffusionHandler    - Diffusion generation       │  │\n│  │  • NoiseCharacterizer  - Noise analysis             │  │\n│  │  • SDEValidator        - SDE validation             │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  LOW-LEVEL UTILITIES                                │  │\n│  │  • codegen_utils       - SymPy code generation      │  │\n│  └───────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Core Utilities (Universal) {#sec-core-utilities}\n\n### BackendManager: Multi-Backend Array Handling {#sec-backendmanager}\n\n**File:** `backend_manager.py` (545 lines)\n\nThe `BackendManager` handles all backend-specific array operations and device management. Users interact with this functionality through system-level methods, never directly.\n\n**Internal responsibilities:**\n\n- Backend detection from array types\n- Array conversion between backends (NumPy ↔ PyTorch ↔ JAX)\n- Backend availability checking\n- Device management (CPU, CUDA, TPU)\n- Default backend configuration\n- Temporary backend switching (context manager)\n\n**User-facing interface (system-level):**\n\n::: {#ex-backend-manager .cell execution_count=3}\n``` {.python .cell-code}\n# ✓ User interacts with system methods\nsystem = Pendulum()\n\n# Check current backend\nprint(f\"Default backend: {system.backend.default_backend}\")\n\n# Set backend for system\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\n# Temporary backend switching\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx = system(x_torch, u_torch)\n    print(f\"Result type: {type(dx)}\")\n\nprint(\"✓ Backend management through system interface\")\n```\n:::\n\n\n**Supported backends:**\n\n| Backend | Execution | Best For |\n|---------|-----------|----------|\n| NumPy | CPU | General purpose, maximum compatibility |\n| PyTorch | CPU/GPU | Neural networks, GPU acceleration, autograd |\n| JAX | CPU/GPU/TPU | Optimization, XLA compilation, functional programming |\n\n**Internal capabilities (framework use only):**\n\n```python\n# Framework code (users never write this)\nbackend = backend_manager.detect(array)\nx_torch = backend_manager.convert(array, target_backend='torch')\nx_cuda = backend_manager.convert(array, target_backend='torch', device='cuda:0')\n```\n\n### CodeGenerator: Symbolic to Numerical Compilation {#sec-codegenerator}\n\n**File:** `code_generator.py` (565 lines)\n\nThe `CodeGenerator` orchestrates the symbolic-to-numerical code generation pipeline with intelligent caching. This is completely internal—users simply call system methods that trigger code generation when needed.\n\n**Internal responsibilities:**\n\n- Generate dynamics functions: f(x, u) → dx/dt\n- Generate output functions: h(x) → y\n- Generate Jacobian functions: A, B, C\n- Per-backend function caching\n- Compilation and warmup\n- Cache invalidation on parameter changes\n\n**How users benefit (transparent):**\n\n::: {#ex-code-generation .cell execution_count=4}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# First call: Code generated and cached automatically\nx = np.array([1.0, 0.0])\nu = np.array([0.0])\ndx1 = system(x, u)  # CodeGenerator works internally\n\n# Subsequent calls: Use cached compiled function (fast)\ndx2 = system(x, u)  # Instant - cached function reused\n\n# When you change parameters, cache automatically invalidates\n# (parameters are accessed via system.parameters dict)\nm_sym = [k for k in system.parameters.keys() if str(k) == 'm'][0]\nl_sym = [k for k in system.parameters.keys() if str(k) == 'l'][0]\nsystem.parameters[m_sym] = 2.0\nsystem.parameters[l_sym] = 1.0\nsystem.reset_caches()  # Explicitly clear cache after parameter change\ndx3 = system(x, u)  # Uses new parameter values\n\nprint(\"✓ Code generation happens transparently\")\n```\n:::\n\n\n**Caching strategy (internal):**\n\n- Functions cached per backend\n- Symbolic Jacobians computed once, then compiled per backend\n- Automatic cache invalidation on parameter changes\n- Lazy generation (only when first needed)\n\n**Backend-specific optimizations (internal):**\n\n- **NumPy:** Common subexpression elimination (CSE)\n- **PyTorch:** Expression simplification for autograd\n- **JAX:** JIT compilation via `jax.jit`\n\n### EquilibriumHandler: Named Equilibrium Management {#sec-equilibriumhandler}\n\n**File:** `equilibrium_handler.py` (221 lines)\n\nThe `EquilibriumHandler` manages multiple named equilibrium points with automatic backend conversion. Users interact through system methods.\n\n**Internal responsibilities:**\n\n- Store equilibria as NumPy arrays (backend-neutral)\n- Convert to any backend on demand\n- Named equilibrium management\n- Equilibrium verification\n- Metadata storage (stability, description, etc.)\n\n**User-facing interface:**\n\n::: {#ex-equilibrium .cell execution_count=5}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Add equilibrium (system delegates to EquilibriumHandler)\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    verify=True,\n    metadata={'stability': 'unstable', 'description': 'Inverted pendulum'}\n)\n\n# Get equilibrium (backend conversion automatic)\nx_eq, u_eq = system.get_equilibrium('upright')\n\n# List all equilibria\nequilibria = system.list_equilibria()\nprint(f\"Available equilibria: {equilibria}\")\n\n# Get metadata\nmeta = system.get_equilibrium_metadata('upright')\nif meta:\n    print(f\"Stability: {meta.get('stability', 'unknown')}\")\nelse:\n    print(\"No metadata available\")\n```\n:::\n\n\n**Automatic features:**\n\n- Origin equilibrium always present\n- Dimension validation on add\n- Finite value checking (no NaN/Inf)\n- Optional verification with tolerance\n- Backend-agnostic storage with on-demand conversion\n\n### SymbolicValidator: System Definition Validation {#sec-symbolicvalidator}\n\n**File:** `symbolic_validator.py` (718 lines)\n\nThe `SymbolicValidator` performs comprehensive validation of symbolic system definitions during initialization. Users benefit from clear error messages without directly interacting with the validator.\n\n**Validation checks (automatic during system creation):**\n\n**Required validations:**\n\n- ✓ `state_vars` is list of `sp.Symbol`\n- ✓ `control_vars` is list of `sp.Symbol`\n- ✓ `_f_sym` is `sp.Matrix` with correct dimensions\n- ✓ `parameters` keys are `sp.Symbol` (not strings)\n- ✓ `order` divides `nx` evenly (nx % order == 0)\n\n**Output function validations (if defined):**\n\n- ✓ `_h_sym` is `sp.Matrix`\n- ✓ `_h_sym` only depends on `state_vars` (not control)\n- ✓ `output_vars` matches `_h_sym` dimensions\n\n**Example validation (automatic):**\n\n```python\n# This validation happens automatically during system creation\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self):\n        x = sp.Symbol('x')\n        \n        # ❌ This will fail validation with clear error message\n        self.parameters = {'m': 1.0}  # String key instead of Symbol\n        \n        # ✓ Correct - validator passes\n        m = sp.Symbol('m')\n        self.parameters = {m: 1.0}  # Symbol key\n```\n\nError messages are clear and actionable, helping users fix issues quickly.\n\n## Deterministic Evaluation Components {#sec-deterministic-evaluation}\n\n### DynamicsEvaluator: Forward Dynamics Computation {#sec-dynamicsevaluator}\n\n**File:** `dynamics_evaluator.py` (576 lines)\n\nThe `DynamicsEvaluator` handles forward dynamics evaluation (dx/dt = f(x, u)) across all backends. Users call `system(x, u)` which internally delegates to this evaluator.\n\n**Internal responsibilities:**\n\n- Evaluate dx/dt = f(x, u) for controlled systems\n- Evaluate dx/dt = f(x) for autonomous systems\n- Handle batched vs single evaluation\n- Backend-specific dispatch\n- Input shape validation\n- Performance tracking\n\n**User-facing interface:**\n\n::: {#ex-dynamics .cell execution_count=6}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Single evaluation (DynamicsEvaluator called internally)\nx = np.array([1.0, 0.0])\nu = np.array([0.0])\ndx = system(x, u)\nprint(f\"State derivative shape: {dx.shape}\")\n\n# Batched evaluation (automatically detected)\nx_batch = np.random.randn(100, 2)\nu_batch = np.zeros((100, 1))\ndx_batch = system(x_batch, u_batch)\nprint(f\"Batch derivatives shape: {dx_batch.shape}\")\n\n# Works seamlessly with different backends\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx_torch = system(x_torch, u_torch)\n    print(f\"PyTorch result type: {type(dx_torch)}\")\n```\n:::\n\n\n**Automatic features:**\n\n- Backend detection from input arrays\n- Shape validation and broadcasting\n- Batched evaluation detection\n- Performance statistics tracking\n\n### LinearizationEngine: Jacobian Computation {#sec-linearizationengine}\n\n**File:** `linearization_engine.py` (907 lines)\n\nThe `LinearizationEngine` computes system linearizations (Jacobians) at equilibrium points. Users access this through `system.linearize()`.\n\n**Mathematical forms:**\n\n**Continuous systems:**\n\n$$\\delta\\dot{x} = A\\delta x + B\\delta u$$\n\nwhere:\n\n$$A = \\frac{\\partial f}{\\partial x}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_x}$$\n\n$$B = \\frac{\\partial f}{\\partial u}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_u}$$\n\n**Discrete systems:**\n\n$$\\delta x[k+1] = A_d\\delta x[k] + B_d\\delta u[k]$$\n\n**User-facing interface:**\n\n::: {#ex-linearization .cell execution_count=7}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Get equilibrium point\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Compute linearization (LinearizationEngine called internally)\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix shape: {A.shape}\")\nprint(f\"B matrix shape: {B.shape}\")\n\n# Works with any backend\nwith system.use_backend('torch'):\n    x_eq_torch = torch.tensor([0.0, 0.0])\n    u_eq_torch = torch.tensor([0.0])\n    A_torch, B_torch = system.linearize(x_eq_torch, u_eq_torch)\n    print(f\"PyTorch A type: {type(A_torch)}\")\n```\n:::\n\n\n**Higher-order system handling:**\n\nFor `order=n` systems where the state is `[q, q̇, ..., q^(n-1)]` and only `q^(n)` is defined:\n\n1. Automatically constructs full state-space representation\n2. Computes Jacobian of complete state derivative\n3. Returns proper $(n_x \\times n_x)$ and $(n_x \\times n_u)$ matrices\n\n### ObservationEngine: Output Function Evaluation {#sec-observationengine}\n\n**File:** `observation_engine.py` (628 lines)\n\nThe `ObservationEngine` handles output function evaluation (y = h(x)) and output Jacobian computation. Users access through `system.output()` and `system.output_jacobian()`.\n\n**Mathematical form:**\n\n$$y = h(x)$$\n\nOutput linearization:\n\n$$\\delta y = C\\delta x$$\n\nwhere\n\n$$C = \\frac{\\partial h}{\\partial x}\\bigg|_{x_{eq}} \\in \\mathbb{R}^{n_y \\times n_x}$$\n\n**User-facing interface:**\n\n::: {#ex-observation .cell execution_count=8}\n``` {.python .cell-code}\n# Create system with output function\nclass ObservableSystem(ContinuousSymbolicSystem):\n    def define_system(self):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -x + u])\n        \n        # Output: only position is measured\n        self._h_sym = sp.Matrix([x])\n        self.output_vars = [sp.Symbol('y')]\n        self.order = 1\n\nsystem = ObservableSystem()\n\n# Evaluate output\nx = np.array([1.5, 0.2])\ny = system.h(x)  # h() method evaluates output\nprint(f\"Output: {y}\")\n\n# Compute output Jacobian\nC = system.linearized_observation(x)\nprint(f\"C matrix shape: {C.shape}\")\n```\n:::\n\n\n## Stochastic Support Components {#sec-stochastic-support}\n\n### DiffusionHandler: SDE Diffusion Management {#sec-diffusionhandler}\n\n**File:** `diffusion_handler.py` (1,069 lines)\n\nThe `DiffusionHandler` generates and caches diffusion functions for stochastic systems. Users interact through `system.diffusion()` method.\n\n**Mathematical form:**\n\n$$dx = f(x, u)dt + g(x, u)dW$$\n\nDiffusion matrix $g(x, u) \\in \\mathbb{R}^{n_x \\times n_w}$ \n\nwhere:\n\n- $n_x$: state dimension\n- $n_w$: number of independent Wiener processes\n\n**Noise structure types (auto-detected):**\n\n| Type | Structure | Optimization |\n|------|-----------|-------------|\n| Additive | $g(x, u) = \\text{constant}$ | Return constant matrix (no recomputation) |\n| Multiplicative Diagonal | $g$ is diagonal | Independent noise channels |\n| Multiplicative Scalar | $n_w = 1$ | Single Wiener process |\n| General | Full matrix coupling | Complete computation |\n\n**User-facing interface:**\n\n::: {#ex-diffusion .cell execution_count=9}\n``` {.python .cell-code}\n# Stochastic system automatically sets up DiffusionHandler\nsystem = LangevinDynamics()\n\n# Evaluate diffusion (DiffusionHandler called internally)\n# LangevinDynamics has nx=2 (position and velocity)\nx = np.array([1.0, 0.5])\nu = np.array([0.0])\ng = system.diffusion(x, u)\nprint(f\"Diffusion matrix shape: {g.shape}\")\n\n# Check noise properties\nprint(f\"Is additive noise: {system.is_additive_noise()}\")\nprint(f\"Noise dimensions: {system.nw}\")\n\n# Get solver recommendations based on noise structure\nsolvers = system.recommend_solvers('torch')\nprint(f\"Recommended solvers: {solvers[:3] if len(solvers) > 3 else solvers}\")\n```\n:::\n\n\n**Automatic optimizations (internal):**\n\n- **Additive noise:** Returns constant matrix, no function calls needed\n- **Diagonal noise:** Specialized handling for independent channels\n- **Scalar noise:** Simplified operations for single Wiener process\n\n### SDEValidator: SDE-Specific Validation {#sec-sdevalidator}\n\n**File:** `sde_validator.py` (544 lines)\n\nThe `SDEValidator` performs SDE-specific validation during system creation. Validation happens automatically with clear error messages.\n\n**Validation checks (automatic):**\n\n- ✓ `diffusion_expr` is `sp.Matrix`\n- ✓ Dimensions: $(n_x, n_w)$ where $n_w \\geq 1$\n- ✓ `diffusion_expr` only uses `state_vars` and `control_vars`\n- ✓ `sde_type` is 'ito' or 'stratonovich'\n- ✓ Compatibility between drift and diffusion\n- ✓ No division by zero in diffusion terms\n\n**Example validation (automatic):**\n\n```python\nclass MyStochasticSystem(ContinuousStochasticSystem):\n    def define_system(self):\n        x = sp.Symbol('x')\n        sigma = sp.Symbol('sigma', positive=True)\n        \n        # ❌ Wrong dimensions - validator catches this\n        self.diffusion_expr = sp.Matrix([[sigma]])  # nx=2 but only 1 row\n        \n        # ✓ Correct dimensions\n        self.diffusion_expr = sp.Matrix([[sigma], [0]])  # (2, 1) ✓\n```\n\n## Low-Level Utilities {#sec-low-level-utilities}\n\n### codegen_utils: SymPy Code Generation {#sec-codegenutils}\n\n**File:** `codegen_utils.py` (733 lines)\n\nLow-level utilities for converting SymPy expressions to executable functions. This is completely internal to the framework.\n\n**Optimization strategies (internal):**\n\n**NumPy:**\n- Common subexpression elimination (CSE)\n- Fast numerical modules ('numpy', 'scipy')\n- Matrix operation optimization\n\n**PyTorch:**\n- Symbolic simplification before generation\n- Automatic differentiation compatibility\n- GPU tensor operation support\n\n**JAX:**\n- JIT compilation via `jax.jit`\n- Pure functional style for XLA\n- Automatic vectorization\n\n## Internal Composition Patterns {#sec-composition-patterns}\n\n::: {.callout-note}\n## Framework Implementation Details\n\nThese patterns show how the framework internally composes delegation layer components. Users never write this code—it's handled automatically by system classes.\n:::\n\n### Pattern 1: Core System Utilities\n\nUsed by all symbolic systems:\n\n```python\n# Internal framework code (in SymbolicSystemBase.__init__)\nself.backend = BackendManager(default_backend, default_device)\nself._code_gen = CodeGenerator(self, self.backend)\nself._validator = SymbolicValidator()\nself.equilibria = EquilibriumHandler(nx, nu)\n```\n\n### Pattern 2: Deterministic Extensions\n\nAdded by continuous and discrete systems:\n\n```python\n# Internal framework code (in ContinuousSymbolicSystem.__init__)\nsuper().__init__(*args, **kwargs)  # Core utilities\n\n# Add deterministic evaluators\nself._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\nself._linearization = LinearizationEngine(self, self._code_gen, self.backend)\nself._observation = ObservationEngine(self, self._code_gen, self.backend)\n```\n\n### Pattern 3: Stochastic Extensions\n\nAdded by stochastic systems:\n\n```python\n# Internal framework code (in ContinuousStochasticSystem.__init__)\nsuper().__init__(*args, **kwargs)  # Deterministic utilities\n\n# Add stochastic support\nself.diffusion_handler = DiffusionHandler(self, self._code_gen, self.backend)\nself.noise_characteristics = NoiseCharacterizer().analyze(self.diffusion_expr)\nself._sde_validator = SDEValidator()\n```\n\n## Design Principles {#sec-design-principles}\n\n### Single Responsibility Principle\n\nEach class has one clear, focused purpose:\n\n- `BackendManager` → Backend management **only**\n- `CodeGenerator` → Code generation **only**\n- `DynamicsEvaluator` → Dynamics evaluation **only**\n- `LinearizationEngine` → Linearization **only**\n\n### Composition Over Inheritance\n\nSystems compose utilities as private attributes rather than inheriting functionality:\n\n```python\n# ❌ NOT: Deep inheritance\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator):\n    pass\n\n# ✓ YES: Composition\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()\n        self._code_gen = CodeGenerator()\n        self._dynamics = DynamicsEvaluator()\n```\n\n### Dependency Injection\n\nUtilities receive dependencies explicitly through constructors:\n\n```python\n# Clear dependency chain (internal framework code)\nbackend_mgr = BackendManager()\ncode_gen = CodeGenerator(system, backend_mgr)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n```\n\n### Interface Segregation\n\nEach utility exposes a minimal, focused interface:\n\n- `BackendManager`: detect, convert, to_backend\n- `CodeGenerator`: generate_dynamics, generate_jacobians\n- `DynamicsEvaluator`: evaluate\n\n### Lazy Initialization\n\nFunctions generated and cached only when first needed:\n\n```python\n# First call: generates and caches\nf = code_gen.generate_dynamics('numpy')\n\n# Subsequent calls: returns cached\nf_again = code_gen.generate_dynamics('numpy')\nassert f is f_again  # Same function object\n```\n\n### Backend Agnosticism\n\nAll utilities work transparently across backends:\n\n```python\n# Same interface, different backends (internal)\ndx_numpy = evaluator.evaluate(x_np, u_np, backend='numpy')\ndx_torch = evaluator.evaluate(x_torch, u_torch, backend='torch')\ndx_jax = evaluator.evaluate(x_jax, u_jax, backend='jax')\n```\n\n## Practical Examples {#sec-practical-examples}\n\n::: {.callout-note}\n## User-Facing Examples\n\nThese examples show how users benefit from the delegation layer through the system interface. Users never directly instantiate delegation layer components.\n:::\n\n### Example 1: Creating a System (Delegation Automatic)\n\n::: {#ex-system-creation .cell execution_count=10}\n``` {.python .cell-code}\nclass SpringMassDamper(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0, c=0.5):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            v,\n            (-k_sym*x - c_sym*v + u)/m_sym\n        ])\n        self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n        self.order = 1\n\n# Delegation layer automatically composed internally\nsystem = SpringMassDamper()\n\n# User interacts with clean system interface\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\ndx = system(x, u)  # DynamicsEvaluator called internally\n\nA, B = system.linearize(np.zeros(2), np.zeros(1))  # LinearizationEngine\nprint(f\"System created with automatic delegation\")\n```\n:::\n\n\n### Example 2: Multi-Backend Usage (Transparent)\n\n::: {#ex-multibackend .cell execution_count=11}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# NumPy computation\nx_np = np.array([1.0, 0.0])\nu_np = np.array([0.0])\ndx_np = system(x_np, u_np)\n\n# PyTorch computation (backend conversion automatic)\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx_torch = system(x_torch, u_torch)\n    print(f\"PyTorch result: {type(dx_torch)}\")\n\n# JAX computation\nwith system.use_backend('jax'):\n    x_jax = jnp.array([1.0, 0.0])\n    u_jax = jnp.array([0.0])\n    dx_jax = system(x_jax, u_jax)\n    print(f\"JAX result: {type(dx_jax)}\")\n\nprint(\"✓ Backend management completely transparent\")\n```\n:::\n\n\n### Example 3: Stochastic System (Full Delegation)\n\n::: {#ex-stochastic-system .cell execution_count=12}\n``` {.python .cell-code}\nclass BrownianMotion(ContinuousStochasticSystem):\n    def define_system(self, mu=0.0, sigma=1.0):\n        x = sp.Symbol('x', real=True)\n        u = sp.Symbol('u', real=True)\n        mu_sym, sigma_sym = sp.symbols('mu sigma', real=True)\n        \n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([mu_sym + u])\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.parameters = {mu_sym: mu, sigma_sym: sigma}\n        self.sde_type = 'ito'\n        self.order = 1\n\n# Stochastic delegation automatic\nsde_system = BrownianMotion()\n\n# User interacts through clean interface\nx = np.array([0.0])\nu = np.array([0.0])\n\n# Drift and diffusion evaluated automatically\nf = sde_system.drift(x, u)  # DynamicsEvaluator\ng = sde_system.diffusion(x, u)  # DiffusionHandler\n\nprint(f\"Noise type: {sde_system.is_additive_noise()}\")\nprint(f\"Recommended methods: {sde_system.recommend_solvers('numpy')[:3]}\")\n```\n:::\n\n\n### Example 4: Equilibrium Management (Delegated)\n\n::: {#ex-equilibrium-management .cell execution_count=13}\n``` {.python .cell-code}\nsystem = Pendulum()\n\n# Add multiple equilibria (delegates to EquilibriumHandler)\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0.0]),\n    u_eq=np.zeros(1),\n    verify=True,\n    metadata={'stability': 'unstable'}\n)\n\nsystem.add_equilibrium(\n    'downright',\n    x_eq=np.array([-np.pi, 0.0]),\n    u_eq=np.zeros(1),\n    metadata={'stability': 'unstable'}\n)\n\n# List and access equilibria\nequilibria = system.list_equilibria()\nprint(f\"Available: {equilibria}\")\n\n# Get equilibrium in any backend\nx_eq_np, u_eq_np = system.get_equilibrium('upright')\n\nwith system.use_backend('torch'):\n    x_eq_torch, u_eq_torch = system.get_equilibrium('upright')\n    print(f\"Backend conversion automatic: {type(x_eq_torch)}\")\n```\n:::\n\n\n### Example 5: Linearization Workflow (Seamless)\n\n::: {#ex-linearization-workflow .cell execution_count=14}\n``` {.python .cell-code}\nsystem = SpringMassDamper()\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Linearize (LinearizationEngine called internally)\nA, B = system.linearize(x_eq, u_eq)\n\n# Analyze stability\neigenvalues = np.linalg.eigvals(A)\nprint(f\"Eigenvalues: {eigenvalues}\")\nprint(f\"Stable: {np.all(eigenvalues.real < 0)}\")\n\n# Linearization works with any backend\nwith system.use_backend('torch'):\n    A_torch, B_torch = system.linearize(\n        torch.zeros(2),\n        torch.zeros(1)\n    )\n    print(f\"PyTorch linearization: {type(A_torch)}\")\n```\n:::\n\n\n## Key Strengths {#sec-key-strengths}\n\n1. **Clean Separation** - Each utility has one clear responsibility\n2. **Encapsulation** - Internal complexity hidden from users\n3. **Reusability** - Components can be composed by different system types\n4. **Testability** - Easy to test each component in isolation\n5. **Flexibility** - Internal implementation can change without affecting users\n6. **Performance** - Intelligent caching and lazy initialization\n7. **Multi-Backend** - Seamless backend switching without user intervention\n8. **Type Safety** - TypedDict and semantic types throughout\n9. **Documentation** - Clear purpose and interface for each component\n10. **Maintainability** - Easy to understand, modify, and extend\n11. **User-Friendly** - Complex functionality exposed through simple interfaces\n\n## Summary\n\nThe delegation layer provides robust internal services that power the ControlDESymulation framework. Through careful composition and encapsulation, these utilities enable powerful functionality while maintaining a clean, user-friendly system interface.\n\nUsers benefit from this architecture without needing to understand its internal workings—they simply interact with intuitive system methods that delegate to the appropriate internal components automatically.\n\n",
    "supporting": [
      "Delegation_Layer_Architecture_files"
    ],
    "filters": [],
    "includes": {}
  }
}