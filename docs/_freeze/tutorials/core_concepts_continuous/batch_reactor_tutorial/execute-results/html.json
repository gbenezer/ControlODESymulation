{
  "hash": "f5e6379754ed19669ab17ab6ee1f185a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Anatomy of a Symbolic System\"\nsubtitle: \"Stochastic Batch Reactors\"\nauthor: \"Gil Benezer\"\ndate: today\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    code-fold: show\n    code-tools: true\n    theme: cosmo\nexecute:\n  eval: true\n  cache: true\n  warning: false\n---\n\nTODO: add front matter describing the batch reactor system\n\n::: {#5543d97d .cell execution_count=1}\n``` {.python .cell-code}\nfrom typing import List, Optional, Tuple\n\nimport numpy as np\nimport sympy as sp\n\nfrom cdesym import ContinuousStochasticSystem\n\nclass ContinuousStochasticBatchReactor(ContinuousStochasticSystem):\n    def define_system(\n        self,\n        k1_val: float = 0.5,\n        k2_val: float = 0.3,\n        E1_val: float = 1000.0,\n        E2_val: float = 1500.0,\n        alpha_val: float = 0.1,\n        T_amb_val: float = 300.0,\n        sigma_A: float = 0.01,\n        sigma_B: float = 0.01,\n        sigma_T: float = 1.0,\n        C_A0: Optional[float] = None,\n        T0: Optional[float] = None,\n    ):\n        # Store initial conditions\n        self.C_A0 = C_A0\n        self.T0 = T0\n\n        # State and control variables\n        C_A, C_B, T = sp.symbols(\"C_A C_B T\", real=True, positive=True)\n        Q = sp.symbols(\"Q\", real=True)\n\n        # Parameters (kinetics and heat transfer)\n        k1, k2, E1, E2, alpha, T_amb = sp.symbols(\n            \"k1 k2 E1 E2 alpha T_amb\",\n            real=True,\n            positive=True,\n        )\n\n        # Noise intensities\n        sigma_A_sym = sp.symbols(\"sigma_A\", real=True, positive=True)\n        sigma_B_sym = sp.symbols(\"sigma_B\", real=True, positive=True)\n        sigma_T_sym = sp.symbols(\"sigma_T\", real=True, positive=True)\n\n        self.parameters = {\n            k1: k1_val,\n            k2: k2_val,\n            E1: E1_val,\n            E2: E2_val,\n            alpha: alpha_val,\n            T_amb: T_amb_val,\n            sigma_A_sym: sigma_A,\n            sigma_B_sym: sigma_B,\n            sigma_T_sym: sigma_T,\n        }\n\n        self.state_vars = [C_A, C_B, T]\n        self.control_vars = [Q]\n        self.output_vars = []\n        self.order = 1\n\n        # Reaction rates (Arrhenius kinetics)\n        r1 = k1 * C_A * sp.exp(-E1 / T)\n        r2 = k2 * C_B * sp.exp(-E2 / T)\n\n        # DRIFT (Deterministic part - same as deterministic reactor)\n        dC_A_dt = -r1\n        dC_B_dt = r1 - r2\n        dT_dt = Q - alpha * (T - T_amb)\n\n        self._f_sym = sp.Matrix([dC_A_dt, dC_B_dt, dT_dt])\n\n        # DIFFUSION (Stochastic part - additive noise)\n        # Diagonal matrix: three independent Wiener processes\n        self.diffusion_expr = sp.Matrix(\n            [\n                [sigma_A_sym, 0, 0],\n                [0, sigma_B_sym, 0],\n                [0, 0, sigma_T_sym],\n            ],\n        )\n\n        # Itô SDE interpretation\n        self.sde_type = \"ito\"\n\n        # Output: Full state measurement (with potential noise in practice)\n        # technically optional\n        self._h_sym = sp.Matrix([C_A, C_B, T])\n\n    def setup_equilibria(self):\n        # Get parameters\n        T_amb = self.parameters[sp.symbols(\"T_amb\")]\n\n        # Complete conversion equilibrium (deterministic part)\n        self.add_equilibrium(\n            \"complete\",\n            x_eq=np.array([0.0, 0.0, T_amb]),\n            u_eq=np.array([0.0]),\n            verify=True,\n            stability=\"stable\",\n            notes=\"Equilibrium of deterministic part (drift). Stochastic trajectories \"\n            \"fluctuate around this point with variance growing over time.\",\n        )\n\n        # Initial condition (if provided)\n        if self.C_A0 is not None and self.T0 is not None:\n            alpha = self.parameters[sp.symbols(\"alpha\")]\n            Q_init = alpha * (self.T0 - T_amb)\n\n            self.add_equilibrium(\n                \"initial\",\n                x_eq=np.array([self.C_A0, 0.0, self.T0]),\n                u_eq=np.array([Q_init]),\n                verify=False,\n                stability=\"unstable\",\n                notes=\"Initial state setpoint (deterministic part). Stochastic trajectories \"\n                \"will fluctuate with std ~ [σ_A·√t, σ_B·√t, σ_T·√t].\",\n            )\n            self.set_default_equilibrium(\"initial\")\n        else:\n            self.set_default_equilibrium(\"complete\")\n```\n:::\n\n\nTODO: go stepwise over the definition of define system\n\nTODO: go over what is optional and what isn't optional about deterministic systems\n\nTODO: clarify what output variables actually are, what they semantically mean, and what _h_sym is relative to _f_sym\n\nTODO: go over the added stochastic system mechanics and clarify that for pure diffusion systems the drift term _f_sym needs to be a zero vector\n\nTODO: go over Ito versus Stratonovich and types of noise\n\nTODO: go over the optional setup_equilibria method and why its there\n\nTODO: go over basic trajectory and phase plotting\n\n",
    "supporting": [
      "batch_reactor_tutorial_files"
    ],
    "filters": [],
    "includes": {}
  }
}