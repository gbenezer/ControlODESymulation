[
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "The Visualization Framework provides interactive, publication-ready plotting for dynamical systems analysis. It consists of 4 core modules totaling ~4,422 lines organized into a 2-layer architecture: centralized theming + specialized plotters.\n\n\n\nThemeable Interactive Visualization - The visualization framework enables:\n\nInteractive Plots - Plotly-based with zoom, pan, hover tooltips\nCentralized Theming - Consistent colors and styles across all plots\nBackend Agnostic - Works with NumPy, PyTorch, JAX seamlessly\nSpecialized Plotters - Dedicated classes for different visualization types\nPublication Ready - High-quality output for papers and presentations\nSystem Integration - Clean system.plotter and system.control_plotter APIs\nAccessible Design - Colorblind-safe palettes available\n\n# Consistent theming across all plots\nplotter = TrajectoryPlotter()\nfig = plotter.plot_trajectory(t, x, theme='publication', color_scheme='colorblind_safe')\nfig.show()\n\n\n\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                         │\n│         (ContinuousSystemBase, DiscreteSystemBase)          │\n│                                                              │\n│  system.plotter          ──────► TrajectoryPlotter          │\n│  system.phase_plotter    ──────► PhasePortraitPlotter       │\n│  system.control_plotter  ──────► ControlPlotter             │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ use theming from\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   THEMING LAYER                             │\n│                   themes.py (623 lines)                     │\n│                                                              │\n│  ColorSchemes:            PlotThemes:                       │\n│  • PLOTLY                • DEFAULT                          │\n│  • D3                    • PUBLICATION                      │\n│  • COLORBLIND_SAFE       • DARK                             │\n│  • TABLEAU                                                  │\n│  • SEQUENTIAL_BLUE                                          │\n│  • DIVERGING_RED_BLUE                                       │\n│                                                              │\n│  Utilities: lighten_color(), darken_color(), interpolate() │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ used by\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   PLOTTER LAYER                             │\n│                                                              │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ TrajectoryPlotter (914 lines)                        │  │\n│  │ • plot_trajectory()        - State vs time           │  │\n│  │ • plot_state_and_control() - Combined view           │  │\n│  │ • plot_comparison()        - Multiple runs           │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                              │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ PhasePortraitPlotter (1,027 lines)                   │  │\n│  │ • plot_2d()                - 2D phase portrait       │  │\n│  │ • plot_3d()                - 3D phase portrait       │  │\n│  │ • plot_limit_cycle()       - Periodic orbits         │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                              │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ ControlPlotter (1,858 lines)                         │  │\n│  │ • plot_eigenvalue_map()         - Stability regions  │  │\n│  │ • plot_gain_comparison()        - Compare gains      │  │\n│  │ • plot_riccati_convergence()    - Solver conv        │  │\n│  │ • plot_controllability_gramian()- Gramian heatmap    │  │\n│  │ • plot_observability_gramian()  - Gramian heatmap    │  │\n│  │ • plot_step_response()          - Step response      │  │\n│  │ • plot_impulse_response()       - Impulse response   │  │\n│  │ • plot_frequency_response()     - Bode plots         │  │\n│  │ • plot_nyquist()                - Nyquist diagram    │  │\n│  │ • plot_root_locus()             - Root locus         │  │\n│  └──────────────────────────────────────────────────────┘  │\n└────────────────────────────────────────────────────────────┘\n\n\n\n\n\n\n\nFile: themes.py (623 lines)\nPurpose: Centralized color palettes and plot styling\nDesign Philosophy:\n\nSingle source of truth for all colors and styles\nEasy customization and extension\nAccessibility (colorblind-safe options)\nPublication-ready defaults\n\nCategories:\n1. Color Schemes\nclass ColorSchemes:\n    \"\"\"Predefined color palettes for plotting.\"\"\"\n    \n    # Categorical schemes (for distinct categories)\n    PLOTLY = [\n        \"#636EFA\",  # Blue\n        \"#EF553B\",  # Red\n        \"#00CC96\",  # Green\n        \"#AB63FA\",  # Purple\n        \"#FFA15A\",  # Orange\n        \"#19D3F3\",  # Cyan\n        \"#FF6692\",  # Pink\n        \"#B6E880\",  # Light green\n        \"#FF97FF\",  # Light purple\n        \"#FECB52\",  # Yellow\n    ]\n    \n    D3 = [\n        \"#1f77b4\",  # Blue\n        \"#ff7f0e\",  # Orange\n        \"#2ca02c\",  # Green\n        # ... 10 colors total\n    ]\n    \n    COLORBLIND_SAFE = [\n        \"#0173B2\",  # Blue (Wong palette)\n        \"#DE8F05\",  # Orange\n        \"#029E73\",  # Green\n        # ... 8 colors (colorblind accessible)\n    ]\n    \n    TABLEAU = [\n        \"#4E79A7\",  # Blue\n        \"#F28E2B\",  # Orange\n        # ... 10 colors\n    ]\n    \n    # Sequential schemes (for heatmaps, continuous data)\n    SEQUENTIAL_BLUE = [\n        \"#f7fbff\",  # Lightest\n        \"#deebf7\",\n        \"#c6dbef\",\n        \"#9ecae1\",\n        \"#6baed6\",\n        \"#4292c6\",\n        \"#2171b5\",\n        \"#08519c\",\n        \"#08306b\",  # Darkest\n    ]\n    \n    SEQUENTIAL_GREEN = [...]  # Similar structure\n    \n    # Diverging schemes (for signed data)\n    DIVERGING_RED_BLUE = [\n        \"#67001f\",  # Dark red\n        \"#b2182b\",\n        \"#d6604d\",\n        \"#f4a582\",\n        \"#fddbc7\",\n        \"#f7f7f7\",  # White (center)\n        \"#d1e5f0\",\n        \"#92c5de\",\n        \"#4393c3\",\n        \"#2166ac\",\n        \"#053061\",  # Dark blue\n    ]\n    \n    DIVERGING_PURPLE_GREEN = [...]  # Similar structure\n    \n    @staticmethod\n    def get_colors(scheme: str, n_colors: Optional[int] = None) -&gt; List[str]:\n        \"\"\"\n        Get colors from a named scheme.\n        \n        Args:\n            scheme: Name of color scheme ('plotly', 'd3', 'colorblind_safe', etc.)\n            n_colors: Number of colors to return (cycles if exceeds palette size)\n        \n        Returns:\n            List of color hex codes\n        \n        Examples:\n            &gt;&gt;&gt; colors = ColorSchemes.get_colors('colorblind_safe', n_colors=3)\n            &gt;&gt;&gt; print(colors)  # ['#0173B2', '#DE8F05', '#029E73']\n        \"\"\"\n2. Plot Themes\nclass PlotThemes:\n    \"\"\"Complete theme configurations for plots.\"\"\"\n    \n    DEFAULT = {\n        'template': 'plotly',\n        'font_family': 'Arial, sans-serif',\n        'font_size': 12,\n        'title_font_size': 16,\n        'axis_line_color': '#444',\n        'grid_color': '#EEE',\n        'background_color': '#FFF',\n        'plot_background_color': '#FFF',\n    }\n    \n    PUBLICATION = {\n        'template': 'simple_white',\n        'font_family': 'Times New Roman, serif',\n        'font_size': 14,\n        'title_font_size': 18,\n        'axis_line_color': '#000',\n        'axis_line_width': 1.5,\n        'grid_color': '#CCC',\n        'grid_width': 0.5,\n        'background_color': '#FFF',\n        'plot_background_color': '#FFF',\n        'showlegend': True,\n        'legend_bgcolor': 'rgba(255,255,255,0.8)',\n        'legend_borderwidth': 1,\n    }\n    \n    DARK = {\n        'template': 'plotly_dark',\n        'font_family': 'Arial, sans-serif',\n        'font_size': 12,\n        'title_font_size': 16,\n        'axis_line_color': '#AAA',\n        'grid_color': '#444',\n        'background_color': '#111',\n        'plot_background_color': '#1E1E1E',\n    }\n    \n    @staticmethod\n    def apply_theme(fig: go.Figure, theme: str = 'default') -&gt; go.Figure:\n        \"\"\"\n        Apply complete theme to figure.\n        \n        Args:\n            fig: Plotly figure to style\n            theme: Theme name ('default', 'publication', 'dark')\n        \n        Returns:\n            Styled figure\n        \n        Examples:\n            &gt;&gt;&gt; fig = go.Figure()\n            &gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme='publication')\n        \"\"\"\n3. Color Utilities\ndef lighten_color(color: str, amount: float = 0.5) -&gt; str:\n    \"\"\"\n    Lighten a hex color.\n    \n    Args:\n        color: Hex color code '#RRGGBB'\n        amount: Amount to lighten (0-1), 0 = no change, 1 = white\n    \n    Returns:\n        Lightened hex color\n    \n    Examples:\n        &gt;&gt;&gt; lighten_color('#1f77b4', 0.5)  # Light blue\n        '#8FBBDA'\n    \"\"\"\n\ndef darken_color(color: str, amount: float = 0.5) -&gt; str:\n    \"\"\"Darken a hex color.\"\"\"\n\ndef interpolate_colors(color1: str, color2: str, n: int) -&gt; List[str]:\n    \"\"\"\n    Create gradient between two colors.\n    \n    Args:\n        color1: Start color hex code\n        color2: End color hex code\n        n: Number of colors in gradient\n    \n    Returns:\n        List of n hex colors\n    \n    Examples:\n        &gt;&gt;&gt; gradient = interpolate_colors('#1f77b4', '#ff7f0e', n=5)\n    \"\"\"\nKey Design Features:\n\nAccessibility - Colorblind-safe palettes (Wong palette)\nVariety - Categorical, sequential, diverging schemes\nConsistency - All plotters use same theme system\nPublication quality - Professional defaults\nCustomization - Easy to add new themes/schemes\n\n\n\n\n\n\n\n\nFile: trajectory_plotter.py (914 lines)\nPurpose: Time-domain visualization (state and control vs time)\nDesign Philosophy:\n\nBackend agnostic (NumPy/PyTorch/JAX)\nAutomatic batch handling (Monte Carlo simulations)\nAdaptive layouts (optimal subplot arrangement)\nInteractive tooltips\n\nArchitecture:\nclass TrajectoryPlotter:\n    \"\"\"\n    Time-domain trajectory visualization.\n    \n    Attributes:\n        backend: Default computational backend\n        default_theme: Default plot theme\n    \"\"\"\n    \n    def __init__(self, backend: Backend = 'numpy', theme: str = 'default'):\n        self.backend = backend\n        self.default_theme = theme\nMethods:\n1. plot_trajectory()\ndef plot_trajectory(\n    self,\n    t: TimePoints,\n    x: StateTrajectory,\n    state_names: Optional[List[str]] = None,\n    show_std: bool = True,\n    color_scheme: str = 'plotly',\n    theme: str = 'default',\n    title: Optional[str] = None\n) -&gt; go.Figure:\n    \"\"\"\n    Plot state variables vs time.\n    \n    Automatically handles:\n    - Single trajectory: (T, nx)\n    - Batched trajectories: (n_batch, T, nx) → shows mean ± std\n    - Adaptive subplot layout\n    \n    Args:\n        t: Time points (T,)\n        x: State trajectory (T, nx) or (n_batch, T, nx)\n        state_names: State variable names for axis labels\n        show_std: Show std deviation bands for batched data\n        color_scheme: Color scheme name\n        theme: Plot theme name\n        title: Plot title\n    \n    Returns:\n        Interactive Plotly figure with subplots for each state\n    \n    Examples:\n        &gt;&gt;&gt; # Single trajectory\n        &gt;&gt;&gt; t = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; x = np.random.randn(100, 2)\n        &gt;&gt;&gt; fig = plotter.plot_trajectory(t, x, state_names=['x₁', 'x₂'])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Batched (Monte Carlo)\n        &gt;&gt;&gt; x_batch = np.random.randn(10, 100, 2)\n        &gt;&gt;&gt; fig = plotter.plot_trajectory(t, x_batch, show_std=True)\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Publication style\n        &gt;&gt;&gt; fig = plotter.plot_trajectory(\n        ...     t, x,\n        ...     theme='publication',\n        ...     color_scheme='colorblind_safe'\n        ... )\n    \"\"\"\n2. plot_state_and_control()\ndef plot_state_and_control(\n    self,\n    t: TimePoints,\n    x: StateTrajectory,\n    u: ControlSequence,\n    state_names: Optional[List[str]] = None,\n    control_names: Optional[List[str]] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Plot states and controls together.\n    \n    Creates subplot grid with states on top, controls on bottom.\n    \n    Args:\n        t: Time points (T,)\n        x: State trajectory (T, nx)\n        u: Control sequence (T, nu)\n        state_names: State variable names\n        control_names: Control input names\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive Plotly figure with state + control subplots\n    \n    Examples:\n        &gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\n        &gt;&gt;&gt; fig = plotter.plot_state_and_control(\n        ...     result['t'],\n        ...     result['x'],\n        ...     result['u'],\n        ...     state_names=['Position', 'Velocity'],\n        ...     control_names=['Force']\n        ... )\n    \"\"\"\n3. plot_comparison()\ndef plot_comparison(\n    self,\n    results: Dict[str, Dict],\n    state_names: Optional[List[str]] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Compare multiple simulation runs.\n    \n    Args:\n        results: Dict mapping run names to integration results\n                 Each result must have 't' and 'x' keys\n        state_names: State variable names\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive Plotly figure comparing runs\n    \n    Examples:\n        &gt;&gt;&gt; results = {\n        ...     'LQR Q=10': system.simulate(...),\n        ...     'LQR Q=100': system.simulate(...),\n        ...     'Open-loop': system.simulate(...)\n        ... }\n        &gt;&gt;&gt; fig = plotter.plot_comparison(results)\n    \"\"\"\nKey Features:\n\n✅ Backend conversion handled automatically\n✅ Batch dimension detected and processed\n✅ Adaptive subplot layouts (optimal rows×cols)\n✅ Mean ± std bands for Monte Carlo\n✅ Interactive tooltips with exact values\n✅ Publication-ready styling\n\n\n\n\n\nFile: phase_portrait.py (1,027 lines)\nPurpose: State space visualization (phase portraits)\nDesign Philosophy:\n\nVisualize dynamics in state space (not time domain)\nSupport 2D and 3D phase portraits\nOptional vector field overlays\nEquilibrium point highlighting\n\nArchitecture:\nclass PhasePortraitPlotter:\n    \"\"\"\n    Phase space visualization.\n    \n    Attributes:\n        backend: Default computational backend\n        default_theme: Default plot theme\n    \"\"\"\n    \n    def __init__(self, backend: Backend = 'numpy', theme: str = 'default'):\n        self.backend = backend\n        self.default_theme = theme\nMethods:\n1. plot_2d()\ndef plot_2d(\n    self,\n    x: StateTrajectory,\n    state_indices: Tuple[int, int] = (0, 1),\n    state_names: Optional[Tuple[str, str]] = None,\n    vector_field: Optional[Callable] = None,\n    equilibria: Optional[List[np.ndarray]] = None,\n    show_direction: bool = False,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    2D phase portrait.\n    \n    Plots trajectories in state space (x₁ vs x₂).\n    \n    Args:\n        x: State trajectory (T, nx) or (n_batch, T, nx)\n        state_indices: Which states to plot (default first two)\n        state_names: Axis labels\n        vector_field: Function (x1, x2) → (dx1, dx2) for arrows\n        equilibria: List of equilibrium points to mark\n        show_direction: Add arrows showing trajectory direction\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive 2D phase portrait\n    \n    Examples:\n        &gt;&gt;&gt; # Basic phase portrait\n        &gt;&gt;&gt; fig = plotter.plot_2d(\n        ...     x=trajectory,  # (T, 2)\n        ...     state_names=('θ', 'ω')\n        ... )\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # With vector field\n        &gt;&gt;&gt; def pendulum_field(theta, omega):\n        ...     return omega, -np.sin(theta)\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; fig = plotter.plot_2d(\n        ...     x=trajectory,\n        ...     vector_field=pendulum_field,\n        ...     equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n        ...     show_direction=True\n        ... )\n    \"\"\"\n2. plot_3d()\ndef plot_3d(\n    self,\n    x: StateTrajectory,\n    state_indices: Tuple[int, int, int] = (0, 1, 2),\n    state_names: Optional[Tuple[str, str, str]] = None,\n    equilibria: Optional[List[np.ndarray]] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    3D phase portrait.\n    \n    Interactive 3D visualization with rotation and zoom.\n    \n    Args:\n        x: State trajectory (T, nx)\n        state_indices: Which states to plot (3 indices)\n        state_names: Axis labels\n        equilibria: Equilibrium points to mark\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive 3D phase portrait\n    \n    Examples:\n        &gt;&gt;&gt; # Lorenz attractor\n        &gt;&gt;&gt; fig = plotter.plot_3d(\n        ...     x=lorenz_trajectory,  # (T, 3)\n        ...     state_names=('x', 'y', 'z'),\n        ...     theme='dark'\n        ... )\n    \"\"\"\n3. plot_limit_cycle()\ndef plot_limit_cycle(\n    self,\n    x: StateTrajectory,\n    state_indices: Tuple[int, int] = (0, 1),\n    highlight_period: Optional[float] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Highlight periodic orbits (limit cycles).\n    \n    Args:\n        x: State trajectory (T, nx)\n        state_indices: Which states to plot\n        highlight_period: If known, highlight one period\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Phase portrait with limit cycle highlighted\n    \n    Examples:\n        &gt;&gt;&gt; # Van der Pol oscillator\n        &gt;&gt;&gt; fig = plotter.plot_limit_cycle(\n        ...     x=vdp_trajectory,\n        ...     highlight_period=6.28,\n        ...     theme='publication'\n        ... )\n    \"\"\"\nKey Features:\n\n✅ 2D and 3D phase space visualization\n✅ Vector field overlays (quiver plots)\n✅ Equilibrium point markers (color-coded by stability)\n✅ Direction arrows on trajectories\n✅ Interactive 3D rotation/zoom\n✅ Limit cycle detection and highlighting\n\n\n\n\n\nFile: control_plots.py (1,858 lines)\nPurpose: Control-specific visualizations\nDesign Philosophy:\n\nSpecialized plots for control analysis\nFrequency domain analysis (Bode, Nyquist)\nStability analysis (eigenvalue maps, root locus)\nPerformance metrics (step response, gramians)\n\nArchitecture:\nclass ControlPlotter:\n    \"\"\"\n    Control system analysis visualization.\n    \n    Attributes:\n        backend: Default computational backend\n        default_theme: Default plot theme\n    \"\"\"\n    \n    def __init__(self, backend: Backend = 'numpy', theme: str = 'default'):\n        self.backend = backend\n        self.default_theme = theme\nMethods (10 total):\n1. plot_eigenvalue_map()\ndef plot_eigenvalue_map(\n    self,\n    eigenvalues: np.ndarray,\n    system_type: str = 'continuous',\n    show_stability_region: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Eigenvalue map with stability regions.\n    \n    Continuous: Plots Re(λ) vs Im(λ) with left half-plane shaded\n    Discrete: Plots eigenvalues on complex plane with unit circle\n    \n    Args:\n        eigenvalues: Complex eigenvalues\n        system_type: 'continuous' or 'discrete'\n        show_stability_region: Shade stability region\n        theme: Plot theme name\n    \n    Returns:\n        Interactive eigenvalue map\n    \n    Examples:\n        &gt;&gt;&gt; result = system.control.design_lqr(A, B, Q, R)\n        &gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n        ...     result['closed_loop_eigenvalues'],\n        ...     system_type='continuous'\n        ... )\n    \"\"\"\n2. plot_gain_comparison()\ndef plot_gain_comparison(\n    self,\n    gains: Dict[str, np.ndarray],\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Compare feedback gains across designs.\n    \n    Args:\n        gains: Dict mapping design names to gain matrices\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Heatmap comparing gains\n    \n    Examples:\n        &gt;&gt;&gt; gains = {\n        ...     'Q=10': design_lqr(10*Q, R)['gain'],\n        ...     'Q=100': design_lqr(100*Q, R)['gain'],\n        ... }\n        &gt;&gt;&gt; fig = plotter.plot_gain_comparison(gains)\n    \"\"\"\n3. plot_riccati_convergence()\ndef plot_riccati_convergence(\n    self,\n    P_history: List[np.ndarray],\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Riccati equation solver convergence.\n    \n    Args:\n        P_history: List of P matrices during iteration\n        theme: Plot theme name\n    \n    Returns:\n        Convergence plot (Frobenius norm vs iteration)\n    \"\"\"\n4. plot_controllability_gramian()\ndef plot_controllability_gramian(\n    self,\n    W_c: np.ndarray,\n    state_names: Optional[List[str]] = None,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Controllability Gramian heatmap.\n    \n    Args:\n        W_c: Controllability Gramian matrix (nx, nx)\n        state_names: State variable names\n        theme: Plot theme name\n    \n    Returns:\n        Heatmap of Gramian\n    \"\"\"\n5. plot_observability_gramian()\ndef plot_observability_gramian(\n    self,\n    W_o: np.ndarray,\n    state_names: Optional[List[str]] = None,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Observability Gramian heatmap.\n    \n    Args:\n        W_o: Observability Gramian matrix (nx, nx)\n        state_names: State variable names\n        theme: Plot theme name\n    \n    Returns:\n        Heatmap of Gramian\n    \"\"\"\n6. plot_step_response()\ndef plot_step_response(\n    self,\n    t: TimePoints,\n    y: OutputSequence,\n    show_metrics: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Step response with performance metrics.\n    \n    Computes and displays:\n    - Rise time (10% → 90%)\n    - Settling time (within 2% of final value)\n    - Overshoot percentage\n    - Steady-state error\n    \n    Args:\n        t: Time points\n        y: Output response (T, ny)\n        show_metrics: Annotate metrics on plot\n        theme: Plot theme name\n    \n    Returns:\n        Step response plot with metrics\n    \"\"\"\n7. plot_impulse_response()\ndef plot_impulse_response(\n    self,\n    t: TimePoints,\n    y: OutputSequence,\n    show_decay: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Impulse response with decay analysis.\n    \n    Args:\n        t: Time points\n        y: Output response (T, ny)\n        show_decay: Show exponential decay envelope\n        theme: Plot theme name\n    \n    Returns:\n        Impulse response plot\n    \"\"\"\n8. plot_frequency_response()\ndef plot_frequency_response(\n    self,\n    omega: np.ndarray,\n    magnitude_db: np.ndarray,\n    phase_deg: np.ndarray,\n    show_margins: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Bode plot (magnitude and phase).\n    \n    Args:\n        omega: Frequency points (rad/s)\n        magnitude_db: Magnitude in dB\n        phase_deg: Phase in degrees\n        show_margins: Show gain/phase margins\n        theme: Plot theme name\n    \n    Returns:\n        Two-subplot Bode plot\n    \n    Examples:\n        &gt;&gt;&gt; from scipy import signal\n        &gt;&gt;&gt; sys = signal.lti(A, B, C, D)\n        &gt;&gt;&gt; omega, mag, phase = signal.bode(sys)\n        &gt;&gt;&gt; fig = plotter.plot_frequency_response(omega, mag, phase)\n    \"\"\"\n9. plot_nyquist()\ndef plot_nyquist(\n    self,\n    real: np.ndarray,\n    imag: np.ndarray,\n    show_unit_circle: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Nyquist diagram for stability analysis.\n    \n    Args:\n        real: Real part of frequency response\n        imag: Imaginary part of frequency response\n        show_unit_circle: Show unit circle and critical point (-1, 0)\n        theme: Plot theme name\n    \n    Returns:\n        Nyquist plot\n    \"\"\"\n10. plot_root_locus()\ndef plot_root_locus(\n    self,\n    pole_paths: np.ndarray,\n    gains: np.ndarray,\n    system_type: str = 'continuous',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Root locus (pole migration vs gain).\n    \n    Args:\n        pole_paths: Pole locations (n_gains, n_poles)\n        gains: Feedback gain values\n        system_type: 'continuous' or 'discrete'\n        theme: Plot theme name\n    \n    Returns:\n        Root locus plot with stability regions\n    \"\"\"\nKey Features:\n\n✅ 10 specialized control analysis plots\n✅ Frequency domain (Bode, Nyquist)\n✅ Time domain (step, impulse)\n✅ Stability analysis (eigenvalues, root locus)\n✅ Gramian visualizations\n✅ Performance metrics\n✅ Interactive annotations\n\n\n\n\n\n\n\n\n\nAll system classes (ContinuousSystemBase, DiscreteSystemBase) provide plotter access:\n# In ContinuousSystemBase / DiscreteSystemBase\n\n@property\ndef plotter(self) -&gt; TrajectoryPlotter:\n    \"\"\"Access trajectory plotting utilities.\"\"\"\n    if not hasattr(self, '_trajectory_plotter'):\n        from src.visualization.trajectory_plotter import TrajectoryPlotter\n        self._trajectory_plotter = TrajectoryPlotter(\n            backend=self._default_backend,\n            theme='default'\n        )\n    return self._trajectory_plotter\n\n@property\ndef phase_plotter(self) -&gt; PhasePortraitPlotter:\n    \"\"\"Access phase portrait plotting utilities.\"\"\"\n    if not hasattr(self, '_phase_portrait_plotter'):\n        from src.visualization.phase_portrait import PhasePortraitPlotter\n        self._phase_portrait_plotter = PhasePortraitPlotter(\n            backend=self._default_backend,\n            theme='default'\n        )\n    return self._phase_portrait_plotter\n\n@property\ndef control_plotter(self) -&gt; ControlPlotter:\n    \"\"\"Access control plotting utilities.\"\"\"\n    if not hasattr(self, '_control_plotter'):\n        from src.visualization.control_plots import ControlPlotter\n        self._control_plotter = ControlPlotter(\n            backend=self._default_backend,\n            theme='default'\n        )\n    return self._control_plotter\n\n\n\n# Create system\nsystem = Pendulum()\n\n# Simulate\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n\n# Plot trajectory (via system)\nfig = system.plotter.plot_trajectory(\n    result['t'],\n    result['x'],\n    state_names=['θ', 'ω'],\n    theme='publication'\n)\nfig.show()\n\n# Plot phase portrait (via system)\nfig = system.phase_plotter.plot_2d(\n    result['x'],\n    state_names=('θ', 'ω'),\n    show_direction=True\n)\nfig.show()\n\n# Plot eigenvalues (via system)\nA, B = system.linearize(x_eq, u_eq)\nlqr = system.control.design_lqr(A, B, Q, R)\nfig = system.control_plotter.plot_eigenvalue_map(\n    lqr['closed_loop_eigenvalues'],\n    system_type='continuous'\n)\nfig.show()\n\n\n\n\n\n\n\nWhy centralized themes?\n# ANTI-PATTERN: Hardcoded colors in each plotter\nclass BadPlotter:\n    def plot(self):\n        fig.add_trace(go.Scatter(line=dict(color='#1f77b4')))  # Hardcoded!\n\n# GOOD PATTERN: Centralized theming\nclass GoodPlotter:\n    def plot(self, color_scheme='plotly', theme='default'):\n        colors = ColorSchemes.get_colors(color_scheme)\n        fig.add_trace(go.Scatter(line=dict(color=colors[0])))\n        fig = PlotThemes.apply_theme(fig, theme)\nBenefits:\n\n✅ Consistent colors across all plots\n✅ Easy to switch themes globally\n✅ Accessibility (colorblind-safe)\n✅ Publication mode with one parameter\n\n\n\n\ndef plot_trajectory(self, t, x, **kwargs):\n    \"\"\"Works with NumPy, PyTorch, JAX.\"\"\"\n    \n    # Convert to NumPy for Plotly\n    t_np = self._to_numpy(t)\n    x_np = self._to_numpy(x)\n    \n    # Plot with Plotly (requires NumPy)\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=t_np, y=x_np[:, 0]))\n    \n    return fig\n\ndef _to_numpy(self, arr):\n    \"\"\"Convert any backend to NumPy.\"\"\"\n    if hasattr(arr, 'cpu'):  # PyTorch\n        return arr.cpu().numpy()\n    elif hasattr(arr, '__array__'):  # JAX\n        return np.array(arr)\n    else:  # NumPy\n        return arr\n\n\n\ndef _determine_subplot_layout(self, n_plots: int) -&gt; Tuple[int, int]:\n    \"\"\"\n    Determine optimal subplot grid.\n    \n    Examples:\n        1-2 plots: (n, 1) vertical\n        3-4 plots: (2, 2) square\n        5-6 plots: (2, 3)\n        7-9 plots: (3, 3)\n    \"\"\"\n    if n_plots &lt;= 2:\n        return n_plots, 1\n    elif n_plots &lt;= 4:\n        return 2, 2\n    else:\n        cols = int(np.ceil(np.sqrt(n_plots)))\n        rows = int(np.ceil(n_plots / cols))\n        return rows, cols\n\n\n\ndef _process_batch(self, x: np.ndarray) -&gt; Tuple[np.ndarray, bool]:\n    \"\"\"\n    Detect and process batch dimension.\n    \n    Args:\n        x: Could be (T, nx) or (n_batch, T, nx)\n    \n    Returns:\n        (data, is_batched)\n        - If batched: returns mean trajectory\n        - If single: returns as-is\n    \"\"\"\n    if x.ndim == 3:  # Batched\n        return np.mean(x, axis=0), True\n    elif x.ndim == 2:  # Single\n        return x, False\n    else:\n        raise ValueError(f\"Invalid shape: {x.shape}\")\n\n\n\n\n\nCentralized Theming - Single source of truth for colors/styles\nBackend Agnostic - NumPy/PyTorch/JAX transparent\nInteractive - Plotly-based with zoom, pan, hover\nPublication Ready - Professional defaults and themes\nAccessible - Colorblind-safe palettes\nSpecialized Plotters - Right tool for each visualization type\nSystem Integration - Clean system.plotter APIs\nAdaptive Layouts - Optimal subplot arrangements\nBatch Support - Monte Carlo visualization automatic\nComprehensive - 16 plot types covering all needs\n\nThis visualization framework provides publication-quality interactive plotting for ControlDESymulation!"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#overview",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#overview",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "The Visualization Framework provides interactive, publication-ready plotting for dynamical systems analysis. It consists of 4 core modules totaling ~4,422 lines organized into a 2-layer architecture: centralized theming + specialized plotters."
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#architecture-philosophy",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#architecture-philosophy",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "Themeable Interactive Visualization - The visualization framework enables:\n\nInteractive Plots - Plotly-based with zoom, pan, hover tooltips\nCentralized Theming - Consistent colors and styles across all plots\nBackend Agnostic - Works with NumPy, PyTorch, JAX seamlessly\nSpecialized Plotters - Dedicated classes for different visualization types\nPublication Ready - High-quality output for papers and presentations\nSystem Integration - Clean system.plotter and system.control_plotter APIs\nAccessible Design - Colorblind-safe palettes available\n\n# Consistent theming across all plots\nplotter = TrajectoryPlotter()\nfig = plotter.plot_trajectory(t, x, theme='publication', color_scheme='colorblind_safe')\nfig.show()"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#framework-layers",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#framework-layers",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                         │\n│         (ContinuousSystemBase, DiscreteSystemBase)          │\n│                                                              │\n│  system.plotter          ──────► TrajectoryPlotter          │\n│  system.phase_plotter    ──────► PhasePortraitPlotter       │\n│  system.control_plotter  ──────► ControlPlotter             │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ use theming from\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   THEMING LAYER                             │\n│                   themes.py (623 lines)                     │\n│                                                              │\n│  ColorSchemes:            PlotThemes:                       │\n│  • PLOTLY                • DEFAULT                          │\n│  • D3                    • PUBLICATION                      │\n│  • COLORBLIND_SAFE       • DARK                             │\n│  • TABLEAU                                                  │\n│  • SEQUENTIAL_BLUE                                          │\n│  • DIVERGING_RED_BLUE                                       │\n│                                                              │\n│  Utilities: lighten_color(), darken_color(), interpolate() │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ used by\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   PLOTTER LAYER                             │\n│                                                              │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ TrajectoryPlotter (914 lines)                        │  │\n│  │ • plot_trajectory()        - State vs time           │  │\n│  │ • plot_state_and_control() - Combined view           │  │\n│  │ • plot_comparison()        - Multiple runs           │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                              │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ PhasePortraitPlotter (1,027 lines)                   │  │\n│  │ • plot_2d()                - 2D phase portrait       │  │\n│  │ • plot_3d()                - 3D phase portrait       │  │\n│  │ • plot_limit_cycle()       - Periodic orbits         │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                              │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │ ControlPlotter (1,858 lines)                         │  │\n│  │ • plot_eigenvalue_map()         - Stability regions  │  │\n│  │ • plot_gain_comparison()        - Compare gains      │  │\n│  │ • plot_riccati_convergence()    - Solver conv        │  │\n│  │ • plot_controllability_gramian()- Gramian heatmap    │  │\n│  │ • plot_observability_gramian()  - Gramian heatmap    │  │\n│  │ • plot_step_response()          - Step response      │  │\n│  │ • plot_impulse_response()       - Impulse response   │  │\n│  │ • plot_frequency_response()     - Bode plots         │  │\n│  │ • plot_nyquist()                - Nyquist diagram    │  │\n│  │ • plot_root_locus()             - Root locus         │  │\n│  └──────────────────────────────────────────────────────┘  │\n└────────────────────────────────────────────────────────────┘"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#module-breakdown",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#module-breakdown",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "File: themes.py (623 lines)\nPurpose: Centralized color palettes and plot styling\nDesign Philosophy:\n\nSingle source of truth for all colors and styles\nEasy customization and extension\nAccessibility (colorblind-safe options)\nPublication-ready defaults\n\nCategories:\n1. Color Schemes\nclass ColorSchemes:\n    \"\"\"Predefined color palettes for plotting.\"\"\"\n    \n    # Categorical schemes (for distinct categories)\n    PLOTLY = [\n        \"#636EFA\",  # Blue\n        \"#EF553B\",  # Red\n        \"#00CC96\",  # Green\n        \"#AB63FA\",  # Purple\n        \"#FFA15A\",  # Orange\n        \"#19D3F3\",  # Cyan\n        \"#FF6692\",  # Pink\n        \"#B6E880\",  # Light green\n        \"#FF97FF\",  # Light purple\n        \"#FECB52\",  # Yellow\n    ]\n    \n    D3 = [\n        \"#1f77b4\",  # Blue\n        \"#ff7f0e\",  # Orange\n        \"#2ca02c\",  # Green\n        # ... 10 colors total\n    ]\n    \n    COLORBLIND_SAFE = [\n        \"#0173B2\",  # Blue (Wong palette)\n        \"#DE8F05\",  # Orange\n        \"#029E73\",  # Green\n        # ... 8 colors (colorblind accessible)\n    ]\n    \n    TABLEAU = [\n        \"#4E79A7\",  # Blue\n        \"#F28E2B\",  # Orange\n        # ... 10 colors\n    ]\n    \n    # Sequential schemes (for heatmaps, continuous data)\n    SEQUENTIAL_BLUE = [\n        \"#f7fbff\",  # Lightest\n        \"#deebf7\",\n        \"#c6dbef\",\n        \"#9ecae1\",\n        \"#6baed6\",\n        \"#4292c6\",\n        \"#2171b5\",\n        \"#08519c\",\n        \"#08306b\",  # Darkest\n    ]\n    \n    SEQUENTIAL_GREEN = [...]  # Similar structure\n    \n    # Diverging schemes (for signed data)\n    DIVERGING_RED_BLUE = [\n        \"#67001f\",  # Dark red\n        \"#b2182b\",\n        \"#d6604d\",\n        \"#f4a582\",\n        \"#fddbc7\",\n        \"#f7f7f7\",  # White (center)\n        \"#d1e5f0\",\n        \"#92c5de\",\n        \"#4393c3\",\n        \"#2166ac\",\n        \"#053061\",  # Dark blue\n    ]\n    \n    DIVERGING_PURPLE_GREEN = [...]  # Similar structure\n    \n    @staticmethod\n    def get_colors(scheme: str, n_colors: Optional[int] = None) -&gt; List[str]:\n        \"\"\"\n        Get colors from a named scheme.\n        \n        Args:\n            scheme: Name of color scheme ('plotly', 'd3', 'colorblind_safe', etc.)\n            n_colors: Number of colors to return (cycles if exceeds palette size)\n        \n        Returns:\n            List of color hex codes\n        \n        Examples:\n            &gt;&gt;&gt; colors = ColorSchemes.get_colors('colorblind_safe', n_colors=3)\n            &gt;&gt;&gt; print(colors)  # ['#0173B2', '#DE8F05', '#029E73']\n        \"\"\"\n2. Plot Themes\nclass PlotThemes:\n    \"\"\"Complete theme configurations for plots.\"\"\"\n    \n    DEFAULT = {\n        'template': 'plotly',\n        'font_family': 'Arial, sans-serif',\n        'font_size': 12,\n        'title_font_size': 16,\n        'axis_line_color': '#444',\n        'grid_color': '#EEE',\n        'background_color': '#FFF',\n        'plot_background_color': '#FFF',\n    }\n    \n    PUBLICATION = {\n        'template': 'simple_white',\n        'font_family': 'Times New Roman, serif',\n        'font_size': 14,\n        'title_font_size': 18,\n        'axis_line_color': '#000',\n        'axis_line_width': 1.5,\n        'grid_color': '#CCC',\n        'grid_width': 0.5,\n        'background_color': '#FFF',\n        'plot_background_color': '#FFF',\n        'showlegend': True,\n        'legend_bgcolor': 'rgba(255,255,255,0.8)',\n        'legend_borderwidth': 1,\n    }\n    \n    DARK = {\n        'template': 'plotly_dark',\n        'font_family': 'Arial, sans-serif',\n        'font_size': 12,\n        'title_font_size': 16,\n        'axis_line_color': '#AAA',\n        'grid_color': '#444',\n        'background_color': '#111',\n        'plot_background_color': '#1E1E1E',\n    }\n    \n    @staticmethod\n    def apply_theme(fig: go.Figure, theme: str = 'default') -&gt; go.Figure:\n        \"\"\"\n        Apply complete theme to figure.\n        \n        Args:\n            fig: Plotly figure to style\n            theme: Theme name ('default', 'publication', 'dark')\n        \n        Returns:\n            Styled figure\n        \n        Examples:\n            &gt;&gt;&gt; fig = go.Figure()\n            &gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme='publication')\n        \"\"\"\n3. Color Utilities\ndef lighten_color(color: str, amount: float = 0.5) -&gt; str:\n    \"\"\"\n    Lighten a hex color.\n    \n    Args:\n        color: Hex color code '#RRGGBB'\n        amount: Amount to lighten (0-1), 0 = no change, 1 = white\n    \n    Returns:\n        Lightened hex color\n    \n    Examples:\n        &gt;&gt;&gt; lighten_color('#1f77b4', 0.5)  # Light blue\n        '#8FBBDA'\n    \"\"\"\n\ndef darken_color(color: str, amount: float = 0.5) -&gt; str:\n    \"\"\"Darken a hex color.\"\"\"\n\ndef interpolate_colors(color1: str, color2: str, n: int) -&gt; List[str]:\n    \"\"\"\n    Create gradient between two colors.\n    \n    Args:\n        color1: Start color hex code\n        color2: End color hex code\n        n: Number of colors in gradient\n    \n    Returns:\n        List of n hex colors\n    \n    Examples:\n        &gt;&gt;&gt; gradient = interpolate_colors('#1f77b4', '#ff7f0e', n=5)\n    \"\"\"\nKey Design Features:\n\nAccessibility - Colorblind-safe palettes (Wong palette)\nVariety - Categorical, sequential, diverging schemes\nConsistency - All plotters use same theme system\nPublication quality - Professional defaults\nCustomization - Easy to add new themes/schemes\n\n\n\n\n\n\n\n\nFile: trajectory_plotter.py (914 lines)\nPurpose: Time-domain visualization (state and control vs time)\nDesign Philosophy:\n\nBackend agnostic (NumPy/PyTorch/JAX)\nAutomatic batch handling (Monte Carlo simulations)\nAdaptive layouts (optimal subplot arrangement)\nInteractive tooltips\n\nArchitecture:\nclass TrajectoryPlotter:\n    \"\"\"\n    Time-domain trajectory visualization.\n    \n    Attributes:\n        backend: Default computational backend\n        default_theme: Default plot theme\n    \"\"\"\n    \n    def __init__(self, backend: Backend = 'numpy', theme: str = 'default'):\n        self.backend = backend\n        self.default_theme = theme\nMethods:\n1. plot_trajectory()\ndef plot_trajectory(\n    self,\n    t: TimePoints,\n    x: StateTrajectory,\n    state_names: Optional[List[str]] = None,\n    show_std: bool = True,\n    color_scheme: str = 'plotly',\n    theme: str = 'default',\n    title: Optional[str] = None\n) -&gt; go.Figure:\n    \"\"\"\n    Plot state variables vs time.\n    \n    Automatically handles:\n    - Single trajectory: (T, nx)\n    - Batched trajectories: (n_batch, T, nx) → shows mean ± std\n    - Adaptive subplot layout\n    \n    Args:\n        t: Time points (T,)\n        x: State trajectory (T, nx) or (n_batch, T, nx)\n        state_names: State variable names for axis labels\n        show_std: Show std deviation bands for batched data\n        color_scheme: Color scheme name\n        theme: Plot theme name\n        title: Plot title\n    \n    Returns:\n        Interactive Plotly figure with subplots for each state\n    \n    Examples:\n        &gt;&gt;&gt; # Single trajectory\n        &gt;&gt;&gt; t = np.linspace(0, 10, 100)\n        &gt;&gt;&gt; x = np.random.randn(100, 2)\n        &gt;&gt;&gt; fig = plotter.plot_trajectory(t, x, state_names=['x₁', 'x₂'])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Batched (Monte Carlo)\n        &gt;&gt;&gt; x_batch = np.random.randn(10, 100, 2)\n        &gt;&gt;&gt; fig = plotter.plot_trajectory(t, x_batch, show_std=True)\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Publication style\n        &gt;&gt;&gt; fig = plotter.plot_trajectory(\n        ...     t, x,\n        ...     theme='publication',\n        ...     color_scheme='colorblind_safe'\n        ... )\n    \"\"\"\n2. plot_state_and_control()\ndef plot_state_and_control(\n    self,\n    t: TimePoints,\n    x: StateTrajectory,\n    u: ControlSequence,\n    state_names: Optional[List[str]] = None,\n    control_names: Optional[List[str]] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Plot states and controls together.\n    \n    Creates subplot grid with states on top, controls on bottom.\n    \n    Args:\n        t: Time points (T,)\n        x: State trajectory (T, nx)\n        u: Control sequence (T, nu)\n        state_names: State variable names\n        control_names: Control input names\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive Plotly figure with state + control subplots\n    \n    Examples:\n        &gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\n        &gt;&gt;&gt; fig = plotter.plot_state_and_control(\n        ...     result['t'],\n        ...     result['x'],\n        ...     result['u'],\n        ...     state_names=['Position', 'Velocity'],\n        ...     control_names=['Force']\n        ... )\n    \"\"\"\n3. plot_comparison()\ndef plot_comparison(\n    self,\n    results: Dict[str, Dict],\n    state_names: Optional[List[str]] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Compare multiple simulation runs.\n    \n    Args:\n        results: Dict mapping run names to integration results\n                 Each result must have 't' and 'x' keys\n        state_names: State variable names\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive Plotly figure comparing runs\n    \n    Examples:\n        &gt;&gt;&gt; results = {\n        ...     'LQR Q=10': system.simulate(...),\n        ...     'LQR Q=100': system.simulate(...),\n        ...     'Open-loop': system.simulate(...)\n        ... }\n        &gt;&gt;&gt; fig = plotter.plot_comparison(results)\n    \"\"\"\nKey Features:\n\n✅ Backend conversion handled automatically\n✅ Batch dimension detected and processed\n✅ Adaptive subplot layouts (optimal rows×cols)\n✅ Mean ± std bands for Monte Carlo\n✅ Interactive tooltips with exact values\n✅ Publication-ready styling\n\n\n\n\n\nFile: phase_portrait.py (1,027 lines)\nPurpose: State space visualization (phase portraits)\nDesign Philosophy:\n\nVisualize dynamics in state space (not time domain)\nSupport 2D and 3D phase portraits\nOptional vector field overlays\nEquilibrium point highlighting\n\nArchitecture:\nclass PhasePortraitPlotter:\n    \"\"\"\n    Phase space visualization.\n    \n    Attributes:\n        backend: Default computational backend\n        default_theme: Default plot theme\n    \"\"\"\n    \n    def __init__(self, backend: Backend = 'numpy', theme: str = 'default'):\n        self.backend = backend\n        self.default_theme = theme\nMethods:\n1. plot_2d()\ndef plot_2d(\n    self,\n    x: StateTrajectory,\n    state_indices: Tuple[int, int] = (0, 1),\n    state_names: Optional[Tuple[str, str]] = None,\n    vector_field: Optional[Callable] = None,\n    equilibria: Optional[List[np.ndarray]] = None,\n    show_direction: bool = False,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    2D phase portrait.\n    \n    Plots trajectories in state space (x₁ vs x₂).\n    \n    Args:\n        x: State trajectory (T, nx) or (n_batch, T, nx)\n        state_indices: Which states to plot (default first two)\n        state_names: Axis labels\n        vector_field: Function (x1, x2) → (dx1, dx2) for arrows\n        equilibria: List of equilibrium points to mark\n        show_direction: Add arrows showing trajectory direction\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive 2D phase portrait\n    \n    Examples:\n        &gt;&gt;&gt; # Basic phase portrait\n        &gt;&gt;&gt; fig = plotter.plot_2d(\n        ...     x=trajectory,  # (T, 2)\n        ...     state_names=('θ', 'ω')\n        ... )\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # With vector field\n        &gt;&gt;&gt; def pendulum_field(theta, omega):\n        ...     return omega, -np.sin(theta)\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; fig = plotter.plot_2d(\n        ...     x=trajectory,\n        ...     vector_field=pendulum_field,\n        ...     equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n        ...     show_direction=True\n        ... )\n    \"\"\"\n2. plot_3d()\ndef plot_3d(\n    self,\n    x: StateTrajectory,\n    state_indices: Tuple[int, int, int] = (0, 1, 2),\n    state_names: Optional[Tuple[str, str, str]] = None,\n    equilibria: Optional[List[np.ndarray]] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    3D phase portrait.\n    \n    Interactive 3D visualization with rotation and zoom.\n    \n    Args:\n        x: State trajectory (T, nx)\n        state_indices: Which states to plot (3 indices)\n        state_names: Axis labels\n        equilibria: Equilibrium points to mark\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Interactive 3D phase portrait\n    \n    Examples:\n        &gt;&gt;&gt; # Lorenz attractor\n        &gt;&gt;&gt; fig = plotter.plot_3d(\n        ...     x=lorenz_trajectory,  # (T, 3)\n        ...     state_names=('x', 'y', 'z'),\n        ...     theme='dark'\n        ... )\n    \"\"\"\n3. plot_limit_cycle()\ndef plot_limit_cycle(\n    self,\n    x: StateTrajectory,\n    state_indices: Tuple[int, int] = (0, 1),\n    highlight_period: Optional[float] = None,\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Highlight periodic orbits (limit cycles).\n    \n    Args:\n        x: State trajectory (T, nx)\n        state_indices: Which states to plot\n        highlight_period: If known, highlight one period\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Phase portrait with limit cycle highlighted\n    \n    Examples:\n        &gt;&gt;&gt; # Van der Pol oscillator\n        &gt;&gt;&gt; fig = plotter.plot_limit_cycle(\n        ...     x=vdp_trajectory,\n        ...     highlight_period=6.28,\n        ...     theme='publication'\n        ... )\n    \"\"\"\nKey Features:\n\n✅ 2D and 3D phase space visualization\n✅ Vector field overlays (quiver plots)\n✅ Equilibrium point markers (color-coded by stability)\n✅ Direction arrows on trajectories\n✅ Interactive 3D rotation/zoom\n✅ Limit cycle detection and highlighting\n\n\n\n\n\nFile: control_plots.py (1,858 lines)\nPurpose: Control-specific visualizations\nDesign Philosophy:\n\nSpecialized plots for control analysis\nFrequency domain analysis (Bode, Nyquist)\nStability analysis (eigenvalue maps, root locus)\nPerformance metrics (step response, gramians)\n\nArchitecture:\nclass ControlPlotter:\n    \"\"\"\n    Control system analysis visualization.\n    \n    Attributes:\n        backend: Default computational backend\n        default_theme: Default plot theme\n    \"\"\"\n    \n    def __init__(self, backend: Backend = 'numpy', theme: str = 'default'):\n        self.backend = backend\n        self.default_theme = theme\nMethods (10 total):\n1. plot_eigenvalue_map()\ndef plot_eigenvalue_map(\n    self,\n    eigenvalues: np.ndarray,\n    system_type: str = 'continuous',\n    show_stability_region: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Eigenvalue map with stability regions.\n    \n    Continuous: Plots Re(λ) vs Im(λ) with left half-plane shaded\n    Discrete: Plots eigenvalues on complex plane with unit circle\n    \n    Args:\n        eigenvalues: Complex eigenvalues\n        system_type: 'continuous' or 'discrete'\n        show_stability_region: Shade stability region\n        theme: Plot theme name\n    \n    Returns:\n        Interactive eigenvalue map\n    \n    Examples:\n        &gt;&gt;&gt; result = system.control.design_lqr(A, B, Q, R)\n        &gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n        ...     result['closed_loop_eigenvalues'],\n        ...     system_type='continuous'\n        ... )\n    \"\"\"\n2. plot_gain_comparison()\ndef plot_gain_comparison(\n    self,\n    gains: Dict[str, np.ndarray],\n    color_scheme: str = 'plotly',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Compare feedback gains across designs.\n    \n    Args:\n        gains: Dict mapping design names to gain matrices\n        color_scheme: Color scheme name\n        theme: Plot theme name\n    \n    Returns:\n        Heatmap comparing gains\n    \n    Examples:\n        &gt;&gt;&gt; gains = {\n        ...     'Q=10': design_lqr(10*Q, R)['gain'],\n        ...     'Q=100': design_lqr(100*Q, R)['gain'],\n        ... }\n        &gt;&gt;&gt; fig = plotter.plot_gain_comparison(gains)\n    \"\"\"\n3. plot_riccati_convergence()\ndef plot_riccati_convergence(\n    self,\n    P_history: List[np.ndarray],\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Riccati equation solver convergence.\n    \n    Args:\n        P_history: List of P matrices during iteration\n        theme: Plot theme name\n    \n    Returns:\n        Convergence plot (Frobenius norm vs iteration)\n    \"\"\"\n4. plot_controllability_gramian()\ndef plot_controllability_gramian(\n    self,\n    W_c: np.ndarray,\n    state_names: Optional[List[str]] = None,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Controllability Gramian heatmap.\n    \n    Args:\n        W_c: Controllability Gramian matrix (nx, nx)\n        state_names: State variable names\n        theme: Plot theme name\n    \n    Returns:\n        Heatmap of Gramian\n    \"\"\"\n5. plot_observability_gramian()\ndef plot_observability_gramian(\n    self,\n    W_o: np.ndarray,\n    state_names: Optional[List[str]] = None,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Observability Gramian heatmap.\n    \n    Args:\n        W_o: Observability Gramian matrix (nx, nx)\n        state_names: State variable names\n        theme: Plot theme name\n    \n    Returns:\n        Heatmap of Gramian\n    \"\"\"\n6. plot_step_response()\ndef plot_step_response(\n    self,\n    t: TimePoints,\n    y: OutputSequence,\n    show_metrics: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Step response with performance metrics.\n    \n    Computes and displays:\n    - Rise time (10% → 90%)\n    - Settling time (within 2% of final value)\n    - Overshoot percentage\n    - Steady-state error\n    \n    Args:\n        t: Time points\n        y: Output response (T, ny)\n        show_metrics: Annotate metrics on plot\n        theme: Plot theme name\n    \n    Returns:\n        Step response plot with metrics\n    \"\"\"\n7. plot_impulse_response()\ndef plot_impulse_response(\n    self,\n    t: TimePoints,\n    y: OutputSequence,\n    show_decay: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Impulse response with decay analysis.\n    \n    Args:\n        t: Time points\n        y: Output response (T, ny)\n        show_decay: Show exponential decay envelope\n        theme: Plot theme name\n    \n    Returns:\n        Impulse response plot\n    \"\"\"\n8. plot_frequency_response()\ndef plot_frequency_response(\n    self,\n    omega: np.ndarray,\n    magnitude_db: np.ndarray,\n    phase_deg: np.ndarray,\n    show_margins: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Bode plot (magnitude and phase).\n    \n    Args:\n        omega: Frequency points (rad/s)\n        magnitude_db: Magnitude in dB\n        phase_deg: Phase in degrees\n        show_margins: Show gain/phase margins\n        theme: Plot theme name\n    \n    Returns:\n        Two-subplot Bode plot\n    \n    Examples:\n        &gt;&gt;&gt; from scipy import signal\n        &gt;&gt;&gt; sys = signal.lti(A, B, C, D)\n        &gt;&gt;&gt; omega, mag, phase = signal.bode(sys)\n        &gt;&gt;&gt; fig = plotter.plot_frequency_response(omega, mag, phase)\n    \"\"\"\n9. plot_nyquist()\ndef plot_nyquist(\n    self,\n    real: np.ndarray,\n    imag: np.ndarray,\n    show_unit_circle: bool = True,\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Nyquist diagram for stability analysis.\n    \n    Args:\n        real: Real part of frequency response\n        imag: Imaginary part of frequency response\n        show_unit_circle: Show unit circle and critical point (-1, 0)\n        theme: Plot theme name\n    \n    Returns:\n        Nyquist plot\n    \"\"\"\n10. plot_root_locus()\ndef plot_root_locus(\n    self,\n    pole_paths: np.ndarray,\n    gains: np.ndarray,\n    system_type: str = 'continuous',\n    theme: str = 'default'\n) -&gt; go.Figure:\n    \"\"\"\n    Root locus (pole migration vs gain).\n    \n    Args:\n        pole_paths: Pole locations (n_gains, n_poles)\n        gains: Feedback gain values\n        system_type: 'continuous' or 'discrete'\n        theme: Plot theme name\n    \n    Returns:\n        Root locus plot with stability regions\n    \"\"\"\nKey Features:\n\n✅ 10 specialized control analysis plots\n✅ Frequency domain (Bode, Nyquist)\n✅ Time domain (step, impulse)\n✅ Stability analysis (eigenvalues, root locus)\n✅ Gramian visualizations\n✅ Performance metrics\n✅ Interactive annotations"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#integration-with-systems",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#integration-with-systems",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "All system classes (ContinuousSystemBase, DiscreteSystemBase) provide plotter access:\n# In ContinuousSystemBase / DiscreteSystemBase\n\n@property\ndef plotter(self) -&gt; TrajectoryPlotter:\n    \"\"\"Access trajectory plotting utilities.\"\"\"\n    if not hasattr(self, '_trajectory_plotter'):\n        from src.visualization.trajectory_plotter import TrajectoryPlotter\n        self._trajectory_plotter = TrajectoryPlotter(\n            backend=self._default_backend,\n            theme='default'\n        )\n    return self._trajectory_plotter\n\n@property\ndef phase_plotter(self) -&gt; PhasePortraitPlotter:\n    \"\"\"Access phase portrait plotting utilities.\"\"\"\n    if not hasattr(self, '_phase_portrait_plotter'):\n        from src.visualization.phase_portrait import PhasePortraitPlotter\n        self._phase_portrait_plotter = PhasePortraitPlotter(\n            backend=self._default_backend,\n            theme='default'\n        )\n    return self._phase_portrait_plotter\n\n@property\ndef control_plotter(self) -&gt; ControlPlotter:\n    \"\"\"Access control plotting utilities.\"\"\"\n    if not hasattr(self, '_control_plotter'):\n        from src.visualization.control_plots import ControlPlotter\n        self._control_plotter = ControlPlotter(\n            backend=self._default_backend,\n            theme='default'\n        )\n    return self._control_plotter\n\n\n\n# Create system\nsystem = Pendulum()\n\n# Simulate\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n\n# Plot trajectory (via system)\nfig = system.plotter.plot_trajectory(\n    result['t'],\n    result['x'],\n    state_names=['θ', 'ω'],\n    theme='publication'\n)\nfig.show()\n\n# Plot phase portrait (via system)\nfig = system.phase_plotter.plot_2d(\n    result['x'],\n    state_names=('θ', 'ω'),\n    show_direction=True\n)\nfig.show()\n\n# Plot eigenvalues (via system)\nA, B = system.linearize(x_eq, u_eq)\nlqr = system.control.design_lqr(A, B, Q, R)\nfig = system.control_plotter.plot_eigenvalue_map(\n    lqr['closed_loop_eigenvalues'],\n    system_type='continuous'\n)\nfig.show()"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#design-patterns",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#design-patterns",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "Why centralized themes?\n# ANTI-PATTERN: Hardcoded colors in each plotter\nclass BadPlotter:\n    def plot(self):\n        fig.add_trace(go.Scatter(line=dict(color='#1f77b4')))  # Hardcoded!\n\n# GOOD PATTERN: Centralized theming\nclass GoodPlotter:\n    def plot(self, color_scheme='plotly', theme='default'):\n        colors = ColorSchemes.get_colors(color_scheme)\n        fig.add_trace(go.Scatter(line=dict(color=colors[0])))\n        fig = PlotThemes.apply_theme(fig, theme)\nBenefits:\n\n✅ Consistent colors across all plots\n✅ Easy to switch themes globally\n✅ Accessibility (colorblind-safe)\n✅ Publication mode with one parameter\n\n\n\n\ndef plot_trajectory(self, t, x, **kwargs):\n    \"\"\"Works with NumPy, PyTorch, JAX.\"\"\"\n    \n    # Convert to NumPy for Plotly\n    t_np = self._to_numpy(t)\n    x_np = self._to_numpy(x)\n    \n    # Plot with Plotly (requires NumPy)\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=t_np, y=x_np[:, 0]))\n    \n    return fig\n\ndef _to_numpy(self, arr):\n    \"\"\"Convert any backend to NumPy.\"\"\"\n    if hasattr(arr, 'cpu'):  # PyTorch\n        return arr.cpu().numpy()\n    elif hasattr(arr, '__array__'):  # JAX\n        return np.array(arr)\n    else:  # NumPy\n        return arr\n\n\n\ndef _determine_subplot_layout(self, n_plots: int) -&gt; Tuple[int, int]:\n    \"\"\"\n    Determine optimal subplot grid.\n    \n    Examples:\n        1-2 plots: (n, 1) vertical\n        3-4 plots: (2, 2) square\n        5-6 plots: (2, 3)\n        7-9 plots: (3, 3)\n    \"\"\"\n    if n_plots &lt;= 2:\n        return n_plots, 1\n    elif n_plots &lt;= 4:\n        return 2, 2\n    else:\n        cols = int(np.ceil(np.sqrt(n_plots)))\n        rows = int(np.ceil(n_plots / cols))\n        return rows, cols\n\n\n\ndef _process_batch(self, x: np.ndarray) -&gt; Tuple[np.ndarray, bool]:\n    \"\"\"\n    Detect and process batch dimension.\n    \n    Args:\n        x: Could be (T, nx) or (n_batch, T, nx)\n    \n    Returns:\n        (data, is_batched)\n        - If batched: returns mean trajectory\n        - If single: returns as-is\n    \"\"\"\n    if x.ndim == 3:  # Batched\n        return np.mean(x, axis=0), True\n    elif x.ndim == 2:  # Single\n        return x, False\n    else:\n        raise ValueError(f\"Invalid shape: {x.shape}\")"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#file-size-summary",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#file-size-summary",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "Module\nLines\nPurpose\n\n\n\n\nTHEMING LAYER\n\n\n\n\nthemes.py\n623\nColor schemes and plot themes\n\n\nPLOTTER LAYER\n\n\n\n\ntrajectory_plotter.py\n914\nTime-domain visualization\n\n\nphase_portrait.py\n1,027\nState space visualization\n\n\ncontrol_plots.py\n1,858\nControl-specific plots\n\n\nTOTAL\n4,422\nComplete framework"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Architecture.html#key-strengths",
    "href": "api/visualization_framework/Visualization_Framework_Architecture.html#key-strengths",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "Centralized Theming - Single source of truth for colors/styles\nBackend Agnostic - NumPy/PyTorch/JAX transparent\nInteractive - Plotly-based with zoom, pan, hover\nPublication Ready - Professional defaults and themes\nAccessible - Colorblind-safe palettes\nSpecialized Plotters - Right tool for each visualization type\nSystem Integration - Clean system.plotter APIs\nAdaptive Layouts - Optimal subplot arrangements\nBatch Support - Monte Carlo visualization automatic\nComprehensive - 16 plot types covering all needs\n\nThis visualization framework provides publication-quality interactive plotting for ControlDESymulation!"
  },
  {
    "objectID": "api/visualization_framework/visualization_framework_text.html",
    "href": "api/visualization_framework/visualization_framework_text.html",
    "title": "Visualization Framework Architecture (Text Diagram)",
    "section": "",
    "text": "═══════════════════════════════════════════════════════════════════════\n               VISUALIZATION FRAMEWORK ARCHITECTURE\n═══════════════════════════════════════════════════════════════════════\n\n                    ┌──────────────────────────┐\n                    │  APPLICATION LAYER       │\n                    │                          │\n                    │  ContinuousSystemBase    │\n                    │  DiscreteSystemBase      │\n                    └──────────┬───────────────┘\n                               │\n                ┌──────────────┴───────────────┐\n                │                              │\n                ↓                              ↓\n    ┌───────────────────────┐      ┌───────────────────────┐\n    │  system.plotter       │      │  system.phase_plotter  │\n    │  TrajectoryPlotter    │      │  PhasePortraitPlotter  │\n    └───────────┬───────────┘      └───────────┬───────────┘\n                │                              │\n                │  ┌──────────────────────────────┐\n                └──┤  system.control_plotter      │\n                   │  ControlPlotter              │\n                   └──────────┬───────────────────┘\n                              │\n                              │ use theming from\n                              ↓\n            ┌──────────────────────────────────────┐\n            │  THEMING LAYER                       │\n            │  themes.py (623 lines)               │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ ColorSchemes                   │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • PLOTLY (10 colors)           │ │\n            │  │ • D3 (10 colors)               │ │\n            │  │ • COLORBLIND_SAFE (8 colors)   │ │\n            │  │ • TABLEAU (10 colors)          │ │\n            │  │ • SEQUENTIAL_BLUE (9 colors)   │ │\n            │  │ • SEQUENTIAL_GREEN (9 colors)  │ │\n            │  │ • DIVERGING_RED_BLUE (11)      │ │\n            │  │ • DIVERGING_PURPLE_GREEN (11)  │ │\n            │  └────────────────────────────────┘ │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ PlotThemes                     │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • DEFAULT (white, clean)       │ │\n            │  │ • PUBLICATION (serif, formal)  │ │\n            │  │ • DARK (dark background)       │ │\n            │  └────────────────────────────────┘ │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ Color Utilities                │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • lighten_color()              │ │\n            │  │ • darken_color()               │ │\n            │  │ • interpolate_colors()         │ │\n            │  └────────────────────────────────┘ │\n            └──────────────┬───────────────────────┘\n                           │ used by\n                           ↓\n            ┌──────────────────────────────────────┐\n            │  PLOTTER LAYER                       │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ TrajectoryPlotter (914 lines)  │ │\n            │  ├────────────────────────────────┤ │\n            │  │ Time-Domain Visualization      │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • plot_trajectory()            │ │\n            │  │   - Single: (T, nx)            │ │\n            │  │   - Batch: (n_batch, T, nx)    │ │\n            │  │   - Mean ± std bands           │ │\n            │  │                                │ │\n            │  │ • plot_state_and_control()     │ │\n            │  │   - Combined view              │ │\n            │  │   - Adaptive layout            │ │\n            │  │                                │ │\n            │  │ • plot_comparison()            │ │\n            │  │   - Multiple runs              │ │\n            │  │   - Overlay plots              │ │\n            │  └────────────────────────────────┘ │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ PhasePortraitPlotter (1027)    │ │\n            │  ├────────────────────────────────┤ │\n            │  │ State Space Visualization      │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • plot_2d()                    │ │\n            │  │   - x₁ vs x₂                   │ │\n            │  │   - Vector fields              │ │\n            │  │   - Equilibria                 │ │\n            │  │   - Direction arrows           │ │\n            │  │                                │ │\n            │  │ • plot_3d()                    │ │\n            │  │   - Interactive 3D             │ │\n            │  │   - Rotate/zoom                │ │\n            │  │                                │ │\n            │  │ • plot_limit_cycle()           │ │\n            │  │   - Periodic orbits            │ │\n            │  │   - Period highlighting        │ │\n            │  └────────────────────────────────┘ │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ ControlPlotter (1858 lines)    │ │\n            │  ├────────────────────────────────┤ │\n            │  │ Control-Specific Plots         │ │\n            │  ├────────────────────────────────┤ │\n            │  │ Stability Analysis:            │ │\n            │  │ • plot_eigenvalue_map()        │ │\n            │  │ • plot_root_locus()            │ │\n            │  │                                │ │\n            │  │ Design Comparison:             │ │\n            │  │ • plot_gain_comparison()       │ │\n            │  │ • plot_riccati_convergence()   │ │\n            │  │                                │ │\n            │  │ Gramian Analysis:              │ │\n            │  │ • plot_controllability_gramian │ │\n            │  │ • plot_observability_gramian   │ │\n            │  │                                │ │\n            │  │ Time Responses:                │ │\n            │  │ • plot_step_response()         │ │\n            │  │ • plot_impulse_response()      │ │\n            │  │                                │ │\n            │  │ Frequency Analysis:            │ │\n            │  │ • plot_frequency_response()    │ │\n            │  │ • plot_nyquist()               │ │\n            │  └────────────────────────────────┘ │\n            └──────────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        MODULE BREAKDOWN\n═══════════════════════════════════════════════════════════════════════\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ THEMING LAYER: themes.py (623 lines)                            ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nColorSchemes Class\n├─ Categorical Schemes (for distinct categories)\n│  ├─ PLOTLY: ['#636EFA', '#EF553B', '#00CC96', ...]  (10 colors)\n│  ├─ D3: ['#1f77b4', '#ff7f0e', '#2ca02c', ...]      (10 colors)\n│  ├─ COLORBLIND_SAFE: ['#0173B2', '#DE8F05', ...]   (8 colors)\n│  └─ TABLEAU: ['#4E79A7', '#F28E2B', '#E15759', ...] (10 colors)\n│\n├─ Sequential Schemes (for heatmaps, continuous data)\n│  ├─ SEQUENTIAL_BLUE: ['#f7fbff', ..., '#08306b']   (9 colors)\n│  └─ SEQUENTIAL_GREEN: ['#f7fcf5', ..., '#00441b']  (9 colors)\n│\n├─ Diverging Schemes (for signed data, ±)\n│  ├─ DIVERGING_RED_BLUE: ['#67001f', ..., '#053061'] (11 colors)\n│  └─ DIVERGING_PURPLE_GREEN: ['#40004b', ..., '#00441b'] (11)\n│\n└─ Methods\n   └─&gt; get_colors(scheme, n_colors) → List[str]\n\nPlotThemes Class\n├─ DEFAULT\n│  ├─ template: 'plotly'\n│  ├─ font: Arial, sans-serif, 12pt\n│  ├─ background: White\n│  └─ grid: #EEE\n│\n├─ PUBLICATION\n│  ├─ template: 'simple_white'\n│  ├─ font: Times New Roman, serif, 14pt\n│  ├─ background: White\n│  ├─ grid: #CCC\n│  └─ borders: Black, thicker lines\n│\n├─ DARK\n│  ├─ template: 'plotly_dark'\n│  ├─ font: Arial, sans-serif, 12pt\n│  ├─ background: #111\n│  └─ grid: #444\n│\n└─ Methods\n   └─&gt; apply_theme(fig, theme) → go.Figure\n\nColor Utilities\n├─&gt; lighten_color(color, amount) → str\n├─&gt; darken_color(color, amount) → str\n└─&gt; interpolate_colors(color1, color2, n) → List[str]\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ PLOTTER LAYER: TrajectoryPlotter (914 lines)                    ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nTrajectoryPlotter.__init__(backend, theme)\n├─&gt; self.backend = backend\n└─&gt; self.default_theme = theme\n\nplot_trajectory(t, x, state_names, show_std, color_scheme, theme)\n├─&gt; Detects batch dimension\n│   ├─ Single: (T, nx) → plot directly\n│   └─ Batch: (n_batch, T, nx) → compute mean, std\n├─&gt; Determines subplot layout\n│   └─&gt; _determine_subplot_layout(nx) → (rows, cols)\n├─&gt; Creates subplots\n│   └─&gt; make_subplots(rows, cols)\n├─&gt; Adds traces for each state\n│   ├─ Mean line\n│   └─ Std bands (if batched and show_std=True)\n├─&gt; Applies theme\n│   └─&gt; PlotThemes.apply_theme(fig, theme)\n└─&gt; Returns: go.Figure\n\nplot_state_and_control(t, x, u, state_names, control_names, ...)\n├─&gt; Creates combined subplot grid\n│   ├─ Top rows: States\n│   └─ Bottom rows: Controls\n├─&gt; Adds state traces\n├─&gt; Adds control traces\n└─&gt; Returns: go.Figure\n\nplot_comparison(results, state_names, color_scheme, theme)\n├─&gt; Iterates over results dict\n├─&gt; Adds trace for each result\n│   └─&gt; Different color per result\n├─&gt; Creates legend\n└─&gt; Returns: go.Figure\n\nInternal Methods\n├─&gt; _to_numpy(arr) → np.ndarray\n│   ├─ PyTorch: arr.cpu().numpy()\n│   ├─ JAX: np.array(arr)\n│   └─ NumPy: arr\n│\n└─&gt; _determine_subplot_layout(n_plots) → (rows, cols)\n    ├─ 1-2 plots: (n, 1)\n    ├─ 3-4 plots: (2, 2)\n    └─ 5+ plots: optimal grid\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ PLOTTER LAYER: PhasePortraitPlotter (1027 lines)                ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nPhasePortraitPlotter.__init__(backend, theme)\n├─&gt; self.backend = backend\n└─&gt; self.default_theme = theme\n\nplot_2d(x, state_indices, state_names, vector_field, equilibria, ...)\n├─&gt; Extracts relevant states\n│   └─&gt; x[:, state_indices]\n├─&gt; Creates main trajectory trace\n│   └─&gt; go.Scatter(x=x₁, y=x₂, mode='lines')\n├─&gt; Optional: Add vector field\n│   ├─&gt; Creates meshgrid\n│   ├─&gt; Evaluates dynamics at grid points\n│   └─&gt; Adds quiver plot (arrows)\n├─&gt; Optional: Add equilibria\n│   └─&gt; go.Scatter(x, y, mode='markers', marker_size=12)\n├─&gt; Optional: Add direction arrows\n│   └─&gt; Annotations with arrows along trajectory\n└─&gt; Returns: go.Figure\n\nplot_3d(x, state_indices, state_names, equilibria, ...)\n├─&gt; Creates 3D scatter trace\n│   └─&gt; go.Scatter3d(x=x₁, y=x₂, z=x₃, mode='lines')\n├─&gt; Optional: Add equilibria\n│   └─&gt; go.Scatter3d (markers)\n├─&gt; Sets 3D layout\n│   ├─&gt; scene.xaxis.title\n│   ├─&gt; scene.yaxis.title\n│   └─&gt; scene.zaxis.title\n└─&gt; Returns: go.Figure\n\nplot_limit_cycle(x, state_indices, highlight_period, ...)\n├─&gt; Plots trajectory\n├─&gt; Optional: Highlights one period\n│   └─&gt; Different color/style for [0, T_period]\n├─&gt; Adds limit cycle annotation\n└─&gt; Returns: go.Figure\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ PLOTTER LAYER: ControlPlotter (1858 lines)                      ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nControlPlotter.__init__(backend, theme)\n├─&gt; self.backend = backend\n└─&gt; self.default_theme = theme\n\nStability Analysis Plots\n├─&gt; plot_eigenvalue_map(eigenvalues, system_type, ...)\n│   ├─&gt; Continuous: Plots Re(λ) vs Im(λ)\n│   │   ├─&gt; Shades left half-plane (stable region)\n│   │   └─&gt; Adds imaginary axis line\n│   └─&gt; Discrete: Plots complex plane\n│       ├─&gt; Draws unit circle\n│       └─&gt; Shades interior (stable region)\n│\n└─&gt; plot_root_locus(pole_paths, gains, system_type, ...)\n    ├─&gt; Plots pole trajectories vs gain\n    ├─&gt; Shows stability boundary\n    └─&gt; Annotates gain values\n\nDesign Comparison Plots\n├─&gt; plot_gain_comparison(gains, ...)\n│   ├─&gt; Creates heatmap\n│   │   └─&gt; go.Heatmap(z=gain_matrix)\n│   └─&gt; Annotates with values\n│\n└─&gt; plot_riccati_convergence(P_history, ...)\n    ├─&gt; Computes Frobenius norm for each P\n    ├─&gt; Plots norm vs iteration\n    └─&gt; Shows convergence threshold\n\nGramian Analysis Plots\n├─&gt; plot_controllability_gramian(W_c, state_names, ...)\n│   ├─&gt; Creates heatmap of W_c\n│   └─&gt; Annotates diagonal (controllability)\n│\n└─&gt; plot_observability_gramian(W_o, state_names, ...)\n    ├─&gt; Creates heatmap of W_o\n    └─&gt; Annotates diagonal (observability)\n\nTime Response Plots\n├─&gt; plot_step_response(t, y, show_metrics, ...)\n│   ├─&gt; Plots step response\n│   ├─&gt; Computes metrics:\n│   │   ├─ Rise time (10% → 90%)\n│   │   ├─ Settling time (±2% band)\n│   │   ├─ Overshoot (%)\n│   │   └─ Steady-state error\n│   └─&gt; Annotates metrics on plot\n│\n└─&gt; plot_impulse_response(t, y, show_decay, ...)\n    ├─&gt; Plots impulse response\n    ├─&gt; Optional: Exponential decay envelope\n    └─&gt; Annotates decay rate\n\nFrequency Analysis Plots\n├─&gt; plot_frequency_response(omega, mag_db, phase_deg, ...)\n│   ├─&gt; Creates 2-subplot figure\n│   │   ├─ Top: Magnitude (dB) vs ω\n│   │   └─ Bottom: Phase (deg) vs ω\n│   ├─&gt; Semilog x-axis\n│   └─&gt; Optional: Gain/phase margins\n│\n└─&gt; plot_nyquist(real, imag, show_unit_circle, ...)\n    ├─&gt; Plots Nyquist diagram\n    ├─&gt; Shows critical point (-1, 0)\n    ├─&gt; Optional: Unit circle\n    └─&gt; Annotates encirclements\n\n\n═══════════════════════════════════════════════════════════════════════\n                        INTEGRATION WITH SYSTEMS\n═══════════════════════════════════════════════════════════════════════\n\nContinuousSystemBase / DiscreteSystemBase\n│\n├─&gt; @property plotter(self) → TrajectoryPlotter\n│   └─&gt; if not hasattr(self, '_trajectory_plotter'):\n│       └─&gt; self._trajectory_plotter = TrajectoryPlotter(\n│               backend=self._default_backend,\n│               theme='default'\n│           )\n│   └─&gt; return self._trajectory_plotter\n│\n├─&gt; @property phase_plotter(self) → PhasePortraitPlotter\n│   └─&gt; if not hasattr(self, '_phase_portrait_plotter'):\n│       └─&gt; self._phase_portrait_plotter = PhasePortraitPlotter(\n│               backend=self._default_backend,\n│               theme='default'\n│           )\n│   └─&gt; return self._phase_portrait_plotter\n│\n└─&gt; @property control_plotter(self) → ControlPlotter\n    └─&gt; if not hasattr(self, '_control_plotter'):\n        └─&gt; self._control_plotter = ControlPlotter(\n                backend=self._default_backend,\n                theme='default'\n            )\n    └─&gt; return self._control_plotter\n\nUsage Example:\n    system = Pendulum()\n    system.set_default_backend('numpy')\n    \n    # Via system properties\n    result = system.integrate(x0, u=None, t_span=(0, 10))\n    \n    fig = system.plotter.plot_trajectory(result['t'], result['x'])\n    # ↑ Uses TrajectoryPlotter with 'numpy' backend\n    \n    fig = system.phase_plotter.plot_2d(result['x'])\n    # ↑ Uses PhasePortraitPlotter with 'numpy' backend\n\n\n═══════════════════════════════════════════════════════════════════════\n                        PLOTTING WORKFLOW\n═══════════════════════════════════════════════════════════════════════\n\nTypical Workflow:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. User calls: system.plotter.plot_trajectory(t, x)            │\n│    ↓                                                             │\n│ 2. TrajectoryPlotter receives backend='numpy' from system      │\n│    ↓                                                             │\n│ 3. Plotter detects data shape                                  │\n│    ├─ (T, nx): Single trajectory                               │\n│    └─ (n_batch, T, nx): Batched → compute mean, std            │\n│    ↓                                                             │\n│ 4. Convert backend to NumPy (Plotly requirement)               │\n│    ├─ PyTorch: arr.cpu().numpy()                               │\n│    ├─ JAX: np.array(arr)                                       │\n│    └─ NumPy: as-is                                             │\n│    ↓                                                             │\n│ 5. Determine optimal subplot layout                            │\n│    └─&gt; _determine_subplot_layout(nx) → (rows, cols)            │\n│    ↓                                                             │\n│ 6. Create Plotly figure with subplots                          │\n│    └─&gt; make_subplots(rows, cols)                               │\n│    ↓                                                             │\n│ 7. Get colors from ColorSchemes                                │\n│    └─&gt; ColorSchemes.get_colors(color_scheme, nx)               │\n│    ↓                                                             │\n│ 8. Add traces for each state                                   │\n│    ├─ Mean line (or single trajectory)                         │\n│    └─ Std bands (if batched)                                   │\n│    ↓                                                             │\n│ 9. Apply theme                                                  │\n│    └─&gt; PlotThemes.apply_theme(fig, theme)                      │\n│    ↓                                                             │\n│ 10. Return interactive Plotly figure                           │\n└─────────────────────────────────────────────────────────────────┘\n\nPhase Portrait Workflow:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. User calls: system.phase_plotter.plot_2d(x)                 │\n│    ↓                                                             │\n│ 2. Extract relevant states: x[:, state_indices]                │\n│    ↓                                                             │\n│ 3. Create main trajectory trace                                │\n│    └─&gt; go.Scatter(x=x₁, y=x₂, mode='lines')                    │\n│    ↓                                                             │\n│ 4. Optional: Add vector field                                  │\n│    ├─&gt; Create meshgrid of state space                          │\n│    ├─&gt; Evaluate dynamics at each point                         │\n│    └─&gt; Add quiver plot (arrows)                                │\n│    ↓                                                             │\n│ 5. Optional: Add equilibrium points                            │\n│    └─&gt; go.Scatter with markers                                 │\n│    ↓                                                             │\n│ 6. Optional: Add direction arrows                              │\n│    └─&gt; Annotations along trajectory                            │\n│    ↓                                                             │\n│ 7. Apply theme and return                                      │\n└─────────────────────────────────────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        FILE SIZE SUMMARY\n═══════════════════════════════════════════════════════════════════════\n\n┌──────────────────────────────┬────────┬──────────────────────────┐\n│ Module                       │ Lines  │ Purpose                  │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ THEMING LAYER                │        │                          │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ themes.py                    │   623  │ Colors and styles        │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ PLOTTER LAYER                │        │                          │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ trajectory_plotter.py        │   914  │ Time-domain plots        │\n│ phase_portrait.py            │ 1,027  │ State space plots        │\n│ control_plots.py             │ 1,858  │ Control analysis plots   │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ TOTAL                        │ 4,422  │ Complete framework       │\n└──────────────────────────────┴────────┴──────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        DESIGN PHILOSOPHY\n═══════════════════════════════════════════════════════════════════════\n\n✓ CENTRALIZED THEMING\n  Single source of truth for colors and styles\n  Easy to maintain consistency\n\n✓ BACKEND AGNOSTIC\n  NumPy/PyTorch/JAX handled transparently\n  Automatic conversion for Plotly\n\n✓ INTERACTIVE\n  Plotly-based plots with zoom, pan, hover\n  Rich user experience\n\n✓ PUBLICATION READY\n  Professional themes and color schemes\n  Export to PDF, PNG, HTML\n\n✓ ACCESSIBLE\n  Colorblind-safe palettes (Wong palette)\n  WCAG compliance\n\n✓ SPECIALIZED PLOTTERS\n  Dedicated class for each visualization type\n  Right tool for the job\n\n✓ SYSTEM INTEGRATION\n  Clean system.plotter properties\n  Automatic backend inheritance\n\n✓ ADAPTIVE LAYOUTS\n  Optimal subplot arrangements\n  Smart defaults\n\n✓ BATCH SUPPORT\n  Monte Carlo visualization automatic\n  Mean ± std bands\n\n✓ COMPREHENSIVE\n  16 plot types covering all needs\n  Time, frequency, state space\n\n\n═══════════════════════════════════════════════════════════════════════\n                        PLOT TYPE SUMMARY\n═══════════════════════════════════════════════════════════════════════\n\nTime-Domain Plots (TrajectoryPlotter)\n  ├─ plot_trajectory()           → State vs time\n  ├─ plot_state_and_control()    → Combined state + control\n  └─ plot_comparison()           → Multiple simulation runs\n\nState-Space Plots (PhasePortraitPlotter)\n  ├─ plot_2d()                   → 2D phase portrait\n  ├─ plot_3d()                   → 3D phase portrait\n  └─ plot_limit_cycle()          → Periodic orbits\n\nControl Analysis (ControlPlotter)\n  ├─ Stability:\n  │  ├─ plot_eigenvalue_map()    → Pole locations\n  │  └─ plot_root_locus()        → Pole migration vs gain\n  ├─ Design:\n  │  ├─ plot_gain_comparison()   → Compare feedback gains\n  │  └─ plot_riccati_convergence() → Solver convergence\n  ├─ Gramians:\n  │  ├─ plot_controllability_gramian() → W_c heatmap\n  │  └─ plot_observability_gramian()   → W_o heatmap\n  ├─ Time Response:\n  │  ├─ plot_step_response()     → Step with metrics\n  │  └─ plot_impulse_response()  → Impulse with decay\n  └─ Frequency:\n     ├─ plot_frequency_response() → Bode plots\n     └─ plot_nyquist()           → Nyquist diagram\n\nTotal: 16 plot types\n\n\n═══════════════════════════════════════════════════════════════════════\n                        COLOR SCHEME REFERENCE\n═══════════════════════════════════════════════════════════════════════\n\nCategorical Schemes (for distinct items):\n  PLOTLY           → 10 colors, default Plotly palette\n  D3               → 10 colors, D3.js standard\n  COLORBLIND_SAFE  → 8 colors, Wong palette (accessible)\n  TABLEAU          → 10 colors, Tableau default\n\nSequential Schemes (for heatmaps):\n  SEQUENTIAL_BLUE  → 9 colors, light → dark blue\n  SEQUENTIAL_GREEN → 9 colors, light → dark green\n\nDiverging Schemes (for signed data):\n  DIVERGING_RED_BLUE      → 11 colors, red ← white → blue\n  DIVERGING_PURPLE_GREEN  → 11 colors, purple ← white → green\n\n\n═══════════════════════════════════════════════════════════════════════\n                        THEME REFERENCE\n═══════════════════════════════════════════════════════════════════════\n\nDEFAULT Theme:\n  Background:   White (#FFF)\n  Font:         Arial, sans-serif, 12pt\n  Grid:         Light gray (#EEE)\n  Template:     'plotly'\n  Use case:     Interactive exploration, web displays\n\nPUBLICATION Theme:\n  Background:   White (#FFF)\n  Font:         Times New Roman, serif, 14pt\n  Grid:         Medium gray (#CCC)\n  Template:     'simple_white'\n  Lines:        Thicker, more contrast\n  Use case:     Papers, formal presentations\n\nDARK Theme:\n  Background:   Dark gray (#111)\n  Plot area:    Slightly lighter (#1E1E1E)\n  Font:         Arial, sans-serif, 12pt\n  Grid:         Dark lines (#444)\n  Template:     'plotly_dark'\n  Use case:     Dark mode, presentations on dark backgrounds\n\n\n═══════════════════════════════════════════════════════════════════════\n\n\nTotal Lines: 4,422 (framework)\nArchitecture: Centralized theming + specialized plotters\nPlot Types: 16 total (3 time-domain, 3 state-space, 10 control)\nColor Schemes: 8 predefined (categorical, sequential, diverging)\nThemes: 3 complete themes (default, publication, dark)\nIntegration: Via system.plotter, system.phase_plotter, system.control_plotter\nPhilosophy: Interactive, accessible, publication-ready visualization\nResult: Comprehensive plotting framework for dynamical systems analysis!"
  },
  {
    "objectID": "api/visualization_framework/visualization_framework_text.html#summary",
    "href": "api/visualization_framework/visualization_framework_text.html#summary",
    "title": "Visualization Framework Architecture (Text Diagram)",
    "section": "",
    "text": "Total Lines: 4,422 (framework)\nArchitecture: Centralized theming + specialized plotters\nPlot Types: 16 total (3 time-domain, 3 state-space, 10 control)\nColor Schemes: 8 predefined (categorical, sequential, diverging)\nThemes: 3 complete themes (default, publication, dark)\nIntegration: Via system.plotter, system.phase_plotter, system.control_plotter\nPhilosophy: Interactive, accessible, publication-ready visualization\nResult: Comprehensive plotting framework for dynamical systems analysis!"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html",
    "href": "api/integration_framework/Integration_Framework_Architecture.html",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "The numerical integration framework provides multi-backend, multi-method support for integrating both deterministic ODEs and stochastic SDEs. The framework consists of 13 core files organized into a clean 2-track architecture: deterministic and stochastic.\n\n\n\nTrack 1: Deterministic ODE Integration\n├── IntegratorBase (abstract)\n├── IntegratorFactory (creates integrators)\n├── Backend-Specific Implementations:\n│   ├── ScipyIntegrator (NumPy)\n│   ├── TorchDiffEqIntegrator (PyTorch)\n│   ├── DiffraxIntegrator (JAX)\n│   └── DiffEqPyIntegrator (Julia)\n└── FixedStepIntegrators (RK4, Euler, Midpoint)\n\nTrack 2: Stochastic SDE Integration\n├── SDEIntegratorBase (extends IntegratorBase)\n├── SDEIntegratorFactory (creates SDE integrators)\n├── Backend-Specific Implementations:\n│   ├── TorchSDEIntegrator (PyTorch)\n│   ├── DiffraxSDEIntegrator (JAX)\n│   └── DiffEqPySDEIntegrator (Julia)\n└── CustomBrownianPath (custom noise support)\n\n\n\n\n\n\n\nFile: integrator_base.py (512 lines)\nPurpose: Abstract base class for all numerical integrators\nKey Features:\n\nDefines unified interface for all integrators\nStepMode enum (FIXED vs ADAPTIVE)\nPerformance statistics tracking\nTypedDict-based IntegrationResult\n\nAbstract Methods:\n- step(x, u, dt) → x_next          # Single integration step\n- integrate(x0, u_func, t_span) → IntegrationResult  # Multi-step\n- name: str                         # Integrator identifier\nAttributes:\n- system: ContinuousSystemBase     # System to integrate\n- dt: float                        # Time step (or initial guess)\n- step_mode: StepMode              # FIXED or ADAPTIVE\n- backend: Backend                 # 'numpy', 'torch', 'jax'\n- rtol, atol: float                # Error tolerances (adaptive)\n- _stats: dict                     # Performance tracking\n\n\n\n\nFile: integrator_factory.py (1,267 lines)\nPurpose: Factory for creating appropriate integrators\nKey Features:\n\nAutomatic backend/method selection\nMethod-to-backend routing\nUse case-specific helpers\nComprehensive method registry\n\nAvailable Backends: - NumPy: scipy, DiffEqPy (Julia), manual methods - PyTorch: torchdiffeq - JAX: diffrax\nFactory Methods:\n# Main creation\ncreate(system, backend, method, dt, **options) → IntegratorBase\n\n# Convenience methods\nauto(system, backend=None) → IntegratorBase           # Best for backend\nfor_production(system) → IntegratorBase               # LSODA or AutoTsit5\nfor_optimization(system) → IntegratorBase             # Diffrax tsit5\nfor_neural_ode(system) → IntegratorBase              # TorchDiffEq dopri5\nfor_julia(system, algorithm='Tsit5') → IntegratorBase # Julia solver\n\n# Backend-specific\nscipy(system, method='RK45', **opts) → ScipyIntegrator\njulia(system, algorithm='Tsit5', **opts) → DiffEqPyIntegrator\ntorch(system, method='dopri5', **opts) → TorchDiffEqIntegrator\njax(system, method='tsit5', **opts) → DiffraxIntegrator\nMethod Registry:\n\n\n\nMethod\nBackend\nType\nBest For\n\n\n\n\nLSODA\nNumPy (scipy)\nAdaptive\nGeneral (auto-stiffness)\n\n\nRK45\nNumPy (scipy)\nAdaptive\nNon-stiff ODEs\n\n\nRadau\nNumPy (scipy)\nAdaptive\nStiff ODEs\n\n\nBDF\nNumPy (scipy)\nAdaptive\nVery stiff ODEs\n\n\nTsit5\nNumPy (Julia)\nAdaptive\nHigh performance\n\n\nVern9\nNumPy (Julia)\nAdaptive\nHigh accuracy\n\n\nRodas5\nNumPy (Julia)\nAdaptive\nStiff (Rosenbrock)\n\n\ndopri5\nPyTorch/JAX\nAdaptive\nNeural ODEs\n\n\ndopri8\nPyTorch/JAX\nAdaptive\nHigh accuracy\n\n\ntsit5\nJAX (diffrax)\nAdaptive\nOptimization\n\n\neuler\nAny\nFixed\nEducational\n\n\nrk4\nAny\nFixed\nSimple systems\n\n\n\n\n\n\n\nFile: `scipy_integrator.py** (~620 lines estimate)\nPurpose: Adaptive integration using scipy.integrate.solve_ivp\nSupported Methods:\n\nRK45 (default): Dormand-Prince 5(4) - general purpose\nRK23: Bogacki-Shampine 3(2) - fast, low accuracy\nDOP853: Dormand-Prince 8(5,3) - high accuracy\nRadau: Implicit RK - stiff systems\nBDF: Backward differentiation - very stiff\nLSODA: Auto stiffness detection\n\nKey Features:\n\nProfessional-grade adaptive stepping\nError control (rtol/atol)\nDense output (interpolation)\nEvent detection\nBoth controlled and autonomous systems\n\nExample:\nintegrator = ScipyIntegrator(\n    system,\n    method='RK45',\n    rtol=1e-6,\n    atol=1e-8\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: torchdiffeq_integrator.py (estimated ~800 lines)\nPurpose: PyTorch integration with GPU acceleration and autograd\nSupported Methods:\n\ndopri5: Dormand-Prince 5(4)\ndopri8: Dormand-Prince 8\nadaptive_heun: Heun’s method\nbosh3: Bogacki-Shampine 3\nfehlberg2: Fehlberg 2(1)\nexplicit_adams, implicit_adams: Multi-step methods\n\nKey Features:\n\nGPU acceleration\nAutomatic differentiation\nAdjoint method for memory efficiency\nNeural ODE support\n\nExample:\nintegrator = TorchDiffEqIntegrator(\n    system,\n    method='dopri5',\n    backend='torch',\n    device='cuda:0'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffrax_integrator.py (estimated ~700 lines)\nPurpose: JAX integration with XLA compilation and autograd\nSupported Methods:\n\ntsit5: Tsitouras 5(4) - recommended\ndopri5: Dormand-Prince 5(4)\ndopri8: Dormand-Prince 8\nheun: Heun’s method\nralston: Ralston’s method\nreversible_heun: Reversible Heun\n\nKey Features:\n\nXLA compilation\nJAX transformations (jit, vmap, grad)\nEfficient for optimization\nFunctional programming style\n\nExample:\nintegrator = DiffraxIntegrator(\n    system,\n    method='tsit5',\n    backend='jax'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffeqpy_integrator.py (estimated ~900 lines)\nPurpose: Julia’s DifferentialEquations.jl via Python bindings\nSupported Methods:\nExtensive Julia solver ecosystem: - Explicit RK: Tsit5, Vern6, Vern7, Vern8, Vern9, DP5, DP8 - Rosenbrock: Rosenbrock23, Rosenbrock32, Rodas4, Rodas5 - BDF: TRBDF2, KenCarp3, KenCarp4, KenCarp5 - Radau: RadauIIA5 - Stabilized: ROCK2, ROCK4 - Symplectic: VelocityVerlet, SymplecticEuler - Auto-switching: AutoTsit5(Rosenbrock23()), AutoVern7(Rodas5())\nKey Features:\n\nHighest performance\nAutomatic stiffness detection\nExtensive method library\nProduction-grade reliability\n\nExample:\nintegrator = DiffEqPyIntegrator(\n    system,\n    algorithm='Vern9',\n    backend='numpy',\n    reltol=1e-12,\n    abstol=1e-14\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: fixed_step_integrators.py (estimated ~600 lines)\nPurpose: Manual implementation of fixed-step methods\nSupported Methods:\n\neuler: Forward Euler (order 1)\nmidpoint: Midpoint method (order 2)\nrk4: Runge-Kutta 4 (order 4)\n\nKey Features:\n\nBackend-agnostic (NumPy, PyTorch, JAX)\nSimple, transparent implementations\nEducational value\nConstant time step\n\nExample:\nintegrator = RK4Integrator(\n    system,\n    dt=0.01,\n    backend='numpy'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\n\n\n\nFile: sde_integrator_base.py (1,080 lines)\nPurpose: Abstract base for SDE integrators\nMathematical Form:\ndx = f(x, u, t)dt + g(x, u, t)dW\nwhere: - f: Drift (deterministic) - g: Diffusion (stochastic intensity) - dW: Brownian motion increments\nKey Differences from ODE:\n\nRandom noise generation\nWeak vs strong convergence\nNoise structure exploitation\nMonte Carlo simulation support\nItô vs Stratonovich interpretation\n\nAbstract Methods:\n- step(x, u, dt, dW) → x_next      # Single SDE step with noise\n- integrate(x0, u_func, t_span) → SDEIntegrationResult\n- integrate_monte_carlo(x0, u_func, t_span, n_paths) → SDEIntegrationResult\nResult Type:\nSDEIntegrationResult = {\n    't': TimePoints,               # Time grid\n    'x': StateVector,              # Trajectory (T, nx) or (n_paths, T, nx)\n    'success': bool,\n    'message': str,\n    'nfev': int,                   # Drift evaluations\n    'diffusion_evals': int,        # Diffusion evaluations\n    'noise_samples': NoiseVector,  # Brownian increments\n    'n_paths': int,                # Number of trajectories\n    'convergence_type': str,       # 'strong' or 'weak'\n    'sde_type': str,               # 'ito' or 'stratonovich'\n    ...\n}\n\n\n\n\nFile: sde_integrator_factory.py (estimated ~1,000 lines)\nPurpose: Factory for creating SDE integrators\nFactory Methods:\ncreate(sde_system, backend, method, dt, **options) → SDEIntegratorBase\nauto(sde_system, backend=None) → SDEIntegratorBase\nfor_monte_carlo(sde_system, n_paths) → SDEIntegratorBase\nAvailable Methods:\n\n\n\nMethod\nBackend\nConvergence\nNoise Type\n\n\n\n\neuler-maruyama\nNumPy/PyTorch/JAX\nStrong (0.5)\nGeneral\n\n\nmilstein\nNumPy\nStrong (1.0)\nDiagonal\n\n\nheun\nPyTorch/JAX\nStrong (1.0)\nAdditive\n\n\nsrk\nPyTorch\nStrong\nGeneral\n\n\nreversible_heun\nPyTorch\nStrong\nAdditive\n\n\n\n\n\n\n\nFile: torchsde_integrator.py (estimated ~800 lines)\nPurpose: PyTorch SDE integration with torchsde\nSupported Methods:\n\neuler: Euler-Maruyama (strong order 0.5)\nheun: Heun’s method (strong order 1.0 for additive)\nsrk: Stochastic Runge-Kutta\nreversible_heun: Reversible Heun (strong order 1.0)\n\nKey Features:\n\nGPU acceleration\nAdaptive stepping\nNoise structure exploitation\nAdjoint method for gradients\n\nExample:\nintegrator = TorchSDEIntegrator(\n    sde_system,\n    method='heun',\n    dt=0.01,\n    backend='torch'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffrax_sde_integrator.py (estimated ~750 lines)\nPurpose: JAX SDE integration with diffrax\nSupported Methods:\n\neuler: Euler-Maruyama\nheun: Heun’s method\nreversible_heun: Reversible Heun\n\nKey Features:\n\nJAX transformations\nXLA compilation\nCustom noise support\nEfficient for optimization\n\nExample:\nintegrator = DiffraxSDEIntegrator(\n    sde_system,\n    method='euler',\n    dt=0.01,\n    backend='jax',\n    seed=42\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffeqpy_sde_integrator.py (estimated ~850 lines)\nPurpose: Julia SDE solvers via DiffEqPy\nSupported Methods:\n\nEuler-Maruyama variants\nMilstein\nStochastic Rosenbrock\nAdvanced Julia SDE methods\n\nKey Features:\n\nProduction-grade SDE solvers\nAutomatic noise structure detection\nHigh-performance algorithms\n\n\n\n\n\nFile: custom_brownian.py (160 lines)\nPurpose: Custom Brownian motion for deterministic testing\nKey Features:\n\nUser-provided noise increments\nDiffrax AbstractPath interface\nDeterministic testing support\nCustom noise patterns\n\nExample:\n# Zero noise for testing\ndW = jnp.zeros(1)\nbrownian = CustomBrownianPath(0.0, 0.01, dW)\n\n# Or random noise\nbrownian = create_custom_or_random_brownian(\n    key, 0.0, 0.01, shape=(nw,), dW=None\n)\n\n\n\n\n\n\n\n\nAll integrators work across backends:\n\nNumPy: CPU, scipy, Julia integration\nPyTorch: GPU, autograd, neural ODEs\nJAX: XLA, functional, optimization\n\n\n\n\nIntegratorFactory and SDEIntegratorFactory provide:\n\nAutomatic method selection\nBackend-specific routing\nConvenience constructors\nUse case optimization\n\n\n\n\nAll integrators return TypedDict results:\n\nIntegrationResult for ODEs\nSDEIntegrationResult for SDEs\nConsistent fields across backends\nOptional fields for extra diagnostics\n\n\n\n\n\nIntegrators compose with systems\nNo deep inheritance hierarchies\nClear separation of concerns\nEasy to extend\n\n\n\n\nBuilt-in statistics:\nintegrator._stats = {\n    'total_fev': int,      # Function evaluations\n    'total_steps': int,    # Integration steps\n    'total_time': float,   # Computation time\n}\n\n\n\n\n\n\n{\n    't': array,              # Time points (T,)\n    'x': array,              # States (T, nx) - time-major\n    'success': bool,         # Integration succeeded\n    'message': str,          # Status message\n    'nfev': int,             # Function evaluations\n    'nsteps': int,           # Steps taken\n    'integration_time': float,  # Wall time (seconds)\n    'solver': str,           # Integrator name\n    \n    # Optional (adaptive methods):\n    'njev': int,             # Jacobian evaluations\n    'nlu': int,              # LU decompositions\n    'status': int,           # Solver status code\n    'sol': object,           # Dense output (if requested)\n    'dense_output': bool,    # Dense output available\n}\n\n\n\n{\n    # All IntegrationResult fields, plus:\n    'diffusion_evals': int,     # Diffusion function calls\n    'noise_samples': array,     # Brownian increments used\n    'n_paths': int,             # Number of trajectories\n    'convergence_type': str,    # 'strong' or 'weak'\n    'sde_type': str,            # 'ito' or 'stratonovich'\n    'noise_type': str,          # 'additive', 'multiplicative', etc.\n    \n    # For Monte Carlo (n_paths &gt; 1):\n    'x': array,                 # (n_paths, T, nx)\n    'statistics': dict,         # mean, std, quantiles\n}\n\n\n\n\n\n\nfrom src.systems.base import ContinuousSymbolicSystem\nfrom src.systems.base.numerical_integration import IntegratorFactory\nimport numpy as np\n\n# Create system (e.g., pendulum)\nsystem = Pendulum(m=1.0, l=0.5)\n\n# Create integrator automatically\nintegrator = IntegratorFactory.auto(system)\n\n# Integrate\nresult = integrator.integrate(\n    x0=np.array([0.1, 0.0]),\n    u_func=lambda t, x: np.zeros(1),\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\nprint(f\"Success: {result['success']}\")\n\n\n\nimport torch\nfrom src.systems.base.numerical_integration import IntegratorFactory\n\n# Create system and move to GPU\nsystem = MyNeuralODE()\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# Create Neural ODE integrator\nintegrator = IntegratorFactory.for_neural_ode(system)\n\n# Integrate on GPU\nx0 = torch.tensor([[1.0, 0.0]], device='cuda:0')\nresult = integrator.integrate(\n    x0=x0,\n    u_func=lambda t, x: torch.zeros(1, device='cuda:0'),\n    t_span=(0.0, 10.0)\n)\n\n\n\nfrom src.systems.base.numerical_integration import IntegratorFactory\n\n# Create Julia integrator with high accuracy\nintegrator = IntegratorFactory.for_julia(\n    system,\n    algorithm='Vern9',  # 9th order\n    reltol=1e-12,\n    abstol=1e-14\n)\n\nresult = integrator.integrate(x0, u_func, t_span=(0, 100))\nprint(f\"Accurate to {result['nfev']} function evaluations\")\n\n\n\nfrom src.systems.base import ContinuousStochasticSystem\nfrom src.systems.base.numerical_integration.stochastic import SDEIntegratorFactory\n\n# Create SDE system (e.g., Ornstein-Uhlenbeck)\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\n# Create SDE integrator\nintegrator = SDEIntegratorFactory.create(\n    sde_system,\n    backend='torch',\n    method='heun',\n    dt=0.01,\n    seed=42\n)\n\n# Single trajectory\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\nprint(f\"Noise type: {result['noise_type']}\")\nprint(f\"SDE type: {result['sde_type']}\")\n\n\n\n# Multiple trajectories for uncertainty quantification\nresult = integrator.integrate_monte_carlo(\n    x0=np.array([1.0]),\n    u_func=lambda t, x: None,\n    t_span=(0, 10),\n    n_paths=1000\n)\n\n# Get statistics\nfrom src.systems.base.numerical_integration.sde_integrator_base import (\n    get_trajectory_statistics\n)\nstats = get_trajectory_statistics(result)\n\nprint(f\"Mean at t=10: {stats['mean'][-1]}\")\nprint(f\"Std at t=10: {stats['std'][-1]}\")\nprint(f\"95% CI: [{stats['q25'][-1]}, {stats['q75'][-1]}]\")\n\n\n\nimport jax.numpy as jnp\nfrom src.systems.base.numerical_integration.stochastic.custom_brownian import (\n    CustomBrownianPath\n)\n\n# Zero noise for deterministic testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(0.0, 0.01, dW)\n\n# Use in integration\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 1),\n    brownian_path=brownian\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse Case\nRecommended Integrator\nReason\n\n\n\n\nGeneral ODE\nIntegratorFactory.for_production(system)\nLSODA auto-stiffness\n\n\nNeural ODE\nIntegratorFactory.for_neural_ode(system)\nTorchDiffEq adjoint\n\n\nOptimization\nIntegratorFactory.for_optimization(system)\nDiffrax JAX\n\n\nHigh Accuracy\nIntegratorFactory.for_julia(system, 'Vern9')\nJulia 9th order\n\n\nStiff ODE\nScipyIntegrator(system, method='BDF')\nImplicit BDF\n\n\nSimple ODE\nRK4Integrator(system, dt=0.01)\nClassic RK4\n\n\nSDE (general)\nSDEIntegratorFactory.auto(sde_system)\nBest for noise type\n\n\nMonte Carlo\nSDEIntegratorFactory.for_monte_carlo(...)\nParallelized\n\n\n\n\n\n\n\n\n\nBackend\nODE Integrator\nSDE Integrator\n\n\n\n\nNumPy\nScipyIntegrator, DiffEqPyIntegrator\n(limited support)\n\n\nPyTorch\nTorchDiffEqIntegrator\nTorchSDEIntegrator\n\n\nJAX\nDiffraxIntegrator\nDiffraxSDEIntegrator\n\n\n\n\n\n\n\n\n\nSystem Type\nBest Integrator\n\n\n\n\nNon-stiff\nRK45, Tsit5, dopri5\n\n\nStiff\nBDF, Radau, Rodas5\n\n\nHigh accuracy\nVern9, DOP853\n\n\nReal-time\nRK4, euler (fixed-step)\n\n\nAdditive noise SDE\nHeun (strong order 1.0)\n\n\nGeneral SDE\nEuler-Maruyama\n\n\n\n\n\n\n\n\nMulti-Backend Support - Seamless NumPy/PyTorch/JAX switching\nExtensive Method Library - 40+ integration methods\nFactory Pattern - Automatic method selection\nType Safety - TypedDict results with IDE support\nPerformance - GPU acceleration, XLA compilation, Julia performance\nFlexibility - Fixed and adaptive stepping\nStochastic Support - Full SDE integration framework\nNoise Structure - Exploits additive/diagonal/scalar noise\nMonte Carlo - Built-in multi-trajectory simulation\nTesting - Custom noise for deterministic testing\n\nThis framework enables state-of-the-art numerical integration for control theory and machine learning applications!"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#overview",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#overview",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "The numerical integration framework provides multi-backend, multi-method support for integrating both deterministic ODEs and stochastic SDEs. The framework consists of 13 core files organized into a clean 2-track architecture: deterministic and stochastic."
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#architecture-tracks",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#architecture-tracks",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "Track 1: Deterministic ODE Integration\n├── IntegratorBase (abstract)\n├── IntegratorFactory (creates integrators)\n├── Backend-Specific Implementations:\n│   ├── ScipyIntegrator (NumPy)\n│   ├── TorchDiffEqIntegrator (PyTorch)\n│   ├── DiffraxIntegrator (JAX)\n│   └── DiffEqPyIntegrator (Julia)\n└── FixedStepIntegrators (RK4, Euler, Midpoint)\n\nTrack 2: Stochastic SDE Integration\n├── SDEIntegratorBase (extends IntegratorBase)\n├── SDEIntegratorFactory (creates SDE integrators)\n├── Backend-Specific Implementations:\n│   ├── TorchSDEIntegrator (PyTorch)\n│   ├── DiffraxSDEIntegrator (JAX)\n│   └── DiffEqPySDEIntegrator (Julia)\n└── CustomBrownianPath (custom noise support)"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#file-breakdown",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#file-breakdown",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "File: integrator_base.py (512 lines)\nPurpose: Abstract base class for all numerical integrators\nKey Features:\n\nDefines unified interface for all integrators\nStepMode enum (FIXED vs ADAPTIVE)\nPerformance statistics tracking\nTypedDict-based IntegrationResult\n\nAbstract Methods:\n- step(x, u, dt) → x_next          # Single integration step\n- integrate(x0, u_func, t_span) → IntegrationResult  # Multi-step\n- name: str                         # Integrator identifier\nAttributes:\n- system: ContinuousSystemBase     # System to integrate\n- dt: float                        # Time step (or initial guess)\n- step_mode: StepMode              # FIXED or ADAPTIVE\n- backend: Backend                 # 'numpy', 'torch', 'jax'\n- rtol, atol: float                # Error tolerances (adaptive)\n- _stats: dict                     # Performance tracking\n\n\n\n\nFile: integrator_factory.py (1,267 lines)\nPurpose: Factory for creating appropriate integrators\nKey Features:\n\nAutomatic backend/method selection\nMethod-to-backend routing\nUse case-specific helpers\nComprehensive method registry\n\nAvailable Backends: - NumPy: scipy, DiffEqPy (Julia), manual methods - PyTorch: torchdiffeq - JAX: diffrax\nFactory Methods:\n# Main creation\ncreate(system, backend, method, dt, **options) → IntegratorBase\n\n# Convenience methods\nauto(system, backend=None) → IntegratorBase           # Best for backend\nfor_production(system) → IntegratorBase               # LSODA or AutoTsit5\nfor_optimization(system) → IntegratorBase             # Diffrax tsit5\nfor_neural_ode(system) → IntegratorBase              # TorchDiffEq dopri5\nfor_julia(system, algorithm='Tsit5') → IntegratorBase # Julia solver\n\n# Backend-specific\nscipy(system, method='RK45', **opts) → ScipyIntegrator\njulia(system, algorithm='Tsit5', **opts) → DiffEqPyIntegrator\ntorch(system, method='dopri5', **opts) → TorchDiffEqIntegrator\njax(system, method='tsit5', **opts) → DiffraxIntegrator\nMethod Registry:\n\n\n\nMethod\nBackend\nType\nBest For\n\n\n\n\nLSODA\nNumPy (scipy)\nAdaptive\nGeneral (auto-stiffness)\n\n\nRK45\nNumPy (scipy)\nAdaptive\nNon-stiff ODEs\n\n\nRadau\nNumPy (scipy)\nAdaptive\nStiff ODEs\n\n\nBDF\nNumPy (scipy)\nAdaptive\nVery stiff ODEs\n\n\nTsit5\nNumPy (Julia)\nAdaptive\nHigh performance\n\n\nVern9\nNumPy (Julia)\nAdaptive\nHigh accuracy\n\n\nRodas5\nNumPy (Julia)\nAdaptive\nStiff (Rosenbrock)\n\n\ndopri5\nPyTorch/JAX\nAdaptive\nNeural ODEs\n\n\ndopri8\nPyTorch/JAX\nAdaptive\nHigh accuracy\n\n\ntsit5\nJAX (diffrax)\nAdaptive\nOptimization\n\n\neuler\nAny\nFixed\nEducational\n\n\nrk4\nAny\nFixed\nSimple systems\n\n\n\n\n\n\n\nFile: `scipy_integrator.py** (~620 lines estimate)\nPurpose: Adaptive integration using scipy.integrate.solve_ivp\nSupported Methods:\n\nRK45 (default): Dormand-Prince 5(4) - general purpose\nRK23: Bogacki-Shampine 3(2) - fast, low accuracy\nDOP853: Dormand-Prince 8(5,3) - high accuracy\nRadau: Implicit RK - stiff systems\nBDF: Backward differentiation - very stiff\nLSODA: Auto stiffness detection\n\nKey Features:\n\nProfessional-grade adaptive stepping\nError control (rtol/atol)\nDense output (interpolation)\nEvent detection\nBoth controlled and autonomous systems\n\nExample:\nintegrator = ScipyIntegrator(\n    system,\n    method='RK45',\n    rtol=1e-6,\n    atol=1e-8\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: torchdiffeq_integrator.py (estimated ~800 lines)\nPurpose: PyTorch integration with GPU acceleration and autograd\nSupported Methods:\n\ndopri5: Dormand-Prince 5(4)\ndopri8: Dormand-Prince 8\nadaptive_heun: Heun’s method\nbosh3: Bogacki-Shampine 3\nfehlberg2: Fehlberg 2(1)\nexplicit_adams, implicit_adams: Multi-step methods\n\nKey Features:\n\nGPU acceleration\nAutomatic differentiation\nAdjoint method for memory efficiency\nNeural ODE support\n\nExample:\nintegrator = TorchDiffEqIntegrator(\n    system,\n    method='dopri5',\n    backend='torch',\n    device='cuda:0'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffrax_integrator.py (estimated ~700 lines)\nPurpose: JAX integration with XLA compilation and autograd\nSupported Methods:\n\ntsit5: Tsitouras 5(4) - recommended\ndopri5: Dormand-Prince 5(4)\ndopri8: Dormand-Prince 8\nheun: Heun’s method\nralston: Ralston’s method\nreversible_heun: Reversible Heun\n\nKey Features:\n\nXLA compilation\nJAX transformations (jit, vmap, grad)\nEfficient for optimization\nFunctional programming style\n\nExample:\nintegrator = DiffraxIntegrator(\n    system,\n    method='tsit5',\n    backend='jax'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffeqpy_integrator.py (estimated ~900 lines)\nPurpose: Julia’s DifferentialEquations.jl via Python bindings\nSupported Methods:\nExtensive Julia solver ecosystem: - Explicit RK: Tsit5, Vern6, Vern7, Vern8, Vern9, DP5, DP8 - Rosenbrock: Rosenbrock23, Rosenbrock32, Rodas4, Rodas5 - BDF: TRBDF2, KenCarp3, KenCarp4, KenCarp5 - Radau: RadauIIA5 - Stabilized: ROCK2, ROCK4 - Symplectic: VelocityVerlet, SymplecticEuler - Auto-switching: AutoTsit5(Rosenbrock23()), AutoVern7(Rodas5())\nKey Features:\n\nHighest performance\nAutomatic stiffness detection\nExtensive method library\nProduction-grade reliability\n\nExample:\nintegrator = DiffEqPyIntegrator(\n    system,\n    algorithm='Vern9',\n    backend='numpy',\n    reltol=1e-12,\n    abstol=1e-14\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: fixed_step_integrators.py (estimated ~600 lines)\nPurpose: Manual implementation of fixed-step methods\nSupported Methods:\n\neuler: Forward Euler (order 1)\nmidpoint: Midpoint method (order 2)\nrk4: Runge-Kutta 4 (order 4)\n\nKey Features:\n\nBackend-agnostic (NumPy, PyTorch, JAX)\nSimple, transparent implementations\nEducational value\nConstant time step\n\nExample:\nintegrator = RK4Integrator(\n    system,\n    dt=0.01,\n    backend='numpy'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\n\n\n\nFile: sde_integrator_base.py (1,080 lines)\nPurpose: Abstract base for SDE integrators\nMathematical Form:\ndx = f(x, u, t)dt + g(x, u, t)dW\nwhere: - f: Drift (deterministic) - g: Diffusion (stochastic intensity) - dW: Brownian motion increments\nKey Differences from ODE:\n\nRandom noise generation\nWeak vs strong convergence\nNoise structure exploitation\nMonte Carlo simulation support\nItô vs Stratonovich interpretation\n\nAbstract Methods:\n- step(x, u, dt, dW) → x_next      # Single SDE step with noise\n- integrate(x0, u_func, t_span) → SDEIntegrationResult\n- integrate_monte_carlo(x0, u_func, t_span, n_paths) → SDEIntegrationResult\nResult Type:\nSDEIntegrationResult = {\n    't': TimePoints,               # Time grid\n    'x': StateVector,              # Trajectory (T, nx) or (n_paths, T, nx)\n    'success': bool,\n    'message': str,\n    'nfev': int,                   # Drift evaluations\n    'diffusion_evals': int,        # Diffusion evaluations\n    'noise_samples': NoiseVector,  # Brownian increments\n    'n_paths': int,                # Number of trajectories\n    'convergence_type': str,       # 'strong' or 'weak'\n    'sde_type': str,               # 'ito' or 'stratonovich'\n    ...\n}\n\n\n\n\nFile: sde_integrator_factory.py (estimated ~1,000 lines)\nPurpose: Factory for creating SDE integrators\nFactory Methods:\ncreate(sde_system, backend, method, dt, **options) → SDEIntegratorBase\nauto(sde_system, backend=None) → SDEIntegratorBase\nfor_monte_carlo(sde_system, n_paths) → SDEIntegratorBase\nAvailable Methods:\n\n\n\nMethod\nBackend\nConvergence\nNoise Type\n\n\n\n\neuler-maruyama\nNumPy/PyTorch/JAX\nStrong (0.5)\nGeneral\n\n\nmilstein\nNumPy\nStrong (1.0)\nDiagonal\n\n\nheun\nPyTorch/JAX\nStrong (1.0)\nAdditive\n\n\nsrk\nPyTorch\nStrong\nGeneral\n\n\nreversible_heun\nPyTorch\nStrong\nAdditive\n\n\n\n\n\n\n\nFile: torchsde_integrator.py (estimated ~800 lines)\nPurpose: PyTorch SDE integration with torchsde\nSupported Methods:\n\neuler: Euler-Maruyama (strong order 0.5)\nheun: Heun’s method (strong order 1.0 for additive)\nsrk: Stochastic Runge-Kutta\nreversible_heun: Reversible Heun (strong order 1.0)\n\nKey Features:\n\nGPU acceleration\nAdaptive stepping\nNoise structure exploitation\nAdjoint method for gradients\n\nExample:\nintegrator = TorchSDEIntegrator(\n    sde_system,\n    method='heun',\n    dt=0.01,\n    backend='torch'\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffrax_sde_integrator.py (estimated ~750 lines)\nPurpose: JAX SDE integration with diffrax\nSupported Methods:\n\neuler: Euler-Maruyama\nheun: Heun’s method\nreversible_heun: Reversible Heun\n\nKey Features:\n\nJAX transformations\nXLA compilation\nCustom noise support\nEfficient for optimization\n\nExample:\nintegrator = DiffraxSDEIntegrator(\n    sde_system,\n    method='euler',\n    dt=0.01,\n    backend='jax',\n    seed=42\n)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n\nFile: diffeqpy_sde_integrator.py (estimated ~850 lines)\nPurpose: Julia SDE solvers via DiffEqPy\nSupported Methods:\n\nEuler-Maruyama variants\nMilstein\nStochastic Rosenbrock\nAdvanced Julia SDE methods\n\nKey Features:\n\nProduction-grade SDE solvers\nAutomatic noise structure detection\nHigh-performance algorithms\n\n\n\n\n\nFile: custom_brownian.py (160 lines)\nPurpose: Custom Brownian motion for deterministic testing\nKey Features:\n\nUser-provided noise increments\nDiffrax AbstractPath interface\nDeterministic testing support\nCustom noise patterns\n\nExample:\n# Zero noise for testing\ndW = jnp.zeros(1)\nbrownian = CustomBrownianPath(0.0, 0.01, dW)\n\n# Or random noise\nbrownian = create_custom_or_random_brownian(\n    key, 0.0, 0.01, shape=(nw,), dW=None\n)"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#design-principles",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#design-principles",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "All integrators work across backends:\n\nNumPy: CPU, scipy, Julia integration\nPyTorch: GPU, autograd, neural ODEs\nJAX: XLA, functional, optimization\n\n\n\n\nIntegratorFactory and SDEIntegratorFactory provide:\n\nAutomatic method selection\nBackend-specific routing\nConvenience constructors\nUse case optimization\n\n\n\n\nAll integrators return TypedDict results:\n\nIntegrationResult for ODEs\nSDEIntegrationResult for SDEs\nConsistent fields across backends\nOptional fields for extra diagnostics\n\n\n\n\n\nIntegrators compose with systems\nNo deep inheritance hierarchies\nClear separation of concerns\nEasy to extend\n\n\n\n\nBuilt-in statistics:\nintegrator._stats = {\n    'total_fev': int,      # Function evaluations\n    'total_steps': int,    # Integration steps\n    'total_time': float,   # Computation time\n}"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#integration-result-types",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#integration-result-types",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "{\n    't': array,              # Time points (T,)\n    'x': array,              # States (T, nx) - time-major\n    'success': bool,         # Integration succeeded\n    'message': str,          # Status message\n    'nfev': int,             # Function evaluations\n    'nsteps': int,           # Steps taken\n    'integration_time': float,  # Wall time (seconds)\n    'solver': str,           # Integrator name\n    \n    # Optional (adaptive methods):\n    'njev': int,             # Jacobian evaluations\n    'nlu': int,              # LU decompositions\n    'status': int,           # Solver status code\n    'sol': object,           # Dense output (if requested)\n    'dense_output': bool,    # Dense output available\n}\n\n\n\n{\n    # All IntegrationResult fields, plus:\n    'diffusion_evals': int,     # Diffusion function calls\n    'noise_samples': array,     # Brownian increments used\n    'n_paths': int,             # Number of trajectories\n    'convergence_type': str,    # 'strong' or 'weak'\n    'sde_type': str,            # 'ito' or 'stratonovich'\n    'noise_type': str,          # 'additive', 'multiplicative', etc.\n    \n    # For Monte Carlo (n_paths &gt; 1):\n    'x': array,                 # (n_paths, T, nx)\n    'statistics': dict,         # mean, std, quantiles\n}"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#usage-examples",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#usage-examples",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "from src.systems.base import ContinuousSymbolicSystem\nfrom src.systems.base.numerical_integration import IntegratorFactory\nimport numpy as np\n\n# Create system (e.g., pendulum)\nsystem = Pendulum(m=1.0, l=0.5)\n\n# Create integrator automatically\nintegrator = IntegratorFactory.auto(system)\n\n# Integrate\nresult = integrator.integrate(\n    x0=np.array([0.1, 0.0]),\n    u_func=lambda t, x: np.zeros(1),\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\nprint(f\"Success: {result['success']}\")\n\n\n\nimport torch\nfrom src.systems.base.numerical_integration import IntegratorFactory\n\n# Create system and move to GPU\nsystem = MyNeuralODE()\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# Create Neural ODE integrator\nintegrator = IntegratorFactory.for_neural_ode(system)\n\n# Integrate on GPU\nx0 = torch.tensor([[1.0, 0.0]], device='cuda:0')\nresult = integrator.integrate(\n    x0=x0,\n    u_func=lambda t, x: torch.zeros(1, device='cuda:0'),\n    t_span=(0.0, 10.0)\n)\n\n\n\nfrom src.systems.base.numerical_integration import IntegratorFactory\n\n# Create Julia integrator with high accuracy\nintegrator = IntegratorFactory.for_julia(\n    system,\n    algorithm='Vern9',  # 9th order\n    reltol=1e-12,\n    abstol=1e-14\n)\n\nresult = integrator.integrate(x0, u_func, t_span=(0, 100))\nprint(f\"Accurate to {result['nfev']} function evaluations\")\n\n\n\nfrom src.systems.base import ContinuousStochasticSystem\nfrom src.systems.base.numerical_integration.stochastic import SDEIntegratorFactory\n\n# Create SDE system (e.g., Ornstein-Uhlenbeck)\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\n# Create SDE integrator\nintegrator = SDEIntegratorFactory.create(\n    sde_system,\n    backend='torch',\n    method='heun',\n    dt=0.01,\n    seed=42\n)\n\n# Single trajectory\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\nprint(f\"Noise type: {result['noise_type']}\")\nprint(f\"SDE type: {result['sde_type']}\")\n\n\n\n# Multiple trajectories for uncertainty quantification\nresult = integrator.integrate_monte_carlo(\n    x0=np.array([1.0]),\n    u_func=lambda t, x: None,\n    t_span=(0, 10),\n    n_paths=1000\n)\n\n# Get statistics\nfrom src.systems.base.numerical_integration.sde_integrator_base import (\n    get_trajectory_statistics\n)\nstats = get_trajectory_statistics(result)\n\nprint(f\"Mean at t=10: {stats['mean'][-1]}\")\nprint(f\"Std at t=10: {stats['std'][-1]}\")\nprint(f\"95% CI: [{stats['q25'][-1]}, {stats['q75'][-1]}]\")\n\n\n\nimport jax.numpy as jnp\nfrom src.systems.base.numerical_integration.stochastic.custom_brownian import (\n    CustomBrownianPath\n)\n\n# Zero noise for deterministic testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(0.0, 0.01, dW)\n\n# Use in integration\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 1),\n    brownian_path=brownian\n)"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#integrator-selection-guide",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#integrator-selection-guide",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "Use Case\nRecommended Integrator\nReason\n\n\n\n\nGeneral ODE\nIntegratorFactory.for_production(system)\nLSODA auto-stiffness\n\n\nNeural ODE\nIntegratorFactory.for_neural_ode(system)\nTorchDiffEq adjoint\n\n\nOptimization\nIntegratorFactory.for_optimization(system)\nDiffrax JAX\n\n\nHigh Accuracy\nIntegratorFactory.for_julia(system, 'Vern9')\nJulia 9th order\n\n\nStiff ODE\nScipyIntegrator(system, method='BDF')\nImplicit BDF\n\n\nSimple ODE\nRK4Integrator(system, dt=0.01)\nClassic RK4\n\n\nSDE (general)\nSDEIntegratorFactory.auto(sde_system)\nBest for noise type\n\n\nMonte Carlo\nSDEIntegratorFactory.for_monte_carlo(...)\nParallelized\n\n\n\n\n\n\n\n\n\nBackend\nODE Integrator\nSDE Integrator\n\n\n\n\nNumPy\nScipyIntegrator, DiffEqPyIntegrator\n(limited support)\n\n\nPyTorch\nTorchDiffEqIntegrator\nTorchSDEIntegrator\n\n\nJAX\nDiffraxIntegrator\nDiffraxSDEIntegrator\n\n\n\n\n\n\n\n\n\nSystem Type\nBest Integrator\n\n\n\n\nNon-stiff\nRK45, Tsit5, dopri5\n\n\nStiff\nBDF, Radau, Rodas5\n\n\nHigh accuracy\nVern9, DOP853\n\n\nReal-time\nRK4, euler (fixed-step)\n\n\nAdditive noise SDE\nHeun (strong order 1.0)\n\n\nGeneral SDE\nEuler-Maruyama"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#file-size-summary",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#file-size-summary",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "File\nLines\nPurpose\n\n\n\n\nintegrator_base.py\n512\nAbstract base\n\n\nintegrator_factory.py\n1,267\nFactory pattern\n\n\nscipy_integrator.py\n~620\nNumPy (scipy)\n\n\ntorchdiffeq_integrator.py\n~800\nPyTorch\n\n\ndiffrax_integrator.py\n~700\nJAX\n\n\ndiffeqpy_integrator.py\n~900\nJulia\n\n\nfixed_step_integrators.py\n~600\nManual methods\n\n\n\n\n\n\n\n\n\nFile\nLines\nPurpose\n\n\n\n\nsde_integrator_base.py\n1,080\nSDE abstract base\n\n\nsde_integrator_factory.py\n~1,000\nSDE factory\n\n\ntorchsde_integrator.py\n~800\nPyTorch SDE\n\n\ndiffrax_sde_integrator.py\n~750\nJAX SDE\n\n\ndiffeqpy_sde_integrator.py\n~850\nJulia SDE\n\n\ncustom_brownian.py\n160\nCustom noise\n\n\n\nTotal: ~10,000+ lines of production-ready integration code"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Architecture.html#key-strengths",
    "href": "api/integration_framework/Integration_Framework_Architecture.html#key-strengths",
    "title": "ControlDESymulation Numerical Integration Framework Architecture",
    "section": "",
    "text": "Multi-Backend Support - Seamless NumPy/PyTorch/JAX switching\nExtensive Method Library - 40+ integration methods\nFactory Pattern - Automatic method selection\nType Safety - TypedDict results with IDE support\nPerformance - GPU acceleration, XLA compilation, Julia performance\nFlexibility - Fixed and adaptive stepping\nStochastic Support - Full SDE integration framework\nNoise Structure - Exploits additive/diagonal/scalar noise\nMonte Carlo - Built-in multi-trajectory simulation\nTesting - Custom noise for deterministic testing\n\nThis framework enables state-of-the-art numerical integration for control theory and machine learning applications!"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html",
    "href": "api/type_system/Type_System_Architecture.html",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "The Type System is the foundational layer that provides semantic types, structured results, and type-safe interfaces for the entire framework. It consists of 8 focused modules totaling ~7,000 lines that define over 200 type aliases and structured dictionaries.\n\n\n\nType-Driven Design - The type system enables:\n\nSemantic Clarity - Names convey mathematical meaning (StateVector, not ArrayLike)\nType Safety - Static type checking via mypy/pyright\nIDE Support - Autocomplete and inline documentation\nBackend Agnosticism - Same types work with NumPy/PyTorch/JAX\nStructured Results - TypedDict for dictionaries (not plain dict)\nSelf-Documenting - Types encode constraints and invariants\n\n# Compare:\ndef bad(x, u):  # What are x and u? Arrays? Scalars? Dimensions?\n    return x + u\n\n# vs:\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear intent: state in, control in, state out.\"\"\"\n    return x + u\n\n\n\n┌────────────────────────────────────────────────────────────┐\n│                    APPLICATION LAYER                        │\n│  (UI Framework, Delegation Layer, Integration Framework)   │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ uses types from\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                    TYPE SYSTEM                              │\n│                                                              │\n│  ┌─────────────────────────────────────────────────┐       │\n│  │  FOUNDATIONAL TYPES                             │       │\n│  │  • core.py           - Vectors, matrices        │       │\n│  │  • backends.py       - Backend enums            │       │\n│  └─────────────────────────────────────────────────┘       │\n│                                                              │\n│  ┌─────────────────────────────────────────────────┐       │\n│  │  DOMAIN TYPES                                   │       │\n│  │  • trajectories.py   - Time series results      │       │\n│  │  • linearization.py  - Jacobian tuples          │       │\n│  │  • symbolic.py       - SymPy types              │       │\n│  │  • control_classical.py - Control design results│       │\n│  └─────────────────────────────────────────────────┘       │\n│                                                              │\n│  ┌─────────────────────────────────────────────────┐       │\n│  │  STRUCTURAL TYPES                               │       │\n│  │  • protocols.py      - Abstract interfaces      │       │\n│  │  • utilities.py      - Helper types             │       │\n│  └─────────────────────────────────────────────────┘       │\n└────────────────────────────────────────────────────────────┘\n\n\n\n\n\n\n\nFile: core.py (1,501 lines)\nPurpose: Fundamental building blocks for all other types\nCategories:\n1. Multi-Backend Arrays (20+ types)\nArrayLike = Union[np.ndarray, torch.Tensor, jnp.ndarray]\nNumpyArray = np.ndarray\nTorchTensor = torch.Tensor\nJaxArray = jnp.ndarray\nScalarLike = Union[float, int, np.number, torch.Tensor, jnp.ndarray]\nIntegerLike = Union[int, np.integer]\n2. Semantic Vector Types (15+ types)\nStateVector         # x ∈ ℝⁿˣ - State\nControlVector       # u ∈ ℝⁿᵘ - Control input\nOutputVector        # y ∈ ℝⁿʸ - Measured output\nNoiseVector         # w ∈ ℝⁿʷ - Stochastic noise\nEquilibriumState    # x_eq - Equilibrium state\nEquilibriumControl  # u_eq - Equilibrium control\nTimeDerivative      # dx/dt - State derivative\nStateIncrement      # δx - State deviation\nControlIncrement    # δu - Control deviation\n3. Matrix Types (30+ types)\n# Dynamics matrices\nStateMatrix         # A ∈ ℝⁿˣˣⁿˣ - ∂f/∂x\nInputMatrix         # B ∈ ℝⁿˣˣⁿᵘ - ∂f/∂u  \nDiffusionMatrix     # G ∈ ℝⁿˣˣⁿʷ - Noise intensity\n\n# Observation matrices\nOutputMatrix        # C ∈ ℝⁿʸˣⁿˣ - ∂h/∂x\nFeedthroughMatrix   # D ∈ ℝⁿʸˣⁿᵘ - Direct feedthrough\n\n# Control matrices\nGainMatrix          # K ∈ ℝⁿᵘˣⁿˣ - Feedback gain\nCostMatrix          # Q ∈ ℝⁿˣˣⁿˣ - State cost\nControlCostMatrix   # R ∈ ℝⁿᵘˣⁿᵘ - Control cost\n\n# Stochastic matrices\nCovarianceMatrix    # P ∈ ℝⁿˣˣⁿˣ - Covariance\nProcessNoiseMatrix  # Q ∈ ℝⁿˣˣⁿˣ - Process noise cov\nMeasurementNoiseMatrix  # R ∈ ℝⁿʸˣⁿʸ - Measurement noise cov\n\n# Special matrices\nIdentityMatrix      # I ∈ ℝⁿˣⁿ\nZeroMatrix         # 0 ∈ ℝᵐˣⁿ\nGramianMatrix      # Controllability/observability\n4. Function Signatures (10+ types)\nDynamicsFunction    # (x, u) → dx/dt\nOutputFunction      # (x) → y\nControlPolicy       # (t, x) → u\nCostFunction        # (x, u) → scalar\nObserverFunction    # (y, u) → x_hat\n5. System Properties (15+ types)\nStateDimension      # nx - Number of states\nControlDimension    # nu - Number of controls\nOutputDimension     # ny - Number of outputs\nNoiseDimension      # nw - Number of Wiener processes\nSystemOrder         # order - Differential order\n\nEquilibriumPoint    # (x_eq, u_eq) - Tuple\nEquilibriumName     # str - Named equilibrium\nKey Design:\n\nSemantic naming - Type names encode mathematical meaning\nMulti-backend - All types support NumPy/PyTorch/JAX\nComposition - Types compose into higher-level structures\nDocumentation - Each type has examples and constraints\n\n\n\n\n\nFile: backends.py (735 lines)\nPurpose: Backend configuration and method selection types\nCategories:\n1. Backend Types\nBackend = Literal[\"numpy\", \"torch\", \"jax\"]\nDevice = str  # 'cpu', 'cuda:0', 'mps', 'tpu'\n\nclass BackendConfig(TypedDict, total=False):\n    backend: Backend\n    device: Optional[Device]\n    dtype: Optional[str]  # 'float32', 'float64'\n2. Integration Methods\nIntegrationMethod = str  # 'RK45', 'dopri5', 'tsit5', etc.\n\n# Specific categories\nOdeMethod = str          # Deterministic methods\nSdeMethod = str          # Stochastic methods\nFixedStepMethod = str    # Fixed-step methods\nAdaptiveMethod = str     # Adaptive methods\n3. Discretization Methods\nDiscretizationMethod = Literal[\n    \"exact\",      # Matrix exponential\n    \"euler\",      # Forward Euler\n    \"tustin\",     # Bilinear transform\n    \"backward\",   # Backward Euler\n    \"matched\",    # Zero-order hold\n]\n4. SDE Types\nSDEType = Literal[\"ito\", \"stratonovich\"]\n\nclass NoiseType(Enum):\n    ADDITIVE = \"additive\"\n    MULTIPLICATIVE = \"multiplicative\"\n    MULTIPLICATIVE_DIAGONAL = \"multiplicative_diagonal\"\n    MULTIPLICATIVE_SCALAR = \"multiplicative_scalar\"\n    MULTIPLICATIVE_GENERAL = \"multiplicative_general\"\n    UNKNOWN = \"unknown\"\n\nclass ConvergenceType(Enum):\n    STRONG = \"strong\"  # Pathwise convergence\n    WEAK = \"weak\"      # Distribution convergence\n5. System Configuration\nclass SystemConfig(TypedDict, total=False):\n    \"\"\"Complete system configuration.\"\"\"\n    nx: int              # State dimension\n    nu: int              # Control dimension\n    ny: int              # Output dimension\n    nw: int              # Noise dimension\n    order: int           # System order\n    dt: Optional[float]  # Time step (discrete)\n    backend: Backend\n    device: Device\nKey Design:\n\nType-safe enums - Literal types prevent typos\nStructured configs - TypedDict for configuration\nExtensible - Easy to add new methods\nSelf-documenting - Clear valid values\n\n\n\n\n\n\n\n\nFile: `trajectories.py** (879 lines)\nPurpose: Time series data and simulation results\nCategories:\n1. Trajectory Types\nStateTrajectory = ArrayLike      # (T, nx) or (T, batch, nx)\nControlSequence = ArrayLike      # (T, nu) or (T, batch, nu)\nOutputSequence = ArrayLike       # (T, ny)\nNoiseSequence = ArrayLike        # (T, nw)\n2. Time Types\nTimePoints = ArrayLike           # (T,) - Time grid\nTimeSpan = Tuple[float, float]   # (t0, tf) - Interval\nTimeStep = float                 # dt - Step size\n3. Integration Results (TypedDict)\nclass IntegrationResult(TypedDict, total=False):\n    \"\"\"ODE integration result.\"\"\"\n    t: TimePoints              # Time points\n    x: StateTrajectory         # State trajectory (T, nx)\n    success: bool              # Integration succeeded\n    message: str               # Status message\n    nfev: int                  # Function evaluations\n    nsteps: int                # Integration steps\n    integration_time: float    # Wall time (seconds)\n    solver: str                # Integrator name\n    \n    # Optional fields (adaptive methods)\n    njev: int                  # Jacobian evaluations\n    nlu: int                   # LU decompositions\n    status: int                # Solver status code\n    sol: Any                   # Dense output object\n    dense_output: bool         # Dense output available\n4. SDE Integration Results\nclass SDEIntegrationResult(TypedDict, total=False):\n    \"\"\"SDE integration result (extends IntegrationResult).\"\"\"\n    # All IntegrationResult fields, plus:\n    diffusion_evals: int       # Diffusion function calls\n    noise_samples: NoiseVector # Brownian increments used\n    n_paths: int               # Number of trajectories\n    convergence_type: str      # 'strong' or 'weak'\n    sde_type: str              # 'ito' or 'stratonovich'\n    noise_type: str            # Noise structure\n5. Batch Results\nclass BatchSimulationResult(TypedDict):\n    \"\"\"Batched simulation result.\"\"\"\n    t: TimePoints                    # (T,)\n    x: StateTrajectory               # (T, batch, nx)\n    u: ControlSequence               # (T, batch, nu)\n    batch_size: int\n    statistics: Dict[str, ArrayLike] # Mean, std, etc.\nKey Design:\n\nTime-major ordering - (T, nx) not (nx, T)\nTypedDict results - Structured, type-safe dictionaries\nOptional fields - Use total=False for flexibility\nConsistent shapes - All trajectories follow same conventions\n\n\n\n\n\nFile: linearization.py (502 lines)\nPurpose: Linearization results and Jacobian types\nCategories:\n1. Basic Linearization\nDeterministicLinearization = Tuple[StateMatrix, InputMatrix]\n# Returns: (A, B) where\n#   A = ∂f/∂x - State Jacobian\n#   B = ∂f/∂u - Control Jacobian\n\nStochasticLinearization = Tuple[StateMatrix, InputMatrix, DiffusionMatrix]\n# Returns: (A, B, G) where\n#   A = ∂f/∂x\n#   B = ∂f/∂u  \n#   G = ∂g/∂x or g(x_eq) - Diffusion\n\nLinearizationResult = Union[DeterministicLinearization, StochasticLinearization]\n# Polymorphic: works with both\n2. Output Linearization\nObservationLinearization = Tuple[OutputMatrix, FeedthroughMatrix]\n# Returns: (C, D) where\n#   C = ∂h/∂x - Output Jacobian\n#   D = ∂h/∂u - Feedthrough (usually 0)\n3. Full State-Space\nFullLinearization = Tuple[StateMatrix, InputMatrix, OutputMatrix, FeedthroughMatrix]\n# Returns: (A, B, C, D)\n\nFullStochasticLinearization = Tuple[\n    StateMatrix, InputMatrix, DiffusionMatrix, OutputMatrix, FeedthroughMatrix\n]\n# Returns: (A, B, G, C, D)\n4. Time-Domain Aliases\nContinuousLinearization = DeterministicLinearization\nDiscreteLinearization = DeterministicLinearization\nContinuousStochasticLinearization = StochasticLinearization\nDiscreteStochasticLinearization = StochasticLinearization\n5. Jacobian-Specific\nStateJacobian = StateMatrix       # A = ∂f/∂x\nControlJacobian = InputMatrix     # B = ∂f/∂u\nOutputJacobian = OutputMatrix     # C = ∂h/∂x\nDiffusionJacobian = DiffusionMatrix  # G = ∂g/∂x\nKey Design:\n\nTuple returns - Natural unpacking: A, B = linearize()\nPolymorphic types - Union handles deterministic/stochastic\nSemantic aliases - Time-domain context clear\nMathematical clarity - Names match theory\n\n\n\n\n\nFile: symbolic.py (646 lines)\nPurpose: SymPy symbolic types\nCategories:\n1. Symbolic Variables\nSymbolicVariable = sp.Symbol        # Single variable\nSymbolicVector = sp.Matrix          # Vector of symbols\nSymbolicMatrix = sp.Matrix          # Matrix expression\nSymbolicExpression = sp.Expr        # General expression\n2. System Components\nDynamicsExpression = sp.Matrix      # f(x, u) symbolic\nOutputExpression = sp.Matrix        # h(x) symbolic\nDiffusionExpression = sp.Matrix     # g(x, u) symbolic\nParameterDict = Dict[sp.Symbol, float]  # Parameter values\n3. Jacobian Expressions\nJacobianExpression = sp.Matrix      # ∂f/∂x symbolic\nHessianExpression = sp.Matrix       # ∂²f/∂x² symbolic\nGradientExpression = sp.Matrix      # ∇f symbolic\n4. Substitution Types\nSubstitutionDict = Dict[sp.Symbol, Union[float, sp.Expr]]\nSimplificationStrategy = Literal[\"simplify\", \"expand\", \"factor\", \"cancel\"]\nKey Design:\n\nSymPy integration - Bridge symbolic ↔︎ numerical\nType annotations - Clarify SymPy usage\nCode generation - Input to compilation pipeline\nParameter substitution - Clear parameter handling\n\n\n\n\n\nFile: control_classical.py (542 lines)\nPurpose: Classical control theory result types\nCategories:\n1. System Analysis Results\nclass StabilityInfo(TypedDict):\n    \"\"\"Stability analysis result.\n    \n    Stability Criteria:\n    - Continuous: All Re(λ) &lt; 0 (left half-plane)\n    - Discrete: All |λ| &lt; 1 (inside unit circle)\n    \"\"\"\n    eigenvalues: np.ndarray          # Complex eigenvalues\n    magnitudes: np.ndarray           # |λ| values\n    max_magnitude: float             # Spectral radius\n    spectral_radius: float           # Same as max_magnitude\n    is_stable: bool                  # Asymptotically stable\n    is_marginally_stable: bool       # On stability boundary\n    is_unstable: bool                # Unstable\n\nclass ControllabilityInfo(TypedDict, total=False):\n    \"\"\"Controllability analysis result.\n    \n    Test: rank(C) = nx where C = [B AB A²B ... Aⁿ⁻¹B]\n    \"\"\"\n    controllability_matrix: ControllabilityMatrix  # (nx, nx*nu)\n    rank: int                        # Rank of C\n    is_controllable: bool            # rank == nx\n    uncontrollable_modes: Optional[np.ndarray]  # Eigenvalues\n\nclass ObservabilityInfo(TypedDict, total=False):\n    \"\"\"Observability analysis result.\n    \n    Test: rank(O) = nx where O = [C; CA; CA²; ...; CAⁿ⁻¹]\n    \"\"\"\n    observability_matrix: ObservabilityMatrix  # (nx*ny, nx)\n    rank: int                        # Rank of O\n    is_observable: bool              # rank == nx\n    unobservable_modes: Optional[np.ndarray]  # Eigenvalues\n2. Control Design Results\nclass LQRResult(TypedDict):\n    \"\"\"Linear Quadratic Regulator result.\n    \n    Minimizes: J = ∫(x'Qx + u'Ru)dt  (continuous)\n               J = Σ(x'Qx + u'Ru)     (discrete)\n    \n    Control law: u = -Kx\n    \"\"\"\n    gain: GainMatrix                 # Feedback gain K (nu, nx)\n    cost_to_go: CovarianceMatrix     # Riccati solution P (nx, nx)\n    closed_loop_eigenvalues: np.ndarray  # eig(A - BK)\n    stability_margin: float          # Phase/gain margin\n\nclass KalmanFilterResult(TypedDict):\n    \"\"\"Kalman Filter (optimal estimator) result.\n    \n    System:\n        x[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0,Q)\n        y[k] = Cx[k] + v[k],            v ~ N(0,R)\n    \n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    gain: GainMatrix                 # Kalman gain L (nx, ny)\n    error_covariance: CovarianceMatrix  # Error cov P (nx, nx)\n    innovation_covariance: CovarianceMatrix  # Innovation S (ny, ny)\n    observer_eigenvalues: np.ndarray  # eig(A - LC)\n\nclass LQGResult(TypedDict):\n    \"\"\"Linear Quadratic Gaussian controller result.\n    \n    Combines LQR (optimal control) + Kalman (optimal estimation)\n    via separation principle.\n    \n    Controller: u = -Kx̂\n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    control_gain: GainMatrix         # LQR gain K (nu, nx)\n    estimator_gain: GainMatrix       # Kalman gain L (nx, ny)\n    control_cost_to_go: CovarianceMatrix  # Controller Riccati P\n    estimation_error_covariance: CovarianceMatrix  # Estimator Riccati P\n    separation_verified: bool        # Separation principle holds\n    closed_loop_stable: bool         # Overall stability\n    controller_eigenvalues: np.ndarray  # eig(A - BK)\n    estimator_eigenvalues: np.ndarray   # eig(A - LC)\n3. Additional Controllers\nclass PolePlacementResult(TypedDict):\n    \"\"\"Pole placement (eigenvalue assignment) result.\n    \n    Design K such that eig(A - BK) = desired poles\n    \"\"\"\n    gain: GainMatrix                 # State feedback gain K\n    desired_poles: np.ndarray        # Desired eigenvalues\n    achieved_poles: np.ndarray       # Actual eig(A - BK)\n    is_controllable: bool            # Arbitrary placement possible\n\nclass LuenbergerObserverResult(TypedDict):\n    \"\"\"Luenberger observer (deterministic estimator) result.\n    \n    Observer: x̂˙ = Ax̂ + Bu + L(y - Cx̂)\n    Error dynamics: e˙ = (A - LC)e\n    \"\"\"\n    gain: GainMatrix                 # Observer gain L (nx, ny)\n    desired_poles: np.ndarray        # Desired observer poles\n    achieved_poles: np.ndarray       # Actual eig(A - LC)\n    is_observable: bool              # Arbitrary placement possible\nUsage Examples:\n# Stability analysis\nstability: StabilityInfo = analyze_stability(A, system_type='continuous')\nif stability['is_stable']:\n    print(f\"Stable with spectral radius {stability['spectral_radius']:.3f}\")\n\n# LQR design\nlqr: LQRResult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\nclosed_loop_A = A - B @ K\n\n# Kalman filter design\nkalman: KalmanFilterResult = system.control.design_kalman(\n    A, C, Q_process, R_measurement, system_type='discrete'\n)\nL = kalman['gain']\n\n# LQG controller (combined)\nlqg: LQGResult = system.control.design_lqg(\n    A, B, C, Q, R, Q_process, R_measurement, system_type='discrete'\n)\nK = lqg['control_gain']\nL = lqg['estimator_gain']\n\n# Controllability check\nctrl: ControllabilityInfo = analyze_controllability(A, B)\nif ctrl['is_controllable']:\n    print(f\"System is controllable with rank {ctrl['rank']}\")\nKey Design:\n\nTypedDict results - Structured, type-safe returns\nMathematical clarity - Names match control theory\nComplete information - All relevant analysis data\nSeparation principle - LQG designed independently\nStability guarantees - Eigenvalues included\nIDE support - Autocomplete for all fields\n\n\n\n\n\n\n\n\nFile: protocols.py (1,086 lines)\nPurpose: Abstract interfaces via Protocol\nCategories:\n1. System Protocols\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Abstract interface for dynamical systems.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    @property\n    def nu(self) -&gt; int: ...\n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\nclass ContinuousSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Continuous-time system interface.\"\"\"\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable,\n        t_span: TimeSpan\n    ) -&gt; IntegrationResult: ...\n\nclass DiscreteSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Discrete-time system interface.\"\"\"\n    @property\n    def dt(self) -&gt; float: ...\n    def step(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n    def simulate(\n        self,\n        x0: StateVector,\n        u_seq: ControlSequence,\n        steps: int\n    ) -&gt; StateTrajectory: ...\n\nclass StochasticSystemProtocol(Protocol):\n    \"\"\"Stochastic system interface.\"\"\"\n    @property\n    def nw(self) -&gt; int: ...\n    def drift(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n    def diffusion(self, x: StateVector, u: ControlVector) -&gt; DiffusionMatrix: ...\n2. Observer Protocols\nclass ObserverProtocol(Protocol):\n    \"\"\"State observer interface.\"\"\"\n    def observe(self, x: StateVector) -&gt; OutputVector: ...\n    def estimate(self, y: OutputVector, u: ControlVector) -&gt; StateVector: ...\n3. Controller Protocols\nclass ControllerProtocol(Protocol):\n    \"\"\"Controller interface.\"\"\"\n    def compute_control(self, x: StateVector) -&gt; ControlVector: ...\n\nclass FeedbackControllerProtocol(ControllerProtocol, Protocol):\n    \"\"\"Linear feedback controller.\"\"\"\n    @property\n    def K(self) -&gt; GainMatrix: ...\nKey Design:\n\nStructural subtyping - Duck typing with type safety\nInterface documentation - Clear contracts\nComposition - Protocols compose naturally\nNo inheritance - Structural not nominal\n\n\n\n\n\nFile: utilities.py (1,132 lines)\nPurpose: Helper types and utilities\nCategories:\n1. Type Guards\ndef is_numpy(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is NumPy.\"\"\"\n    return isinstance(arr, np.ndarray)\n\ndef is_torch(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is PyTorch.\"\"\"\n    return hasattr(arr, '__module__') and 'torch' in arr.__module__\n\ndef is_jax(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is JAX.\"\"\"\n    return hasattr(arr, '__module__') and 'jax' in arr.__module__\n2. Shape Utilities\ndef is_batched(arr: ArrayLike, expected_dims: int = 1) -&gt; bool:\n    \"\"\"Check if array is batched.\"\"\"\n    return arr.ndim &gt; expected_dims\n\ndef get_batch_size(arr: ArrayLike) -&gt; Optional[int]:\n    \"\"\"Get batch size if batched.\"\"\"\n    return arr.shape[0] if is_batched(arr) else None\n\ndef get_state_dim(x: StateVector) -&gt; int:\n    \"\"\"Get state dimension.\"\"\"\n    return x.shape[-1] if x.ndim &gt; 0 else 1\n3. Performance Types\nclass ExecutionStats(TypedDict):\n    \"\"\"Performance statistics.\"\"\"\n    count: int              # Number of calls\n    total_time: float       # Total time (seconds)\n    avg_time: float         # Average time\n    min_time: float         # Fastest call\n    max_time: float         # Slowest call\n4. Validation Types\nclass ValidationResult(TypedDict):\n    \"\"\"Validation result.\"\"\"\n    valid: bool\n    errors: List[str]\n    warnings: List[str]\n    info: Dict[str, Any]\nKey Design:\n\nRuntime utilities - Complement static types\nType guards - Enable type narrowing\nPerformance tracking - Structured metrics\nValidation - Structured error reporting\n\n\n\n\n\n\n\n\n\n# Bad: Structural (what it is)\ndef compute(arr1: np.ndarray, arr2: np.ndarray) -&gt; np.ndarray:\n    pass\n\n# Good: Semantic (what it means)\ndef compute_control(x: StateVector, K: GainMatrix) -&gt; ControlVector:\n    pass\n\n\n\n# Same function signature works for all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # Works with NumPy, PyTorch, JAX\n    return f(x, u)\n\n\n\n# Bad: Plain dict (no type safety)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# Good: TypedDict (type-safe, documented)\ndef integrate() -&gt; IntegrationResult:\n    return {'t': t, 'x': x, 'success': True, ...}\n\n\n\nclass IntegrationResult(TypedDict, total=False):\n    # Required fields\n    t: TimePoints\n    x: StateTrajectory\n    success: bool\n    \n    # Optional fields (adaptive methods only)\n    njev: int  # May not be present\n    sol: Any   # Dense output (optional)\n\n\n\nLinearizationResult = Union[\n    Tuple[StateMatrix, InputMatrix],           # Deterministic\n    Tuple[StateMatrix, InputMatrix, DiffusionMatrix]  # Stochastic\n]\n\n# Single function handles both\ndef analyze(result: LinearizationResult):\n    A, B = result[0], result[1]\n    if len(result) == 3:\n        G = result[2]  # Stochastic\n\n\n\n# No inheritance needed - structural typing\nclass MySystem:\n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies DynamicalSystemProtocol structurally\nsystem: DynamicalSystemProtocol = MySystem()\n\n\n\n\n\n\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __call__(self, x: StateVector, u: Optional[ControlVector] = None) -&gt; StateVector:\n        \"\"\"Evaluate dynamics.\"\"\"\n        return self._dynamics.evaluate(x, u, backend=self._default_backend)\n    \n    def linearize(\n        self,\n        x_eq: EquilibriumState,\n        u_eq: EquilibriumControl,\n        backend: Backend = \"numpy\"\n    ) -&gt; DeterministicLinearization:\n        \"\"\"Compute linearization.\"\"\"\n        return self._linearization.linearize_continuous(x_eq, u_eq, backend)\n\n\n\nclass DynamicsEvaluator:\n    def evaluate(\n        self,\n        x: StateVector,\n        u: Optional[ControlVector],\n        backend: Backend\n    ) -&gt; StateVector:\n        \"\"\"Evaluate forward dynamics.\"\"\"\n        f_func: DynamicsFunction = self.code_gen.generate_dynamics(backend)\n        return f_func(x, u)\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        \"\"\"Get performance statistics.\"\"\"\n        return {\n            'count': self._call_count,\n            'total_time': self._total_time,\n            'avg_time': self._total_time / self._call_count,\n            'min_time': self._min_time,\n            'max_time': self._max_time\n        }\n\n\n\nclass ScipyIntegrator(IntegratorBase):\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable[[ScalarLike, StateVector], Optional[ControlVector]],\n        t_span: TimeSpan,\n        t_eval: Optional[TimePoints] = None\n    ) -&gt; IntegrationResult:\n        \"\"\"Integrate using scipy.\"\"\"\n        # ... implementation ...\n        \n        result: IntegrationResult = {\n            't': sol.t,\n            'x': sol.y.T,\n            'success': sol.success,\n            'message': sol.message,\n            'nfev': sol.nfev,\n            'nsteps': sol.nfev,\n            'integration_time': elapsed,\n            'solver': self.name\n        }\n        \n        # Optional fields\n        if hasattr(sol, 'njev'):\n            result['njev'] = sol.njev\n        \n        return result\n\n\n\n\n\nSemantic Clarity - Names convey mathematical meaning\nType Safety - Static checking prevents errors\nIDE Support - Autocomplete and documentation\nBackend Agnostic - Works with NumPy/PyTorch/JAX\nStructured Results - TypedDict not plain dict\nSelf-Documenting - Types encode constraints\nComposition - Types compose naturally\nExtensible - Easy to add new types\nConsistent - Same conventions throughout\nTestable - Type-driven testing\n\nThis type system is the foundation that enables the clean, type-safe architecture of the entire ControlDESymulation framework!"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#overview",
    "href": "api/type_system/Type_System_Architecture.html#overview",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "The Type System is the foundational layer that provides semantic types, structured results, and type-safe interfaces for the entire framework. It consists of 8 focused modules totaling ~7,000 lines that define over 200 type aliases and structured dictionaries."
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#architecture-philosophy",
    "href": "api/type_system/Type_System_Architecture.html#architecture-philosophy",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "Type-Driven Design - The type system enables:\n\nSemantic Clarity - Names convey mathematical meaning (StateVector, not ArrayLike)\nType Safety - Static type checking via mypy/pyright\nIDE Support - Autocomplete and inline documentation\nBackend Agnosticism - Same types work with NumPy/PyTorch/JAX\nStructured Results - TypedDict for dictionaries (not plain dict)\nSelf-Documenting - Types encode constraints and invariants\n\n# Compare:\ndef bad(x, u):  # What are x and u? Arrays? Scalars? Dimensions?\n    return x + u\n\n# vs:\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear intent: state in, control in, state out.\"\"\"\n    return x + u"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#type-system-layers",
    "href": "api/type_system/Type_System_Architecture.html#type-system-layers",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "┌────────────────────────────────────────────────────────────┐\n│                    APPLICATION LAYER                        │\n│  (UI Framework, Delegation Layer, Integration Framework)   │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ uses types from\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                    TYPE SYSTEM                              │\n│                                                              │\n│  ┌─────────────────────────────────────────────────┐       │\n│  │  FOUNDATIONAL TYPES                             │       │\n│  │  • core.py           - Vectors, matrices        │       │\n│  │  • backends.py       - Backend enums            │       │\n│  └─────────────────────────────────────────────────┘       │\n│                                                              │\n│  ┌─────────────────────────────────────────────────┐       │\n│  │  DOMAIN TYPES                                   │       │\n│  │  • trajectories.py   - Time series results      │       │\n│  │  • linearization.py  - Jacobian tuples          │       │\n│  │  • symbolic.py       - SymPy types              │       │\n│  │  • control_classical.py - Control design results│       │\n│  └─────────────────────────────────────────────────┘       │\n│                                                              │\n│  ┌─────────────────────────────────────────────────┐       │\n│  │  STRUCTURAL TYPES                               │       │\n│  │  • protocols.py      - Abstract interfaces      │       │\n│  │  • utilities.py      - Helper types             │       │\n│  └─────────────────────────────────────────────────┘       │\n└────────────────────────────────────────────────────────────┘"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#module-breakdown",
    "href": "api/type_system/Type_System_Architecture.html#module-breakdown",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "File: core.py (1,501 lines)\nPurpose: Fundamental building blocks for all other types\nCategories:\n1. Multi-Backend Arrays (20+ types)\nArrayLike = Union[np.ndarray, torch.Tensor, jnp.ndarray]\nNumpyArray = np.ndarray\nTorchTensor = torch.Tensor\nJaxArray = jnp.ndarray\nScalarLike = Union[float, int, np.number, torch.Tensor, jnp.ndarray]\nIntegerLike = Union[int, np.integer]\n2. Semantic Vector Types (15+ types)\nStateVector         # x ∈ ℝⁿˣ - State\nControlVector       # u ∈ ℝⁿᵘ - Control input\nOutputVector        # y ∈ ℝⁿʸ - Measured output\nNoiseVector         # w ∈ ℝⁿʷ - Stochastic noise\nEquilibriumState    # x_eq - Equilibrium state\nEquilibriumControl  # u_eq - Equilibrium control\nTimeDerivative      # dx/dt - State derivative\nStateIncrement      # δx - State deviation\nControlIncrement    # δu - Control deviation\n3. Matrix Types (30+ types)\n# Dynamics matrices\nStateMatrix         # A ∈ ℝⁿˣˣⁿˣ - ∂f/∂x\nInputMatrix         # B ∈ ℝⁿˣˣⁿᵘ - ∂f/∂u  \nDiffusionMatrix     # G ∈ ℝⁿˣˣⁿʷ - Noise intensity\n\n# Observation matrices\nOutputMatrix        # C ∈ ℝⁿʸˣⁿˣ - ∂h/∂x\nFeedthroughMatrix   # D ∈ ℝⁿʸˣⁿᵘ - Direct feedthrough\n\n# Control matrices\nGainMatrix          # K ∈ ℝⁿᵘˣⁿˣ - Feedback gain\nCostMatrix          # Q ∈ ℝⁿˣˣⁿˣ - State cost\nControlCostMatrix   # R ∈ ℝⁿᵘˣⁿᵘ - Control cost\n\n# Stochastic matrices\nCovarianceMatrix    # P ∈ ℝⁿˣˣⁿˣ - Covariance\nProcessNoiseMatrix  # Q ∈ ℝⁿˣˣⁿˣ - Process noise cov\nMeasurementNoiseMatrix  # R ∈ ℝⁿʸˣⁿʸ - Measurement noise cov\n\n# Special matrices\nIdentityMatrix      # I ∈ ℝⁿˣⁿ\nZeroMatrix         # 0 ∈ ℝᵐˣⁿ\nGramianMatrix      # Controllability/observability\n4. Function Signatures (10+ types)\nDynamicsFunction    # (x, u) → dx/dt\nOutputFunction      # (x) → y\nControlPolicy       # (t, x) → u\nCostFunction        # (x, u) → scalar\nObserverFunction    # (y, u) → x_hat\n5. System Properties (15+ types)\nStateDimension      # nx - Number of states\nControlDimension    # nu - Number of controls\nOutputDimension     # ny - Number of outputs\nNoiseDimension      # nw - Number of Wiener processes\nSystemOrder         # order - Differential order\n\nEquilibriumPoint    # (x_eq, u_eq) - Tuple\nEquilibriumName     # str - Named equilibrium\nKey Design:\n\nSemantic naming - Type names encode mathematical meaning\nMulti-backend - All types support NumPy/PyTorch/JAX\nComposition - Types compose into higher-level structures\nDocumentation - Each type has examples and constraints\n\n\n\n\n\nFile: backends.py (735 lines)\nPurpose: Backend configuration and method selection types\nCategories:\n1. Backend Types\nBackend = Literal[\"numpy\", \"torch\", \"jax\"]\nDevice = str  # 'cpu', 'cuda:0', 'mps', 'tpu'\n\nclass BackendConfig(TypedDict, total=False):\n    backend: Backend\n    device: Optional[Device]\n    dtype: Optional[str]  # 'float32', 'float64'\n2. Integration Methods\nIntegrationMethod = str  # 'RK45', 'dopri5', 'tsit5', etc.\n\n# Specific categories\nOdeMethod = str          # Deterministic methods\nSdeMethod = str          # Stochastic methods\nFixedStepMethod = str    # Fixed-step methods\nAdaptiveMethod = str     # Adaptive methods\n3. Discretization Methods\nDiscretizationMethod = Literal[\n    \"exact\",      # Matrix exponential\n    \"euler\",      # Forward Euler\n    \"tustin\",     # Bilinear transform\n    \"backward\",   # Backward Euler\n    \"matched\",    # Zero-order hold\n]\n4. SDE Types\nSDEType = Literal[\"ito\", \"stratonovich\"]\n\nclass NoiseType(Enum):\n    ADDITIVE = \"additive\"\n    MULTIPLICATIVE = \"multiplicative\"\n    MULTIPLICATIVE_DIAGONAL = \"multiplicative_diagonal\"\n    MULTIPLICATIVE_SCALAR = \"multiplicative_scalar\"\n    MULTIPLICATIVE_GENERAL = \"multiplicative_general\"\n    UNKNOWN = \"unknown\"\n\nclass ConvergenceType(Enum):\n    STRONG = \"strong\"  # Pathwise convergence\n    WEAK = \"weak\"      # Distribution convergence\n5. System Configuration\nclass SystemConfig(TypedDict, total=False):\n    \"\"\"Complete system configuration.\"\"\"\n    nx: int              # State dimension\n    nu: int              # Control dimension\n    ny: int              # Output dimension\n    nw: int              # Noise dimension\n    order: int           # System order\n    dt: Optional[float]  # Time step (discrete)\n    backend: Backend\n    device: Device\nKey Design:\n\nType-safe enums - Literal types prevent typos\nStructured configs - TypedDict for configuration\nExtensible - Easy to add new methods\nSelf-documenting - Clear valid values\n\n\n\n\n\n\n\n\nFile: `trajectories.py** (879 lines)\nPurpose: Time series data and simulation results\nCategories:\n1. Trajectory Types\nStateTrajectory = ArrayLike      # (T, nx) or (T, batch, nx)\nControlSequence = ArrayLike      # (T, nu) or (T, batch, nu)\nOutputSequence = ArrayLike       # (T, ny)\nNoiseSequence = ArrayLike        # (T, nw)\n2. Time Types\nTimePoints = ArrayLike           # (T,) - Time grid\nTimeSpan = Tuple[float, float]   # (t0, tf) - Interval\nTimeStep = float                 # dt - Step size\n3. Integration Results (TypedDict)\nclass IntegrationResult(TypedDict, total=False):\n    \"\"\"ODE integration result.\"\"\"\n    t: TimePoints              # Time points\n    x: StateTrajectory         # State trajectory (T, nx)\n    success: bool              # Integration succeeded\n    message: str               # Status message\n    nfev: int                  # Function evaluations\n    nsteps: int                # Integration steps\n    integration_time: float    # Wall time (seconds)\n    solver: str                # Integrator name\n    \n    # Optional fields (adaptive methods)\n    njev: int                  # Jacobian evaluations\n    nlu: int                   # LU decompositions\n    status: int                # Solver status code\n    sol: Any                   # Dense output object\n    dense_output: bool         # Dense output available\n4. SDE Integration Results\nclass SDEIntegrationResult(TypedDict, total=False):\n    \"\"\"SDE integration result (extends IntegrationResult).\"\"\"\n    # All IntegrationResult fields, plus:\n    diffusion_evals: int       # Diffusion function calls\n    noise_samples: NoiseVector # Brownian increments used\n    n_paths: int               # Number of trajectories\n    convergence_type: str      # 'strong' or 'weak'\n    sde_type: str              # 'ito' or 'stratonovich'\n    noise_type: str            # Noise structure\n5. Batch Results\nclass BatchSimulationResult(TypedDict):\n    \"\"\"Batched simulation result.\"\"\"\n    t: TimePoints                    # (T,)\n    x: StateTrajectory               # (T, batch, nx)\n    u: ControlSequence               # (T, batch, nu)\n    batch_size: int\n    statistics: Dict[str, ArrayLike] # Mean, std, etc.\nKey Design:\n\nTime-major ordering - (T, nx) not (nx, T)\nTypedDict results - Structured, type-safe dictionaries\nOptional fields - Use total=False for flexibility\nConsistent shapes - All trajectories follow same conventions\n\n\n\n\n\nFile: linearization.py (502 lines)\nPurpose: Linearization results and Jacobian types\nCategories:\n1. Basic Linearization\nDeterministicLinearization = Tuple[StateMatrix, InputMatrix]\n# Returns: (A, B) where\n#   A = ∂f/∂x - State Jacobian\n#   B = ∂f/∂u - Control Jacobian\n\nStochasticLinearization = Tuple[StateMatrix, InputMatrix, DiffusionMatrix]\n# Returns: (A, B, G) where\n#   A = ∂f/∂x\n#   B = ∂f/∂u  \n#   G = ∂g/∂x or g(x_eq) - Diffusion\n\nLinearizationResult = Union[DeterministicLinearization, StochasticLinearization]\n# Polymorphic: works with both\n2. Output Linearization\nObservationLinearization = Tuple[OutputMatrix, FeedthroughMatrix]\n# Returns: (C, D) where\n#   C = ∂h/∂x - Output Jacobian\n#   D = ∂h/∂u - Feedthrough (usually 0)\n3. Full State-Space\nFullLinearization = Tuple[StateMatrix, InputMatrix, OutputMatrix, FeedthroughMatrix]\n# Returns: (A, B, C, D)\n\nFullStochasticLinearization = Tuple[\n    StateMatrix, InputMatrix, DiffusionMatrix, OutputMatrix, FeedthroughMatrix\n]\n# Returns: (A, B, G, C, D)\n4. Time-Domain Aliases\nContinuousLinearization = DeterministicLinearization\nDiscreteLinearization = DeterministicLinearization\nContinuousStochasticLinearization = StochasticLinearization\nDiscreteStochasticLinearization = StochasticLinearization\n5. Jacobian-Specific\nStateJacobian = StateMatrix       # A = ∂f/∂x\nControlJacobian = InputMatrix     # B = ∂f/∂u\nOutputJacobian = OutputMatrix     # C = ∂h/∂x\nDiffusionJacobian = DiffusionMatrix  # G = ∂g/∂x\nKey Design:\n\nTuple returns - Natural unpacking: A, B = linearize()\nPolymorphic types - Union handles deterministic/stochastic\nSemantic aliases - Time-domain context clear\nMathematical clarity - Names match theory\n\n\n\n\n\nFile: symbolic.py (646 lines)\nPurpose: SymPy symbolic types\nCategories:\n1. Symbolic Variables\nSymbolicVariable = sp.Symbol        # Single variable\nSymbolicVector = sp.Matrix          # Vector of symbols\nSymbolicMatrix = sp.Matrix          # Matrix expression\nSymbolicExpression = sp.Expr        # General expression\n2. System Components\nDynamicsExpression = sp.Matrix      # f(x, u) symbolic\nOutputExpression = sp.Matrix        # h(x) symbolic\nDiffusionExpression = sp.Matrix     # g(x, u) symbolic\nParameterDict = Dict[sp.Symbol, float]  # Parameter values\n3. Jacobian Expressions\nJacobianExpression = sp.Matrix      # ∂f/∂x symbolic\nHessianExpression = sp.Matrix       # ∂²f/∂x² symbolic\nGradientExpression = sp.Matrix      # ∇f symbolic\n4. Substitution Types\nSubstitutionDict = Dict[sp.Symbol, Union[float, sp.Expr]]\nSimplificationStrategy = Literal[\"simplify\", \"expand\", \"factor\", \"cancel\"]\nKey Design:\n\nSymPy integration - Bridge symbolic ↔︎ numerical\nType annotations - Clarify SymPy usage\nCode generation - Input to compilation pipeline\nParameter substitution - Clear parameter handling\n\n\n\n\n\nFile: control_classical.py (542 lines)\nPurpose: Classical control theory result types\nCategories:\n1. System Analysis Results\nclass StabilityInfo(TypedDict):\n    \"\"\"Stability analysis result.\n    \n    Stability Criteria:\n    - Continuous: All Re(λ) &lt; 0 (left half-plane)\n    - Discrete: All |λ| &lt; 1 (inside unit circle)\n    \"\"\"\n    eigenvalues: np.ndarray          # Complex eigenvalues\n    magnitudes: np.ndarray           # |λ| values\n    max_magnitude: float             # Spectral radius\n    spectral_radius: float           # Same as max_magnitude\n    is_stable: bool                  # Asymptotically stable\n    is_marginally_stable: bool       # On stability boundary\n    is_unstable: bool                # Unstable\n\nclass ControllabilityInfo(TypedDict, total=False):\n    \"\"\"Controllability analysis result.\n    \n    Test: rank(C) = nx where C = [B AB A²B ... Aⁿ⁻¹B]\n    \"\"\"\n    controllability_matrix: ControllabilityMatrix  # (nx, nx*nu)\n    rank: int                        # Rank of C\n    is_controllable: bool            # rank == nx\n    uncontrollable_modes: Optional[np.ndarray]  # Eigenvalues\n\nclass ObservabilityInfo(TypedDict, total=False):\n    \"\"\"Observability analysis result.\n    \n    Test: rank(O) = nx where O = [C; CA; CA²; ...; CAⁿ⁻¹]\n    \"\"\"\n    observability_matrix: ObservabilityMatrix  # (nx*ny, nx)\n    rank: int                        # Rank of O\n    is_observable: bool              # rank == nx\n    unobservable_modes: Optional[np.ndarray]  # Eigenvalues\n2. Control Design Results\nclass LQRResult(TypedDict):\n    \"\"\"Linear Quadratic Regulator result.\n    \n    Minimizes: J = ∫(x'Qx + u'Ru)dt  (continuous)\n               J = Σ(x'Qx + u'Ru)     (discrete)\n    \n    Control law: u = -Kx\n    \"\"\"\n    gain: GainMatrix                 # Feedback gain K (nu, nx)\n    cost_to_go: CovarianceMatrix     # Riccati solution P (nx, nx)\n    closed_loop_eigenvalues: np.ndarray  # eig(A - BK)\n    stability_margin: float          # Phase/gain margin\n\nclass KalmanFilterResult(TypedDict):\n    \"\"\"Kalman Filter (optimal estimator) result.\n    \n    System:\n        x[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0,Q)\n        y[k] = Cx[k] + v[k],            v ~ N(0,R)\n    \n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    gain: GainMatrix                 # Kalman gain L (nx, ny)\n    error_covariance: CovarianceMatrix  # Error cov P (nx, nx)\n    innovation_covariance: CovarianceMatrix  # Innovation S (ny, ny)\n    observer_eigenvalues: np.ndarray  # eig(A - LC)\n\nclass LQGResult(TypedDict):\n    \"\"\"Linear Quadratic Gaussian controller result.\n    \n    Combines LQR (optimal control) + Kalman (optimal estimation)\n    via separation principle.\n    \n    Controller: u = -Kx̂\n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    control_gain: GainMatrix         # LQR gain K (nu, nx)\n    estimator_gain: GainMatrix       # Kalman gain L (nx, ny)\n    control_cost_to_go: CovarianceMatrix  # Controller Riccati P\n    estimation_error_covariance: CovarianceMatrix  # Estimator Riccati P\n    separation_verified: bool        # Separation principle holds\n    closed_loop_stable: bool         # Overall stability\n    controller_eigenvalues: np.ndarray  # eig(A - BK)\n    estimator_eigenvalues: np.ndarray   # eig(A - LC)\n3. Additional Controllers\nclass PolePlacementResult(TypedDict):\n    \"\"\"Pole placement (eigenvalue assignment) result.\n    \n    Design K such that eig(A - BK) = desired poles\n    \"\"\"\n    gain: GainMatrix                 # State feedback gain K\n    desired_poles: np.ndarray        # Desired eigenvalues\n    achieved_poles: np.ndarray       # Actual eig(A - BK)\n    is_controllable: bool            # Arbitrary placement possible\n\nclass LuenbergerObserverResult(TypedDict):\n    \"\"\"Luenberger observer (deterministic estimator) result.\n    \n    Observer: x̂˙ = Ax̂ + Bu + L(y - Cx̂)\n    Error dynamics: e˙ = (A - LC)e\n    \"\"\"\n    gain: GainMatrix                 # Observer gain L (nx, ny)\n    desired_poles: np.ndarray        # Desired observer poles\n    achieved_poles: np.ndarray       # Actual eig(A - LC)\n    is_observable: bool              # Arbitrary placement possible\nUsage Examples:\n# Stability analysis\nstability: StabilityInfo = analyze_stability(A, system_type='continuous')\nif stability['is_stable']:\n    print(f\"Stable with spectral radius {stability['spectral_radius']:.3f}\")\n\n# LQR design\nlqr: LQRResult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\nclosed_loop_A = A - B @ K\n\n# Kalman filter design\nkalman: KalmanFilterResult = system.control.design_kalman(\n    A, C, Q_process, R_measurement, system_type='discrete'\n)\nL = kalman['gain']\n\n# LQG controller (combined)\nlqg: LQGResult = system.control.design_lqg(\n    A, B, C, Q, R, Q_process, R_measurement, system_type='discrete'\n)\nK = lqg['control_gain']\nL = lqg['estimator_gain']\n\n# Controllability check\nctrl: ControllabilityInfo = analyze_controllability(A, B)\nif ctrl['is_controllable']:\n    print(f\"System is controllable with rank {ctrl['rank']}\")\nKey Design:\n\nTypedDict results - Structured, type-safe returns\nMathematical clarity - Names match control theory\nComplete information - All relevant analysis data\nSeparation principle - LQG designed independently\nStability guarantees - Eigenvalues included\nIDE support - Autocomplete for all fields\n\n\n\n\n\n\n\n\nFile: protocols.py (1,086 lines)\nPurpose: Abstract interfaces via Protocol\nCategories:\n1. System Protocols\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Abstract interface for dynamical systems.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    @property\n    def nu(self) -&gt; int: ...\n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\nclass ContinuousSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Continuous-time system interface.\"\"\"\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable,\n        t_span: TimeSpan\n    ) -&gt; IntegrationResult: ...\n\nclass DiscreteSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Discrete-time system interface.\"\"\"\n    @property\n    def dt(self) -&gt; float: ...\n    def step(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n    def simulate(\n        self,\n        x0: StateVector,\n        u_seq: ControlSequence,\n        steps: int\n    ) -&gt; StateTrajectory: ...\n\nclass StochasticSystemProtocol(Protocol):\n    \"\"\"Stochastic system interface.\"\"\"\n    @property\n    def nw(self) -&gt; int: ...\n    def drift(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n    def diffusion(self, x: StateVector, u: ControlVector) -&gt; DiffusionMatrix: ...\n2. Observer Protocols\nclass ObserverProtocol(Protocol):\n    \"\"\"State observer interface.\"\"\"\n    def observe(self, x: StateVector) -&gt; OutputVector: ...\n    def estimate(self, y: OutputVector, u: ControlVector) -&gt; StateVector: ...\n3. Controller Protocols\nclass ControllerProtocol(Protocol):\n    \"\"\"Controller interface.\"\"\"\n    def compute_control(self, x: StateVector) -&gt; ControlVector: ...\n\nclass FeedbackControllerProtocol(ControllerProtocol, Protocol):\n    \"\"\"Linear feedback controller.\"\"\"\n    @property\n    def K(self) -&gt; GainMatrix: ...\nKey Design:\n\nStructural subtyping - Duck typing with type safety\nInterface documentation - Clear contracts\nComposition - Protocols compose naturally\nNo inheritance - Structural not nominal\n\n\n\n\n\nFile: utilities.py (1,132 lines)\nPurpose: Helper types and utilities\nCategories:\n1. Type Guards\ndef is_numpy(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is NumPy.\"\"\"\n    return isinstance(arr, np.ndarray)\n\ndef is_torch(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is PyTorch.\"\"\"\n    return hasattr(arr, '__module__') and 'torch' in arr.__module__\n\ndef is_jax(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is JAX.\"\"\"\n    return hasattr(arr, '__module__') and 'jax' in arr.__module__\n2. Shape Utilities\ndef is_batched(arr: ArrayLike, expected_dims: int = 1) -&gt; bool:\n    \"\"\"Check if array is batched.\"\"\"\n    return arr.ndim &gt; expected_dims\n\ndef get_batch_size(arr: ArrayLike) -&gt; Optional[int]:\n    \"\"\"Get batch size if batched.\"\"\"\n    return arr.shape[0] if is_batched(arr) else None\n\ndef get_state_dim(x: StateVector) -&gt; int:\n    \"\"\"Get state dimension.\"\"\"\n    return x.shape[-1] if x.ndim &gt; 0 else 1\n3. Performance Types\nclass ExecutionStats(TypedDict):\n    \"\"\"Performance statistics.\"\"\"\n    count: int              # Number of calls\n    total_time: float       # Total time (seconds)\n    avg_time: float         # Average time\n    min_time: float         # Fastest call\n    max_time: float         # Slowest call\n4. Validation Types\nclass ValidationResult(TypedDict):\n    \"\"\"Validation result.\"\"\"\n    valid: bool\n    errors: List[str]\n    warnings: List[str]\n    info: Dict[str, Any]\nKey Design:\n\nRuntime utilities - Complement static types\nType guards - Enable type narrowing\nPerformance tracking - Structured metrics\nValidation - Structured error reporting"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#type-system-design-principles",
    "href": "api/type_system/Type_System_Architecture.html#type-system-design-principles",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "# Bad: Structural (what it is)\ndef compute(arr1: np.ndarray, arr2: np.ndarray) -&gt; np.ndarray:\n    pass\n\n# Good: Semantic (what it means)\ndef compute_control(x: StateVector, K: GainMatrix) -&gt; ControlVector:\n    pass\n\n\n\n# Same function signature works for all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # Works with NumPy, PyTorch, JAX\n    return f(x, u)\n\n\n\n# Bad: Plain dict (no type safety)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# Good: TypedDict (type-safe, documented)\ndef integrate() -&gt; IntegrationResult:\n    return {'t': t, 'x': x, 'success': True, ...}\n\n\n\nclass IntegrationResult(TypedDict, total=False):\n    # Required fields\n    t: TimePoints\n    x: StateTrajectory\n    success: bool\n    \n    # Optional fields (adaptive methods only)\n    njev: int  # May not be present\n    sol: Any   # Dense output (optional)\n\n\n\nLinearizationResult = Union[\n    Tuple[StateMatrix, InputMatrix],           # Deterministic\n    Tuple[StateMatrix, InputMatrix, DiffusionMatrix]  # Stochastic\n]\n\n# Single function handles both\ndef analyze(result: LinearizationResult):\n    A, B = result[0], result[1]\n    if len(result) == 3:\n        G = result[2]  # Stochastic\n\n\n\n# No inheritance needed - structural typing\nclass MySystem:\n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies DynamicalSystemProtocol structurally\nsystem: DynamicalSystemProtocol = MySystem()"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#usage-throughout-the-framework",
    "href": "api/type_system/Type_System_Architecture.html#usage-throughout-the-framework",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "class ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __call__(self, x: StateVector, u: Optional[ControlVector] = None) -&gt; StateVector:\n        \"\"\"Evaluate dynamics.\"\"\"\n        return self._dynamics.evaluate(x, u, backend=self._default_backend)\n    \n    def linearize(\n        self,\n        x_eq: EquilibriumState,\n        u_eq: EquilibriumControl,\n        backend: Backend = \"numpy\"\n    ) -&gt; DeterministicLinearization:\n        \"\"\"Compute linearization.\"\"\"\n        return self._linearization.linearize_continuous(x_eq, u_eq, backend)\n\n\n\nclass DynamicsEvaluator:\n    def evaluate(\n        self,\n        x: StateVector,\n        u: Optional[ControlVector],\n        backend: Backend\n    ) -&gt; StateVector:\n        \"\"\"Evaluate forward dynamics.\"\"\"\n        f_func: DynamicsFunction = self.code_gen.generate_dynamics(backend)\n        return f_func(x, u)\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        \"\"\"Get performance statistics.\"\"\"\n        return {\n            'count': self._call_count,\n            'total_time': self._total_time,\n            'avg_time': self._total_time / self._call_count,\n            'min_time': self._min_time,\n            'max_time': self._max_time\n        }\n\n\n\nclass ScipyIntegrator(IntegratorBase):\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable[[ScalarLike, StateVector], Optional[ControlVector]],\n        t_span: TimeSpan,\n        t_eval: Optional[TimePoints] = None\n    ) -&gt; IntegrationResult:\n        \"\"\"Integrate using scipy.\"\"\"\n        # ... implementation ...\n        \n        result: IntegrationResult = {\n            't': sol.t,\n            'x': sol.y.T,\n            'success': sol.success,\n            'message': sol.message,\n            'nfev': sol.nfev,\n            'nsteps': sol.nfev,\n            'integration_time': elapsed,\n            'solver': self.name\n        }\n        \n        # Optional fields\n        if hasattr(sol, 'njev'):\n            result['njev'] = sol.njev\n        \n        return result"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#file-size-summary",
    "href": "api/type_system/Type_System_Architecture.html#file-size-summary",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "Module\nLines\nCategories\nPurpose\n\n\n\n\ncore.py\n1,501\nVectors, matrices, functions\nFundamental types\n\n\nbackends.py\n735\nBackends, methods, configs\nConfiguration\n\n\ntrajectories.py\n879\nTime series, results\nSimulation data\n\n\nlinearization.py\n502\nJacobians, tuples\nLinearization\n\n\nsymbolic.py\n646\nSymPy types\nSymbolic math\n\n\ncontrol_classical.py\n542\nControl design, analysis\nClassical control\n\n\nprotocols.py\n1,086\nAbstract interfaces\nContracts\n\n\nutilities.py\n1,132\nHelpers, guards\nRuntime support\n\n\nTOTAL\n7,023\n200+ types\nComplete system"
  },
  {
    "objectID": "api/type_system/Type_System_Architecture.html#key-strengths",
    "href": "api/type_system/Type_System_Architecture.html#key-strengths",
    "title": "ControlDESymulation Type System Architecture",
    "section": "",
    "text": "Semantic Clarity - Names convey mathematical meaning\nType Safety - Static checking prevents errors\nIDE Support - Autocomplete and documentation\nBackend Agnostic - Works with NumPy/PyTorch/JAX\nStructured Results - TypedDict not plain dict\nSelf-Documenting - Types encode constraints\nComposition - Types compose naturally\nExtensible - Easy to add new types\nConsistent - Same conventions throughout\nTestable - Type-driven testing\n\nThis type system is the foundation that enables the clean, type-safe architecture of the entire ControlDESymulation framework!"
  },
  {
    "objectID": "api/type_system/type_system_text.html",
    "href": "api/type_system/type_system_text.html",
    "title": "Type System Architecture (Text Diagram)",
    "section": "",
    "text": "═══════════════════════════════════════════════════════════════════════\n                      TYPE SYSTEM ARCHITECTURE\n═══════════════════════════════════════════════════════════════════════\n\n                    ┌──────────────────────────┐\n                    │   APPLICATION LAYER      │\n                    │                          │\n                    │  • UI Framework          │\n                    │  • Delegation Layer      │\n                    │  • Integration Framework │\n                    └──────────┬───────────────┘\n                               │\n                               │ uses types from\n                               │\n                ┌──────────────┴───────────────┐\n                ↓                              ↓\n┏━━━━━━━━━━━━━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ FOUNDATIONAL TYPES      ┃      ┃ DOMAIN TYPES            ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ core.py (1,501 lines)   ┃      ┃ trajectories.py (879)   ┃\n┃ ├─ Multi-Backend Arrays ┃      ┃ ├─ StateTrajectory      ┃\n┃ │  • ArrayLike          ┃      ┃ │  • ControlSequence    ┃\n┃ │  • NumpyArray         ┃      ┃ │  • OutputSequence     ┃\n┃ │  • TorchTensor        ┃      ┃ │  • TimePoints         ┃\n┃ │  • JaxArray           ┃      ┃ └─ IntegrationResult    ┃\n┃ │  • ScalarLike         ┃      ┃    SDEIntegrationResult ┃\n┃ ├─ Semantic Vectors     ┃      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ │  • StateVector        ┃      ┃ linearization.py (502)  ┃\n┃ │  • ControlVector      ┃      ┃ ├─ DeterministicLin     ┃\n┃ │  • OutputVector       ┃      ┃ │  • StochasticLin      ┃\n┃ │  • NoiseVector        ┃      ┃ │  • LinearizationResult┃\n┃ │  • EquilibriumState   ┃      ┃ ├─ ObservationLin       ┃\n┃ ├─ Matrix Types         ┃      ┃ └─ Jacobians           ┃\n┃ │  • StateMatrix        ┃      ┃    • StateJacobian     ┃\n┃ │  • InputMatrix        ┃      ┃    • ControlJacobian   ┃\n┃ │  • OutputMatrix       ┃      ┃    • OutputJacobian    ┃\n┃ │  • GainMatrix         ┃      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ │  • CovarianceMatrix   ┃      ┃ symbolic.py (646)       ┃\n┃ └─ Function Signatures  ┃      ┃ ├─ SymbolicVariable    ┃\n┃    • DynamicsFunction   ┃      ┃ │  • SymbolicVector     ┃\n┃    • OutputFunction     ┃      ┃ │  • SymbolicExpression ┃\n┃    • ControlPolicy      ┃      ┃ ├─ DynamicsExpression  ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┃ │  • OutputExpression   ┃\n┃ backends.py (735 lines) ┃      ┃ │  • DiffusionExpression┃\n┃ ├─ Backend Types        ┃      ┃ └─ ParameterDict       ┃\n┃ │  • Backend            ┃      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ │  • Device             ┃      ┃ control_classical.py    ┃\n┃ │  • BackendConfig      ┃      ┃ ├─ Analysis Results     ┃\n┃ ├─ Integration Methods  ┃      ┃ │  • StabilityInfo      ┃\n┃ │  • IntegrationMethod  ┃      ┃ │  • ControllabilityInfo┃\n┃ │  • OdeMethod          ┃      ┃ │  • ObservabilityInfo  ┃\n┃ │  • SdeMethod          ┃      ┃ ├─ Control Design       ┃\n┃ ├─ Noise Types          ┃      ┃ │  • LQRResult          ┃\n┃ │  • NoiseType          ┃      ┃ │  • KalmanFilterResult ┃\n┃ │  • SDEType            ┃      ┃ │  • LQGResult          ┃\n┃ │  • ConvergenceType    ┃      ┃ └─ Other Controllers    ┃\n┃ └─ Configuration        ┃      ┃    • PolePlacementResult┃\n┃    • SystemConfig       ┃      ┃    • LuenbergerObserver ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\n                                 ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n                                 ┃ utilities.py (1,132)    ┃\n                                 ┃ ├─ Type Guards          ┃\n                                 ┃ │  • is_numpy()         ┃\n                                 ┃ │  • is_torch()         ┃\n                                 ┃ │  • is_jax()           ┃\n                                 ┃ ├─ Shape Utilities      ┃\n                                 ┃ │  • is_batched()       ┃\n                                 ┃ │  • get_batch_size()   ┃\n                                 ┃ ├─ Performance Types    ┃\n                                 ┃ │  • ExecutionStats     ┃\n                                 ┃ └─ Validation Types     ┃\n                                 ┃    • ValidationResult   ┃\n                                 ┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\n\n═══════════════════════════════════════════════════════════════════════\n                        TYPE CATEGORIES\n═══════════════════════════════════════════════════════════════════════\n\n┌────────────────────────┬────────┬──────────────────────────────────┐\n│ Category               │ Count  │ Examples                         │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ VECTOR TYPES           │  15+   │ StateVector, ControlVector,      │\n│                        │        │ NoiseVector, EquilibriumState    │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ MATRIX TYPES           │  30+   │ StateMatrix, GainMatrix,         │\n│                        │        │ CovarianceMatrix, DiffusionMatrix│\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ FUNCTION TYPES         │  10+   │ DynamicsFunction, ControlPolicy, │\n│                        │        │ ObserverFunction                 │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ BACKEND TYPES          │  20+   │ Backend, Device, IntegrationMethod│\n│                        │        │ NoiseType, SDEType               │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ TRAJECTORY TYPES       │  15+   │ StateTrajectory, TimePoints,     │\n│                        │        │ IntegrationResult                │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ LINEARIZATION TYPES    │  15+   │ DeterministicLinearization,      │\n│                        │        │ StateJacobian, LinearizationResult│\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ CONTROL TYPES          │  8     │ LQRResult, KalmanFilterResult,   │\n│                        │        │ LQGResult, StabilityInfo         │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ SYMBOLIC TYPES         │  10+   │ SymbolicExpression, ParameterDict│\n│                        │        │ DynamicsExpression               │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ PROTOCOL TYPES         │  20+   │ DynamicalSystemProtocol,         │\n│                        │        │ ContinuousSystemProtocol         │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ UTILITY TYPES          │  20+   │ ExecutionStats, ValidationResult,│\n│                        │        │ Type guards, shape utilities     │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ TYPEDDICT RESULTS      │  20+   │ IntegrationResult,               │\n│                        │        │ SDEIntegrationResult,            │\n│                        │        │ LQRResult, LQGResult             │\n├────────────────────────┼────────┼──────────────────────────────────┤\n│ TOTAL TYPES            │ 200+   │                                  │\n└────────────────────────┴────────┴──────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        DESIGN PRINCIPLES\n═══════════════════════════════════════════════════════════════════════\n\n1. SEMANTIC OVER STRUCTURAL\n   ┌────────────────────────────────────────┐\n   │ Bad:  arr1: np.ndarray                 │\n   │ Good: x: StateVector                   │\n   │                                        │\n   │ Name conveys MEANING not just TYPE     │\n   └────────────────────────────────────────┘\n\n2. BACKEND AGNOSTICISM\n   ┌────────────────────────────────────────┐\n   │ ArrayLike = Union[                     │\n   │   np.ndarray,                          │\n   │   torch.Tensor,                        │\n   │   jnp.ndarray                          │\n   │ ]                                      │\n   │                                        │\n   │ Same types work across all backends    │\n   └────────────────────────────────────────┘\n\n3. TYPEDDICT FOR STRUCTURES\n   ┌────────────────────────────────────────┐\n   │ Bad:  def f() -&gt; dict                  │\n   │ Good: def f() -&gt; IntegrationResult     │\n   │                                        │\n   │ class IntegrationResult(TypedDict):    │\n   │     t: TimePoints                      │\n   │     x: StateTrajectory                 │\n   │     success: bool                      │\n   │                                        │\n   │ Type-safe, IDE-friendly, documented    │\n   └────────────────────────────────────────┘\n\n4. OPTIONAL FIELDS VIA total=False\n   ┌────────────────────────────────────────┐\n   │ class IntegrationResult(               │\n   │     TypedDict, total=False             │\n   │ ):                                     │\n   │     # Required                         │\n   │     t: TimePoints                      │\n   │     success: bool                      │\n   │                                        │\n   │     # Optional                         │\n   │     njev: int  # Adaptive only         │\n   │     sol: Any   # Dense output          │\n   └────────────────────────────────────────┘\n\n5. PROTOCOLS NOT INHERITANCE\n   ┌────────────────────────────────────────┐\n   │ class System:  # No inheritance!       │\n   │     def __call__(self, x, u): ...      │\n   │                                        │\n   │ # Satisfies protocol structurally:     │\n   │ system: DynamicalSystemProtocol = ...  │\n   │                                        │\n   │ Structural subtyping (duck typing)     │\n   └────────────────────────────────────────┘\n\n6. POLYMORPHIC VIA UNION\n   ┌────────────────────────────────────────┐\n   │ LinearizationResult = Union[           │\n   │     Tuple[A, B],        # Deterministic│\n   │     Tuple[A, B, G]      # Stochastic   │\n   │ ]                                      │\n   │                                        │\n   │ result = system.linearize(...)         │\n   │ A, B = result[0], result[1]            │\n   │ if len(result) == 3:                   │\n   │     G = result[2]  # Stochastic        │\n   └────────────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        USAGE FLOW\n═══════════════════════════════════════════════════════════════════════\n\n1. IMPORT TYPES\n   from src.types.core import StateVector, ControlVector\n   from src.types.backends import Backend\n   from src.types.trajectories import IntegrationResult\n\n2. TYPE ANNOTATIONS\n   def dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n       return f(x, u)\n\n3. STRUCTURED RESULTS\n   result: IntegrationResult = integrator.integrate(x0, u_func, t_span)\n\n4. TYPE-SAFE ACCESS\n   t: TimePoints = result['t']\n   x: StateTrajectory = result['x']\n   success: bool = result['success']\n\n5. IDE AUTOCOMPLETE\n   result['  # IDE shows: t, x, success, nfev, ...\n\n6. STATIC TYPE CHECKING\n   $ mypy src/\n   Success: no issues found in 50 source files\n\n\n═══════════════════════════════════════════════════════════════════════\n                        FILE STATISTICS\n═══════════════════════════════════════════════════════════════════════\n\n┌─────────────────────┬─────────┬────────────────────────────────┐\n│ Module              │ Lines   │ Purpose                        │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ FOUNDATIONAL        │         │                                │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ core.py             │  1,501  │ Vectors, matrices, functions   │\n│ backends.py         │    735  │ Backends, configs, methods     │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ Subtotal            │  2,236  │                                │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ DOMAIN              │         │                                │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ trajectories.py     │    879  │ Time series, results           │\n│ linearization.py    │    502  │ Jacobians, tuples              │\n│ symbolic.py         │    646  │ SymPy types                    │\n│ control_classical.py│    542  │ Control design results         │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ Subtotal            │  2,569  │                                │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ STRUCTURAL          │         │                                │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ protocols.py        │  1,086  │ Abstract interfaces            │\n│ utilities.py        │  1,132  │ Helpers, guards                │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ Subtotal            │  2,218  │                                │\n├─────────────────────┼─────────┼────────────────────────────────┤\n│ TOTAL               │  7,023  │ 200+ types                     │\n└─────────────────────┴─────────┴────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        KEY BENEFITS\n═══════════════════════════════════════════════════════════════════════\n\n✓ SEMANTIC CLARITY\n  Names encode mathematical meaning\n\n✓ TYPE SAFETY\n  Static checking prevents errors\n\n✓ IDE SUPPORT\n  Autocomplete and inline docs\n\n✓ BACKEND AGNOSTIC\n  NumPy/PyTorch/JAX seamless\n\n✓ STRUCTURED RESULTS\n  TypedDict not plain dict\n\n✓ SELF-DOCUMENTING\n  Types encode constraints\n\n✓ COMPOSITION\n  Types compose naturally\n\n✓ EXTENSIBLE\n  Easy to add new types\n\n✓ CONSISTENT\n  Same patterns throughout\n\n✓ TESTABLE\n  Type-driven testing\n\n\n═══════════════════════════════════════════════════════════════════════\n\n\nFoundation: 7,023 lines defining 200+ types\nPhilosophy: Type-driven design for clarity and safety\nArchitecture: 3 layers (Foundational, Domain, Structural)\nImpact: Enables clean, type-safe code throughout framework\nResult: Self-documenting, IDE-friendly, statically checkable codebase"
  },
  {
    "objectID": "api/type_system/type_system_text.html#type-system-summary",
    "href": "api/type_system/type_system_text.html#type-system-summary",
    "title": "Type System Architecture (Text Diagram)",
    "section": "",
    "text": "Foundation: 7,023 lines defining 200+ types\nPhilosophy: Type-driven design for clarity and safety\nArchitecture: 3 layers (Foundational, Domain, Structural)\nImpact: Enables clean, type-safe code throughout framework\nResult: Self-documenting, IDE-friendly, statically checkable codebase"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html",
    "href": "api/ui_framework/UI_Framework_Architecture.html",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "The UI (User Interface) framework consists of 8 core files organized into a 4-layer architecture that eliminates ~1,800 lines of code duplication while maintaining clean separation of concerns.\n\n\n\nLayer 0: SymbolicSystemBase (time-domain agnostic)\n         |\n         +------------------+\n         |                  |\nLayer 1: ContinuousSystemBase  DiscreteSystemBase\n         (continuous)       (discrete)\n         |                  |\n         +--------+         +--------+\n         |        |         |        |\nLayer 2: Continuous Discrete  Continuous Discrete\n         Symbolic   Symbolic  Stochastic Stochastic\n         |          |         |          |\nLayer 3: ContinuousStochasticSystem  DiscreteStochasticSystem\n         (extends Layer 2)            (extends Layer 2)\n\n\n\n\n\nFile: symbolic_system_base.py\nPurpose: Time-domain agnostic symbolic machinery\nResponsibilities:\n\nSymbolic variable management (state_vars, control_vars, output_vars)\nParameter handling and substitution\nCode generation via CodeGenerator (multi-backend)\nBackend management (NumPy, PyTorch, JAX)\nEquilibrium point management (add, get, remove, list)\nConfiguration persistence (save/load JSON)\nPerformance tracking and statistics\nAbstract methods: define_system(), print_equations()\n\nKey Design:\n\nUses composition for utilities (BackendManager, CodeGenerator, EquilibriumHandler, SymbolicValidator)\nTemplate method pattern: __init__ orchestrates define → validate → initialize\nMakes NO assumptions about continuous vs discrete time\n\nWhat it does NOT provide:\n\nForward dynamics evaluation (__call__, step)\nTime integration (integrate, simulate)\nLinearization computation\nThese are left to time-domain-specific layers\n\n\n\n\n\n\n\nFile: continuous_system_base.py\nPurpose: Abstract interface for continuous-time systems\nCore Interface:\ndx/dt = f(x, u, t)  # Continuous dynamics\n\n# Abstract methods (must implement):\n- __call__(x, u, t) → dx/dt          # Evaluate dynamics\n- integrate(x0, u, t_span) → result  # Numerical integration\n- linearize(x_eq, u_eq) → (A, B)     # Jacobian matrices\n\n# Concrete method (provided):\n- simulate(x0, controller, t_span, dt) → result  # High-level simulation\nKey Features:\n\nFlexible control input handling (None, arrays, callables)\nMulti-backend integration support\nDense output and adaptive stepping\nComprehensive solver diagnostics\n\n\n\n\nFile: discrete_system_base.py\nPurpose: Abstract interface for discrete-time systems\nCore Interface:\nx[k+1] = f(x[k], u[k], k)  # Discrete dynamics\n\n# Abstract property:\n- dt: float  # Sampling period (must implement)\n\n# Abstract methods:\n- step(x, u, k) → x_next              # Single step\n- simulate(x0, u_sequence, n_steps)   # Multi-step simulation\n- linearize(x_eq, u_eq) → (Ad, Bd)    # Discrete Jacobians\n\n# Concrete method (provided):\n- rollout(x0, policy, n_steps)  # Closed-loop simulation\nKey Features:\n\nTime-major array convention: (n_steps, nx)\nState-feedback policy support\nSampling frequency properties\n\n\n\n\n\n\n\n\nFile: continuous_symbolic_system.py\nInheritance: SymbolicSystemBase + ContinuousSystemBase\nPurpose: Combines symbolic machinery with continuous-time execution\nKey Components:\n\nDynamicsEvaluator: Evaluates dx/dt = f(x, u)\nLinearizationEngine: Computes A = ∂f/∂x, B = ∂f/∂u\nObservationEngine: Evaluates y = h(x), C = ∂h/∂x\nIntegratorFactory: Creates appropriate ODE solvers\n\nUsage Pattern:\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, param1=1.0):\n        # Define state_vars, control_vars\n        # Set self._f_sym (drift)\n        # Set self.parameters\n        # Set self.order\n\n\n\nFile: discrete_symbolic_system.py (1,020 lines)\nInheritance: SymbolicSystemBase + DiscreteSystemBase\nPurpose: Combines symbolic machinery with discrete-time execution\nKey Components:\n\nDynamicsEvaluator: Evaluates x[k+1] = f(x[k], u[k])\nLinearizationEngine: Computes Ad = ∂f/∂x, Bd = ∂f/∂u\nObservationEngine: Evaluates y[k] = h(x[k])\n\nCritical Requirement: Must set self._dt in define_system()\nUsage Pattern:\nclass MyDiscreteSystem(DiscreteSymbolicSystem):\n    def define_system(self, dt=0.01, param1=1.0):\n        # Define state_vars, control_vars\n        # Set self._f_sym (next state function)\n        # Set self.parameters\n        # Set self._dt  # REQUIRED!\n        # Set self.order\n\n\n\n\n\n\n\nFile: continuous_stochastic_system.py (1,103 lines)\nInheritance: ContinuousSymbolicSystem (single inheritance)\nPurpose: Adds stochastic differential equation (SDE) support\nMathematical Form:\ndx = f(x, u, t)dt + g(x, u, t)dW\n\nwhere:\n- f: Drift (inherited from parent)\n- g: Diffusion matrix (added here)\n- dW: Brownian motion increments\nKey Components:\n\nDiffusionHandler: Generates and caches diffusion functions\nNoiseCharacterizer: Automatic noise structure analysis\nSDEValidator: SDE-specific validation\nSDEIntegratorFactory: Stochastic integration methods\n\nNoise Types (Auto-Detected):\n\nADDITIVE: g(x,u,t) = constant\nMULTIPLICATIVE: g(x,u,t) depends on state\nDIAGONAL: Independent noise sources\nSCALAR: Single Wiener process\nGENERAL: Full coupling\n\nUsage Pattern:\nclass MySDESystem(ContinuousStochasticSystem):\n    def define_system(self, sigma=0.5):\n        # Define drift (same as continuous symbolic)\n        # ... state_vars, _f_sym, parameters, order ...\n        \n        # ADD: Define diffusion\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'  # or 'stratonovich'\n\n\n\nFile: discrete_stochastic_system.py (1,383 lines)\nInheritance: DiscreteSymbolicSystem (single inheritance)\nPurpose: Adds stochastic difference equation support\nMathematical Form:\nx[k+1] = f(x[k], u[k]) + g(x[k], u[k])·w[k]\n\nwhere:\n- f: Deterministic dynamics (inherited from parent)\n- g: Diffusion matrix\n- w[k]: Discrete-time noise\nSimilar structure to continuous stochastic but for discrete-time\n\n\n\n\n\nFile: discretized_system.py (4,916 lines!)\nPurpose: Creates discrete-time approximations from continuous systems\nKey Features:\n\nMultiple discretization methods (Euler, RK4, Tustin, etc.)\nPreserves symbolic structure when possible\nHandles both deterministic and stochastic systems\nAutomatic validation of discretization accuracy\n\n\n\n\n\n\n\n\n\nLayer 2 uses multiple inheritance to combine:\n\nSymbolic machinery (SymbolicSystemBase)\nTime-domain interface (ContinuousSystemBase or DiscreteSystemBase)\n\nUses super().__init__() for proper MRO (Method Resolution Order)\n\n\n\n\n\nSpecialized functionality delegated to utility classes:\n\nBackendManager\nCodeGenerator\nEquilibriumHandler\nDynamicsEvaluator\nLinearizationEngine\nObservationEngine\n\n\n\n\n\n\nBase classes define workflow\nSubclasses fill in specific implementations\ndefine_system() is the key extension point\n\n\n\n\n\nLayer 0: Symbolic manipulation (time-agnostic)\nLayer 1: Time-domain semantics (abstract)\nLayer 2: Concrete execution (symbolic + time-domain)\nLayer 3: Specialized extensions (stochastic)\n\n\n\n\n\nThe ~1,800 lines previously duplicated between continuous and discrete are now in SymbolicSystemBase\nStochastic systems extend deterministic via single inheritance\nNo repeated code for backend management, code generation, etc.\n\n\n\n\n\n\n\nIn SymbolicSystemBase subclasses:\ndef define_system(self, **params):\n    \"\"\"Define symbolic system.\n    \n    Must set:\n    - self.state_vars: List[sp.Symbol]\n    - self.control_vars: List[sp.Symbol]\n    - self._f_sym: sp.Matrix (dynamics)\n    - self.parameters: Dict[sp.Symbol, float]\n    - self.order: int\n    \n    For discrete: Must also set self._dt\n    For stochastic: Must also set self.diffusion_expr\n    \"\"\"\n\ndef print_equations(self, simplify=True):\n    \"\"\"Print system equations in readable form.\"\"\"\n\n\n\nAll systems provide:\n- nx: int          # State dimension\n- nu: int          # Control dimension  \n- ny: int          # Output dimension\n- nq: int          # Physical dimension (nx / order)\n- order: int       # System order\n\n# Discrete only:\n- dt: float        # Sampling period\n- sampling_frequency: float\n\n# Stochastic only:\n- nw: int          # Number of Wiener processes\n- is_additive_noise(): bool\n- is_multiplicative_noise(): bool\n\n\n\n\nAll systems support multi-backend execution:\n\nNumPy: Default, CPU-based\nPyTorch: GPU acceleration, automatic differentiation\nJAX: XLA compilation, automatic differentiation\nJulia (via DiffEqPy): High-performance ODE/SDE solvers\n\n\n\n\n\n\n\nscipy: RK45, RK23, DOP853, Radau, BDF, LSODA\nJulia (DiffEqPy): Tsit5, Vern7, Vern9, Rodas5, etc.\nJAX (diffrax): dopri5, tsit5, heun, etc.\nPyTorch (torchdiffeq): dopri5, euler, rk4, etc.\n\n\n\n\n\nsdeint: euler-maruyama, milstein, etc.\ntorchsde: euler, heun, srk, reversible_heun\nJAX implementations: euler-maruyama with noise analysis\n\n\n\n\n\n\n\nfrom src.systems.base import ContinuousSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass Pendulum(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, l=0.5, g=9.81, b=0.1):\n        theta, omega = sp.symbols('theta omega', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, l_sym, g_sym, b_sym = sp.symbols('m l g b', positive=True)\n        \n        self.state_vars = [theta, omega]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            omega,\n            -(g_sym/l_sym)*sp.sin(theta) - (b_sym/(m_sym*l_sym**2))*omega + u/(m_sym*l_sym**2)\n        ])\n        self.parameters = {m_sym: m, l_sym: l, g_sym: g, b_sym: b}\n        self.order = 1\n\n# Use\nsystem = Pendulum(m=0.5, l=0.3)\nx = np.array([0.1, 0.0])\ndx = system(x, u=np.array([0.0]))  # Evaluate dynamics\nresult = system.integrate(x, u=None, t_span=(0, 5), method='RK45')\nA, B = system.linearize(np.zeros(2), np.zeros(1))\n\n\n\nclass DiscreteLinear(DiscreteSymbolicSystem):\n    def define_system(self, a=0.9, b=0.1, dt=0.01):\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        a_sym, b_sym = sp.symbols('a b', real=True)\n        \n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([a_sym*x + b_sym*u])\n        self.parameters = {a_sym: a, b_sym: b}\n        self._dt = dt  # REQUIRED!\n        self.order = 1\n\n# Use\nsystem = DiscreteLinear(a=0.95, dt=0.1)\nx_next = system.step(x, u)\nresult = system.simulate(x0, u_sequence=None, n_steps=100)\n\n\n\nclass OrnsteinUhlenbeck(ContinuousStochasticSystem):\n    def define_system(self, alpha=1.0, sigma=0.5):\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        alpha_sym = sp.symbols('alpha', positive=True)\n        sigma_sym = sp.symbols('sigma', positive=True)\n        \n        # Drift\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n        self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'\n\n# Use\nsystem = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nprint(system.is_additive_noise())  # True\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='euler-maruyama')\n\n\n\n\n\nClean separation of concerns - each layer has a single responsibility\nZero code duplication - symbolic machinery shared across all systems\nType safety - comprehensive TypedDict definitions throughout\nBackend flexibility - seamlessly switch between NumPy/PyTorch/JAX/Julia\nExtensibility - easy to add new system types via inheritance\nMathematical rigor - proper handling of ODEs, SDEs, difference equations\nPerformance - multi-backend support enables GPU acceleration\nDocumentation - extensive docstrings with mathematical notation\n\nThis is production-quality systems engineering with excellent abstraction layers!"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#overview",
    "href": "api/ui_framework/UI_Framework_Architecture.html#overview",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "The UI (User Interface) framework consists of 8 core files organized into a 4-layer architecture that eliminates ~1,800 lines of code duplication while maintaining clean separation of concerns."
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#architecture-layers",
    "href": "api/ui_framework/UI_Framework_Architecture.html#architecture-layers",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "Layer 0: SymbolicSystemBase (time-domain agnostic)\n         |\n         +------------------+\n         |                  |\nLayer 1: ContinuousSystemBase  DiscreteSystemBase\n         (continuous)       (discrete)\n         |                  |\n         +--------+         +--------+\n         |        |         |        |\nLayer 2: Continuous Discrete  Continuous Discrete\n         Symbolic   Symbolic  Stochastic Stochastic\n         |          |         |          |\nLayer 3: ContinuousStochasticSystem  DiscreteStochasticSystem\n         (extends Layer 2)            (extends Layer 2)"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#layer-breakdown",
    "href": "api/ui_framework/UI_Framework_Architecture.html#layer-breakdown",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "File: symbolic_system_base.py\nPurpose: Time-domain agnostic symbolic machinery\nResponsibilities:\n\nSymbolic variable management (state_vars, control_vars, output_vars)\nParameter handling and substitution\nCode generation via CodeGenerator (multi-backend)\nBackend management (NumPy, PyTorch, JAX)\nEquilibrium point management (add, get, remove, list)\nConfiguration persistence (save/load JSON)\nPerformance tracking and statistics\nAbstract methods: define_system(), print_equations()\n\nKey Design:\n\nUses composition for utilities (BackendManager, CodeGenerator, EquilibriumHandler, SymbolicValidator)\nTemplate method pattern: __init__ orchestrates define → validate → initialize\nMakes NO assumptions about continuous vs discrete time\n\nWhat it does NOT provide:\n\nForward dynamics evaluation (__call__, step)\nTime integration (integrate, simulate)\nLinearization computation\nThese are left to time-domain-specific layers\n\n\n\n\n\n\n\nFile: continuous_system_base.py\nPurpose: Abstract interface for continuous-time systems\nCore Interface:\ndx/dt = f(x, u, t)  # Continuous dynamics\n\n# Abstract methods (must implement):\n- __call__(x, u, t) → dx/dt          # Evaluate dynamics\n- integrate(x0, u, t_span) → result  # Numerical integration\n- linearize(x_eq, u_eq) → (A, B)     # Jacobian matrices\n\n# Concrete method (provided):\n- simulate(x0, controller, t_span, dt) → result  # High-level simulation\nKey Features:\n\nFlexible control input handling (None, arrays, callables)\nMulti-backend integration support\nDense output and adaptive stepping\nComprehensive solver diagnostics\n\n\n\n\nFile: discrete_system_base.py\nPurpose: Abstract interface for discrete-time systems\nCore Interface:\nx[k+1] = f(x[k], u[k], k)  # Discrete dynamics\n\n# Abstract property:\n- dt: float  # Sampling period (must implement)\n\n# Abstract methods:\n- step(x, u, k) → x_next              # Single step\n- simulate(x0, u_sequence, n_steps)   # Multi-step simulation\n- linearize(x_eq, u_eq) → (Ad, Bd)    # Discrete Jacobians\n\n# Concrete method (provided):\n- rollout(x0, policy, n_steps)  # Closed-loop simulation\nKey Features:\n\nTime-major array convention: (n_steps, nx)\nState-feedback policy support\nSampling frequency properties\n\n\n\n\n\n\n\n\nFile: continuous_symbolic_system.py\nInheritance: SymbolicSystemBase + ContinuousSystemBase\nPurpose: Combines symbolic machinery with continuous-time execution\nKey Components:\n\nDynamicsEvaluator: Evaluates dx/dt = f(x, u)\nLinearizationEngine: Computes A = ∂f/∂x, B = ∂f/∂u\nObservationEngine: Evaluates y = h(x), C = ∂h/∂x\nIntegratorFactory: Creates appropriate ODE solvers\n\nUsage Pattern:\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, param1=1.0):\n        # Define state_vars, control_vars\n        # Set self._f_sym (drift)\n        # Set self.parameters\n        # Set self.order\n\n\n\nFile: discrete_symbolic_system.py (1,020 lines)\nInheritance: SymbolicSystemBase + DiscreteSystemBase\nPurpose: Combines symbolic machinery with discrete-time execution\nKey Components:\n\nDynamicsEvaluator: Evaluates x[k+1] = f(x[k], u[k])\nLinearizationEngine: Computes Ad = ∂f/∂x, Bd = ∂f/∂u\nObservationEngine: Evaluates y[k] = h(x[k])\n\nCritical Requirement: Must set self._dt in define_system()\nUsage Pattern:\nclass MyDiscreteSystem(DiscreteSymbolicSystem):\n    def define_system(self, dt=0.01, param1=1.0):\n        # Define state_vars, control_vars\n        # Set self._f_sym (next state function)\n        # Set self.parameters\n        # Set self._dt  # REQUIRED!\n        # Set self.order\n\n\n\n\n\n\n\nFile: continuous_stochastic_system.py (1,103 lines)\nInheritance: ContinuousSymbolicSystem (single inheritance)\nPurpose: Adds stochastic differential equation (SDE) support\nMathematical Form:\ndx = f(x, u, t)dt + g(x, u, t)dW\n\nwhere:\n- f: Drift (inherited from parent)\n- g: Diffusion matrix (added here)\n- dW: Brownian motion increments\nKey Components:\n\nDiffusionHandler: Generates and caches diffusion functions\nNoiseCharacterizer: Automatic noise structure analysis\nSDEValidator: SDE-specific validation\nSDEIntegratorFactory: Stochastic integration methods\n\nNoise Types (Auto-Detected):\n\nADDITIVE: g(x,u,t) = constant\nMULTIPLICATIVE: g(x,u,t) depends on state\nDIAGONAL: Independent noise sources\nSCALAR: Single Wiener process\nGENERAL: Full coupling\n\nUsage Pattern:\nclass MySDESystem(ContinuousStochasticSystem):\n    def define_system(self, sigma=0.5):\n        # Define drift (same as continuous symbolic)\n        # ... state_vars, _f_sym, parameters, order ...\n        \n        # ADD: Define diffusion\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'  # or 'stratonovich'\n\n\n\nFile: discrete_stochastic_system.py (1,383 lines)\nInheritance: DiscreteSymbolicSystem (single inheritance)\nPurpose: Adds stochastic difference equation support\nMathematical Form:\nx[k+1] = f(x[k], u[k]) + g(x[k], u[k])·w[k]\n\nwhere:\n- f: Deterministic dynamics (inherited from parent)\n- g: Diffusion matrix\n- w[k]: Discrete-time noise\nSimilar structure to continuous stochastic but for discrete-time\n\n\n\n\n\nFile: discretized_system.py (4,916 lines!)\nPurpose: Creates discrete-time approximations from continuous systems\nKey Features:\n\nMultiple discretization methods (Euler, RK4, Tustin, etc.)\nPreserves symbolic structure when possible\nHandles both deterministic and stochastic systems\nAutomatic validation of discretization accuracy"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#design-principles",
    "href": "api/ui_framework/UI_Framework_Architecture.html#design-principles",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "Layer 2 uses multiple inheritance to combine:\n\nSymbolic machinery (SymbolicSystemBase)\nTime-domain interface (ContinuousSystemBase or DiscreteSystemBase)\n\nUses super().__init__() for proper MRO (Method Resolution Order)\n\n\n\n\n\nSpecialized functionality delegated to utility classes:\n\nBackendManager\nCodeGenerator\nEquilibriumHandler\nDynamicsEvaluator\nLinearizationEngine\nObservationEngine\n\n\n\n\n\n\nBase classes define workflow\nSubclasses fill in specific implementations\ndefine_system() is the key extension point\n\n\n\n\n\nLayer 0: Symbolic manipulation (time-agnostic)\nLayer 1: Time-domain semantics (abstract)\nLayer 2: Concrete execution (symbolic + time-domain)\nLayer 3: Specialized extensions (stochastic)\n\n\n\n\n\nThe ~1,800 lines previously duplicated between continuous and discrete are now in SymbolicSystemBase\nStochastic systems extend deterministic via single inheritance\nNo repeated code for backend management, code generation, etc."
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#key-abstractions",
    "href": "api/ui_framework/UI_Framework_Architecture.html#key-abstractions",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "In SymbolicSystemBase subclasses:\ndef define_system(self, **params):\n    \"\"\"Define symbolic system.\n    \n    Must set:\n    - self.state_vars: List[sp.Symbol]\n    - self.control_vars: List[sp.Symbol]\n    - self._f_sym: sp.Matrix (dynamics)\n    - self.parameters: Dict[sp.Symbol, float]\n    - self.order: int\n    \n    For discrete: Must also set self._dt\n    For stochastic: Must also set self.diffusion_expr\n    \"\"\"\n\ndef print_equations(self, simplify=True):\n    \"\"\"Print system equations in readable form.\"\"\"\n\n\n\nAll systems provide:\n- nx: int          # State dimension\n- nu: int          # Control dimension  \n- ny: int          # Output dimension\n- nq: int          # Physical dimension (nx / order)\n- order: int       # System order\n\n# Discrete only:\n- dt: float        # Sampling period\n- sampling_frequency: float\n\n# Stochastic only:\n- nw: int          # Number of Wiener processes\n- is_additive_noise(): bool\n- is_multiplicative_noise(): bool"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#backend-support",
    "href": "api/ui_framework/UI_Framework_Architecture.html#backend-support",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "All systems support multi-backend execution:\n\nNumPy: Default, CPU-based\nPyTorch: GPU acceleration, automatic differentiation\nJAX: XLA compilation, automatic differentiation\nJulia (via DiffEqPy): High-performance ODE/SDE solvers"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#integration-methods",
    "href": "api/ui_framework/UI_Framework_Architecture.html#integration-methods",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "scipy: RK45, RK23, DOP853, Radau, BDF, LSODA\nJulia (DiffEqPy): Tsit5, Vern7, Vern9, Rodas5, etc.\nJAX (diffrax): dopri5, tsit5, heun, etc.\nPyTorch (torchdiffeq): dopri5, euler, rk4, etc.\n\n\n\n\n\nsdeint: euler-maruyama, milstein, etc.\ntorchsde: euler, heun, srk, reversible_heun\nJAX implementations: euler-maruyama with noise analysis"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#usage-examples",
    "href": "api/ui_framework/UI_Framework_Architecture.html#usage-examples",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "from src.systems.base import ContinuousSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass Pendulum(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, l=0.5, g=9.81, b=0.1):\n        theta, omega = sp.symbols('theta omega', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, l_sym, g_sym, b_sym = sp.symbols('m l g b', positive=True)\n        \n        self.state_vars = [theta, omega]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            omega,\n            -(g_sym/l_sym)*sp.sin(theta) - (b_sym/(m_sym*l_sym**2))*omega + u/(m_sym*l_sym**2)\n        ])\n        self.parameters = {m_sym: m, l_sym: l, g_sym: g, b_sym: b}\n        self.order = 1\n\n# Use\nsystem = Pendulum(m=0.5, l=0.3)\nx = np.array([0.1, 0.0])\ndx = system(x, u=np.array([0.0]))  # Evaluate dynamics\nresult = system.integrate(x, u=None, t_span=(0, 5), method='RK45')\nA, B = system.linearize(np.zeros(2), np.zeros(1))\n\n\n\nclass DiscreteLinear(DiscreteSymbolicSystem):\n    def define_system(self, a=0.9, b=0.1, dt=0.01):\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        a_sym, b_sym = sp.symbols('a b', real=True)\n        \n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([a_sym*x + b_sym*u])\n        self.parameters = {a_sym: a, b_sym: b}\n        self._dt = dt  # REQUIRED!\n        self.order = 1\n\n# Use\nsystem = DiscreteLinear(a=0.95, dt=0.1)\nx_next = system.step(x, u)\nresult = system.simulate(x0, u_sequence=None, n_steps=100)\n\n\n\nclass OrnsteinUhlenbeck(ContinuousStochasticSystem):\n    def define_system(self, alpha=1.0, sigma=0.5):\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        alpha_sym = sp.symbols('alpha', positive=True)\n        sigma_sym = sp.symbols('sigma', positive=True)\n        \n        # Drift\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n        self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'\n\n# Use\nsystem = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nprint(system.is_additive_noise())  # True\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='euler-maruyama')"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#file-size-summary",
    "href": "api/ui_framework/UI_Framework_Architecture.html#file-size-summary",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "File\nLines\nPurpose\n\n\n\n\nsymbolic_system_base.py\n1,678\nFoundation (Layer 0)\n\n\ncontinuous_system_base.py\n915\nContinuous interface (Layer 1)\n\n\ndiscrete_system_base.py\n487\nDiscrete interface (Layer 1)\n\n\ncontinuous_symbolic_system.py\n1,318\nContinuous concrete (Layer 2)\n\n\ndiscrete_symbolic_system.py\n1,020\nDiscrete concrete (Layer 2)\n\n\ncontinuous_stochastic_system.py\n1,103\nContinuous SDE (Layer 3)\n\n\ndiscrete_stochastic_system.py\n1,383\nDiscrete stochastic (Layer 3)\n\n\ndiscretized_system.py\n4,916\nDiscretization utility\n\n\n\nTotal: ~12,820 lines of production-ready code with comprehensive documentation"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Architecture.html#strengths-of-this-architecture",
    "href": "api/ui_framework/UI_Framework_Architecture.html#strengths-of-this-architecture",
    "title": "ControlDESymulation UI Framework Architecture",
    "section": "",
    "text": "Clean separation of concerns - each layer has a single responsibility\nZero code duplication - symbolic machinery shared across all systems\nType safety - comprehensive TypedDict definitions throughout\nBackend flexibility - seamlessly switch between NumPy/PyTorch/JAX/Julia\nExtensibility - easy to add new system types via inheritance\nMathematical rigor - proper handling of ODEs, SDEs, difference equations\nPerformance - multi-backend support enables GPU acceleration\nDocumentation - extensive docstrings with mathematical notation\n\nThis is production-quality systems engineering with excellent abstraction layers!"
  },
  {
    "objectID": "api/control_framework/control_framework_text.html",
    "href": "api/control_framework/control_framework_text.html",
    "title": "Control Framework Architecture (Text Diagram)",
    "section": "",
    "text": "═══════════════════════════════════════════════════════════════════════\n                   CONTROL FRAMEWORK ARCHITECTURE\n═══════════════════════════════════════════════════════════════════════\n\n                    ┌──────────────────────────┐\n                    │  APPLICATION LAYER       │\n                    │                          │\n                    │  ContinuousSystemBase    │\n                    │  DiscreteSystemBase      │\n                    └──────────┬───────────────┘\n                               │\n                ┌──────────────┴───────────────┐\n                │                              │\n                ↓                              ↓\n    ┌───────────────────────┐      ┌───────────────────────┐\n    │  system.control       │      │  system.analysis      │\n    │  ControlSynthesis     │      │  SystemAnalysis       │\n    │  (388 lines)          │      │  (431 lines)          │\n    └───────────┬───────────┘      └───────────┬───────────┘\n                │                              │\n                │  delegates to                │  delegates to\n                │                              │\n                └──────────────┬───────────────┘\n                               │\n                               ↓\n            ┌──────────────────────────────────────┐\n            │  PURE FUNCTION LAYER                 │\n            │  classical_control_functions.py      │\n            │  (967 lines)                         │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ Control Design Functions       │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • design_lqr()                 │ │\n            │  │ • design_kalman_filter()       │ │\n            │  │ • design_lqg()                 │ │\n            │  └────────────────────────────────┘ │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ System Analysis Functions      │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • analyze_stability()          │ │\n            │  │ • analyze_controllability()    │ │\n            │  │ • analyze_observability()      │ │\n            │  └────────────────────────────────┘ │\n            │                                      │\n            │  All functions are:                  │\n            │  - Pure (no state)                   │\n            │  - Backend agnostic                  │\n            │  - TypedDict results                 │\n            └──────────────┬───────────────────────┘\n                           │ returns\n                           ↓\n            ┌──────────────────────────────────────┐\n            │  TYPE LAYER                          │\n            │  control_classical.py (542 lines)    │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ Analysis Result Types          │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • StabilityInfo                │ │\n            │  │ • ControllabilityInfo          │ │\n            │  │ • ObservabilityInfo            │ │\n            │  └────────────────────────────────┘ │\n            │                                      │\n            │  ┌────────────────────────────────┐ │\n            │  │ Control Design Result Types    │ │\n            │  ├────────────────────────────────┤ │\n            │  │ • LQRResult                    │ │\n            │  │ • KalmanFilterResult           │ │\n            │  │ • LQGResult                    │ │\n            │  └────────────────────────────────┘ │\n            └──────────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        MODULE BREAKDOWN\n═══════════════════════════════════════════════════════════════════════\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ PURE FUNCTION LAYER: classical_control_functions.py (967 lines) ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nControl Design Functions\n├─ design_lqr()\n│  ├─ Continuous-time LQR\n│  │  └─&gt; solve_continuous_are(A, B, Q, R)\n│  ├─ Discrete-time LQR\n│  │  └─&gt; solve_discrete_are(A, B, Q, R)\n│  └─&gt; Returns: LQRResult\n│\n├─ design_kalman_filter()\n│  ├─ Continuous-time Kalman\n│  │  └─&gt; solve_continuous_are(A.T, C.T, Q, R)\n│  ├─ Discrete-time Kalman\n│  │  └─&gt; solve_discrete_are(A.T, C.T, Q, R)\n│  └─&gt; Returns: KalmanFilterResult\n│\n└─ design_lqg()\n   ├─&gt; Calls: design_lqr() + design_kalman_filter()\n   ├─&gt; Verifies: separation_principle\n   ├─&gt; Checks: closed_loop_stability\n   └─&gt; Returns: LQGResult\n\nSystem Analysis Functions\n├─ analyze_stability()\n│  ├─&gt; Computes: eigenvalues of A\n│  ├─&gt; Tests:\n│  │  • Continuous: Re(λ) &lt; 0 ?\n│  │  • Discrete:   |λ| &lt; 1 ?\n│  └─&gt; Returns: StabilityInfo\n│\n├─ analyze_controllability()\n│  ├─&gt; Constructs: C = [B AB A²B ... Aⁿ⁻¹B]\n│  ├─&gt; Computes: rank(C)\n│  ├─&gt; Tests: rank(C) == nx ?\n│  └─&gt; Returns: ControllabilityInfo\n│\n└─ analyze_observability()\n   ├─&gt; Constructs: O = [C; CA; CA²; ...; CAⁿ⁻¹]\n   ├─&gt; Computes: rank(O)\n   ├─&gt; Tests: rank(O) == nx ?\n   └─&gt; Returns: ObservabilityInfo\n\nInternal Utilities\n├─ _to_numpy(arr, backend)\n│  └─&gt; Converts: torch/jax → numpy (for scipy)\n│\n└─ _from_numpy(arr, backend)\n   └─&gt; Converts: numpy → torch/jax (back to original)\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ WRAPPER LAYER                                                    ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nControlSynthesis (388 lines)\n├─ __init__(backend)\n│  └─&gt; Stores: self.backend\n│\n├─ design_lqr(A, B, Q, R, N, system_type)\n│  └─&gt; Routes: design_lqr(..., backend=self.backend)\n│\n├─ design_kalman(A, C, Q, R, system_type)\n│  └─&gt; Routes: design_kalman_filter(..., backend=self.backend)\n│\n└─ design_lqg(A, B, C, Q_state, R_control, Q_process, R_measurement, N, system_type)\n   └─&gt; Routes: design_lqg(..., backend=self.backend)\n\nSystemAnalysis (431 lines)\n├─ __init__(backend)\n│  └─&gt; Stores: self.backend\n│\n├─ stability(A, system_type)\n│  └─&gt; Routes: analyze_stability(..., backend=self.backend)\n│\n├─ controllability(A, B)\n│  └─&gt; Routes: analyze_controllability(..., backend=self.backend)\n│\n└─ observability(A, C)\n   └─&gt; Routes: analyze_observability(..., backend=self.backend)\n\n\n═══════════════════════════════════════════════════════════════════════\n                        INTEGRATION WITH SYSTEMS\n═══════════════════════════════════════════════════════════════════════\n\nContinuousSystemBase / DiscreteSystemBase\n│\n├─&gt; @property control(self) -&gt; ControlSynthesis\n│   └─&gt; if not hasattr(self, '_control_synthesis'):\n│       └─&gt; self._control_synthesis = ControlSynthesis(self._default_backend)\n│   └─&gt; return self._control_synthesis\n│\n└─&gt; @property analysis(self) -&gt; SystemAnalysis\n    └─&gt; if not hasattr(self, '_system_analysis'):\n        └─&gt; self._system_analysis = SystemAnalysis(self._default_backend)\n    └─&gt; return self._system_analysis\n\nUsage:\n    system = Pendulum()\n    system.set_default_backend('torch')\n    \n    # Automatic backend handling\n    result = system.control.design_lqr(A, B, Q, R)\n    # ↑ Uses 'torch' backend automatically\n    \n    stability = system.analysis.stability(A)\n    # ↑ Uses 'torch' backend automatically\n\n\n═══════════════════════════════════════════════════════════════════════\n                        ALGORITHM FLOW\n═══════════════════════════════════════════════════════════════════════\n\nLQR Design Flow:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. User calls: system.control.design_lqr(A, B, Q, R)           │\n│    ↓                                                             │\n│ 2. ControlSynthesis routes to: design_lqr(..., backend='torch')│\n│    ↓                                                             │\n│ 3. design_lqr() converts: A, B, Q, R  →  NumPy                 │\n│    ↓                                                             │\n│ 4. Solve Riccati: solve_continuous_are(A_np, B_np, Q_np, R_np) │\n│    ↓                                                             │\n│ 5. Compute gain: K = R⁻¹B'P                                    │\n│    ↓                                                             │\n│ 6. Compute eigenvalues: eig(A - BK)                            │\n│    ↓                                                             │\n│ 7. Convert back: K_np, P_np  →  torch.Tensor                   │\n│    ↓                                                             │\n│ 8. Return: LQRResult with all fields                           │\n└─────────────────────────────────────────────────────────────────┘\n\nLQG Design Flow:\n┌─────────────────────────────────────────────────────────────────┐\n│ 1. User calls: system.control.design_lqg(A, B, C, ...)         │\n│    ↓                                                             │\n│ 2. design_lqg() internally calls:                              │\n│    ├─&gt; lqr_result = design_lqr(A, B, Q_state, R_control)       │\n│    └─&gt; kalman_result = design_kalman_filter(A, C, Q_proc, R_m) │\n│    ↓                                                             │\n│ 3. Extract gains:                                               │\n│    ├─&gt; K = lqr_result['gain']                                  │\n│    └─&gt; L = kalman_result['gain']                               │\n│    ↓                                                             │\n│ 4. Verify separation principle:                                │\n│    └─&gt; closed_loop_stable = all(eig(A-BK) ∪ eig(A-LC) stable) │\n│    ↓                                                             │\n│ 5. Return: LQGResult with combined information                 │\n└─────────────────────────────────────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        FILE SIZE SUMMARY\n═══════════════════════════════════════════════════════════════════════\n\n┌──────────────────────────────┬────────┬──────────────────────────┐\n│ Module                       │ Lines  │ Purpose                  │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ PURE FUNCTION LAYER          │        │                          │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ classical_control_functions  │   967  │ Stateless algorithms     │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ WRAPPER LAYER                │        │                          │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ control_synthesis            │   388  │ Control design wrapper   │\n│ system_analysis              │   431  │ System analysis wrapper  │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ TYPE LAYER                   │        │                          │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ control_classical            │   542  │ TypedDict results        │\n├──────────────────────────────┼────────┼──────────────────────────┤\n│ TOTAL                        │ 2,328  │ Complete framework       │\n└──────────────────────────────┴────────┴──────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        DESIGN PHILOSOPHY\n═══════════════════════════════════════════════════════════════════════\n\n✓ PURE FUNCTIONS\n  Stateless algorithms like scipy\n  Easy to test, easy to reason about\n\n✓ THIN WRAPPERS\n  Minimal composition layer\n  No business logic in wrappers\n\n✓ COMPOSITION OVER INHERITANCE\n  Systems use utilities via properties\n  Not inherited methods\n\n✓ TYPE SAFETY\n  All results are TypedDict\n  IDE autocomplete support\n\n✓ BACKEND AGNOSTIC\n  Internal conversion to/from NumPy\n  Transparent to user\n\n✓ SEPARATION OF CONCERNS\n  Analysis ≠ Synthesis\n  Clear boundaries\n\n✓ MATHEMATICAL RIGOR\n  Correct classical control theory\n  Verified against textbooks\n\n✓ SCIPY-LIKE API\n  Familiar to control engineers\n  Takes matrices, returns dicts\n\n\n═══════════════════════════════════════════════════════════════════════\n                        KEY ALGORITHMS\n═══════════════════════════════════════════════════════════════════════\n\nContinuous-Time LQR:\n    Minimize: J = ∫₀^∞ (x'Qx + u'Ru) dt\n    Riccati:  A'P + PA - PBR⁻¹B'P + Q = 0\n    Gain:     K = R⁻¹B'P\n    Control:  u = -Kx\n\nDiscrete-Time LQR:\n    Minimize: J = Σₖ (x'Qx + u'Ru)\n    Riccati:  P = A'PA - A'PB(R+B'PB)⁻¹B'PA + Q\n    Gain:     K = (R+B'PB)⁻¹B'PA\n    Control:  u[k] = -Kx[k]\n\nKalman Filter:\n    System:   x[k+1] = Ax[k] + Bu[k] + w[k]\n              y[k] = Cx[k] + v[k]\n    Gain:     L = APC'(CPC'+R)⁻¹\n    Estimate: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n\nLQG Controller:\n    Controller: u = -Kx̂\n    Estimator:  x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    Separation: Design K and L independently\n    Poles:      eig(A-BK) ∪ eig(A-LC)\n\n\n═══════════════════════════════════════════════════════════════════════\n\n\nTotal Lines: 2,328 (framework) + 542 (types) = 2,870 lines\nArchitecture: Pure functions + thin wrappers + composition\nCore Functions: 6 (3 design + 3 analysis)\nIntegration: Via system.control and system.analysis properties\nPhilosophy: Functional design, type safety, backend agnosticism\nResult: Production-ready classical control theory framework!"
  },
  {
    "objectID": "api/control_framework/control_framework_text.html#summary",
    "href": "api/control_framework/control_framework_text.html#summary",
    "title": "Control Framework Architecture (Text Diagram)",
    "section": "",
    "text": "Total Lines: 2,328 (framework) + 542 (types) = 2,870 lines\nArchitecture: Pure functions + thin wrappers + composition\nCore Functions: 6 (3 design + 3 analysis)\nIntegration: Via system.control and system.analysis properties\nPhilosophy: Functional design, type safety, backend agnosticism\nResult: Production-ready classical control theory framework!"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "from src.systems.examples import Pendulum\nimport numpy as np\n\n# Create system\nsystem = Pendulum()\n\n# Linearize at equilibrium\nx_eq = np.array([np.pi, 0])  # Upright position\nu_eq = np.zeros(1)\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])   # State cost\nR = np.array([[0.1]])  # Control cost\n\nresult = system.control.design_lqr(\n    A, B, Q, R,\n    system_type='continuous'\n)\n\n# Extract gain\nK = result['gain']\nprint(f\"LQR gain: {K}\")\nprint(f\"Stable: {np.all(np.real(result['closed_loop_eigenvalues']) &lt; 0)}\")\n\n# Apply controller\nu = -K @ (x - x_eq)\n\n\n\n# Define measurement model\nC = np.array([[1, 0]])  # Measure position only\n\n# Define noise covariances\nQ_process = 0.01 * np.eye(2)  # Process noise\nR_meas = np.array([[0.1]])     # Measurement noise\n\n# Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_meas,\n    system_type='continuous'\n)\n\n# Extract Kalman gain\nL = kalman['gain']\nprint(f\"Observer stable: {np.all(np.abs(kalman['observer_eigenvalues']) &lt; 1)}\")\n\n# Use in estimation loop\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Prediction\n    x_hat_pred = A @ x_hat + B @ u[k]\n    \n    # Correction\n    innovation = y[k] - C @ x_hat_pred\n    x_hat = x_hat_pred + L @ innovation\n\n\n\n# Design combined LQR + Kalman filter\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state=np.diag([10, 1]),\n    R_control=np.array([[0.1]]),\n    Q_process=0.01 * np.eye(2),\n    R_measurement=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Extract both gains\nK = lqg['control_gain']      # LQR gain\nL = lqg['estimator_gain']    # Kalman gain\n\nprint(f\"LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"Separation verified: {lqg['separation_verified']}\")\n\n# Implement LQG controller\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Control (certainty equivalence)\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Prediction\n    x_hat = A @ x_hat + B @ u[k]\n    \n    # Measurement update\n    innovation = y[k] - C @ x_hat\n    x_hat = x_hat + L @ innovation\n\n\n\n# Check stability\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Stable: {stability['is_stable']}\")\nprint(f\"Eigenvalues: {stability['eigenvalues']}\")\n\n# Check controllability\nctrl = system.analysis.controllability(A, B)\nprint(f\"Controllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']}\")\n\n# Check observability\nobs = system.analysis.observability(A, C)\nprint(f\"Observable: {obs['is_observable']}\")\n\n\n\n\n\n\n\n# Continuous-time LQR\nresult = system.control.design_lqr(\n    A, B,\n    Q=np.diag([10, 1]),\n    R=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Discrete-time LQR\nresult = system.control.design_lqr(\n    A, B,\n    Q=np.diag([10, 1]),\n    R=np.array([[0.1]]),\n    system_type='discrete'\n)\n\n# With cross-coupling term\nresult = system.control.design_lqr(\n    A, B,\n    Q=np.diag([10, 1]),\n    R=np.array([[0.1]]),\n    N=np.array([[0.5], [0.1]]),  # Cross-coupling\n    system_type='continuous'\n)\n\n# Access result fields\nK = result['gain']                         # Feedback gain (nu, nx)\nP = result['cost_to_go']                   # Riccati solution (nx, nx)\neigs = result['closed_loop_eigenvalues']   # eig(A - BK)\nmargin = result['stability_margin']        # Robustness measure\n\n# Verify stability\nis_stable_continuous = np.all(np.real(eigs) &lt; 0)\nis_stable_discrete = np.all(np.abs(eigs) &lt; 1)\n\n\n\n# Continuous-time Kalman filter\nkalman = system.control.design_kalman(\n    A, C,\n    Q=0.01 * np.eye(2),\n    R=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Discrete-time Kalman filter\nkalman = system.control.design_kalman(\n    A, C,\n    Q=0.01 * np.eye(2),\n    R=np.array([[0.1]]),\n    system_type='discrete'\n)\n\n# Access result fields\nL = kalman['gain']                      # Kalman gain (nx, ny)\nP = kalman['error_covariance']          # Error covariance (nx, nx)\nS = kalman['innovation_covariance']     # Innovation cov (ny, ny)\neigs = kalman['observer_eigenvalues']   # eig(A - LC)\n\n# Verify observer stability\nobs_stable_continuous = np.all(np.real(eigs) &lt; 0)\nobs_stable_discrete = np.all(np.abs(eigs) &lt; 1)\n\n\n\n# Design LQG (LQR + Kalman via separation principle)\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state=np.diag([10, 1]),      # LQR state cost\n    R_control=np.array([[0.1]]),   # LQR control cost\n    Q_process=0.01 * np.eye(2),    # Process noise covariance\n    R_measurement=np.array([[0.1]]),  # Measurement noise covariance\n    system_type='continuous'\n)\n\n# Access result fields\nK = lqg['control_gain']                # LQR gain (nu, nx)\nL = lqg['estimator_gain']              # Kalman gain (nx, ny)\nP_ctrl = lqg['control_cost_to_go']     # Controller Riccati\nP_est = lqg['estimation_error_covariance']  # Estimator Riccati\nstable = lqg['closed_loop_stable']     # Overall stability\nseparated = lqg['separation_verified']  # Separation principle\nctrl_eigs = lqg['controller_eigenvalues']  # eig(A - BK)\nest_eigs = lqg['estimator_eigenvalues']    # eig(A - LC)\n\n# Verify separation principle\nassert separated, \"Separation principle should hold\"\nprint(f\"Combined system stable: {stable}\")\n\n\n\n\n\n\n\n# Continuous-time stability\nstability = system.analysis.stability(A, system_type='continuous')\n\n# Discrete-time stability\nstability = system.analysis.stability(A, system_type='discrete')\n\n# Access result fields\neigs = stability['eigenvalues']          # Complex eigenvalues\nmags = stability['magnitudes']           # |λ| values\nrho = stability['spectral_radius']       # max |λ|\nis_stable = stability['is_stable']       # Asymptotic stability\nis_marginal = stability['is_marginally_stable']  # On boundary\nis_unstable = stability['is_unstable']   # Unstable\n\n# Stability criteria\nif stability['is_stable']:\n    print(\"System is asymptotically stable\")\nelif stability['is_marginally_stable']:\n    print(\"System is marginally stable\")\nelse:\n    print(\"System is unstable\")\n    print(f\"Unstable eigenvalues: {eigs[np.real(eigs) &gt; 0]}\")  # Continuous\n    print(f\"Unstable eigenvalues: {eigs[np.abs(eigs) &gt; 1]}\")   # Discrete\n\n\n\n# Check controllability\nctrl = system.analysis.controllability(A, B)\n\n# Access result fields\nC_matrix = ctrl['controllability_matrix']  # (nx, nx*nu)\nrank = ctrl['rank']                        # Rank of C_matrix\ncontrollable = ctrl['is_controllable']     # rank == nx\n\n# Check for uncontrollable modes\nif not controllable:\n    uncontrol_modes = ctrl['uncontrollable_modes']\n    print(f\"Uncontrollable eigenvalues: {uncontrol_modes}\")\n    \n# Verify for LQR design\nif controllable:\n    print(\"✓ System is controllable - can design LQR\")\nelse:\n    print(\"✗ System not controllable - LQR may fail\")\n    print(f\"Controllability rank: {rank} / {A.shape[0]}\")\n\n\n\n# Check observability\nobs = system.analysis.observability(A, C)\n\n# Access result fields\nO_matrix = obs['observability_matrix']  # (nx*ny, nx)\nrank = obs['rank']                      # Rank of O_matrix\nobservable = obs['is_observable']       # rank == nx\n\n# Check for unobservable modes\nif not observable:\n    unobs_modes = obs['unobservable_modes']\n    print(f\"Unobservable eigenvalues: {unobs_modes}\")\n\n# Verify for Kalman filter design\nif observable:\n    print(\"✓ System is observable - can design Kalman filter\")\nelse:\n    print(\"✗ System not observable - Kalman filter may fail\")\n    print(f\"Observability rank: {rank} / {A.shape[0]}\")\n\n\n\n\n\n\n\n# 1. Linearize at equilibrium\nA, B = system.linearize(x_eq, u_eq)\n\n# 2. Design LQR\nQ = np.diag([10, 1])   # Penalize states\nR = np.array([[0.1]])  # Penalize control\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = result['gain']\n\n# 3. Implement controller\ndef lqr_controller(x, t):\n    return -K @ (x - x_eq)\n\n# 4. Simulate\nresult_sim = system.simulate(\n    x0=x0,\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\n# 1. Design controller (assumes full state)\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Partial measurement\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\n\n# 2. Design observer\nkalman = system.control.design_kalman(A, C, Q_proc, R_meas, system_type='continuous')\nL = kalman['gain']\n\n# 3. Implement observer-based controller\nx_hat = np.zeros(system.nx)\n\ndef observer_controller(x, t):\n    # Use estimated state\n    return -K @ (x_hat - x_eq)\n\n# 4. Update loop\nfor k in range(N):\n    # Get measurement\n    y_meas = C @ x_true[k] + noise[k]\n    \n    # Control based on estimate\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Propagate estimate\n    x_hat_dot = A @ x_hat + B @ u[k] + L @ (y_meas - C @ x_hat)\n    x_hat += dt * x_hat_dot\n\n\n\n# 1. Design combined LQG\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state, R_control,\n    Q_process, R_measurement,\n    system_type='continuous'\n)\n\nK = lqg['control_gain']\nL = lqg['estimator_gain']\n\n# 2. Initialize estimate\nx_hat = np.zeros(system.nx)\n\n# 3. Control loop\nfor k in range(N):\n    # Certainty equivalence control\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Get measurement\n    y_meas = C @ x_true[k] + meas_noise[k]\n    \n    # Prediction step\n    x_hat = A @ x_hat + B @ u[k]\n    \n    # Correction step\n    innovation = y_meas - C @ x_hat\n    x_hat = x_hat + L @ innovation\n\n\n\n# 1. Design discrete LQR\nAd, Bd = discrete_system.linearize(x_eq, u_eq)\nresult = discrete_system.control.design_lqr(\n    Ad, Bd, Q, R,\n    system_type='discrete'  # Important!\n)\nK = result['gain']\n\n# 2. Discrete control law\nfor k in range(N):\n    u[k] = -K @ (x[k] - x_eq)\n    x[k+1] = discrete_system.step(x[k], u[k])\n\n\n\n# Bryson's rule: Normalize by maximum acceptable values\nx_max = np.array([0.5, 2.0])  # Max acceptable deviation\nu_max = np.array([10.0])      # Max acceptable control\n\nQ = np.diag(1 / x_max**2)\nR = np.diag(1 / u_max**2)\n\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Iterate if needed\nfor q_scale in [1.0, 10.0, 100.0]:\n    Q_scaled = q_scale * Q\n    result = system.control.design_lqr(A, B, Q_scaled, R, system_type='continuous')\n    \n    # Check performance\n    K = result['gain']\n    closed_loop_poles = result['closed_loop_eigenvalues']\n    print(f\"q_scale={q_scale}: poles = {closed_loop_poles}\")\n\n\n\n# Before designing controllers, verify system properties\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])\n\n# 1. Check stability of open-loop\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Open-loop stable: {stability['is_stable']}\")\n\n# 2. Check controllability (required for LQR)\nctrl = system.analysis.controllability(A, B)\nif not ctrl['is_controllable']:\n    print(\"WARNING: System not controllable - LQR may fail\")\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 3. Check observability (required for Kalman)\nobs = system.analysis.observability(A, C)\nif not obs['is_observable']:\n    print(\"WARNING: System not observable - Kalman filter may fail\")\n    print(f\"Unobservable modes: {obs['unobservable_modes']}\")\n\n# 4. Proceed with design only if conditions met\nif ctrl['is_controllable'] and obs['is_observable']:\n    lqg = system.control.design_lqg(A, B, C, Q, R, Q_proc, R_meas)\n    print(\"✓ LQG design successful\")\n\n\n\nimport torch\nimport jax.numpy as jnp\n\n# NumPy backend (default)\nsystem_np = Pendulum()\nsystem_np.set_default_backend('numpy')\nresult_np = system_np.control.design_lqr(A_np, B_np, Q_np, R_np)\n\n# PyTorch backend\nsystem_torch = Pendulum()\nsystem_torch.set_default_backend('torch')\nsystem_torch.set_default_device('cuda:0')\nA_torch = torch.tensor(A_np, device='cuda:0')\nB_torch = torch.tensor(B_np, device='cuda:0')\nresult_torch = system_torch.control.design_lqr(A_torch, B_torch, Q_torch, R_torch)\n\n# Result is on GPU\nassert result_torch['gain'].device.type == 'cuda'\n\n# JAX backend\nsystem_jax = Pendulum()\nsystem_jax.set_default_backend('jax')\nA_jax = jnp.array(A_np)\nB_jax = jnp.array(B_np)\nresult_jax = system_jax.control.design_lqr(A_jax, B_jax, Q_jax, R_jax)\n\n\n\n\n\n\n\nPossible Causes: - System not controllable - (Q, A) not detectable - Ill-conditioned matrices\nSolutions:\n# 1. Check controllability\nctrl = system.analysis.controllability(A, B)\nif not ctrl['is_controllable']:\n    print(f\"System not controllable. Rank: {ctrl['rank']}/{A.shape[0]}\")\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 2. Add regularization to Q\nQ_regularized = Q + 1e-6 * np.eye(nx)\n\n# 3. Check (Q, A) detectability\n# All uncontrollable modes should have Re(λ) &lt; 0 (continuous)\n# or |λ| &lt; 1 (discrete)\n\n\n\nPossible Causes: - System not observable - (A, Q^(1/2)) not controllable - Singular measurement noise R\nSolutions:\n# 1. Check observability\nobs = system.analysis.observability(A, C)\nif not obs['is_observable']:\n    print(f\"System not observable. Rank: {obs['rank']}/{A.shape[0]}\")\n    \n    # Try adding measurements\n    C_full = np.eye(nx)\n    obs_full = system.analysis.observability(A, C_full)\n    print(f\"With full state measurement: {obs_full['is_observable']}\")\n\n# 2. Ensure R is positive definite\nR_regularized = R + 1e-6 * np.eye(ny)\n\n# 3. Check process noise controllability\n# All unobservable modes should be damped by process noise\n\n\n\nPossible Causes: - Wrong system_type (continuous vs discrete) - Numerical errors in linearization - Equilibrium not actually an equilibrium\nSolutions:\n# 1. Verify equilibrium\nf_eq = system(x_eq, u_eq)\nprint(f\"f(x_eq, u_eq) = {f_eq}\")  # Should be near zero\nassert np.allclose(f_eq, 0, atol=1e-6), \"Not an equilibrium!\"\n\n# 2. Check linearization accuracy\ndx_linear = A @ (x - x_eq) + B @ (u - u_eq)\ndx_nonlinear = system(x, u)\nerror = np.linalg.norm(dx_linear - dx_nonlinear)\nprint(f\"Linearization error: {error}\")\n\n# 3. Verify system_type matches system\nif isinstance(system, ContinuousSystemBase):\n    system_type = 'continuous'\nelif isinstance(system, DiscreteSystemBase):\n    system_type = 'discrete'\n\nresult = system.control.design_lqr(A, B, Q, R, system_type=system_type)\n\n\n\nThis is expected! - LQG closed-loop has 2*nx eigenvalues - Should be: eig(A-BK) ∪ eig(A-LC)\n# Verify separation\nlqr = system.control.design_lqr(A, B, Q, R)\nkalman = system.control.design_kalman(A, C, Q_proc, R_meas)\nlqg = system.control.design_lqg(A, B, C, Q, R, Q_proc, R_meas)\n\n# Combined eigenvalues\ncombined = np.concatenate([\n    lqr['closed_loop_eigenvalues'],\n    kalman['observer_eigenvalues']\n])\n\n# Should match LQG eigenvalues (up to ordering)\nlqg_combined = np.concatenate([\n    lqg['controller_eigenvalues'],\n    lqg['estimator_eigenvalues']\n])\n\nassert np.allclose(sorted(combined), sorted(lqg_combined))\n\n\n\n\n\nFor cases where you need to use control functions without a system object:\nfrom src.control.classical_control_functions import (\n    design_lqr,\n    design_kalman_filter,\n    design_lqg,\n    analyze_stability,\n    analyze_controllability,\n    analyze_observability\n)\nimport numpy as np\n\n# Define matrices directly\nA = np.array([[0, 1], [-2, -3]])\nB = np.array([[0], [1]])\nC = np.array([[1, 0]])\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\n\n# Call functions directly\nlqr_result = design_lqr(A, B, Q, R, system_type='continuous', backend='numpy')\nK = lqr_result['gain']\n\nkalman_result = design_kalman_filter(\n    A, C,\n    Q=0.01*np.eye(2),\n    R=np.array([[0.1]]),\n    system_type='continuous',\n    backend='numpy'\n)\nL = kalman_result['gain']\n\n# Analysis\nstability = analyze_stability(A, system_type='continuous', backend='numpy')\nctrl = analyze_controllability(A, B, backend='numpy')\nobs = analyze_observability(A, C, backend='numpy')\n\n\n\n\ndef test_lqr_design():\n    \"\"\"Test LQR controller design and stability.\"\"\"\n    # Create system\n    system = Pendulum()\n    x_eq = np.array([np.pi, 0])\n    u_eq = np.zeros(1)\n    \n    # Linearize\n    A, B = system.linearize(x_eq, u_eq)\n    \n    # Design LQR\n    Q = np.diag([10, 1])\n    R = np.array([[0.1]])\n    result = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n    \n    # Test 1: Gain has correct shape\n    K = result['gain']\n    assert K.shape == (1, 2), f\"Gain shape incorrect: {K.shape}\"\n    \n    # Test 2: Closed-loop is stable\n    eigs = result['closed_loop_eigenvalues']\n    assert np.all(np.real(eigs) &lt; 0), \"Closed-loop unstable!\"\n    \n    # Test 3: P is positive definite\n    P = result['cost_to_go']\n    assert np.all(np.linalg.eigvals(P) &gt; 0), \"P not positive definite!\"\n    \n    # Test 4: P satisfies Riccati equation\n    # A'P + PA - PBR^{-1}B'P + Q = 0\n    riccati_error = A.T @ P + P @ A - P @ B @ np.linalg.solve(R, B.T @ P) + Q\n    assert np.allclose(riccati_error, 0, atol=1e-6), \"Riccati not satisfied!\"\n    \n    print(\"✓ All LQR tests passed\")\n\ntest_lqr_design()\n\n\n\n\n\nArchitecture: See Control_Framework_Architecture.md for complete details\nType Definitions: See Type_System_Architecture.md for TypedDict documentation\nPure Functions: See src/control/classical_control_functions.py\nWrappers: See src/control/control_synthesis.py and src/control/system_analysis.py"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#quick-start",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#quick-start",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "from src.systems.examples import Pendulum\nimport numpy as np\n\n# Create system\nsystem = Pendulum()\n\n# Linearize at equilibrium\nx_eq = np.array([np.pi, 0])  # Upright position\nu_eq = np.zeros(1)\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])   # State cost\nR = np.array([[0.1]])  # Control cost\n\nresult = system.control.design_lqr(\n    A, B, Q, R,\n    system_type='continuous'\n)\n\n# Extract gain\nK = result['gain']\nprint(f\"LQR gain: {K}\")\nprint(f\"Stable: {np.all(np.real(result['closed_loop_eigenvalues']) &lt; 0)}\")\n\n# Apply controller\nu = -K @ (x - x_eq)\n\n\n\n# Define measurement model\nC = np.array([[1, 0]])  # Measure position only\n\n# Define noise covariances\nQ_process = 0.01 * np.eye(2)  # Process noise\nR_meas = np.array([[0.1]])     # Measurement noise\n\n# Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_meas,\n    system_type='continuous'\n)\n\n# Extract Kalman gain\nL = kalman['gain']\nprint(f\"Observer stable: {np.all(np.abs(kalman['observer_eigenvalues']) &lt; 1)}\")\n\n# Use in estimation loop\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Prediction\n    x_hat_pred = A @ x_hat + B @ u[k]\n    \n    # Correction\n    innovation = y[k] - C @ x_hat_pred\n    x_hat = x_hat_pred + L @ innovation\n\n\n\n# Design combined LQR + Kalman filter\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state=np.diag([10, 1]),\n    R_control=np.array([[0.1]]),\n    Q_process=0.01 * np.eye(2),\n    R_measurement=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Extract both gains\nK = lqg['control_gain']      # LQR gain\nL = lqg['estimator_gain']    # Kalman gain\n\nprint(f\"LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"Separation verified: {lqg['separation_verified']}\")\n\n# Implement LQG controller\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Control (certainty equivalence)\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Prediction\n    x_hat = A @ x_hat + B @ u[k]\n    \n    # Measurement update\n    innovation = y[k] - C @ x_hat\n    x_hat = x_hat + L @ innovation\n\n\n\n# Check stability\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Stable: {stability['is_stable']}\")\nprint(f\"Eigenvalues: {stability['eigenvalues']}\")\n\n# Check controllability\nctrl = system.analysis.controllability(A, B)\nprint(f\"Controllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']}\")\n\n# Check observability\nobs = system.analysis.observability(A, C)\nprint(f\"Observable: {obs['is_observable']}\")"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#control-design-methods",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#control-design-methods",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "# Continuous-time LQR\nresult = system.control.design_lqr(\n    A, B,\n    Q=np.diag([10, 1]),\n    R=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Discrete-time LQR\nresult = system.control.design_lqr(\n    A, B,\n    Q=np.diag([10, 1]),\n    R=np.array([[0.1]]),\n    system_type='discrete'\n)\n\n# With cross-coupling term\nresult = system.control.design_lqr(\n    A, B,\n    Q=np.diag([10, 1]),\n    R=np.array([[0.1]]),\n    N=np.array([[0.5], [0.1]]),  # Cross-coupling\n    system_type='continuous'\n)\n\n# Access result fields\nK = result['gain']                         # Feedback gain (nu, nx)\nP = result['cost_to_go']                   # Riccati solution (nx, nx)\neigs = result['closed_loop_eigenvalues']   # eig(A - BK)\nmargin = result['stability_margin']        # Robustness measure\n\n# Verify stability\nis_stable_continuous = np.all(np.real(eigs) &lt; 0)\nis_stable_discrete = np.all(np.abs(eigs) &lt; 1)\n\n\n\n# Continuous-time Kalman filter\nkalman = system.control.design_kalman(\n    A, C,\n    Q=0.01 * np.eye(2),\n    R=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Discrete-time Kalman filter\nkalman = system.control.design_kalman(\n    A, C,\n    Q=0.01 * np.eye(2),\n    R=np.array([[0.1]]),\n    system_type='discrete'\n)\n\n# Access result fields\nL = kalman['gain']                      # Kalman gain (nx, ny)\nP = kalman['error_covariance']          # Error covariance (nx, nx)\nS = kalman['innovation_covariance']     # Innovation cov (ny, ny)\neigs = kalman['observer_eigenvalues']   # eig(A - LC)\n\n# Verify observer stability\nobs_stable_continuous = np.all(np.real(eigs) &lt; 0)\nobs_stable_discrete = np.all(np.abs(eigs) &lt; 1)\n\n\n\n# Design LQG (LQR + Kalman via separation principle)\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state=np.diag([10, 1]),      # LQR state cost\n    R_control=np.array([[0.1]]),   # LQR control cost\n    Q_process=0.01 * np.eye(2),    # Process noise covariance\n    R_measurement=np.array([[0.1]]),  # Measurement noise covariance\n    system_type='continuous'\n)\n\n# Access result fields\nK = lqg['control_gain']                # LQR gain (nu, nx)\nL = lqg['estimator_gain']              # Kalman gain (nx, ny)\nP_ctrl = lqg['control_cost_to_go']     # Controller Riccati\nP_est = lqg['estimation_error_covariance']  # Estimator Riccati\nstable = lqg['closed_loop_stable']     # Overall stability\nseparated = lqg['separation_verified']  # Separation principle\nctrl_eigs = lqg['controller_eigenvalues']  # eig(A - BK)\nest_eigs = lqg['estimator_eigenvalues']    # eig(A - LC)\n\n# Verify separation principle\nassert separated, \"Separation principle should hold\"\nprint(f\"Combined system stable: {stable}\")"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#system-analysis-methods",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#system-analysis-methods",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "# Continuous-time stability\nstability = system.analysis.stability(A, system_type='continuous')\n\n# Discrete-time stability\nstability = system.analysis.stability(A, system_type='discrete')\n\n# Access result fields\neigs = stability['eigenvalues']          # Complex eigenvalues\nmags = stability['magnitudes']           # |λ| values\nrho = stability['spectral_radius']       # max |λ|\nis_stable = stability['is_stable']       # Asymptotic stability\nis_marginal = stability['is_marginally_stable']  # On boundary\nis_unstable = stability['is_unstable']   # Unstable\n\n# Stability criteria\nif stability['is_stable']:\n    print(\"System is asymptotically stable\")\nelif stability['is_marginally_stable']:\n    print(\"System is marginally stable\")\nelse:\n    print(\"System is unstable\")\n    print(f\"Unstable eigenvalues: {eigs[np.real(eigs) &gt; 0]}\")  # Continuous\n    print(f\"Unstable eigenvalues: {eigs[np.abs(eigs) &gt; 1]}\")   # Discrete\n\n\n\n# Check controllability\nctrl = system.analysis.controllability(A, B)\n\n# Access result fields\nC_matrix = ctrl['controllability_matrix']  # (nx, nx*nu)\nrank = ctrl['rank']                        # Rank of C_matrix\ncontrollable = ctrl['is_controllable']     # rank == nx\n\n# Check for uncontrollable modes\nif not controllable:\n    uncontrol_modes = ctrl['uncontrollable_modes']\n    print(f\"Uncontrollable eigenvalues: {uncontrol_modes}\")\n    \n# Verify for LQR design\nif controllable:\n    print(\"✓ System is controllable - can design LQR\")\nelse:\n    print(\"✗ System not controllable - LQR may fail\")\n    print(f\"Controllability rank: {rank} / {A.shape[0]}\")\n\n\n\n# Check observability\nobs = system.analysis.observability(A, C)\n\n# Access result fields\nO_matrix = obs['observability_matrix']  # (nx*ny, nx)\nrank = obs['rank']                      # Rank of O_matrix\nobservable = obs['is_observable']       # rank == nx\n\n# Check for unobservable modes\nif not observable:\n    unobs_modes = obs['unobservable_modes']\n    print(f\"Unobservable eigenvalues: {unobs_modes}\")\n\n# Verify for Kalman filter design\nif observable:\n    print(\"✓ System is observable - can design Kalman filter\")\nelse:\n    print(\"✗ System not observable - Kalman filter may fail\")\n    print(f\"Observability rank: {rank} / {A.shape[0]}\")"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#common-patterns",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#common-patterns",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "# 1. Linearize at equilibrium\nA, B = system.linearize(x_eq, u_eq)\n\n# 2. Design LQR\nQ = np.diag([10, 1])   # Penalize states\nR = np.array([[0.1]])  # Penalize control\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = result['gain']\n\n# 3. Implement controller\ndef lqr_controller(x, t):\n    return -K @ (x - x_eq)\n\n# 4. Simulate\nresult_sim = system.simulate(\n    x0=x0,\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\n# 1. Design controller (assumes full state)\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Partial measurement\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\n\n# 2. Design observer\nkalman = system.control.design_kalman(A, C, Q_proc, R_meas, system_type='continuous')\nL = kalman['gain']\n\n# 3. Implement observer-based controller\nx_hat = np.zeros(system.nx)\n\ndef observer_controller(x, t):\n    # Use estimated state\n    return -K @ (x_hat - x_eq)\n\n# 4. Update loop\nfor k in range(N):\n    # Get measurement\n    y_meas = C @ x_true[k] + noise[k]\n    \n    # Control based on estimate\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Propagate estimate\n    x_hat_dot = A @ x_hat + B @ u[k] + L @ (y_meas - C @ x_hat)\n    x_hat += dt * x_hat_dot\n\n\n\n# 1. Design combined LQG\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state, R_control,\n    Q_process, R_measurement,\n    system_type='continuous'\n)\n\nK = lqg['control_gain']\nL = lqg['estimator_gain']\n\n# 2. Initialize estimate\nx_hat = np.zeros(system.nx)\n\n# 3. Control loop\nfor k in range(N):\n    # Certainty equivalence control\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Get measurement\n    y_meas = C @ x_true[k] + meas_noise[k]\n    \n    # Prediction step\n    x_hat = A @ x_hat + B @ u[k]\n    \n    # Correction step\n    innovation = y_meas - C @ x_hat\n    x_hat = x_hat + L @ innovation\n\n\n\n# 1. Design discrete LQR\nAd, Bd = discrete_system.linearize(x_eq, u_eq)\nresult = discrete_system.control.design_lqr(\n    Ad, Bd, Q, R,\n    system_type='discrete'  # Important!\n)\nK = result['gain']\n\n# 2. Discrete control law\nfor k in range(N):\n    u[k] = -K @ (x[k] - x_eq)\n    x[k+1] = discrete_system.step(x[k], u[k])\n\n\n\n# Bryson's rule: Normalize by maximum acceptable values\nx_max = np.array([0.5, 2.0])  # Max acceptable deviation\nu_max = np.array([10.0])      # Max acceptable control\n\nQ = np.diag(1 / x_max**2)\nR = np.diag(1 / u_max**2)\n\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Iterate if needed\nfor q_scale in [1.0, 10.0, 100.0]:\n    Q_scaled = q_scale * Q\n    result = system.control.design_lqr(A, B, Q_scaled, R, system_type='continuous')\n    \n    # Check performance\n    K = result['gain']\n    closed_loop_poles = result['closed_loop_eigenvalues']\n    print(f\"q_scale={q_scale}: poles = {closed_loop_poles}\")\n\n\n\n# Before designing controllers, verify system properties\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])\n\n# 1. Check stability of open-loop\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Open-loop stable: {stability['is_stable']}\")\n\n# 2. Check controllability (required for LQR)\nctrl = system.analysis.controllability(A, B)\nif not ctrl['is_controllable']:\n    print(\"WARNING: System not controllable - LQR may fail\")\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 3. Check observability (required for Kalman)\nobs = system.analysis.observability(A, C)\nif not obs['is_observable']:\n    print(\"WARNING: System not observable - Kalman filter may fail\")\n    print(f\"Unobservable modes: {obs['unobservable_modes']}\")\n\n# 4. Proceed with design only if conditions met\nif ctrl['is_controllable'] and obs['is_observable']:\n    lqg = system.control.design_lqg(A, B, C, Q, R, Q_proc, R_meas)\n    print(\"✓ LQG design successful\")\n\n\n\nimport torch\nimport jax.numpy as jnp\n\n# NumPy backend (default)\nsystem_np = Pendulum()\nsystem_np.set_default_backend('numpy')\nresult_np = system_np.control.design_lqr(A_np, B_np, Q_np, R_np)\n\n# PyTorch backend\nsystem_torch = Pendulum()\nsystem_torch.set_default_backend('torch')\nsystem_torch.set_default_device('cuda:0')\nA_torch = torch.tensor(A_np, device='cuda:0')\nB_torch = torch.tensor(B_np, device='cuda:0')\nresult_torch = system_torch.control.design_lqr(A_torch, B_torch, Q_torch, R_torch)\n\n# Result is on GPU\nassert result_torch['gain'].device.type == 'cuda'\n\n# JAX backend\nsystem_jax = Pendulum()\nsystem_jax.set_default_backend('jax')\nA_jax = jnp.array(A_np)\nB_jax = jnp.array(B_np)\nresult_jax = system_jax.control.design_lqr(A_jax, B_jax, Q_jax, R_jax)"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#troubleshooting",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#troubleshooting",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "Possible Causes: - System not controllable - (Q, A) not detectable - Ill-conditioned matrices\nSolutions:\n# 1. Check controllability\nctrl = system.analysis.controllability(A, B)\nif not ctrl['is_controllable']:\n    print(f\"System not controllable. Rank: {ctrl['rank']}/{A.shape[0]}\")\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 2. Add regularization to Q\nQ_regularized = Q + 1e-6 * np.eye(nx)\n\n# 3. Check (Q, A) detectability\n# All uncontrollable modes should have Re(λ) &lt; 0 (continuous)\n# or |λ| &lt; 1 (discrete)\n\n\n\nPossible Causes: - System not observable - (A, Q^(1/2)) not controllable - Singular measurement noise R\nSolutions:\n# 1. Check observability\nobs = system.analysis.observability(A, C)\nif not obs['is_observable']:\n    print(f\"System not observable. Rank: {obs['rank']}/{A.shape[0]}\")\n    \n    # Try adding measurements\n    C_full = np.eye(nx)\n    obs_full = system.analysis.observability(A, C_full)\n    print(f\"With full state measurement: {obs_full['is_observable']}\")\n\n# 2. Ensure R is positive definite\nR_regularized = R + 1e-6 * np.eye(ny)\n\n# 3. Check process noise controllability\n# All unobservable modes should be damped by process noise\n\n\n\nPossible Causes: - Wrong system_type (continuous vs discrete) - Numerical errors in linearization - Equilibrium not actually an equilibrium\nSolutions:\n# 1. Verify equilibrium\nf_eq = system(x_eq, u_eq)\nprint(f\"f(x_eq, u_eq) = {f_eq}\")  # Should be near zero\nassert np.allclose(f_eq, 0, atol=1e-6), \"Not an equilibrium!\"\n\n# 2. Check linearization accuracy\ndx_linear = A @ (x - x_eq) + B @ (u - u_eq)\ndx_nonlinear = system(x, u)\nerror = np.linalg.norm(dx_linear - dx_nonlinear)\nprint(f\"Linearization error: {error}\")\n\n# 3. Verify system_type matches system\nif isinstance(system, ContinuousSystemBase):\n    system_type = 'continuous'\nelif isinstance(system, DiscreteSystemBase):\n    system_type = 'discrete'\n\nresult = system.control.design_lqr(A, B, Q, R, system_type=system_type)\n\n\n\nThis is expected! - LQG closed-loop has 2*nx eigenvalues - Should be: eig(A-BK) ∪ eig(A-LC)\n# Verify separation\nlqr = system.control.design_lqr(A, B, Q, R)\nkalman = system.control.design_kalman(A, C, Q_proc, R_meas)\nlqg = system.control.design_lqg(A, B, C, Q, R, Q_proc, R_meas)\n\n# Combined eigenvalues\ncombined = np.concatenate([\n    lqr['closed_loop_eigenvalues'],\n    kalman['observer_eigenvalues']\n])\n\n# Should match LQG eigenvalues (up to ordering)\nlqg_combined = np.concatenate([\n    lqg['controller_eigenvalues'],\n    lqg['estimator_eigenvalues']\n])\n\nassert np.allclose(sorted(combined), sorted(lqg_combined))"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#direct-function-usage-advanced",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#direct-function-usage-advanced",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "For cases where you need to use control functions without a system object:\nfrom src.control.classical_control_functions import (\n    design_lqr,\n    design_kalman_filter,\n    design_lqg,\n    analyze_stability,\n    analyze_controllability,\n    analyze_observability\n)\nimport numpy as np\n\n# Define matrices directly\nA = np.array([[0, 1], [-2, -3]])\nB = np.array([[0], [1]])\nC = np.array([[1, 0]])\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\n\n# Call functions directly\nlqr_result = design_lqr(A, B, Q, R, system_type='continuous', backend='numpy')\nK = lqr_result['gain']\n\nkalman_result = design_kalman_filter(\n    A, C,\n    Q=0.01*np.eye(2),\n    R=np.array([[0.1]]),\n    system_type='continuous',\n    backend='numpy'\n)\nL = kalman_result['gain']\n\n# Analysis\nstability = analyze_stability(A, system_type='continuous', backend='numpy')\nctrl = analyze_controllability(A, B, backend='numpy')\nobs = analyze_observability(A, C, backend='numpy')"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#testing-your-controller",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#testing-your-controller",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "def test_lqr_design():\n    \"\"\"Test LQR controller design and stability.\"\"\"\n    # Create system\n    system = Pendulum()\n    x_eq = np.array([np.pi, 0])\n    u_eq = np.zeros(1)\n    \n    # Linearize\n    A, B = system.linearize(x_eq, u_eq)\n    \n    # Design LQR\n    Q = np.diag([10, 1])\n    R = np.array([[0.1]])\n    result = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n    \n    # Test 1: Gain has correct shape\n    K = result['gain']\n    assert K.shape == (1, 2), f\"Gain shape incorrect: {K.shape}\"\n    \n    # Test 2: Closed-loop is stable\n    eigs = result['closed_loop_eigenvalues']\n    assert np.all(np.real(eigs) &lt; 0), \"Closed-loop unstable!\"\n    \n    # Test 3: P is positive definite\n    P = result['cost_to_go']\n    assert np.all(np.linalg.eigvals(P) &gt; 0), \"P not positive definite!\"\n    \n    # Test 4: P satisfies Riccati equation\n    # A'P + PA - PBR^{-1}B'P + Q = 0\n    riccati_error = A.T @ P + P @ A - P @ B @ np.linalg.solve(R, B.T @ P) + Q\n    assert np.allclose(riccati_error, 0, atol=1e-6), \"Riccati not satisfied!\"\n    \n    print(\"✓ All LQR tests passed\")\n\ntest_lqr_design()"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Quick_Reference.html#references",
    "href": "api/control_framework/Control_Framework_Quick_Reference.html#references",
    "title": "Control Framework Quick Reference",
    "section": "",
    "text": "Architecture: See Control_Framework_Architecture.md for complete details\nType Definitions: See Type_System_Architecture.md for TypedDict documentation\nPure Functions: See src/control/classical_control_functions.py\nWrappers: See src/control/control_synthesis.py and src/control/system_analysis.py"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "The Delegation Layer (also called the Support Framework) provides specialized services to the UI framework through composition rather than inheritance. This layer consists of 11 focused utility classes totaling ~7,200 lines that handle backend management, code generation, dynamics evaluation, and stochastic analysis.\n\n\n\nComposition Over Inheritance - Instead of creating deep inheritance hierarchies, the UI framework composes these specialized utilities:\n# In ContinuousSymbolicSystem.__init__():\nself.backend = BackendManager(default_backend, default_device)\nself._code_gen = CodeGenerator(self, self.backend)\nself._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\nself._linearization = LinearizationEngine(self, self._code_gen, self.backend)\nself._observation = ObservationEngine(self, self._code_gen, self.backend)\nself.equilibria = EquilibriumHandler(nx, nu)\nThis design provides:\n\nSingle Responsibility - Each class does one thing well\nReusability - Utilities can be used independently\nTestability - Each component tested in isolation\nFlexibility - Easy to swap implementations\nClarity - Clear separation of concerns\n\n\n\n\n┌──────────────────────────────────────────────────────────────┐\n│                     UI FRAMEWORK                              │\n│  (SymbolicSystemBase, ContinuousSymbolicSystem, etc.)        │\n└────────────────────┬─────────────────────────────────────────┘\n                     │ uses (composition)\n                     ↓\n┌──────────────────────────────────────────────────────────────┐\n│                  DELEGATION LAYER                             │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  CORE UTILITIES (Universal)                         │    │\n│  │  • BackendManager      - Multi-backend support      │    │\n│  │  • CodeGenerator       - Symbolic → numerical       │    │\n│  │  • EquilibriumHandler  - Equilibrium management     │    │\n│  │  • SymbolicValidator   - System validation          │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  DETERMINISTIC EVALUATION (ODE Systems)             │    │\n│  │  • DynamicsEvaluator    - Forward dynamics          │    │\n│  │  • LinearizationEngine  - Jacobian computation      │    │\n│  │  • ObservationEngine    - Output evaluation         │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  STOCHASTIC SUPPORT (SDE Systems)                   │    │\n│  │  • DiffusionHandler    - Diffusion generation       │    │\n│  │  • NoiseCharacterizer  - Noise analysis             │    │\n│  │  • SDEValidator        - SDE validation             │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  LOW-LEVEL UTILITIES                                │    │\n│  │  • codegen_utils       - SymPy code generation      │    │\n│  └─────────────────────────────────────────────────────┘    │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\n\n\n\nFile: backend_manager.py (545 lines)\nPurpose: Multi-backend array handling and device management\nResponsibilities:\n\nBackend detection from array types\nArray conversion between backends (NumPy ↔︎ PyTorch ↔︎ JAX)\nBackend availability checking\nDevice management (CPU, CUDA, TPU)\nDefault backend configuration\nTemporary backend switching (context manager)\n\nKey Features:\n# Detect backend from array\nbackend = mgr.detect(array)  # Returns 'numpy', 'torch', or 'jax'\n\n# Convert between backends\nx_torch = mgr.to_backend(x_numpy, 'torch')\nx_jax = mgr.to_backend(x_torch, 'jax')\n\n# Device placement\nx_cuda = mgr.to_device(x, 'cuda:0')\n\n# Temporary backend switching\nwith mgr.use_backend('jax'):\n    # Operations use JAX\n    result = compute()\nSupported Backends:\n\nNumPy: CPU-based, universal compatibility\nPyTorch: GPU acceleration, autograd, neural networks\nJAX: XLA compilation, functional programming, optimization\n\nProperties:\nmgr.default_backend     # Current default backend\nmgr.preferred_device    # Current device (cpu, cuda:0, etc.)\nmgr.available_backends  # List of available backends\n\n\n\n\nFile: code_generator.py (565 lines)\nPurpose: Orchestrates symbolic → numerical code generation with caching\nResponsibilities:\n\nGenerate dynamics functions: f(x, u) → dx/dt\nGenerate output functions: h(x) → y\nGenerate Jacobian functions: A, B, C\nPer-backend function caching\nCompilation and warmup\nCache invalidation on parameter changes\n\nKey Features:\n# Generate dynamics function (cached)\nf_numpy = code_gen.generate_dynamics('numpy')\nf_torch = code_gen.generate_dynamics('torch')\nf_jax = code_gen.generate_dynamics('jax', jit=True)\n\n# Generate Jacobians\nA_func = code_gen.generate_jacobian_A('numpy')\nB_func = code_gen.generate_jacobian_B('numpy')\n\n# Output function\nh_func = code_gen.generate_output('numpy')\nC_func = code_gen.generate_jacobian_C('numpy')\n\n# Compile all backends at once\ntimings = code_gen.compile_all(backends=['numpy', 'torch', 'jax'])\nCaching Strategy:\n\nFunctions cached per backend\nSymbolic Jacobians computed once, then compiled per backend\nCache invalidated on parameter changes\nAutomatic recompilation when needed\n\nBackend-Specific Optimizations:\n\nNumPy: Uses lambdify with CSE (common subexpression elimination)\nPyTorch: Simplifies expressions before generation\nJAX: JIT compilation via jax.jit\n\n\n\n\n\nFile: equilibrium_handler.py (221 lines)\nPurpose: Manages multiple named equilibrium points\nResponsibilities:\n\nStore equilibria as NumPy arrays (backend-neutral)\nConvert to any backend on demand\nNamed equilibrium management\nEquilibrium verification\nMetadata storage (stability, description, etc.)\nDefault equilibrium selection\n\nKey Features:\n# Add equilibrium with verification\nequilibria.add(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    verify_fn=lambda x, u: system(x, u),\n    metadata={'stability': 'unstable'}\n)\n\n# Get in any backend\nx_eq_numpy = equilibria.get_x('upright', backend='numpy')\nx_eq_torch = equilibria.get_x('upright', backend='torch')\n\n# Set default\nequilibria.set_default('upright')\n\n# Get both state and control\nx_eq, u_eq = equilibria.get_both('upright', backend='jax')\n\n# List all\nnames = equilibria.list_names()  # ['origin', 'upright', ...]\n\n# Get metadata\nmeta = equilibria.get_metadata('upright')\nprint(meta['stability'])  # 'unstable'\nAutomatic Features:\n\nOrigin equilibrium always present\nDimension validation on add\nFinite value checking (no NaN/Inf)\nOptional verification with tolerance\n\n\n\n\n\nFile: symbolic_validator.py (718 lines)\nPurpose: Validates symbolic system definitions\nResponsibilities:\n\nCheck state/control variable consistency\nValidate symbolic expression dimensions\nVerify parameter keys (Symbol, not string)\nCheck system order compatibility\nEnsure output function validity\nDetect common errors early\n\nValidation Checks:\n# Required validations\n✓ state_vars is list of sp.Symbol\n✓ control_vars is list of sp.Symbol  \n✓ _f_sym is sp.Matrix with correct dimensions\n✓ parameters keys are sp.Symbol (not strings)\n✓ order divides nx evenly (nx % order == 0)\n\n# Output function validations (if defined)\n✓ _h_sym is sp.Matrix\n✓ _h_sym only depends on state_vars (not control)\n✓ output_vars matches _h_sym dimensions\n\n# Error messages are clear and actionable\nExample Errors Caught:\n# Bad: String keys\nself.parameters = {'m': 1.0}  # ❌ String key\n# Good: Symbol keys  \nself.parameters = {m_sym: 1.0}  # ✓ Symbol key\n\n# Bad: Wrong dimensions\nself._f_sym = sp.Matrix([x, y])  # nx=2, but system has nx=3\n# Good: Correct dimensions\nself._f_sym = sp.Matrix([x, y, z])  # ✓ nx=3\n\n\n\n\n\n\n\nFile: dynamics_evaluator.py (576 lines)\nPurpose: Forward dynamics evaluation across backends\nResponsibilities:\n\nEvaluate dx/dt = f(x, u) for controlled systems\nEvaluate dx/dt = f(x) for autonomous systems (u=None)\nHandle batched vs single evaluation\nBackend-specific dispatch\nInput shape validation\nPerformance tracking\n\nKey Features:\n# Single evaluation\ndx = evaluator.evaluate(x, u, backend='numpy')\n\n# Autonomous system (u=None)\ndx = evaluator.evaluate(x, backend='numpy')\n\n# Batched evaluation\nx_batch = np.random.randn(100, nx)  # (batch, nx)\nu_batch = np.random.randn(100, nu)  # (batch, nu)\ndx_batch = evaluator.evaluate(x_batch, u_batch)  # (batch, nx)\n\n# Get performance stats\nstats = evaluator.get_stats()\nprint(f\"Total evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']:.6f}s\")\nBackend Dispatch:\n\nAutomatically detects input backend\nUses cached compiled functions\nHandles shape mismatches gracefully\nConverts outputs to match input backend\n\nPerformance Tracking:\n{\n    'count': int,        # Number of evaluations\n    'total_time': float, # Total time (seconds)\n    'avg_time': float,   # Average per evaluation\n    'min_time': float,   # Fastest evaluation\n    'max_time': float,   # Slowest evaluation\n}\n\n\n\n\nFile: linearization_engine.py (907 lines)\nPurpose: Compute linearizations (Jacobians) at equilibria\nResponsibilities:\n\nCompute continuous Jacobians: A = ∂f/∂x, B = ∂f/∂u\nCompute discrete Jacobians: Ad = ∂f/∂x, Bd = ∂f/∂u\nHandle higher-order systems (order &gt; 1)\nAutomatic state-space construction\nSymbolic and numerical Jacobians\nBackend-agnostic evaluation\n\nMathematical Forms:\nContinuous Systems:\nLinearization at (x_eq, u_eq):\nδẋ = A·δx + B·δu\n\nwhere:\nA = ∂f/∂x|(x_eq, u_eq)  ∈ ℝ^(nx × nx)\nB = ∂f/∂u|(x_eq, u_eq)  ∈ ℝ^(nx × nu)\nDiscrete Systems:\nLinearization at (x_eq, u_eq):\nδx[k+1] = Ad·δx[k] + Bd·δu[k]\n\nwhere:\nAd = ∂f/∂x|(x_eq, u_eq)  ∈ ℝ^(nx × nx)\nBd = ∂f/∂u|(x_eq, u_eq)  ∈ ℝ^(nx × nu)\nKey Features:\n# Continuous linearization\nA, B = engine.linearize_continuous(x_eq, u_eq, backend='numpy')\n\n# Discrete linearization\nAd, Bd = engine.linearize_discrete(x_eq, u_eq, backend='numpy')\n\n# Higher-order systems (automatic state-space)\n# For order=2 system: q̈ = f(q, q̇, u)\n# Automatically constructs: [q̇, q̈]ᵀ = A[q, q̇]ᵀ + Bu\nA, B = engine.linearize_continuous(x_eq, u_eq)\n\n# Get symbolic Jacobians (one-time computation)\nA_sym = engine.get_symbolic_A()\nB_sym = engine.get_symbolic_B()\nHigher-Order Handling:\nFor order=n systems where state is [q, q̇, ..., q^(n-1)] and only q^(n) is returned:\n\nAutomatically constructs full state derivative\nComputes Jacobian of full state-space form\nReturns proper (nx × nx) and (nx × nu) matrices\n\n\n\n\n\nFile: observation_engine.py (628 lines)\nPurpose: Output function evaluation and linearization\nResponsibilities:\n\nEvaluate output: y = h(x)\nCompute output Jacobian: C = ∂h/∂x\nBatched output evaluation\nMulti-backend support\nPerformance tracking\n\nMathematical Form:\nOutput equation:\ny = h(x)\n\nOutput linearization:\nδy = C·δx\n\nwhere:\nC = ∂h/∂x|(x_eq)  ∈ ℝ^(ny × nx)\nKey Features:\n# Evaluate output\ny = engine.observe(x, backend='numpy')\n\n# Batched evaluation\nx_batch = np.random.randn(100, nx)\ny_batch = engine.observe(x_batch)  # (100, ny)\n\n# Output Jacobian\nC = engine.linearize_output(x_eq, backend='numpy')\n\n# Check if output defined\nif engine.has_output():\n    y = engine.observe(x)\nValidation:\n\nEnsures h(x) doesn’t depend on control u\nChecks dimension consistency\nValidates symbolic expressions\n\n\n\n\n\n\n\n\nFile: diffusion_handler.py (1,069 lines)\nPurpose: Generate and cache diffusion functions for SDEs\nResponsibilities:\n\nGenerate diffusion matrix: g(x, u) ∈ ℝ^(nx × nw)\nAutomatic noise structure detection\nSpecialized functions for additive/diagonal/scalar noise\nMulti-backend diffusion compilation\nStratonovich correction computation\nPerformance optimization\n\nMathematical Form:\nSDE: dx = f(x, u)dt + g(x, u)dW\n\nDiffusion matrix g(x, u):\n- Shape: (nx, nw)\n- nx: state dimension\n- nw: number of independent Wiener processes\n\nNoise types (auto-detected):\n- ADDITIVE: g(x, u) = constant\n- MULTIPLICATIVE: g depends on x or u\n- DIAGONAL: g is diagonal (independent noise)\n- SCALAR: nw = 1 (single Wiener process)\nKey Features:\n# Generate diffusion function\ng_func = handler.generate_diffusion('numpy')\n\n# Evaluate diffusion\ng_matrix = handler.evaluate_diffusion(x, u, backend='numpy')\n\n# Automatic noise detection\nnoise_type = handler.get_noise_type()\n# Returns: ADDITIVE, MULTIPLICATIVE_DIAGONAL, etc.\n\n# Stratonovich correction\ncorrection = handler.compute_stratonovich_correction(x, u)\n\n# Optimized for additive noise\nif handler.is_additive():\n    g_const = handler.get_additive_matrix()  # Constant matrix\nNoise Structure Exploitation:\n\nAdditive (constant): Returns constant matrix, no recomputation needed\nMultiplicative types:\n\nDiagonal: Independent noise channels, specialized handling\nScalar: Single Wiener process (nw=1), simplified operations\nGeneral: Full matrix coupling, complete computation\n\n\n\n\n\n\nFile: noise_analysis.py (692 lines)\nPurpose: Automatic noise structure analysis\nResponsibilities:\n\nDetect noise types (additive, multiplicative, etc.)\nIdentify noise structure (diagonal, scalar, general)\nRecommend optimal SDE solvers\nCompute noise statistics\nValidate noise properties\n\nNoise Classification:\nNoiseType:\n├─ ADDITIVE               # g(x,u) = constant\n├─ MULTIPLICATIVE         # g depends on x or u\n│  ├─ DIAGONAL            # Independent noise sources\n│  ├─ SCALAR              # Single Wiener process\n│  └─ GENERAL             # Full coupling\n└─ UNKNOWN                # Cannot determine\nKey Features:\n# Automatic characterization\ncharacteristics = characterizer.analyze()\n\n# Access properties\nnoise_type = characteristics.noise_type\nis_additive = characteristics.is_additive\nis_diagonal = characteristics.is_diagonal\nnw = characteristics.nw  # Number of Wiener processes\n\n# Solver recommendations\nsolvers = characteristics.recommend_solvers('torch')\n# Returns: ['heun', 'reversible_heun'] for additive\n# Returns: ['euler-maruyama'] for multiplicative\n\n# Validation\nif not characteristics.is_valid:\n    print(characteristics.validation_message)\nSolver Recommendations:\n\n\n\nNoise Type\nBackend\nRecommended Solvers\n\n\n\n\nAdditive\nPyTorch\nheun, reversible_heun\n\n\nAdditive\nJAX\nheun, reversible_heun\n\n\nMultiplicative Diagonal\nNumPy\nmilstein\n\n\nGeneral\nAll\neuler-maruyama\n\n\n\n\n\n\n\nFile: sde_validator.py (544 lines)\nPurpose: SDE-specific validation\nResponsibilities:\n\nValidate diffusion matrix dimensions\nCheck SDE type (Itô vs Stratonovich)\nEnsure compatibility with drift\nVerify noise structure claims\nValidate stochastic system definition\n\nValidation Checks:\n✓ diffusion_expr is sp.Matrix\n✓ Dimensions: (nx, nw) where nw ≥ 1\n✓ diffusion_expr only uses state_vars and control_vars\n✓ sde_type is 'ito' or 'stratonovich'\n✓ Compatibility with drift _f_sym\n✓ No division by zero in diffusion terms\n✓ Finite symbolic expressions\nExample Errors Caught:\n# Bad: Wrong dimensions\nself.diffusion_expr = sp.Matrix([[sigma]])  # nx=2, but only 1 row\n# Good: Correct dimensions\nself.diffusion_expr = sp.Matrix([[sigma], [0]])  # (2, 1)\n\n# Bad: Invalid SDE type\nself.sde_type = 'unknown'  # ❌\n# Good: Valid type\nself.sde_type = 'ito'  # ✓\n\n\n\n\n\n\n\nFile: codegen_utils.py (733 lines)\nPurpose: Low-level SymPy → executable code conversion\nResponsibilities:\n\nSymPy Matrix → callable function\nBackend-specific code generation\nCommon subexpression elimination (CSE)\nSymbolic simplification strategies\nNumPy/PyTorch/JAX code generation\nFunction signature handling\n\nKey Functions:\n# Main generation function\nfunc = generate_function(\n    expr,           # sp.Matrix symbolic expression\n    input_vars,     # List of sp.Symbol variables\n    backend='numpy', # Target backend\n    simplify=True,  # Apply simplification\n    cse=True,       # Common subexpression elimination\n    jit=False       # JIT compile (JAX only)\n)\n\n# Backend-specific optimizations\nfunc_numpy = generate_function(expr, vars, backend='numpy', cse=True)\nfunc_torch = generate_function(expr, vars, backend='torch', simplify=True)\nfunc_jax = generate_function(expr, vars, backend='jax', jit=True)\nOptimization Strategies:\nNumPy:\n\nCommon subexpression elimination (CSE)\nFast numerical modules (‘numpy’, ‘scipy’)\nMatrix operations optimization\n\nPyTorch:\n\nSymbolic simplification before generation\nAutomatic differentiation compatibility\nGPU tensor operations\n\nJAX:\n\nJIT compilation via jax.jit\nPure functional style\nXLA optimization\nAutomatic vectorization\n\nGenerated Function Signatures:\n# Dynamics function\nf(x, u) → dx/dt\n# where x: array(nx,), u: array(nu,) → array(nx,)\n\n# Jacobian function\nA(x, u) → matrix(nx, nx)\nB(x, u) → matrix(nx, nu)\n\n# Output function\nh(x) → y\n# where x: array(nx,) → array(ny,)\n\n\n\n\n\n\n\n\nUsed by: All symbolic systems\n# In SymbolicSystemBase.__init__():\nself.backend = BackendManager(default_backend, default_device)\nself._code_gen = CodeGenerator(self, self.backend)\nself._validator = SymbolicValidator()\nself.equilibria = EquilibriumHandler(nx, nu)\n\n\n\nUsed by: ContinuousSymbolicSystem, DiscreteSymbolicSystem\n# In ContinuousSymbolicSystem.__init__():\nsuper().__init__(*args, **kwargs)  # Sets up core utilities\n\n# Add deterministic evaluators\nself._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\nself._linearization = LinearizationEngine(self, self._code_gen, self.backend)\nself._observation = ObservationEngine(self, self._code_gen, self.backend)\n\n\n\nUsed by: ContinuousStochasticSystem, DiscreteStochasticSystem\n# In ContinuousStochasticSystem.__init__():\nsuper().__init__(*args, **kwargs)  # Sets up deterministic utilities\n\n# Add stochastic support\nself.diffusion_handler = DiffusionHandler(self, self._code_gen, self.backend)\nself.noise_characteristics = NoiseCharacterizer().analyze(self.diffusion_expr)\nself._sde_validator = SDEValidator()\n\n\n\n\n\n\nEach class has one clear purpose:\n\nBackendManager → Backend management ONLY\nCodeGenerator → Code generation ONLY\nDynamicsEvaluator → Dynamics evaluation ONLY\n\n\n\n\nSystems compose utilities rather than inherit:\n# NOT: class System(BackendManager, CodeGenerator, ...)\n# YES: class System:\n#          self.backend = BackendManager()\n#          self._code_gen = CodeGenerator()\n\n\n\nUtilities receive dependencies via constructor:\nDynamicsEvaluator(system, code_gen, backend_mgr)\n\n\n\nEach utility has focused, minimal interface:\n\nBackendManager: detect, convert, to_backend\nCodeGenerator: generate_dynamics, generate_jacobian_A/B/C\nDynamicsEvaluator: evaluate\n\n\n\n\nFunctions generated and cached on first use:\n# First call: generates and caches\nf = code_gen.generate_dynamics('numpy')\n\n# Subsequent calls: returns cached\nf_again = code_gen.generate_dynamics('numpy')\nassert f is f_again  # Same object\n\n\n\nUtilities work with all backends transparently:\n# Same interface, different backends\ndx_numpy = evaluator.evaluate(x_np, u_np, backend='numpy')\ndx_torch = evaluator.evaluate(x_torch, u_torch, backend='torch')\ndx_jax = evaluator.evaluate(x_jax, u_jax, backend='jax')\n\n\n\n\n\n\nfrom src.systems.base import ContinuousSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym = sp.symbols('m k', positive=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k_sym*x/m_sym + u/m_sym])\n        self.parameters = {m_sym: m, k_sym: k}\n        self.order = 1\n\n# System automatically sets up:\nsystem = MySystem()\n# system.backend         (BackendManager)\n# system._code_gen       (CodeGenerator)\n# system._dynamics       (DynamicsEvaluator)\n# system._linearization  (LinearizationEngine)\n# system.equilibria      (EquilibriumHandler)\n\n# Use the delegated functionality\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\n\n# Dynamics (via DynamicsEvaluator)\ndx = system(x, u)\n\n# Linearization (via LinearizationEngine)\nA, B = system.linearize(np.zeros(2), np.zeros(1))\n\n# Equilibria (via EquilibriumHandler)\nsystem.add_equilibrium('test', x_eq=np.zeros(2), u_eq=np.zeros(1))\n\n\n\nimport torch\n\n# Switch backend for entire system\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# Backend manager handles conversions\nx_torch = torch.tensor([[1.0, 0.0]], device='cuda:0')\nu_torch = torch.tensor([[0.5]], device='cuda:0')\n\n# Automatically uses PyTorch backend\ndx_torch = system(x_torch, u_torch)\n\n# Equilibria converted on demand\nx_eq_torch = system.equilibria.get_x('origin', backend='torch')\n\n\n\n# First call: generates and caches\nimport time\n\nstart = time.time()\nf_numpy = system._code_gen.generate_dynamics('numpy')\nt1 = time.time() - start\nprint(f\"First generation: {t1:.3f}s\")\n\n# Second call: returns cached (instant)\nstart = time.time()\nf_numpy_again = system._code_gen.generate_dynamics('numpy')\nt2 = time.time() - start\nprint(f\"Cached retrieval: {t2:.6f}s\")  # ~0.000001s\n\nassert f_numpy is f_numpy_again  # Same function object\n\n\n\nfrom src.systems.base import ContinuousStochasticSystem\n\nclass StochasticOscillator(ContinuousStochasticSystem):\n    def define_system(self, k=10.0, sigma=0.5):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        k_sym, sigma_sym = sp.symbols('k sigma', positive=True)\n        \n        # Drift\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k_sym*x + u])\n        self.parameters = {k_sym: k, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion (additive noise)\n        self.diffusion_expr = sp.Matrix([[0], [sigma_sym]])\n        self.sde_type = 'ito'\n\n# System sets up additional stochastic delegation:\nsde_system = StochasticOscillator()\n# sde_system.diffusion_handler       (DiffusionHandler)\n# sde_system.noise_characteristics   (NoiseCharacteristics)\n# (plus all deterministic utilities)\n\n# Use stochastic functionality\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\n\n# Drift (via DynamicsEvaluator)\nf = sde_system.drift(x, u)\n\n# Diffusion (via DiffusionHandler)\ng = sde_system.diffusion(x, u)\n\n# Noise analysis (automatic)\nprint(f\"Noise type: {sde_system.noise_characteristics.noise_type}\")\nprint(f\"Additive: {sde_system.is_additive_noise()}\")\nprint(f\"Recommended solvers: {sde_system.recommend_solvers('torch')}\")\n\n\n\n# DynamicsEvaluator tracks performance\nfor i in range(1000):\n    dx = system(np.random.randn(2), np.zeros(1))\n\n# Get statistics\nstats = system._dynamics.get_stats()\nprint(f\"Evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']:.6f}s\")\nprint(f\"Total time: {stats['total_time']:.3f}s\")\n\n\n\n\n\nClean Separation - Each utility has one responsibility\nReusability - Can use utilities independently\nTestability - Easy to test in isolation\nFlexibility - Easy to add new utilities\nPerformance - Caching and lazy initialization\nMulti-Backend - Seamless backend switching\nType Safety - TypedDict and semantic types\nDocumentation - Clear purpose and interface\nMaintainability - Easy to understand and modify\nExtensibility - Composition enables new features\n\nThis delegation layer is the foundation that makes the UI framework clean, powerful, and maintainable!"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#overview",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#overview",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "The Delegation Layer (also called the Support Framework) provides specialized services to the UI framework through composition rather than inheritance. This layer consists of 11 focused utility classes totaling ~7,200 lines that handle backend management, code generation, dynamics evaluation, and stochastic analysis."
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#architecture-philosophy",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#architecture-philosophy",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "Composition Over Inheritance - Instead of creating deep inheritance hierarchies, the UI framework composes these specialized utilities:\n# In ContinuousSymbolicSystem.__init__():\nself.backend = BackendManager(default_backend, default_device)\nself._code_gen = CodeGenerator(self, self.backend)\nself._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\nself._linearization = LinearizationEngine(self, self._code_gen, self.backend)\nself._observation = ObservationEngine(self, self._code_gen, self.backend)\nself.equilibria = EquilibriumHandler(nx, nu)\nThis design provides:\n\nSingle Responsibility - Each class does one thing well\nReusability - Utilities can be used independently\nTestability - Each component tested in isolation\nFlexibility - Easy to swap implementations\nClarity - Clear separation of concerns"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#architecture-layers",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#architecture-layers",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "┌──────────────────────────────────────────────────────────────┐\n│                     UI FRAMEWORK                              │\n│  (SymbolicSystemBase, ContinuousSymbolicSystem, etc.)        │\n└────────────────────┬─────────────────────────────────────────┘\n                     │ uses (composition)\n                     ↓\n┌──────────────────────────────────────────────────────────────┐\n│                  DELEGATION LAYER                             │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  CORE UTILITIES (Universal)                         │    │\n│  │  • BackendManager      - Multi-backend support      │    │\n│  │  • CodeGenerator       - Symbolic → numerical       │    │\n│  │  • EquilibriumHandler  - Equilibrium management     │    │\n│  │  • SymbolicValidator   - System validation          │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  DETERMINISTIC EVALUATION (ODE Systems)             │    │\n│  │  • DynamicsEvaluator    - Forward dynamics          │    │\n│  │  • LinearizationEngine  - Jacobian computation      │    │\n│  │  • ObservationEngine    - Output evaluation         │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  STOCHASTIC SUPPORT (SDE Systems)                   │    │\n│  │  • DiffusionHandler    - Diffusion generation       │    │\n│  │  • NoiseCharacterizer  - Noise analysis             │    │\n│  │  • SDEValidator        - SDE validation             │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                                │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │  LOW-LEVEL UTILITIES                                │    │\n│  │  • codegen_utils       - SymPy code generation      │    │\n│  └─────────────────────────────────────────────────────┘    │\n└──────────────────────────────────────────────────────────────┘"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#component-breakdown",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#component-breakdown",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "File: backend_manager.py (545 lines)\nPurpose: Multi-backend array handling and device management\nResponsibilities:\n\nBackend detection from array types\nArray conversion between backends (NumPy ↔︎ PyTorch ↔︎ JAX)\nBackend availability checking\nDevice management (CPU, CUDA, TPU)\nDefault backend configuration\nTemporary backend switching (context manager)\n\nKey Features:\n# Detect backend from array\nbackend = mgr.detect(array)  # Returns 'numpy', 'torch', or 'jax'\n\n# Convert between backends\nx_torch = mgr.to_backend(x_numpy, 'torch')\nx_jax = mgr.to_backend(x_torch, 'jax')\n\n# Device placement\nx_cuda = mgr.to_device(x, 'cuda:0')\n\n# Temporary backend switching\nwith mgr.use_backend('jax'):\n    # Operations use JAX\n    result = compute()\nSupported Backends:\n\nNumPy: CPU-based, universal compatibility\nPyTorch: GPU acceleration, autograd, neural networks\nJAX: XLA compilation, functional programming, optimization\n\nProperties:\nmgr.default_backend     # Current default backend\nmgr.preferred_device    # Current device (cpu, cuda:0, etc.)\nmgr.available_backends  # List of available backends\n\n\n\n\nFile: code_generator.py (565 lines)\nPurpose: Orchestrates symbolic → numerical code generation with caching\nResponsibilities:\n\nGenerate dynamics functions: f(x, u) → dx/dt\nGenerate output functions: h(x) → y\nGenerate Jacobian functions: A, B, C\nPer-backend function caching\nCompilation and warmup\nCache invalidation on parameter changes\n\nKey Features:\n# Generate dynamics function (cached)\nf_numpy = code_gen.generate_dynamics('numpy')\nf_torch = code_gen.generate_dynamics('torch')\nf_jax = code_gen.generate_dynamics('jax', jit=True)\n\n# Generate Jacobians\nA_func = code_gen.generate_jacobian_A('numpy')\nB_func = code_gen.generate_jacobian_B('numpy')\n\n# Output function\nh_func = code_gen.generate_output('numpy')\nC_func = code_gen.generate_jacobian_C('numpy')\n\n# Compile all backends at once\ntimings = code_gen.compile_all(backends=['numpy', 'torch', 'jax'])\nCaching Strategy:\n\nFunctions cached per backend\nSymbolic Jacobians computed once, then compiled per backend\nCache invalidated on parameter changes\nAutomatic recompilation when needed\n\nBackend-Specific Optimizations:\n\nNumPy: Uses lambdify with CSE (common subexpression elimination)\nPyTorch: Simplifies expressions before generation\nJAX: JIT compilation via jax.jit\n\n\n\n\n\nFile: equilibrium_handler.py (221 lines)\nPurpose: Manages multiple named equilibrium points\nResponsibilities:\n\nStore equilibria as NumPy arrays (backend-neutral)\nConvert to any backend on demand\nNamed equilibrium management\nEquilibrium verification\nMetadata storage (stability, description, etc.)\nDefault equilibrium selection\n\nKey Features:\n# Add equilibrium with verification\nequilibria.add(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    verify_fn=lambda x, u: system(x, u),\n    metadata={'stability': 'unstable'}\n)\n\n# Get in any backend\nx_eq_numpy = equilibria.get_x('upright', backend='numpy')\nx_eq_torch = equilibria.get_x('upright', backend='torch')\n\n# Set default\nequilibria.set_default('upright')\n\n# Get both state and control\nx_eq, u_eq = equilibria.get_both('upright', backend='jax')\n\n# List all\nnames = equilibria.list_names()  # ['origin', 'upright', ...]\n\n# Get metadata\nmeta = equilibria.get_metadata('upright')\nprint(meta['stability'])  # 'unstable'\nAutomatic Features:\n\nOrigin equilibrium always present\nDimension validation on add\nFinite value checking (no NaN/Inf)\nOptional verification with tolerance\n\n\n\n\n\nFile: symbolic_validator.py (718 lines)\nPurpose: Validates symbolic system definitions\nResponsibilities:\n\nCheck state/control variable consistency\nValidate symbolic expression dimensions\nVerify parameter keys (Symbol, not string)\nCheck system order compatibility\nEnsure output function validity\nDetect common errors early\n\nValidation Checks:\n# Required validations\n✓ state_vars is list of sp.Symbol\n✓ control_vars is list of sp.Symbol  \n✓ _f_sym is sp.Matrix with correct dimensions\n✓ parameters keys are sp.Symbol (not strings)\n✓ order divides nx evenly (nx % order == 0)\n\n# Output function validations (if defined)\n✓ _h_sym is sp.Matrix\n✓ _h_sym only depends on state_vars (not control)\n✓ output_vars matches _h_sym dimensions\n\n# Error messages are clear and actionable\nExample Errors Caught:\n# Bad: String keys\nself.parameters = {'m': 1.0}  # ❌ String key\n# Good: Symbol keys  \nself.parameters = {m_sym: 1.0}  # ✓ Symbol key\n\n# Bad: Wrong dimensions\nself._f_sym = sp.Matrix([x, y])  # nx=2, but system has nx=3\n# Good: Correct dimensions\nself._f_sym = sp.Matrix([x, y, z])  # ✓ nx=3\n\n\n\n\n\n\n\nFile: dynamics_evaluator.py (576 lines)\nPurpose: Forward dynamics evaluation across backends\nResponsibilities:\n\nEvaluate dx/dt = f(x, u) for controlled systems\nEvaluate dx/dt = f(x) for autonomous systems (u=None)\nHandle batched vs single evaluation\nBackend-specific dispatch\nInput shape validation\nPerformance tracking\n\nKey Features:\n# Single evaluation\ndx = evaluator.evaluate(x, u, backend='numpy')\n\n# Autonomous system (u=None)\ndx = evaluator.evaluate(x, backend='numpy')\n\n# Batched evaluation\nx_batch = np.random.randn(100, nx)  # (batch, nx)\nu_batch = np.random.randn(100, nu)  # (batch, nu)\ndx_batch = evaluator.evaluate(x_batch, u_batch)  # (batch, nx)\n\n# Get performance stats\nstats = evaluator.get_stats()\nprint(f\"Total evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']:.6f}s\")\nBackend Dispatch:\n\nAutomatically detects input backend\nUses cached compiled functions\nHandles shape mismatches gracefully\nConverts outputs to match input backend\n\nPerformance Tracking:\n{\n    'count': int,        # Number of evaluations\n    'total_time': float, # Total time (seconds)\n    'avg_time': float,   # Average per evaluation\n    'min_time': float,   # Fastest evaluation\n    'max_time': float,   # Slowest evaluation\n}\n\n\n\n\nFile: linearization_engine.py (907 lines)\nPurpose: Compute linearizations (Jacobians) at equilibria\nResponsibilities:\n\nCompute continuous Jacobians: A = ∂f/∂x, B = ∂f/∂u\nCompute discrete Jacobians: Ad = ∂f/∂x, Bd = ∂f/∂u\nHandle higher-order systems (order &gt; 1)\nAutomatic state-space construction\nSymbolic and numerical Jacobians\nBackend-agnostic evaluation\n\nMathematical Forms:\nContinuous Systems:\nLinearization at (x_eq, u_eq):\nδẋ = A·δx + B·δu\n\nwhere:\nA = ∂f/∂x|(x_eq, u_eq)  ∈ ℝ^(nx × nx)\nB = ∂f/∂u|(x_eq, u_eq)  ∈ ℝ^(nx × nu)\nDiscrete Systems:\nLinearization at (x_eq, u_eq):\nδx[k+1] = Ad·δx[k] + Bd·δu[k]\n\nwhere:\nAd = ∂f/∂x|(x_eq, u_eq)  ∈ ℝ^(nx × nx)\nBd = ∂f/∂u|(x_eq, u_eq)  ∈ ℝ^(nx × nu)\nKey Features:\n# Continuous linearization\nA, B = engine.linearize_continuous(x_eq, u_eq, backend='numpy')\n\n# Discrete linearization\nAd, Bd = engine.linearize_discrete(x_eq, u_eq, backend='numpy')\n\n# Higher-order systems (automatic state-space)\n# For order=2 system: q̈ = f(q, q̇, u)\n# Automatically constructs: [q̇, q̈]ᵀ = A[q, q̇]ᵀ + Bu\nA, B = engine.linearize_continuous(x_eq, u_eq)\n\n# Get symbolic Jacobians (one-time computation)\nA_sym = engine.get_symbolic_A()\nB_sym = engine.get_symbolic_B()\nHigher-Order Handling:\nFor order=n systems where state is [q, q̇, ..., q^(n-1)] and only q^(n) is returned:\n\nAutomatically constructs full state derivative\nComputes Jacobian of full state-space form\nReturns proper (nx × nx) and (nx × nu) matrices\n\n\n\n\n\nFile: observation_engine.py (628 lines)\nPurpose: Output function evaluation and linearization\nResponsibilities:\n\nEvaluate output: y = h(x)\nCompute output Jacobian: C = ∂h/∂x\nBatched output evaluation\nMulti-backend support\nPerformance tracking\n\nMathematical Form:\nOutput equation:\ny = h(x)\n\nOutput linearization:\nδy = C·δx\n\nwhere:\nC = ∂h/∂x|(x_eq)  ∈ ℝ^(ny × nx)\nKey Features:\n# Evaluate output\ny = engine.observe(x, backend='numpy')\n\n# Batched evaluation\nx_batch = np.random.randn(100, nx)\ny_batch = engine.observe(x_batch)  # (100, ny)\n\n# Output Jacobian\nC = engine.linearize_output(x_eq, backend='numpy')\n\n# Check if output defined\nif engine.has_output():\n    y = engine.observe(x)\nValidation:\n\nEnsures h(x) doesn’t depend on control u\nChecks dimension consistency\nValidates symbolic expressions\n\n\n\n\n\n\n\n\nFile: diffusion_handler.py (1,069 lines)\nPurpose: Generate and cache diffusion functions for SDEs\nResponsibilities:\n\nGenerate diffusion matrix: g(x, u) ∈ ℝ^(nx × nw)\nAutomatic noise structure detection\nSpecialized functions for additive/diagonal/scalar noise\nMulti-backend diffusion compilation\nStratonovich correction computation\nPerformance optimization\n\nMathematical Form:\nSDE: dx = f(x, u)dt + g(x, u)dW\n\nDiffusion matrix g(x, u):\n- Shape: (nx, nw)\n- nx: state dimension\n- nw: number of independent Wiener processes\n\nNoise types (auto-detected):\n- ADDITIVE: g(x, u) = constant\n- MULTIPLICATIVE: g depends on x or u\n- DIAGONAL: g is diagonal (independent noise)\n- SCALAR: nw = 1 (single Wiener process)\nKey Features:\n# Generate diffusion function\ng_func = handler.generate_diffusion('numpy')\n\n# Evaluate diffusion\ng_matrix = handler.evaluate_diffusion(x, u, backend='numpy')\n\n# Automatic noise detection\nnoise_type = handler.get_noise_type()\n# Returns: ADDITIVE, MULTIPLICATIVE_DIAGONAL, etc.\n\n# Stratonovich correction\ncorrection = handler.compute_stratonovich_correction(x, u)\n\n# Optimized for additive noise\nif handler.is_additive():\n    g_const = handler.get_additive_matrix()  # Constant matrix\nNoise Structure Exploitation:\n\nAdditive (constant): Returns constant matrix, no recomputation needed\nMultiplicative types:\n\nDiagonal: Independent noise channels, specialized handling\nScalar: Single Wiener process (nw=1), simplified operations\nGeneral: Full matrix coupling, complete computation\n\n\n\n\n\n\nFile: noise_analysis.py (692 lines)\nPurpose: Automatic noise structure analysis\nResponsibilities:\n\nDetect noise types (additive, multiplicative, etc.)\nIdentify noise structure (diagonal, scalar, general)\nRecommend optimal SDE solvers\nCompute noise statistics\nValidate noise properties\n\nNoise Classification:\nNoiseType:\n├─ ADDITIVE               # g(x,u) = constant\n├─ MULTIPLICATIVE         # g depends on x or u\n│  ├─ DIAGONAL            # Independent noise sources\n│  ├─ SCALAR              # Single Wiener process\n│  └─ GENERAL             # Full coupling\n└─ UNKNOWN                # Cannot determine\nKey Features:\n# Automatic characterization\ncharacteristics = characterizer.analyze()\n\n# Access properties\nnoise_type = characteristics.noise_type\nis_additive = characteristics.is_additive\nis_diagonal = characteristics.is_diagonal\nnw = characteristics.nw  # Number of Wiener processes\n\n# Solver recommendations\nsolvers = characteristics.recommend_solvers('torch')\n# Returns: ['heun', 'reversible_heun'] for additive\n# Returns: ['euler-maruyama'] for multiplicative\n\n# Validation\nif not characteristics.is_valid:\n    print(characteristics.validation_message)\nSolver Recommendations:\n\n\n\nNoise Type\nBackend\nRecommended Solvers\n\n\n\n\nAdditive\nPyTorch\nheun, reversible_heun\n\n\nAdditive\nJAX\nheun, reversible_heun\n\n\nMultiplicative Diagonal\nNumPy\nmilstein\n\n\nGeneral\nAll\neuler-maruyama\n\n\n\n\n\n\n\nFile: sde_validator.py (544 lines)\nPurpose: SDE-specific validation\nResponsibilities:\n\nValidate diffusion matrix dimensions\nCheck SDE type (Itô vs Stratonovich)\nEnsure compatibility with drift\nVerify noise structure claims\nValidate stochastic system definition\n\nValidation Checks:\n✓ diffusion_expr is sp.Matrix\n✓ Dimensions: (nx, nw) where nw ≥ 1\n✓ diffusion_expr only uses state_vars and control_vars\n✓ sde_type is 'ito' or 'stratonovich'\n✓ Compatibility with drift _f_sym\n✓ No division by zero in diffusion terms\n✓ Finite symbolic expressions\nExample Errors Caught:\n# Bad: Wrong dimensions\nself.diffusion_expr = sp.Matrix([[sigma]])  # nx=2, but only 1 row\n# Good: Correct dimensions\nself.diffusion_expr = sp.Matrix([[sigma], [0]])  # (2, 1)\n\n# Bad: Invalid SDE type\nself.sde_type = 'unknown'  # ❌\n# Good: Valid type\nself.sde_type = 'ito'  # ✓\n\n\n\n\n\n\n\nFile: codegen_utils.py (733 lines)\nPurpose: Low-level SymPy → executable code conversion\nResponsibilities:\n\nSymPy Matrix → callable function\nBackend-specific code generation\nCommon subexpression elimination (CSE)\nSymbolic simplification strategies\nNumPy/PyTorch/JAX code generation\nFunction signature handling\n\nKey Functions:\n# Main generation function\nfunc = generate_function(\n    expr,           # sp.Matrix symbolic expression\n    input_vars,     # List of sp.Symbol variables\n    backend='numpy', # Target backend\n    simplify=True,  # Apply simplification\n    cse=True,       # Common subexpression elimination\n    jit=False       # JIT compile (JAX only)\n)\n\n# Backend-specific optimizations\nfunc_numpy = generate_function(expr, vars, backend='numpy', cse=True)\nfunc_torch = generate_function(expr, vars, backend='torch', simplify=True)\nfunc_jax = generate_function(expr, vars, backend='jax', jit=True)\nOptimization Strategies:\nNumPy:\n\nCommon subexpression elimination (CSE)\nFast numerical modules (‘numpy’, ‘scipy’)\nMatrix operations optimization\n\nPyTorch:\n\nSymbolic simplification before generation\nAutomatic differentiation compatibility\nGPU tensor operations\n\nJAX:\n\nJIT compilation via jax.jit\nPure functional style\nXLA optimization\nAutomatic vectorization\n\nGenerated Function Signatures:\n# Dynamics function\nf(x, u) → dx/dt\n# where x: array(nx,), u: array(nu,) → array(nx,)\n\n# Jacobian function\nA(x, u) → matrix(nx, nx)\nB(x, u) → matrix(nx, nu)\n\n# Output function\nh(x) → y\n# where x: array(nx,) → array(ny,)"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#composition-patterns",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#composition-patterns",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "Used by: All symbolic systems\n# In SymbolicSystemBase.__init__():\nself.backend = BackendManager(default_backend, default_device)\nself._code_gen = CodeGenerator(self, self.backend)\nself._validator = SymbolicValidator()\nself.equilibria = EquilibriumHandler(nx, nu)\n\n\n\nUsed by: ContinuousSymbolicSystem, DiscreteSymbolicSystem\n# In ContinuousSymbolicSystem.__init__():\nsuper().__init__(*args, **kwargs)  # Sets up core utilities\n\n# Add deterministic evaluators\nself._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\nself._linearization = LinearizationEngine(self, self._code_gen, self.backend)\nself._observation = ObservationEngine(self, self._code_gen, self.backend)\n\n\n\nUsed by: ContinuousStochasticSystem, DiscreteStochasticSystem\n# In ContinuousStochasticSystem.__init__():\nsuper().__init__(*args, **kwargs)  # Sets up deterministic utilities\n\n# Add stochastic support\nself.diffusion_handler = DiffusionHandler(self, self._code_gen, self.backend)\nself.noise_characteristics = NoiseCharacterizer().analyze(self.diffusion_expr)\nself._sde_validator = SDEValidator()"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#file-size-summary",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#file-size-summary",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "File\nLines\nPurpose\n\n\n\n\nbackend_manager.py\n545\nMulti-backend support\n\n\ncode_generator.py\n565\nSymbolic → numerical\n\n\nequilibrium_handler.py\n221\nEquilibrium management\n\n\nsymbolic_validator.py\n718\nSystem validation\n\n\nSubtotal\n2,049\nCore services\n\n\n\n\n\n\n\n\n\nFile\nLines\nPurpose\n\n\n\n\ndynamics_evaluator.py\n576\nForward dynamics\n\n\nlinearization_engine.py\n907\nJacobian computation\n\n\nobservation_engine.py\n628\nOutput evaluation\n\n\nSubtotal\n2,111\nDeterministic\n\n\n\n\n\n\n\n\n\nFile\nLines\nPurpose\n\n\n\n\ndiffusion_handler.py\n1,069\nDiffusion generation\n\n\nnoise_analysis.py\n692\nNoise characterization\n\n\nsde_validator.py\n544\nSDE validation\n\n\nSubtotal\n2,305\nStochastic\n\n\n\n\n\n\n\n\n\nFile\nLines\nPurpose\n\n\n\n\ncodegen_utils.py\n733\nCode generation\n\n\nSubtotal\n733\nLow-level\n\n\n\nTotal: 7,198 lines of delegation layer code"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#design-principles",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#design-principles",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "Each class has one clear purpose:\n\nBackendManager → Backend management ONLY\nCodeGenerator → Code generation ONLY\nDynamicsEvaluator → Dynamics evaluation ONLY\n\n\n\n\nSystems compose utilities rather than inherit:\n# NOT: class System(BackendManager, CodeGenerator, ...)\n# YES: class System:\n#          self.backend = BackendManager()\n#          self._code_gen = CodeGenerator()\n\n\n\nUtilities receive dependencies via constructor:\nDynamicsEvaluator(system, code_gen, backend_mgr)\n\n\n\nEach utility has focused, minimal interface:\n\nBackendManager: detect, convert, to_backend\nCodeGenerator: generate_dynamics, generate_jacobian_A/B/C\nDynamicsEvaluator: evaluate\n\n\n\n\nFunctions generated and cached on first use:\n# First call: generates and caches\nf = code_gen.generate_dynamics('numpy')\n\n# Subsequent calls: returns cached\nf_again = code_gen.generate_dynamics('numpy')\nassert f is f_again  # Same object\n\n\n\nUtilities work with all backends transparently:\n# Same interface, different backends\ndx_numpy = evaluator.evaluate(x_np, u_np, backend='numpy')\ndx_torch = evaluator.evaluate(x_torch, u_torch, backend='torch')\ndx_jax = evaluator.evaluate(x_jax, u_jax, backend='jax')"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#usage-examples",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#usage-examples",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "from src.systems.base import ContinuousSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym = sp.symbols('m k', positive=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k_sym*x/m_sym + u/m_sym])\n        self.parameters = {m_sym: m, k_sym: k}\n        self.order = 1\n\n# System automatically sets up:\nsystem = MySystem()\n# system.backend         (BackendManager)\n# system._code_gen       (CodeGenerator)\n# system._dynamics       (DynamicsEvaluator)\n# system._linearization  (LinearizationEngine)\n# system.equilibria      (EquilibriumHandler)\n\n# Use the delegated functionality\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\n\n# Dynamics (via DynamicsEvaluator)\ndx = system(x, u)\n\n# Linearization (via LinearizationEngine)\nA, B = system.linearize(np.zeros(2), np.zeros(1))\n\n# Equilibria (via EquilibriumHandler)\nsystem.add_equilibrium('test', x_eq=np.zeros(2), u_eq=np.zeros(1))\n\n\n\nimport torch\n\n# Switch backend for entire system\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# Backend manager handles conversions\nx_torch = torch.tensor([[1.0, 0.0]], device='cuda:0')\nu_torch = torch.tensor([[0.5]], device='cuda:0')\n\n# Automatically uses PyTorch backend\ndx_torch = system(x_torch, u_torch)\n\n# Equilibria converted on demand\nx_eq_torch = system.equilibria.get_x('origin', backend='torch')\n\n\n\n# First call: generates and caches\nimport time\n\nstart = time.time()\nf_numpy = system._code_gen.generate_dynamics('numpy')\nt1 = time.time() - start\nprint(f\"First generation: {t1:.3f}s\")\n\n# Second call: returns cached (instant)\nstart = time.time()\nf_numpy_again = system._code_gen.generate_dynamics('numpy')\nt2 = time.time() - start\nprint(f\"Cached retrieval: {t2:.6f}s\")  # ~0.000001s\n\nassert f_numpy is f_numpy_again  # Same function object\n\n\n\nfrom src.systems.base import ContinuousStochasticSystem\n\nclass StochasticOscillator(ContinuousStochasticSystem):\n    def define_system(self, k=10.0, sigma=0.5):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        k_sym, sigma_sym = sp.symbols('k sigma', positive=True)\n        \n        # Drift\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k_sym*x + u])\n        self.parameters = {k_sym: k, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion (additive noise)\n        self.diffusion_expr = sp.Matrix([[0], [sigma_sym]])\n        self.sde_type = 'ito'\n\n# System sets up additional stochastic delegation:\nsde_system = StochasticOscillator()\n# sde_system.diffusion_handler       (DiffusionHandler)\n# sde_system.noise_characteristics   (NoiseCharacteristics)\n# (plus all deterministic utilities)\n\n# Use stochastic functionality\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\n\n# Drift (via DynamicsEvaluator)\nf = sde_system.drift(x, u)\n\n# Diffusion (via DiffusionHandler)\ng = sde_system.diffusion(x, u)\n\n# Noise analysis (automatic)\nprint(f\"Noise type: {sde_system.noise_characteristics.noise_type}\")\nprint(f\"Additive: {sde_system.is_additive_noise()}\")\nprint(f\"Recommended solvers: {sde_system.recommend_solvers('torch')}\")\n\n\n\n# DynamicsEvaluator tracks performance\nfor i in range(1000):\n    dx = system(np.random.randn(2), np.zeros(1))\n\n# Get statistics\nstats = system._dynamics.get_stats()\nprint(f\"Evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']:.6f}s\")\nprint(f\"Total time: {stats['total_time']:.3f}s\")"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Architecture.html#key-strengths",
    "href": "api/delegation_layer/Delegation_Layer_Architecture.html#key-strengths",
    "title": "ControlDESymulation Delegation Layer Architecture",
    "section": "",
    "text": "Clean Separation - Each utility has one responsibility\nReusability - Can use utilities independently\nTestability - Easy to test in isolation\nFlexibility - Easy to add new utilities\nPerformance - Caching and lazy initialization\nMulti-Backend - Seamless backend switching\nType Safety - TypedDict and semantic types\nDocumentation - Clear purpose and interface\nMaintainability - Easy to understand and modify\nExtensibility - Composition enables new features\n\nThis delegation layer is the foundation that makes the UI framework clean, powerful, and maintainable!"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Create and switch to new branch in one command\ngit switch -c feature/unified-discrete-interface\n\n# Verify you're on the new branch\ngit branch --show-current\n\n\n\n# Create and switch to new branch\ngit checkout -b feature/unified-discrete-interface\n\n# Verify you're on the new branch\ngit branch\n\n\n\n# Create the branch (but stay on current branch)\ngit branch feature/unified-discrete-interface\n\n# Switch to it\ngit switch feature/unified-discrete-interface\n# OR\ngit checkout feature/unified-discrete-interface\n\n\n\n\n\n\n\n# Switch to main branch\ngit switch main\n# OR if your default branch is 'master'\ngit switch master\n\n# Make sure you have latest changes\ngit pull origin main\n\n\n\n# Create and switch to feature branch\ngit switch -c feature/unified-discrete-interface\n\n# Push branch to remote (GitHub) and set upstream\ngit push -u origin feature/unified-discrete-interface\nBranch Naming Convention: - feature/ - New features - bugfix/ - Bug fixes - hotfix/ - Urgent production fixes - refactor/ - Code refactoring (your case) - docs/ - Documentation updates\nAlternative branch name (more descriptive):\ngit switch -c refactor/unified-discrete-interface-types\n\n\n\n# Check current branch\ngit branch --show-current\n\n# See all branches (local and remote)\ngit branch -a\n\n# See which remote your branch tracks\ngit branch -vv\n\n\n\n\n\n\n\n# 1. Make your code changes\n\n# 2. Check what changed\ngit status\n\n# 3. Stage changes\ngit add src/systems/base/core/continuous_system_base.py\n# OR stage all changes\ngit add .\n\n# 4. Commit with descriptive message\ngit commit -m \"Phase 1.1: Create ContinuousSystemBase abstract class\"\n\n# 5. Push to remote\ngit push\n\n\n\n# Good commit messages\ngit commit -m \"Phase 1.1: Add ContinuousSystemBase with abstract methods\"\ngit commit -m \"Phase 2.1: Rename SymbolicDynamicalSystem to ContinuousSymbolicSystem\"\ngit commit -m \"Phase 3.4: Add LinearizationResult structured return types\"\n\n# Include more detail in multi-line commits\ngit commit -m \"Phase 3.4: Add LinearizationResult types\n\n- Create ContinuousLinearization dataclass\n- Create DiscreteLinearization dataclass  \n- Update linearize() methods to return structured types\n- Add backward compatibility via __iter__\n\nCloses #123\"\n\n\n\n# Push current branch to remote\ngit push\n\n# If first time pushing this branch\ngit push -u origin feature/unified-discrete-interface\n\n# Force push (CAREFUL - only use if you're alone on branch)\ngit push --force-with-lease\n\n\n\n\n\n\n\n# Switch to your feature branch\ngit switch feature/unified-discrete-interface\n\n# Fetch latest from remote\ngit fetch origin\n\n# Merge main into your branch\ngit merge origin/main\n\n# If conflicts, resolve them, then:\ngit add .\ngit commit -m \"Merge main into feature branch\"\ngit push\n\n\n\n# Switch to your feature branch\ngit switch feature/unified-discrete-interface\n\n# Fetch latest\ngit fetch origin\n\n# Rebase on main\ngit rebase origin/main\n\n# If conflicts, resolve them, then:\ngit add .\ngit rebase --continue\n\n# Force push (rebase rewrites history)\ngit push --force-with-lease\nWhen to use which: - Merge: Safer, preserves all history, creates merge commits - Rebase: Cleaner history, but rewrites commits (don’t use on shared branches)\n\n\n\n\n\n\n\n# Local branches\ngit branch\n\n# Remote branches\ngit branch -r\n\n# All branches (local + remote)\ngit branch -a\n\n# Branches with last commit info\ngit branch -v\n\n\n\n# Switch to existing branch\ngit switch main\ngit switch feature/unified-discrete-interface\n\n# Switch to previous branch\ngit switch -\n\n\n\n# Delete local branch (only if fully merged)\ngit branch -d feature/unified-discrete-interface\n\n# Force delete local branch\ngit branch -D feature/unified-discrete-interface\n\n# Delete remote branch\ngit push origin --delete feature/unified-discrete-interface\n\n\n\n\n\n\n\n# Morning: Update your branch\ngit switch feature/unified-discrete-interface\ngit pull origin feature/unified-discrete-interface\ngit merge origin/main  # Get latest from main\n\n# Work on Phase 1.1\n# ... make changes ...\n\n# Commit your work\ngit add .\ngit commit -m \"Phase 1.1: Complete ContinuousSystemBase implementation\"\ngit push\n\n# Repeat for each phase/task\n\n\n\n# Small, frequent commits as you work\ngit add src/systems/base/core/continuous_system_base.py\ngit commit -m \"WIP: Add abstract methods to ContinuousSystemBase\"\ngit push\n\n# Continue working...\ngit add tests/core_class_unit_tests/continuous_system_base_test.py\ngit commit -m \"WIP: Add tests for ContinuousSystemBase\"\ngit push\n\n# When phase complete\ngit commit -m \"Phase 1.1: Complete ContinuousSystemBase with tests\"\ngit push\n\n\n\n# Oops, forgot to add a file to last commit\ngit add forgotten_file.py\ngit commit --amend --no-edit\ngit push --force-with-lease\n\n# Oops, want to change last commit message\ngit commit --amend -m \"Phase 1.1: Better commit message\"\ngit push --force-with-lease\n\n# Oops, want to undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Oops, want to undo last commit (discard changes)\ngit reset --hard HEAD~1\n\n\n\n\n\n\n\n# Switch to your branch\ngit switch feature/unified-discrete-interface\n\n# Pull latest changes\ngit pull\n\n# Run all tests\npytest tests/\n\n# Ensure no uncommitted changes\ngit status\n\n\n\n# Get latest main\ngit fetch origin\n\n# Merge main into your branch (resolve any conflicts)\ngit merge origin/main\n\n# Run tests again\npytest tests/\n\n# Push updated branch\ngit push\n\n\n\n\nGo to your repository on GitHub\nClick “Pull requests” tab\nClick “New pull request”\nSelect:\n\nBase: main\nCompare: feature/unified-discrete-interface\n\nFill in PR description (use template below)\nRequest reviewers\nClick “Create pull request”\n\n\n\n\n# Option A: Merge via GitHub interface (recommended)\n# - Click \"Merge pull request\" on GitHub\n# - Choose merge strategy (usually \"Squash and merge\" or \"Merge commit\")\n\n# Option B: Merge locally\ngit switch main\ngit pull origin main\ngit merge feature/unified-discrete-interface\ngit push origin main\n\n\n\n# Delete local branch\ngit branch -d feature/unified-discrete-interface\n\n# Delete remote branch\ngit push origin --delete feature/unified-discrete-interface\n\n\n\n\n\nCreate .github/PULL_REQUEST_TEMPLATE.md:\n## Description\nBrief description of changes\n\n## Related Issue\nCloses #[issue number]\n\n## Type of Change\n- [ ] Refactoring (restructuring code without changing functionality)\n- [ ] New feature\n- [ ] Bug fix\n- [ ] Breaking change\n- [ ] Documentation update\n\n## Phases Completed\n- [ ] Phase 0: Pre-implementation preparation\n- [ ] Phase 1: Abstract base classes\n- [ ] Phase 2: Rename continuous systems\n- [ ] Phase 3: Type system integration\n- [ ] Phase 4: Discrete systems refactor\n... etc\n\n## Testing\n- [ ] All existing tests pass\n- [ ] New tests added for new functionality\n- [ ] Test coverage maintained/improved\n- [ ] Manual testing completed\n\n## Breaking Changes\nList any breaking changes and migration path\n\n## Checklist\n- [ ] Code follows project style guidelines\n- [ ] Self-review completed\n- [ ] Documentation updated\n- [ ] No new warnings introduced\n- [ ] Backward compatibility maintained (or documented)\n\n\n\n\n\n\n# Create branch for Phase 1\ngit switch -c phase-1-base-classes\n# ... work on Phase 1 ...\ngit push -u origin phase-1-base-classes\n\n# Create branch for Phase 2 (based on main, not Phase 1)\ngit switch main\ngit switch -c phase-2-rename-classes\n# ... work on Phase 2 ...\ngit push -u origin phase-2-rename-classes\n\n# Switch between branches\ngit switch phase-1-base-classes\ngit switch phase-2-rename-classes\ngit switch main\n\n\n\n# Complete Phase 1\ngit switch phase-1-base-classes\n# ... finish work ...\ngit push\n\n# Create Phase 2 branch FROM Phase 1\ngit switch -c phase-2-rename-classes phase-1-base-classes\n# ... work on Phase 2 ...\ngit push -u origin phase-2-rename-classes\n\n# When Phase 1 is merged to main, update Phase 2\ngit switch phase-2-rename-classes\ngit rebase main\n\n\n\n\n\n\n\n# Solution 1: Commit changes\ngit add .\ngit commit -m \"WIP: Save current work\"\ngit switch other-branch\n\n# Solution 2: Stash changes\ngit stash\ngit switch other-branch\n# Later, restore changes\ngit switch original-branch\ngit stash pop\n\n# Solution 3: Discard changes (CAREFUL!)\ngit reset --hard\ngit switch other-branch\n\n\n\n# Your local branch diverged from remote\ngit pull --rebase origin feature/unified-discrete-interface\n# Resolve conflicts if any\ngit push\n\n\n\n# You're on main but should be on feature branch\ngit switch -c feature/unified-discrete-interface  # Create branch from current state\ngit switch main\ngit reset --hard origin/main  # Reset main to remote state\n\n\n\n# When merging/rebasing\ngit merge origin/main\n# CONFLICT (content): Merge conflict in some_file.py\n\n# 1. Open conflicted files, resolve conflicts\n# Look for &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD markers\n\n# 2. Stage resolved files\ngit add some_file.py\n\n# 3. Complete merge\ngit commit  # For merge\n# OR\ngit rebase --continue  # For rebase\n\n\n\n\n\n\n\n# Set your identity\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Set default branch name\ngit config --global init.defaultBranch main\n\n# Enable helpful colors\ngit config --global color.ui auto\n\n# Set default editor\ngit config --global core.editor \"code --wait\"  # VS Code\n# OR\ngit config --global core.editor \"vim\"  # Vim\n\n# Enable auto-correction\ngit config --global help.autocorrect 1\n\n\n\n# Add to ~/.gitconfig or run these commands\ngit config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.sw switch\ngit config --global alias.br branch\ngit config --global alias.ci commit\ngit config --global alias.unstage 'reset HEAD --'\ngit config --global alias.last 'log -1 HEAD'\ngit config --global alias.visual 'log --graph --oneline --all'\n\n# Now you can use:\ngit st          # Instead of git status\ngit sw main     # Instead of git switch main\ngit visual      # See branch graph\n\n\n\n\n\n# 1. Start fresh\ngit switch main\ngit pull origin main\n\n# 2. Create feature branch\ngit switch -c feature/unified-discrete-interface\ngit push -u origin feature/unified-discrete-interface\n\n# 3. Work on phases\n# Phase 1\ngit add .\ngit commit -m \"Phase 1: Complete abstract base classes\"\ngit push\n\n# Phase 2\ngit add .\ngit commit -m \"Phase 2: Rename continuous systems\"\ngit push\n\n# ... continue for each phase\n\n# 4. Keep updated with main\ngit fetch origin\ngit merge origin/main\n# Resolve conflicts if any\ngit push\n\n# 5. When complete, create PR on GitHub\n\n# 6. After PR merged, cleanup\ngit switch main\ngit pull origin main\ngit branch -d feature/unified-discrete-interface\n\n\n\n\n# CREATE & SWITCH\ngit switch -c branch-name          # Create and switch\ngit push -u origin branch-name     # Push new branch\n\n# SWITCH\ngit switch branch-name             # Switch to branch\ngit switch -                       # Switch to previous branch\n\n# UPDATE\ngit pull                          # Update current branch\ngit fetch origin                  # Fetch all changes\ngit merge origin/main             # Merge main into current\n\n# COMMIT\ngit add .                         # Stage all changes\ngit commit -m \"message\"           # Commit with message\ngit push                          # Push to remote\n\n# VIEW\ngit branch                        # List local branches\ngit branch -a                     # List all branches\ngit status                        # See current state\ngit log --oneline                 # See commit history\n\n# DELETE\ngit branch -d branch-name         # Delete local branch\ngit push origin --delete branch-name  # Delete remote branch\n\nGood luck with your refactoring! Start with Phase 0, create your branch, and work through each phase systematically. 🚀"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#quick-start-create-and-switch-to-feature-branch",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#quick-start-create-and-switch-to-feature-branch",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Create and switch to new branch in one command\ngit switch -c feature/unified-discrete-interface\n\n# Verify you're on the new branch\ngit branch --show-current\n\n\n\n# Create and switch to new branch\ngit checkout -b feature/unified-discrete-interface\n\n# Verify you're on the new branch\ngit branch\n\n\n\n# Create the branch (but stay on current branch)\ngit branch feature/unified-discrete-interface\n\n# Switch to it\ngit switch feature/unified-discrete-interface\n# OR\ngit checkout feature/unified-discrete-interface"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#complete-branching-workflow",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#complete-branching-workflow",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Switch to main branch\ngit switch main\n# OR if your default branch is 'master'\ngit switch master\n\n# Make sure you have latest changes\ngit pull origin main\n\n\n\n# Create and switch to feature branch\ngit switch -c feature/unified-discrete-interface\n\n# Push branch to remote (GitHub) and set upstream\ngit push -u origin feature/unified-discrete-interface\nBranch Naming Convention: - feature/ - New features - bugfix/ - Bug fixes - hotfix/ - Urgent production fixes - refactor/ - Code refactoring (your case) - docs/ - Documentation updates\nAlternative branch name (more descriptive):\ngit switch -c refactor/unified-discrete-interface-types\n\n\n\n# Check current branch\ngit branch --show-current\n\n# See all branches (local and remote)\ngit branch -a\n\n# See which remote your branch tracks\ngit branch -vv"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#working-on-your-branch",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#working-on-your-branch",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# 1. Make your code changes\n\n# 2. Check what changed\ngit status\n\n# 3. Stage changes\ngit add src/systems/base/core/continuous_system_base.py\n# OR stage all changes\ngit add .\n\n# 4. Commit with descriptive message\ngit commit -m \"Phase 1.1: Create ContinuousSystemBase abstract class\"\n\n# 5. Push to remote\ngit push\n\n\n\n# Good commit messages\ngit commit -m \"Phase 1.1: Add ContinuousSystemBase with abstract methods\"\ngit commit -m \"Phase 2.1: Rename SymbolicDynamicalSystem to ContinuousSymbolicSystem\"\ngit commit -m \"Phase 3.4: Add LinearizationResult structured return types\"\n\n# Include more detail in multi-line commits\ngit commit -m \"Phase 3.4: Add LinearizationResult types\n\n- Create ContinuousLinearization dataclass\n- Create DiscreteLinearization dataclass  \n- Update linearize() methods to return structured types\n- Add backward compatibility via __iter__\n\nCloses #123\"\n\n\n\n# Push current branch to remote\ngit push\n\n# If first time pushing this branch\ngit push -u origin feature/unified-discrete-interface\n\n# Force push (CAREFUL - only use if you're alone on branch)\ngit push --force-with-lease"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#keeping-your-branch-updated",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#keeping-your-branch-updated",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Switch to your feature branch\ngit switch feature/unified-discrete-interface\n\n# Fetch latest from remote\ngit fetch origin\n\n# Merge main into your branch\ngit merge origin/main\n\n# If conflicts, resolve them, then:\ngit add .\ngit commit -m \"Merge main into feature branch\"\ngit push\n\n\n\n# Switch to your feature branch\ngit switch feature/unified-discrete-interface\n\n# Fetch latest\ngit fetch origin\n\n# Rebase on main\ngit rebase origin/main\n\n# If conflicts, resolve them, then:\ngit add .\ngit rebase --continue\n\n# Force push (rebase rewrites history)\ngit push --force-with-lease\nWhen to use which: - Merge: Safer, preserves all history, creates merge commits - Rebase: Cleaner history, but rewrites commits (don’t use on shared branches)"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#viewing-and-managing-branches",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#viewing-and-managing-branches",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Local branches\ngit branch\n\n# Remote branches\ngit branch -r\n\n# All branches (local + remote)\ngit branch -a\n\n# Branches with last commit info\ngit branch -v\n\n\n\n# Switch to existing branch\ngit switch main\ngit switch feature/unified-discrete-interface\n\n# Switch to previous branch\ngit switch -\n\n\n\n# Delete local branch (only if fully merged)\ngit branch -d feature/unified-discrete-interface\n\n# Force delete local branch\ngit branch -D feature/unified-discrete-interface\n\n# Delete remote branch\ngit push origin --delete feature/unified-discrete-interface"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#common-workflows",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#common-workflows",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Morning: Update your branch\ngit switch feature/unified-discrete-interface\ngit pull origin feature/unified-discrete-interface\ngit merge origin/main  # Get latest from main\n\n# Work on Phase 1.1\n# ... make changes ...\n\n# Commit your work\ngit add .\ngit commit -m \"Phase 1.1: Complete ContinuousSystemBase implementation\"\ngit push\n\n# Repeat for each phase/task\n\n\n\n# Small, frequent commits as you work\ngit add src/systems/base/core/continuous_system_base.py\ngit commit -m \"WIP: Add abstract methods to ContinuousSystemBase\"\ngit push\n\n# Continue working...\ngit add tests/core_class_unit_tests/continuous_system_base_test.py\ngit commit -m \"WIP: Add tests for ContinuousSystemBase\"\ngit push\n\n# When phase complete\ngit commit -m \"Phase 1.1: Complete ContinuousSystemBase with tests\"\ngit push\n\n\n\n# Oops, forgot to add a file to last commit\ngit add forgotten_file.py\ngit commit --amend --no-edit\ngit push --force-with-lease\n\n# Oops, want to change last commit message\ngit commit --amend -m \"Phase 1.1: Better commit message\"\ngit push --force-with-lease\n\n# Oops, want to undo last commit (keep changes)\ngit reset --soft HEAD~1\n\n# Oops, want to undo last commit (discard changes)\ngit reset --hard HEAD~1"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#merging-your-branch-back-to-main",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#merging-your-branch-back-to-main",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Switch to your branch\ngit switch feature/unified-discrete-interface\n\n# Pull latest changes\ngit pull\n\n# Run all tests\npytest tests/\n\n# Ensure no uncommitted changes\ngit status\n\n\n\n# Get latest main\ngit fetch origin\n\n# Merge main into your branch (resolve any conflicts)\ngit merge origin/main\n\n# Run tests again\npytest tests/\n\n# Push updated branch\ngit push\n\n\n\n\nGo to your repository on GitHub\nClick “Pull requests” tab\nClick “New pull request”\nSelect:\n\nBase: main\nCompare: feature/unified-discrete-interface\n\nFill in PR description (use template below)\nRequest reviewers\nClick “Create pull request”\n\n\n\n\n# Option A: Merge via GitHub interface (recommended)\n# - Click \"Merge pull request\" on GitHub\n# - Choose merge strategy (usually \"Squash and merge\" or \"Merge commit\")\n\n# Option B: Merge locally\ngit switch main\ngit pull origin main\ngit merge feature/unified-discrete-interface\ngit push origin main\n\n\n\n# Delete local branch\ngit branch -d feature/unified-discrete-interface\n\n# Delete remote branch\ngit push origin --delete feature/unified-discrete-interface"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#pull-request-template",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#pull-request-template",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "Create .github/PULL_REQUEST_TEMPLATE.md:\n## Description\nBrief description of changes\n\n## Related Issue\nCloses #[issue number]\n\n## Type of Change\n- [ ] Refactoring (restructuring code without changing functionality)\n- [ ] New feature\n- [ ] Bug fix\n- [ ] Breaking change\n- [ ] Documentation update\n\n## Phases Completed\n- [ ] Phase 0: Pre-implementation preparation\n- [ ] Phase 1: Abstract base classes\n- [ ] Phase 2: Rename continuous systems\n- [ ] Phase 3: Type system integration\n- [ ] Phase 4: Discrete systems refactor\n... etc\n\n## Testing\n- [ ] All existing tests pass\n- [ ] New tests added for new functionality\n- [ ] Test coverage maintained/improved\n- [ ] Manual testing completed\n\n## Breaking Changes\nList any breaking changes and migration path\n\n## Checklist\n- [ ] Code follows project style guidelines\n- [ ] Self-review completed\n- [ ] Documentation updated\n- [ ] No new warnings introduced\n- [ ] Backward compatibility maintained (or documented)"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#advanced-working-with-multiple-feature-branches",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#advanced-working-with-multiple-feature-branches",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Create branch for Phase 1\ngit switch -c phase-1-base-classes\n# ... work on Phase 1 ...\ngit push -u origin phase-1-base-classes\n\n# Create branch for Phase 2 (based on main, not Phase 1)\ngit switch main\ngit switch -c phase-2-rename-classes\n# ... work on Phase 2 ...\ngit push -u origin phase-2-rename-classes\n\n# Switch between branches\ngit switch phase-1-base-classes\ngit switch phase-2-rename-classes\ngit switch main\n\n\n\n# Complete Phase 1\ngit switch phase-1-base-classes\n# ... finish work ...\ngit push\n\n# Create Phase 2 branch FROM Phase 1\ngit switch -c phase-2-rename-classes phase-1-base-classes\n# ... work on Phase 2 ...\ngit push -u origin phase-2-rename-classes\n\n# When Phase 1 is merged to main, update Phase 2\ngit switch phase-2-rename-classes\ngit rebase main"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#troubleshooting",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#troubleshooting",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Solution 1: Commit changes\ngit add .\ngit commit -m \"WIP: Save current work\"\ngit switch other-branch\n\n# Solution 2: Stash changes\ngit stash\ngit switch other-branch\n# Later, restore changes\ngit switch original-branch\ngit stash pop\n\n# Solution 3: Discard changes (CAREFUL!)\ngit reset --hard\ngit switch other-branch\n\n\n\n# Your local branch diverged from remote\ngit pull --rebase origin feature/unified-discrete-interface\n# Resolve conflicts if any\ngit push\n\n\n\n# You're on main but should be on feature branch\ngit switch -c feature/unified-discrete-interface  # Create branch from current state\ngit switch main\ngit reset --hard origin/main  # Reset main to remote state\n\n\n\n# When merging/rebasing\ngit merge origin/main\n# CONFLICT (content): Merge conflict in some_file.py\n\n# 1. Open conflicted files, resolve conflicts\n# Look for &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD markers\n\n# 2. Stage resolved files\ngit add some_file.py\n\n# 3. Complete merge\ngit commit  # For merge\n# OR\ngit rebase --continue  # For rebase"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#git-configuration-for-better-experience",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#git-configuration-for-better-experience",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# Set your identity\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Set default branch name\ngit config --global init.defaultBranch main\n\n# Enable helpful colors\ngit config --global color.ui auto\n\n# Set default editor\ngit config --global core.editor \"code --wait\"  # VS Code\n# OR\ngit config --global core.editor \"vim\"  # Vim\n\n# Enable auto-correction\ngit config --global help.autocorrect 1\n\n\n\n# Add to ~/.gitconfig or run these commands\ngit config --global alias.st status\ngit config --global alias.co checkout\ngit config --global alias.sw switch\ngit config --global alias.br branch\ngit config --global alias.ci commit\ngit config --global alias.unstage 'reset HEAD --'\ngit config --global alias.last 'log -1 HEAD'\ngit config --global alias.visual 'log --graph --oneline --all'\n\n# Now you can use:\ngit st          # Instead of git status\ngit sw main     # Instead of git switch main\ngit visual      # See branch graph"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#summary-refactoring-workflow",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#summary-refactoring-workflow",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# 1. Start fresh\ngit switch main\ngit pull origin main\n\n# 2. Create feature branch\ngit switch -c feature/unified-discrete-interface\ngit push -u origin feature/unified-discrete-interface\n\n# 3. Work on phases\n# Phase 1\ngit add .\ngit commit -m \"Phase 1: Complete abstract base classes\"\ngit push\n\n# Phase 2\ngit add .\ngit commit -m \"Phase 2: Rename continuous systems\"\ngit push\n\n# ... continue for each phase\n\n# 4. Keep updated with main\ngit fetch origin\ngit merge origin/main\n# Resolve conflicts if any\ngit push\n\n# 5. When complete, create PR on GitHub\n\n# 6. After PR merged, cleanup\ngit switch main\ngit pull origin main\ngit branch -d feature/unified-discrete-interface"
  },
  {
    "objectID": "personal_reference/GIT_BRANCHING_GUIDE.html#quick-reference-card",
    "href": "personal_reference/GIT_BRANCHING_GUIDE.html#quick-reference-card",
    "title": "Git Branching Guide for Refactoring Project",
    "section": "",
    "text": "# CREATE & SWITCH\ngit switch -c branch-name          # Create and switch\ngit push -u origin branch-name     # Push new branch\n\n# SWITCH\ngit switch branch-name             # Switch to branch\ngit switch -                       # Switch to previous branch\n\n# UPDATE\ngit pull                          # Update current branch\ngit fetch origin                  # Fetch all changes\ngit merge origin/main             # Merge main into current\n\n# COMMIT\ngit add .                         # Stage all changes\ngit commit -m \"message\"           # Commit with message\ngit push                          # Push to remote\n\n# VIEW\ngit branch                        # List local branches\ngit branch -a                     # List all branches\ngit status                        # See current state\ngit log --oneline                 # See commit history\n\n# DELETE\ngit branch -d branch-name         # Delete local branch\ngit push origin --delete branch-name  # Delete remote branch\n\nGood luck with your refactoring! Start with Phase 0, create your branch, and work through each phase systematically. 🚀"
  },
  {
    "objectID": "tutorials/basic_usage.html",
    "href": "tutorials/basic_usage.html",
    "title": "Basic Usage",
    "section": "",
    "text": "This tutorial covers the basics of defining and simulating dynamical systems."
  },
  {
    "objectID": "tutorials/basic_usage.html#introduction",
    "href": "tutorials/basic_usage.html#introduction",
    "title": "Basic Usage",
    "section": "",
    "text": "This tutorial covers the basics of defining and simulating dynamical systems."
  },
  {
    "objectID": "tutorials/basic_usage.html#setting-up",
    "href": "tutorials/basic_usage.html#setting-up",
    "title": "Basic Usage",
    "section": "Setting Up",
    "text": "Setting Up\nFirst, import the necessary modules:\n\n# TODO: Change once API regarding exports stabilizes\nimport sys\nfrom pathlib import Path\nsys.path.insert(0, str(Path.cwd().parent.parent))\n\nimport numpy as np\nimport sympy as sp\n# need to adjust import once API stabilizes\nfrom src.systems.base.core.continuous_symbolic_system import ContinuousSymbolicSystem\n\n# Set random seed for reproducibility\nnp.random.seed(42)"
  },
  {
    "objectID": "tutorials/basic_usage.html#defining-a-simple-system",
    "href": "tutorials/basic_usage.html#defining-a-simple-system",
    "title": "Basic Usage",
    "section": "Defining a Simple System",
    "text": "Defining a Simple System\nLet’s create a simple pendulum:\n\nclass SymbolicPendulum(ContinuousSymbolicSystem):\n    def define_system(\n        self,\n        m_val: float = 1.0,\n        l_val: float = 1.0,\n        beta_val: float = 1.0,\n        g_val: float = 9.81,\n    ):\n        \"\"\"First order model of a pendulum\"\"\"\n        # define the symbolic variables\n        theta, theta_dot = sp.symbols(\"theta theta_dot\", real=True)\n        u = sp.symbols(\"u\", real=True)\n        m, l, beta, g = sp.symbols(\"m l beta g\", real=True, positive=True)\n\n        # add the variables to the system fields properly\n        self.parameters = {m: m_val, l: l_val, beta: beta_val, g: g_val}\n        self.state_vars = [theta, theta_dot]\n        self.control_vars = [u]\n        self.order = 1\n\n        # define the dynamics of the system\n        ml2 = m * l * l\n        self._f_sym = sp.Matrix(\n            [theta_dot, (-beta / ml2) * theta_dot + (g / l) * sp.sin(theta) + u / ml2],\n        )\n        self._h_sym = sp.Matrix([theta])\n\n    def setup_equilibria(self):\n        # method to add equilibria to the system automatically after initialization\n\n        # add the stable equilibrium where the pendulum is hanging down\n        self.add_equilibrium(\n            'downward',\n            x_eq=np.array([0.0, 0.0]),\n            u_eq=np.array([0.0]),\n            verify=True\n            )\n\n        # add the unstable equilibrium where the pendulum is inverted\n        self.add_equilibrium(\n            'inverted',\n            x_eq=np.array([np.pi, 0.0]),\n            u_eq=np.array([0.0]),\n            stability='unstable',\n            notes='Requires active control'\n            )\n\n# Instantiate the system\npendulum = SymbolicPendulum()\n\n# Initial conditions\nx0 = np.array([1.0, 0.0])"
  },
  {
    "objectID": "tutorials/basic_usage.html#simulation",
    "href": "tutorials/basic_usage.html#simulation",
    "title": "Basic Usage",
    "section": "Simulation",
    "text": "Simulation\nNow simulate the system:\n\n# Integrate a trajectory with auto-selection of\n# relevant arguments\npendulum_integration_result = pendulum.integrate(\n        x0=x0,\n        t_span = (0.0, 200.0)\n    )\nprint(pendulum_integration_result['x'])\n\n[[ 1.00000000e+00  0.00000000e+00]\n [ 1.00000594e+00  9.89506734e-03]\n [ 1.00071537e+00  1.08212210e-01]\n [ 1.01616061e+00  5.07153694e-01]\n [ 1.06848383e+00  1.02955621e+00]\n [ 1.17671541e+00  1.63677770e+00]\n [ 1.36135156e+00  2.32255220e+00]\n [ 1.64282360e+00  3.05918535e+00]\n [ 2.03894953e+00  3.75224346e+00]\n [ 2.39769093e+00  4.10243396e+00]\n [ 2.77307091e+00  4.19097647e+00]\n [ 3.12306614e+00  3.99941533e+00]\n [ 3.44946098e+00  3.54918825e+00]\n [ 3.74593616e+00  2.85135623e+00]\n [ 3.98806126e+00  1.95098168e+00]\n [ 4.13669483e+00  1.01563199e+00]\n [ 4.19214004e+00  1.63426037e-01]\n [ 4.17347014e+00 -5.71812199e-01]\n [ 4.09367426e+00 -1.21935449e+00]\n [ 3.89225819e+00 -1.94846312e+00]\n [ 3.66106240e+00 -2.34050770e+00]\n [ 3.40784356e+00 -2.47861435e+00]\n [ 3.17389337e+00 -2.38305962e+00]\n [ 2.96897566e+00 -2.11414159e+00]\n [ 2.79926395e+00 -1.72230825e+00]\n [ 2.67127049e+00 -1.26032604e+00]\n [ 2.58714906e+00 -7.77560678e-01]\n [ 2.54434775e+00 -3.12898845e-01]\n [ 2.53608001e+00  5.07841521e-02]\n [ 2.55031914e+00  3.90350203e-01]\n [ 2.58942501e+00  7.22758516e-01]\n [ 2.66407238e+00  1.05276262e+00]\n [ 2.78164690e+00  1.32743586e+00]\n [ 2.94512832e+00  1.47578887e+00]\n [ 3.08421902e+00  1.45352558e+00]\n [ 3.21433212e+00  1.31539210e+00]\n [ 3.32106277e+00  1.09880058e+00]\n [ 3.40230554e+00  8.37045783e-01]\n [ 3.45809888e+00  5.56885977e-01]\n [ 3.48993697e+00  2.80434884e-01]\n [ 3.50053139e+00  5.09671269e-02]\n [ 3.49674851e+00 -1.66095391e-01]\n [ 3.48105039e+00 -3.51975133e-01]\n [ 3.44797609e+00 -5.47171599e-01]\n [ 3.39399482e+00 -7.22457494e-01]\n [ 3.31494794e+00 -8.50723292e-01]\n [ 3.22077512e+00 -8.89284590e-01]\n [ 3.14100846e+00 -8.44438658e-01]\n [ 3.06863211e+00 -7.38563533e-01]\n [ 3.01140032e+00 -5.95521072e-01]\n [ 2.96957184e+00 -4.33122275e-01]\n [ 2.94254937e+00 -2.65558171e-01]\n [ 2.92902536e+00 -1.04779569e-01]\n [ 2.92657197e+00  2.01954892e-02]\n [ 2.93124397e+00  1.37399426e-01]\n [ 2.94381246e+00  2.52539973e-01]\n [ 2.96726311e+00  3.66214231e-01]\n [ 3.00344566e+00  4.62821844e-01]\n [ 3.05523559e+00  5.25590050e-01]\n [ 3.10954797e+00  5.30498766e-01]\n [ 3.15545890e+00  4.92294699e-01]\n [ 3.19630834e+00  4.21061512e-01]\n [ 3.22798460e+00  3.30837703e-01]\n [ 3.25047003e+00  2.31595009e-01]\n [ 3.26425451e+00  1.31376405e-01]\n [ 3.27026348e+00  3.69817622e-02]\n [ 3.27032022e+00 -3.43047605e-02]\n [ 3.26666050e+00 -9.86728336e-02]\n [ 3.25761244e+00 -1.69084140e-01]\n [ 3.24181592e+00 -2.35664155e-01]\n [ 3.21815604e+00 -2.89725638e-01]\n [ 3.18429553e+00 -3.20362152e-01]\n [ 3.15309066e+00 -3.15024789e-01]\n [ 3.12425170e+00 -2.83201790e-01]\n [ 3.10139564e+00 -2.35289018e-01]\n [ 3.08426522e+00 -1.78385638e-01]\n [ 3.07261108e+00 -1.17822972e-01]\n [ 3.06604485e+00 -5.81409399e-02]\n [ 3.06391073e+00 -3.19254554e-03]\n [ 3.06520910e+00  4.35237186e-02]\n [ 3.06927926e+00  8.53220221e-02]\n [ 3.07718395e+00  1.27126526e-01]\n [ 3.08955775e+00  1.63244849e-01]\n [ 3.10726627e+00  1.88035031e-01]\n [ 3.12816580e+00  1.92641150e-01]\n [ 3.14514919e+00  1.79958412e-01]\n [ 3.16033354e+00  1.54737449e-01]\n [ 3.17212690e+00  1.22261680e-01]\n [ 3.18054391e+00  8.62211126e-02]\n [ 3.18575878e+00  4.95671531e-02]\n [ 3.18809120e+00  1.47877291e-02]\n [ 3.18815692e+00 -1.23013864e-02]\n [ 3.18669387e+00 -3.72472605e-02]\n [ 3.18318709e+00 -6.32930745e-02]\n [ 3.17716500e+00 -8.74168199e-02]\n [ 3.16823847e+00 -1.06481427e-01]\n [ 3.15542108e+00 -1.16344724e-01]\n [ 3.14425889e+00 -1.12974432e-01]\n [ 3.13402907e+00 -1.00361978e-01]\n [ 3.12597354e+00 -8.22061579e-02]\n [ 3.12001933e+00 -6.10201956e-02]\n [ 3.11607217e+00 -3.87168038e-02]\n [ 3.11397966e+00 -1.69135780e-02]\n [ 3.11349387e+00  3.03959580e-03]\n [ 3.11424836e+00  1.99722041e-02]\n [ 3.11619328e+00  3.59527477e-02]\n [ 3.11965933e+00  5.09455024e-02]\n [ 3.12486174e+00  6.29970672e-02]\n [ 3.13227772e+00  6.97647228e-02]\n [ 3.13924900e+00  6.85030107e-02]\n [ 3.14565047e+00  6.12201209e-02]\n [ 3.15066718e+00  5.03702462e-02]\n [ 3.15438222e+00  3.75522333e-02]\n [ 3.15685855e+00  2.39480995e-02]\n [ 3.15818359e+00  1.05557129e-02]\n [ 3.15849886e+00 -1.80105467e-03]\n [ 3.15800914e+00 -1.24488409e-02]\n [ 3.15674425e+00 -2.23848531e-02]\n [ 3.15452235e+00 -3.14861594e-02]\n [ 3.15121844e+00 -3.85760631e-02]\n [ 3.14649146e+00 -4.21343003e-02]\n [ 3.14235443e+00 -4.07366153e-02]\n [ 3.13858943e+00 -3.58599955e-02]\n [ 3.13566035e+00 -2.89428967e-02]\n [ 3.13353222e+00 -2.09315167e-02]\n [ 3.13216692e+00 -1.25372147e-02]\n [ 3.13150744e+00 -4.35425333e-03]\n [ 3.13146523e+00  3.13701267e-03]\n [ 3.13191792e+00  9.56471022e-03]\n [ 3.13291978e+00  1.56785138e-02]\n [ 3.13455026e+00  2.08957463e-02]\n [ 3.13689673e+00  2.44761263e-02]\n [ 3.13982748e+00  2.52470715e-02]\n [ 3.14218397e+00  2.34303798e-02]\n [ 3.14426409e+00  1.97920700e-02]\n [ 3.14583987e+00  1.51377795e-02]\n [ 3.14692072e+00  9.99961667e-03]\n [ 3.14753235e+00  4.79139280e-03]\n [ 3.14771625e+00 -1.48573647e-04]\n [ 3.14753131e+00 -4.55749185e-03]\n [ 3.14700120e+00 -8.51894725e-03]\n [ 3.14607679e+00 -1.19584262e-02]\n [ 3.14471960e+00 -1.44243935e-02]\n [ 3.14274700e+00 -1.52168659e-02]\n [ 3.14126140e+00 -1.41278918e-02]\n [ 3.13995878e+00 -1.18463742e-02]\n [ 3.13898608e+00 -8.91326674e-03]\n [ 3.13833357e+00 -5.67398777e-03]\n [ 3.13798480e+00 -2.39361634e-03]\n [ 3.13791522e+00  7.11147546e-04]\n [ 3.13809130e+00  3.47172962e-03]\n [ 3.13851094e+00  5.92296315e-03]\n [ 3.13919510e+00  7.88956976e-03]\n [ 3.14017196e+00  9.05833852e-03]\n [ 3.14130633e+00  8.96353596e-03]\n [ 3.14216969e+00  7.94709126e-03]\n [ 3.14289295e+00  6.27958460e-03]\n [ 3.14340223e+00  4.29235799e-03]\n [ 3.14370360e+00  2.19249329e-03]\n [ 3.14380909e+00  1.42118141e-04]\n [ 3.14373581e+00 -1.72700778e-03]\n [ 3.14349560e+00 -3.35269744e-03]\n [ 3.14308031e+00 -4.65416671e-03]\n [ 3.14248032e+00 -5.43142294e-03]\n [ 3.14176893e+00 -5.39588036e-03]\n [ 3.14121794e+00 -4.73355729e-03]\n [ 3.14076496e+00 -3.63636789e-03]\n [ 3.14045888e+00 -2.33820167e-03]\n [ 3.14029426e+00 -9.80680528e-04]\n [ 3.14026291e+00  3.24928130e-04]\n [ 3.14035388e+00  1.48587367e-03]\n [ 3.14056313e+00  2.45203169e-03]\n [ 3.14089131e+00  3.11823585e-03]\n [ 3.14135428e+00  3.31087302e-03]\n [ 3.14173830e+00  2.97780792e-03]\n [ 3.14205576e+00  2.29617476e-03]\n [ 3.14226553e+00  1.45919024e-03]\n [ 3.14237498e+00  5.74272931e-04]\n [ 3.14239022e+00 -2.76107404e-04]\n [ 3.14231858e+00 -1.02082592e-03]\n [ 3.14216416e+00 -1.60887130e-03]\n [ 3.14192970e+00 -1.95609287e-03]\n [ 3.14162659e+00 -1.93086667e-03]\n [ 3.14140273e+00 -1.60707343e-03]\n [ 3.14123303e+00 -1.09529058e-03]\n [ 3.14113700e+00 -5.19022421e-04]\n [ 3.14111006e+00  5.11138777e-05]\n [ 3.14114702e+00  5.57610324e-04]\n [ 3.14124279e+00  9.52755413e-04]\n [ 3.14139301e+00  1.17905278e-03]\n [ 3.14160364e+00  1.13158056e-03]\n [ 3.14174142e+00  8.84302690e-04]\n [ 3.14183687e+00  5.24739666e-04]\n [ 3.14187979e+00  1.40970592e-04]\n [ 3.14187436e+00 -2.16686588e-04]\n [ 3.14182533e+00 -5.06150755e-04]\n [ 3.14173742e+00 -6.88241524e-04]\n [ 3.14161463e+00 -7.06354352e-04]\n [ 3.14151551e+00 -5.62875743e-04]\n [ 3.14144742e+00 -3.25032433e-04]\n [ 3.14141926e+00 -7.03313058e-05]\n [ 3.14142625e+00  1.62052026e-04]\n [ 3.14146404e+00  3.39667936e-04]\n [ 3.14152774e+00  4.30995225e-04]\n [ 3.14161385e+00  3.87041285e-04]\n [ 3.14166643e+00  2.56802779e-04]\n [ 3.14169422e+00  8.78789056e-05]\n [ 3.14169516e+00 -7.18071988e-05]\n [ 3.14167319e+00 -1.95291298e-04]\n [ 3.14163276e+00 -2.58785606e-04]\n [ 3.14157878e+00 -2.31111947e-04]\n [ 3.14154505e+00 -1.41481075e-04]\n [ 3.14153000e+00 -2.80078299e-05]\n [ 3.14153415e+00  7.22900284e-05]\n [ 3.14155371e+00  1.39622060e-04]\n [ 3.14158424e+00  1.55943790e-04]\n [ 3.14161433e+00  1.09766492e-04]\n [ 3.14162947e+00  3.11100721e-05]\n [ 3.14162858e+00 -3.80192307e-05]\n [ 3.14161624e+00 -8.37136594e-05]\n [ 3.14159639e+00 -9.31037917e-05]\n [ 3.14157747e+00 -5.91379446e-05]\n [ 3.14156983e+00 -5.86463167e-06]\n [ 3.14157324e+00  3.57246453e-05]\n [ 3.14158378e+00  5.62689047e-05]\n [ 3.14159765e+00  4.67433144e-05]\n [ 3.14160545e+00  1.66692415e-05]\n [ 3.14160553e+00 -1.47083113e-05]\n [ 3.14159966e+00 -3.24691762e-05]\n [ 3.14159094e+00 -3.04293256e-05]\n [ 3.14158507e+00 -1.08889744e-05]\n [ 3.14158511e+00  1.02260471e-05]\n [ 3.14158933e+00  2.02917502e-05]\n [ 3.14159498e+00  1.57458037e-05]\n [ 3.14159761e+00  1.67198733e-06]\n [ 3.14159625e+00 -9.86893795e-06]\n [ 3.14159281e+00 -1.19382530e-05]\n [ 3.14158981e+00 -3.02054129e-06]\n [ 3.14159027e+00  5.27157846e-06]\n [ 3.14159244e+00  7.26284274e-06]\n [ 3.14159435e+00  1.92470593e-06]\n [ 3.14159400e+00 -3.43689204e-06]\n [ 3.14159253e+00 -4.11373001e-06]\n [ 3.14159157e+00  1.96622233e-08]\n [ 3.14159230e+00  2.67652273e-06]\n [ 3.14159317e+00  1.30233299e-06]\n [ 3.14159315e+00 -1.19235098e-06]\n [ 3.14159252e+00 -1.32683240e-06]\n [ 3.14159230e+00  4.79139108e-07]\n [ 3.14159273e+00  8.14276829e-07]\n [ 3.14159287e+00 -2.71621815e-07]\n [ 3.14159258e+00 -4.34536892e-07]\n [ 3.14159255e+00  2.58763002e-07]\n [ 3.14159273e+00  1.48307269e-07]\n [ 3.14159267e+00 -2.13765648e-07]\n [ 3.14159260e+00  5.17434022e-08]\n [ 3.14159268e+00  7.67585013e-08]\n [ 3.14159266e+00 -8.16053568e-08]\n [ 3.14159264e+00  4.53264182e-08]\n [ 3.14159267e+00 -1.96651486e-08]\n [ 3.14159264e+00 -2.75938962e-10]\n [ 3.14159266e+00  9.73720571e-09]\n [ 3.14159264e+00 -1.41923220e-08]\n [ 3.14159266e+00  1.60729140e-08]\n [ 3.14159264e+00 -1.70091489e-08]\n [ 3.14159267e+00  1.78148534e-08]\n [ 3.14159264e+00 -2.06100669e-08]\n [ 3.14159266e+00  2.53622576e-08]\n [ 3.14159264e+00 -2.89267874e-08]\n [ 3.14159266e+00  3.14961509e-08]\n [ 3.14159264e+00 -3.52975890e-08]\n [ 3.14159267e+00  3.92737193e-08]\n [ 3.14159264e+00 -4.33606832e-08]\n [ 3.14159266e+00  4.98604080e-08]\n [ 3.14159265e+00 -5.02283405e-08]\n [ 3.14159266e+00  5.47838585e-08]\n [ 3.14159263e+00 -1.02637556e-07]\n [ 3.14159267e+00  1.07978822e-07]\n [ 3.14159265e+00 -1.02719329e-07]\n [ 3.14159265e+00  9.06612738e-08]\n [ 3.14159267e+00 -5.35856810e-08]\n [ 3.14159264e+00  1.46370279e-08]\n [ 3.14159267e+00 -3.83957444e-09]\n [ 3.14159264e+00 -8.52257144e-09]\n [ 3.14159266e+00  1.50704089e-08]\n [ 3.14159265e+00 -1.77575046e-08]\n [ 3.14159266e+00  1.91668807e-08]\n [ 3.14159264e+00 -2.00379487e-08]\n [ 3.14159267e+00  2.17147531e-08]\n [ 3.14159264e+00 -2.68007394e-08]\n [ 3.14159266e+00  3.14729768e-08]\n [ 3.14159265e+00 -3.39332034e-08]\n [ 3.14159266e+00  3.83955538e-08]\n [ 3.14159264e+00 -4.66781038e-08]\n [ 3.14159266e+00  5.41848421e-08]\n [ 3.14159265e+00 -5.32157017e-08]\n [ 3.14159266e+00  5.78683058e-08]\n [ 3.14159266e+00 -5.13807326e-08]\n [ 3.14159265e+00  4.19965583e-08]\n [ 3.14159266e+00 -3.84165255e-08]\n [ 3.14159265e+00  3.44760517e-08]\n [ 3.14159266e+00 -4.37553432e-08]\n [ 3.14159264e+00  4.53992124e-08]\n [ 3.14159266e+00 -4.50716824e-08]\n [ 3.14159264e+00  4.16506967e-08]\n [ 3.14159267e+00 -3.55500554e-08]\n [ 3.14159264e+00  2.73259710e-08]\n [ 3.14159267e+00 -1.81975690e-08]\n [ 3.14159264e+00  9.58711982e-09]\n [ 3.14159266e+00 -2.61980355e-09]\n [ 3.14159264e+00 -2.28477849e-09]\n [ 3.14159266e+00  5.39628535e-09]\n [ 3.14159264e+00 -7.34741170e-09]\n [ 3.14159266e+00  8.85053668e-09]\n [ 3.14159264e+00 -1.05669493e-08]\n [ 3.14159266e+00  1.28648808e-08]\n [ 3.14159264e+00 -1.55661939e-08]\n [ 3.14159266e+00  1.82223941e-08]\n [ 3.14159264e+00 -2.06243221e-08]\n [ 3.14159266e+00  2.28932975e-08]\n [ 3.14159264e+00 -2.52751620e-08]\n [ 3.14159266e+00  2.79755143e-08]\n [ 3.14159264e+00 -3.09778132e-08]\n [ 3.14159266e+00  3.40235725e-08]\n [ 3.14159264e+00 -3.70848204e-08]\n [ 3.14159266e+00  4.05171218e-08]\n [ 3.14159264e+00 -4.43960683e-08]\n [ 3.14159267e+00  4.83404857e-08]\n [ 3.14159264e+00 -5.19964824e-08]\n [ 3.14159266e+00  5.48685493e-08]\n [ 3.14159265e+00 -5.91818224e-08]\n [ 3.14159267e+00  7.15859378e-08]\n [ 3.14159264e+00 -7.61537373e-08]\n [ 3.14159266e+00  7.75668315e-08]\n [ 3.14159265e+00 -7.89850660e-08]\n [ 3.14159267e+00  1.11356934e-07]\n [ 3.14159266e+00 -9.54618677e-08]\n [ 3.14159264e+00  5.32391933e-08]\n [ 3.14159267e+00 -1.73789058e-08]\n [ 3.14159264e+00 -8.42596333e-09]\n [ 3.14159266e+00  1.75831560e-08]\n [ 3.14159265e+00 -2.08116598e-08]\n [ 3.14159266e+00  2.27298855e-08]\n [ 3.14159264e+00 -2.46651289e-08]\n [ 3.14159267e+00  2.56699349e-08]\n [ 3.14159264e+00 -3.22956454e-08]\n [ 3.14159266e+00  3.88528538e-08]\n [ 3.14159265e+00 -4.00517537e-08]\n [ 3.14159266e+00  4.81495413e-08]\n [ 3.14159262e+00 -1.07972672e-07]\n [ 3.14159266e+00  1.26377178e-07]\n [ 3.14159267e+00 -8.11496761e-08]\n [ 3.14159263e+00  3.41712288e-08]\n [ 3.14159267e+00  2.68455941e-09]\n [ 3.14159264e+00 -2.11314733e-08]\n [ 3.14159266e+00  2.73188705e-08]\n [ 3.14159265e+00 -2.93027291e-08]\n [ 3.14159266e+00  3.67269393e-08]\n [ 3.14159264e+00 -4.02588980e-08]\n [ 3.14159267e+00  4.39706332e-08]\n [ 3.14159264e+00 -4.75810599e-08]\n [ 3.14159266e+00  5.01096862e-08]\n [ 3.14159265e+00 -5.49364426e-08]\n [ 3.14159267e+00  7.01761389e-08]\n [ 3.14159264e+00 -7.39787491e-08]\n [ 3.14159266e+00  7.15673699e-08]\n [ 3.14159265e+00 -7.47732274e-08]\n [ 3.14159265e+00  5.87945421e-08]\n [ 3.14159267e+00 -3.70342051e-08]\n [ 3.14159264e+00  2.66201121e-08]\n [ 3.14159267e+00 -1.68961192e-08]\n [ 3.14159264e+00  1.20937326e-08]\n [ 3.14159266e+00 -7.46206422e-09]\n [ 3.14159264e+00  3.38079471e-09]\n [ 3.14159266e+00 -3.18319686e-11]\n [ 3.14159264e+00 -2.63958054e-09]\n [ 3.14159266e+00  4.85078297e-09]\n [ 3.14159264e+00 -6.87793250e-09]\n [ 3.14159266e+00  8.95340047e-09]\n [ 3.14159264e+00 -1.11834727e-08]\n [ 3.14159266e+00  1.35343425e-08]\n [ 3.14159264e+00 -1.59104901e-08]\n [ 3.14159266e+00  1.82584352e-08]\n [ 3.14159264e+00 -2.06081334e-08]\n [ 3.14159266e+00  2.30402394e-08]\n [ 3.14159264e+00 -2.56233371e-08]\n [ 3.14159266e+00  2.83669865e-08]\n [ 3.14159264e+00 -3.12329783e-08]\n [ 3.14159266e+00  3.42079031e-08]\n [ 3.14159264e+00 -3.73472176e-08]\n [ 3.14159266e+00  4.07149816e-08]\n [ 3.14159264e+00 -4.42962362e-08]\n [ 3.14159266e+00  4.80004459e-08]\n [ 3.14159264e+00 -5.17924215e-08]\n [ 3.14159266e+00  5.59661845e-08]\n [ 3.14159264e+00 -6.11461790e-08]\n [ 3.14159267e+00  6.72949098e-08]\n [ 3.14159264e+00 -7.28909042e-08]\n [ 3.14159266e+00  7.64848123e-08]\n [ 3.14159265e+00 -7.80732091e-08]\n [ 3.14159266e+00  8.59380535e-08]\n [ 3.14159262e+00 -1.46325093e-07]\n [ 3.14159265e+00  1.40832691e-07]\n [ 3.14159268e+00 -8.09370323e-08]\n [ 3.14159263e+00 -4.86802530e-09]\n [ 3.14159266e+00  4.69033504e-08]\n [ 3.14159265e+00 -4.31004882e-08]\n [ 3.14159265e+00  5.65038061e-08]\n [ 3.14159264e+00 -1.31590593e-07]\n [ 3.14159268e+00  1.48074679e-07]\n [ 3.14159264e+00 -1.50000407e-07]\n [ 3.14159265e+00  1.30147044e-07]\n [ 3.14159267e+00 -1.17005706e-07]\n [ 3.14159263e+00  8.30545184e-08]\n [ 3.14159268e+00 -4.87475446e-08]\n [ 3.14159263e+00  1.46968854e-08]\n [ 3.14159267e+00  1.20962628e-08]\n [ 3.14159264e+00 -2.46754499e-08]\n [ 3.14159266e+00  2.77804429e-08]\n [ 3.14159265e+00 -3.10337340e-08]\n [ 3.14159267e+00  4.18738374e-08]\n [ 3.14159264e+00 -4.89811213e-08]\n [ 3.14159266e+00  4.98926077e-08]\n [ 3.14159265e+00 -5.27848649e-08]\n [ 3.14159268e+00  1.50663484e-07]\n [ 3.14159266e+00 -1.43008758e-07]\n [ 3.14159263e+00  8.06656724e-08]\n [ 3.14159268e+00 -2.04003755e-10]\n [ 3.14159264e+00 -4.26448928e-08]\n [ 3.14159265e+00  4.27338193e-08]\n [ 3.14159265e+00 -4.66334625e-08]\n [ 3.14159265e+00  4.09844472e-08]\n [ 3.14159266e+00 -3.33279994e-08]\n [ 3.14159265e+00  3.50314883e-08]\n [ 3.14159266e+00 -3.67945559e-08]\n [ 3.14159265e+00  5.15898416e-08]\n [ 3.14159266e+00 -6.00108977e-08]\n [ 3.14159265e+00  6.87961399e-08]\n [ 3.14159266e+00  5.53718364e-08]]"
  },
  {
    "objectID": "tutorials/basic_usage.html#visualization",
    "href": "tutorials/basic_usage.html#visualization",
    "title": "Basic Usage",
    "section": "Visualization",
    "text": "Visualization\nPlot the trajectory in 2D:\n\nSTATE_NAMES = ['angle', 'angular velocity']\ntrajectory_plot = pendulum.plot(\n    result=pendulum_integration_result,\n    state_names = STATE_NAMES\n)\ntrajectory_plot.show()"
  },
  {
    "objectID": "tutorials/basic_usage.html#phase-portrait",
    "href": "tutorials/basic_usage.html#phase-portrait",
    "title": "Basic Usage",
    "section": "Phase Portrait",
    "text": "Phase Portrait\nPlot the 2D phase portrait\n\nupright_point = pendulum.get_equilibrium('inverted')\ndownward_point = pendulum.get_equilibrium('downward')\nphase_portrait = pendulum.phase_plotter.plot_2d(\n    x=pendulum_integration_result['x'],\n    state_names = STATE_NAMES,\n    show_direction = True,\n    equilibria=[upright_point, \n                downward_point]\n)\nphase_portrait.show()"
  },
  {
    "objectID": "tutorials/basic_usage.html#next-steps",
    "href": "tutorials/basic_usage.html#next-steps",
    "title": "Basic Usage",
    "section": "Next Steps",
    "text": "Next Steps\n\nLearn about stochastic systems not implemented\nExplore different backends not implemented\nSee advanced examples not implemented"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "A practical guide to using the code quality tools installed in your development environment.\n\n\n\nQuick Reference\nDaily Development Workflow\nTool-by-Tool Guide\nIterative Quality Improvement\nCI/CD Integration\nIDE Integration\nTroubleshooting\n\n\n\n\n\n\n\n# Format and fix everything\nruff check src/ --fix && ruff format src/ && black src/\n\n# Full quality check (no changes)\nruff check src/ && black --check src/ && mypy src/ && pytest tests/\n\n# Pre-commit (everything)\nruff check src/ tests/ --fix && ruff format src/ tests/ && black src/ tests/ && mypy src/ && pytest tests/ -x\n\n\n\n\n\n\nTool\nPurpose\nSpeed\nAuto-Fix\n\n\n\n\nRuff\nLinting (errors, style, imports)\n⚡ Blazing\n✅ Yes\n\n\nBlack\nCode formatting\nFast\n✅ Yes\n\n\nisort\nImport sorting\nFast\n✅ Yes (but use Ruff)\n\n\nMypy\nType checking\nMedium\n❌ No\n\n\nPytest\nTesting\nVaries\n❌ No\n\n\nBandit\nSecurity scanning\nFast\n❌ No\n\n\nPylint\nAdvanced linting\nSlow\n❌ No\n\n\nFlake8\nClassic linting\nMedium\n❌ No (but use Ruff)\n\n\n\n\n\n\n\n\n\n\n# 1. Pull latest changes\ngit pull origin main\n\n# 2. Quick health check\nruff check src/ && mypy src/ --ignore-missing-imports\n\n# 3. Run tests to ensure everything works\npytest tests/ -x --tb=short\n\n\n\n# After writing/modifying code:\n\n# Step 1: Auto-fix obvious issues (imports, formatting)\nruff check src/ --fix\n\n# Step 2: Format code\nruff format src/\n\n# Step 3: Check what's left\nruff check src/\n\n# Step 4: Fix remaining issues manually\n# (edit code based on ruff output)\n\n# Step 5: Type check\nmypy src/\n\n# Step 6: Run relevant tests\npytest tests/unit/your_module_test.py -v\n\n\n\n# Full check pipeline\nruff check src/ tests/ --fix          # Fix auto-fixable\nruff format src/ tests/               # Format\nblack src/ tests/                     # Ensure Black compliance\nmypy src/                             # Type check\npytest tests/ --tb=short              # Run all tests\n\n# If all pass:\ngit add -A\ngit commit -m \"Your descriptive message\"\n\n\n\n# Simulate CI locally\nruff check src/ tests/\nblack --check src/ tests/\nmypy src/ --ignore-missing-imports\npytest tests/ --cov=src --cov-report=term-missing\n\n\n\n\n\n\n\n\n\n\n\nFinds bugs (unused variables, undefined names)\nEnforces style (PEP 8, naming conventions)\nSorts imports\nSuggests modern Python idioms\nCatches security issues\n\n\n\n\n# Check for issues\nruff check src/\n\n# Fix auto-fixable issues\nruff check src/ --fix\n\n# Show what would be fixed (preview)\nruff check src/ --fix --diff\n\n# Check specific rules\nruff check src/ --select F,E    # Only Pyflakes and pycodestyle errors\n\n# Ignore specific rules temporarily\nruff check src/ --ignore E501   # Ignore line length\n\n\n\nUnused imports:\n$ ruff check src/module.py\nsrc/module.py:5:1: F401 [*] `numpy` imported but unused\n\n# Auto-fix:\n$ ruff check src/module.py --fix\nImport sorting:\n$ ruff check src/module.py\nsrc/module.py:1:1: I001 [*] Import block is un-sorted or un-formatted\n\n# Auto-fix:\n$ ruff check src/module.py --select I --fix\nComplexity issues:\n$ ruff check src/module.py --select C90\nsrc/module.py:42:1: C901 `complex_function` is too complex (15 &gt; 15)\n\n# Manual fix required - refactor the function\n\n\n\n# See what each category does:\nruff rule E501   # Line too long\nruff rule F401   # Unused import\nruff rule I001   # Import sorting\nruff rule B008   # Do not perform function calls in argument defaults\nruff rule N802   # Function name should be lowercase\nruff rule S101   # Use of assert\nruff rule PLR0913 # Too many arguments\n\n\n\n# Format code (Black-compatible)\nruff format src/\n\n# Check if formatted (CI mode)\nruff format src/ --check\n\n# See changes without applying\nruff format src/ --diff\n\n\n\n\n\n\n\n\nFormats code to Black’s opinionated style\nEnforces consistent formatting across codebase\n100% deterministic (same input → same output)\n\n\n\n\n# Format files (modifies in-place)\nblack src/\n\n# Check if files are formatted (no changes)\nblack --check src/\n\n# Show what would change\nblack --diff src/\n\n# Format specific file\nblack src/systems/base/core/continuous_system_base.py\n\n\n\n[tool.black]\nline-length = 100  # Your choice (default is 88)\ntarget-version = [\"py39\", \"py310\", \"py311\", \"py312\"]\n\n\n\nBefore committing:\n# Format everything\nblack src/ tests/\n\n# Verify\nblack --check src/ tests/\nFormat only changed files:\n# Get changed Python files\ngit diff --name-only --diff-filter=AM | grep \"\\.py$\" | xargs black\nCheck formatting in CI:\n# This is what runs in GitHub Actions\nblack --check src/ tests/\n\n\n\n\n\n\n\n\nStatic type analysis (finds type errors without running code)\nCatches bugs before runtime\nImproves IDE autocomplete\nDocuments function contracts\n\n\n\n\n# Check all source code\nmypy src/\n\n# Check with explanations\nmypy src/ --show-error-codes --pretty\n\n# Check specific module\nmypy src/systems/base/core/\n\n# Generate HTML report\nmypy src/ --html-report mypy-report\n\n\n\n\n\nStart with your type definitions:\n# These should be fully typed first\nmypy src/types/core.py --strict\nmypy src/types/backends.py --strict\nmypy src/types/trajectories.py --strict\nFix all issues, then update config:\n[[tool.mypy.overrides]]\nmodule = \"src.types.*\"\ndisallow_untyped_defs = true\n\n\n\nType your abstract base classes:\nmypy src/systems/base/core/continuous_system_base.py --strict\nmypy src/systems/base/numerical_integration/integrator_base.py --strict\nAdd type hints:\nfrom typing import Protocol, TypeVar, Generic\nfrom src.types.core import StateVector, ControlVector\n\nclass IntegratorBase:\n    def __init__(\n        self, \n        system: ContinuousSystemBase,\n        dt: float,\n        backend: str = \"numpy\"\n    ) -&gt; None:\n        self.system = system\n        self.dt = dt\n        self.backend = backend\n    \n    def step(\n        self, \n        x: StateVector, \n        u: Optional[ControlVector] = None,\n        dt: Optional[float] = None\n    ) -&gt; StateVector:\n        ...\n\n\n\nType concrete classes:\nmypy src/systems/base/numerical_integration/stochastic/ --strict\n\n\n\nOnce most code is typed:\n[tool.mypy]\ndisallow_untyped_defs = true\ndisallow_any_generics = true\ndisallow_untyped_calls = true\n\n\n\n\nOptional values:\nfrom typing import Optional\n\ndef step(self, x: StateVector, u: Optional[ControlVector] = None) -&gt; StateVector:\n    if u is None:\n        u = np.zeros(self.nu)\n    return x + self.dt * self.f(x, u)\nUnion types:\nfrom typing import Union\nimport torch\nimport jax.numpy as jnp\n\nArrayLike = Union[np.ndarray, torch.Tensor, jnp.ndarray]\n\ndef to_numpy(x: ArrayLike) -&gt; np.ndarray:\n    if isinstance(x, np.ndarray):\n        return x\n    elif isinstance(x, torch.Tensor):\n        return x.detach().cpu().numpy()\n    else:  # JAX\n        return np.asarray(x)\nProtocol types (duck typing with type safety):\nfrom typing import Protocol\n\nclass Integrable(Protocol):\n    nx: int\n    nu: int\n    \n    def __call__(\n        self, \n        x: StateVector, \n        u: Optional[ControlVector],\n        t: float\n    ) -&gt; StateVector:\n        ...\n\ndef create_integrator(system: Integrable, dt: float) -&gt; IntegratorBase:\n    # Mypy ensures system has nx, nu, and __call__\n    return EulerIntegrator(system, dt)\nGeneric types:\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T', np.ndarray, torch.Tensor)\n\nclass Backend(Generic[T]):\n    def zeros(self, shape: Tuple[int, ...]) -&gt; T:\n        ...\n\n\n\nIssue: Library has no type stubs\n$ mypy src/module.py\nsrc/module.py:5: error: Library stubs not installed for \"scipy\"\n\n# Solution: Already configured!\n[[tool.mypy.overrides]]\nmodule = [\"scipy.*\", \"plotly.*\", ...]\nignore_missing_imports = true\nIssue: Can’t infer type\n# Error: Need type annotation\nresult = some_complex_operation()  # ❌\n\n# Fix: Add explicit type\nresult: StateVector = some_complex_operation()  # ✓\n\n# Or: Add return type to function\ndef some_complex_operation() -&gt; StateVector:\n    ...\nIssue: Type too strict\n# If mypy is being too strict temporarily:\nx = complex_tensor_operation()  # type: ignore[assignment]\n\n# Better: Fix the actual type issue\nx: torch.Tensor = complex_tensor_operation()\n\n\n\n\n\n\n\n# Run all tests\npytest tests/\n\n# Run with verbose output\npytest tests/ -v\n\n# Run specific test file\npytest tests/unit/integrator_unit_tests/stochastic/diffrax_sde_integrator_test.py\n\n# Run specific test\npytest tests/unit/core_class_unit_tests/discretized_system_tests/discretized_system_test.py::TestStepMethodFixedStep::test_step_advances_state\n\n# Run tests matching pattern\npytest tests/ -k \"sde\" -v\n\n# Stop at first failure\npytest tests/ -x\n\n# Show local variables on failure\npytest tests/ -l\n\n# Run with coverage\npytest tests/ --cov=src --cov-report=html\n\n# Run only fast tests (skip slow)\npytest tests/ -m \"not slow\"\n\n\n\n# Run only unit tests\npytest tests/ -m unit\n\n# Skip GPU tests\npytest tests/ -m \"not gpu\"\n\n# Run JAX-specific tests only\npytest tests/ -m jax\n\n# Combine markers\npytest tests/ -m \"unit and not slow\"\n\n\n\n# While developing a feature:\n\n# 1. Run related tests continuously\npytest tests/unit/your_module/ -v --tb=short\n\n# 2. Run with auto-rerun on file changes (install pytest-watch)\npip install pytest-watch\nptw tests/unit/your_module/\n\n# 3. When tests pass, run full suite\npytest tests/\n\n# 4. Check coverage\npytest tests/ --cov=src --cov-report=term-missing\n# Look for untested code and add tests\n\n\n\n\n\n\n\n\nFinds security vulnerabilities\nChecks for dangerous patterns\nValidates cryptographic usage\nDetects hardcoded secrets\n\n\n\n\n# Scan all code\nbandit -r src/\n\n# Scan with config (uses your pyproject.toml)\nbandit -r src/ -c pyproject.toml\n\n# Output to file\nbandit -r src/ -f json -o bandit-report.json\n\n# Only high severity\nbandit -r src/ -ll\n\n\n\n# B301: Pickle is insecure\nimport pickle  # ❌ Bandit warns\n\n# Better:\nimport json    # ✓\n\n# B608: SQL injection risk\nquery = f\"SELECT * FROM users WHERE id={user_id}\"  # ❌\n\n# Better:\nquery = \"SELECT * FROM users WHERE id=?\"  # ✓ Use parameterized queries\n\n\n\n\n\n\n\n\nScans dependencies for known vulnerabilities\nChecks against CVE database\nAlerts to outdated packages with security issues\n\n\n\n\n# Scan current environment\nsafety check\n\n# Scan requirements file\nsafety check -r requirements.txt\n\n# JSON output\nsafety check --json\n\n# Continue even if vulnerabilities found\nsafety check --continue-on-error\n\n\n\n\n\n\n\n\nMore comprehensive linting than Ruff\nChecks code complexity\nFinds design issues\nSlower but more thorough\n\n\n\n\n# Check all code\npylint src/\n\n# Check specific module\npylint src/systems/base/\n\n# Generate report\npylint src/ --output-format=json &gt; pylint-report.json\n\n# Score only\npylint src/ --score=y\n\n\n\n\nRuff: Daily development (fast feedback)\nPylint: Periodic deep checks (before releases)\n\n\n\n\n\n\n\n\n# Run with coverage\npytest tests/ --cov=src\n\n# HTML report (detailed)\npytest tests/ --cov=src --cov-report=html\n# Opens in htmlcov/index.html\n\n# Show missing lines\npytest tests/ --cov=src --cov-report=term-missing\n\n# Fail if coverage below threshold\npytest tests/ --cov=src --cov-fail-under=80\n\n\n\n$ pytest tests/ --cov=src --cov-report=term-missing\n\nName                                  Stmts   Miss  Cover   Missing\n-------------------------------------------------------------------\nsrc/__init__.py                          12      2    83%   45-46\nsrc/systems/base/core/continuous.py     156     23    85%   89-92, 145-156\n-------------------------------------------------------------------\nTOTAL                                  2847    234    92%\nWhat to do: - &lt;80% coverage: Add tests for untested code - Missing critical paths: Add tests for error handling - 100% coverage: Great, but don’t obsess (diminishing returns)\n\n\n\n\n\n\n\nStep 1: Write code with basic types\n# my_new_integrator.py\nfrom src.types.core import StateVector, ControlVector\nfrom typing import Optional\n\nclass MyIntegrator:\n    def __init__(self, system, dt: float):\n        self.system = system\n        self.dt = dt\n    \n    def step(self, x: StateVector, u: Optional[ControlVector]) -&gt; StateVector:\n        # Implementation\n        return x  # placeholder\nStep 2: Auto-fix basic issues\n# Fix imports, basic style\nruff check src/systems/my_new_integrator.py --fix\n\n# Format\nruff format src/systems/my_new_integrator.py\nStep 3: Check for issues\n# Lint\nruff check src/systems/my_new_integrator.py\n\n# Type check\nmypy src/systems/my_new_integrator.py --strict\nStep 4: Fix reported issues\n# Mypy says: Missing return type\ndef step(self, x, u):  # ❌\n    ...\n\n# Fix:\ndef step(self, x: StateVector, u: Optional[ControlVector]) -&gt; StateVector:  # ✓\n    ...\nStep 5: Write tests\n# Create test file\ntouch tests/unit/my_new_integrator_test.py\n\n# Run tests as you write them\npytest tests/unit/my_new_integrator_test.py -v\nStep 6: Check coverage\npytest tests/unit/my_new_integrator_test.py --cov=src/systems/my_new_integrator\n# Aim for &gt;90%\n\n\n\nStep 1: Establish baseline\n# Run all checks, save output\nruff check src/old_module.py &gt; ruff-before.txt\nmypy src/old_module.py &gt; mypy-before.txt\npytest tests/unit/old_module_test.py --cov &gt; coverage-before.txt\nStep 2: Auto-fix what you can\nruff check src/old_module.py --fix\nruff format src/old_module.py\nStep 3: Add type hints incrementally\n# Start with function signatures (inputs/outputs)\ndef my_function(x, u):  # Before\n    return x + u\n\ndef my_function(x: StateVector, u: ControlVector) -&gt; StateVector:  # After\n    return x + u\nStep 4: Run tests after each change\n# Ensure refactoring doesn't break anything\npytest tests/unit/old_module_test.py -v\nStep 5: Compare improvement\nruff check src/old_module.py &gt; ruff-after.txt\nmypy src/old_module.py &gt; mypy-after.txt\npytest tests/unit/old_module_test.py --cov &gt; coverage-after.txt\n\n# Compare\ndiff ruff-before.txt ruff-after.txt\n\n\n\nStep 1: Check current coverage\npytest tests/ --cov=src --cov-report=html\n# Open htmlcov/index.html\n# Click on modules with &lt;80% coverage\nStep 2: Add tests for uncovered lines\n# Coverage report shows lines 45-52 not covered\n# These are error handling paths\n\ndef test_error_handling():\n    \"\"\"Test that invalid input raises ValueError.\"\"\"\n    integrator = MyIntegrator(system, dt=-0.01)  # Invalid dt\n    \n    with pytest.raises(ValueError, match=\"dt must be positive\"):\n        integrator.step(x0, u0)\nStep 3: Add edge case tests\n# Test boundary conditions\ndef test_zero_state():\n    result = integrator.step(np.zeros(nx), None)\n    assert result.shape == (nx,)\n\ndef test_large_dt():\n    integrator = MyIntegrator(system, dt=1.0)  # Unusually large\n    result = integrator.step(x0, u0)\n    assert np.all(np.isfinite(result))\nStep 4: Re-check coverage\npytest tests/unit/my_test.py --cov=src/my_module --cov-report=term-missing\n\n\n\n\n\nYour .github/workflows/ci.yml runs these checks automatically.\n\n\n# Run exactly what CI runs\n#!/bin/bash\n\necho \"=== Installing dependencies ===\"\npip install -e \".[dev]\"\n\necho \"=== Linting with ruff ===\"\nruff check src/ tests/\n\necho \"=== Format check with black ===\"\nblack --check src/ tests/\n\necho \"=== Type checking with mypy ===\"\nmypy src/ --ignore-missing-imports\n\necho \"=== Running tests ===\"\npytest tests/ -v --cov=src --cov-report=xml --cov-report=term-missing\n\necho \"=== Security scan ===\"\nbandit -r src/\n\necho \"=== Building package ===\"\npython -m build\n\necho \"=== All checks passed! ===\"\nSave as scripts/ci-local.sh, make executable:\nchmod +x scripts/ci-local.sh\n./scripts/ci-local.sh\n\n\n\nCreate .pre-commit-config.yaml:\nrepos:\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.14.10\n    hooks:\n      # Run linter\n      - id: ruff\n        args: [--fix]\n      # Run formatter\n      - id: ruff-format\n\n  - repo: https://github.com/psf/black\n    rev: 25.11.0\n    hooks:\n      - id: black\n        language_version: python3.9\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.19.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all]\n        args: [--ignore-missing-imports]\nInstall and use:\n# Install hooks\npre-commit install\n\n# Run manually on all files\npre-commit run --all-files\n\n# Run on staged files (automatic when you commit)\ngit commit -m \"message\"  # Hooks run automatically\n\n# Skip hooks (when needed)\ngit commit -m \"message\" --no-verify\n\n\n\n\n\n\n\nInstall extensions: 1. Python (Microsoft) 2. Pylance (Microsoft) - includes mypy-like checking 3. Ruff (Astral Software) 4. Test Explorer\nSettings (.vscode/settings.json):\n{\n  // Ruff\n  \"[python]\": {\n    \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.ruff\": \"explicit\",\n      \"source.organizeImports.ruff\": \"explicit\"\n    }\n  },\n  \n  // Mypy\n  \"python.linting.mypyEnabled\": true,\n  \"python.linting.mypyArgs\": [\n    \"--config-file=pyproject.toml\",\n    \"--ignore-missing-imports\"\n  ],\n  \n  // Pytest\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\n    \"tests\"\n  ],\n  \n  // Type checking\n  \"python.analysis.typeCheckingMode\": \"basic\"\n}\nUsage: - Save file → Auto-formats with Ruff - Hover over code → See type information - Problems panel → Shows linting/type errors - Test explorer → Run/debug tests\n\n\n\nBuilt-in support: - Settings → Tools → Black → Enable - Settings → Tools → External Tools → Add Ruff - Settings → Editor → Inspections → Enable mypy\nKeyboard shortcuts: - Ctrl+Alt+L: Reformat code - Ctrl+Alt+Shift+L: Reformat options - Alt+Enter: Quick fixes\n\n\n\n\n\nCreate scripts/quality-check.sh:\n#!/bin/bash\n# Comprehensive quality check for ControlDESymulation\n\nset -e  # Exit on error\n\nFAILED=0\n\necho \"╔═══════════════════════════════════════════════════════╗\"\necho \"║     ControlDESymulation Quality Check                 ║\"\necho \"╚═══════════════════════════════════════════════════════╝\"\necho \"\"\n\n# ============================================================================\n# 1. Ruff Linting\n# ============================================================================\necho \"→ Running Ruff linter...\"\nif ruff check src/ tests/; then\n    echo \"✓ Ruff: No linting issues\"\nelse\n    echo \"✗ Ruff: Linting issues found\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 2. Ruff Formatting\n# ============================================================================\necho \"→ Checking Ruff formatting...\"\nif ruff format src/ tests/ --check; then\n    echo \"✓ Ruff Format: Code is formatted\"\nelse\n    echo \"✗ Ruff Format: Code needs formatting\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 3. Black Formatting\n# ============================================================================\necho \"→ Checking Black formatting...\"\nif black --check src/ tests/; then\n    echo \"✓ Black: Code is formatted\"\nelse\n    echo \"✗ Black: Code needs formatting\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 4. Mypy Type Checking\n# ============================================================================\necho \"→ Running Mypy type checker...\"\nif mypy src/ --ignore-missing-imports; then\n    echo \"✓ Mypy: No type errors\"\nelse\n    echo \"✗ Mypy: Type errors found\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 5. Pytest Tests\n# ============================================================================\necho \"→ Running pytest...\"\nif pytest tests/ --tb=short -q; then\n    echo \"✓ Pytest: All tests passed\"\nelse\n    echo \"✗ Pytest: Some tests failed\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 6. Coverage Check\n# ============================================================================\necho \"→ Checking test coverage...\"\nif pytest tests/ --cov=src --cov-report=term-missing --cov-fail-under=80 -q; then\n    echo \"✓ Coverage: ≥80%\"\nelse\n    echo \"✗ Coverage: &lt;80%\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 7. Security Scan (Optional)\n# ============================================================================\necho \"→ Running Bandit security scan...\"\nif bandit -r src/ -ll -q; then\n    echo \"✓ Bandit: No security issues\"\nelse\n    echo \"⚠ Bandit: Potential security issues (review manually)\"\n    # Don't fail on bandit warnings\nfi\necho \"\"\n\n# ============================================================================\n# Summary\n# ============================================================================\necho \"╔═══════════════════════════════════════════════════════╗\"\nif [ $FAILED -eq 0 ]; then\n    echo \"║  ✓ All quality checks passed!                        ║\"\n    echo \"╚═══════════════════════════════════════════════════════╝\"\n    exit 0\nelse\n    echo \"║  ✗ Some quality checks failed                        ║\"\n    echo \"╚═══════════════════════════════════════════════════════╝\"\n    exit 1\nfi\nMake executable and run:\nchmod +x scripts/quality-check.sh\n./scripts/quality-check.sh\n\n\n\n\nCreate scripts/auto-fix.sh:\n#!/bin/bash\n# Auto-fix all fixable issues\n\necho \"🔧 Auto-fixing code quality issues...\"\necho \"\"\n\n# 1. Ruff fixes (imports, style, simple bugs)\necho \"→ Ruff auto-fix...\"\nruff check src/ tests/ --fix\necho \"\"\n\n# 2. Ruff format\necho \"→ Ruff format...\"\nruff format src/ tests/\necho \"\"\n\n# 3. Black format (for compatibility)\necho \"→ Black format...\"\nblack src/ tests/\necho \"\"\n\n# 4. Check what's left\necho \"→ Remaining issues:\"\nruff check src/ tests/\necho \"\"\n\necho \"✓ Auto-fix complete!\"\necho \"  Manual fixes needed for:\"\necho \"  - Type errors (mypy)\"\necho \"  - Complex linting issues (ruff)\"\necho \"  - Test failures (pytest)\"\n\n\n\n\n\n\n# Fast feedback loop - runs in ~2-5 seconds\nruff check src/your_module.py --fix\nmypy src/your_module.py\npytest tests/unit/your_module_test.py -x\n\n\n\n# More thorough - runs in ~30-60 seconds\nruff check src/ tests/ --fix\nruff format src/ tests/\nblack src/ tests/\nmypy src/\npytest tests/ -x --tb=short\n\n\n\n# Comprehensive - runs in ~2-5 minutes\n./scripts/quality-check.sh\n\n# Plus additional checks:\npylint src/ --score=y\nbandit -r src/\nsafety check\npytest tests/ --cov=src --cov-report=html\n\n\n\n\n\n\n\nProblem:\n$ ruff format src/\n$ black --check src/\nwould reformat src/module.py\nSolution: Black is more opinionated. Use Black as the final authority:\nruff check src/ --fix    # Fix linting\nruff format src/          # Ruff format\nblack src/                # Black format (final)\nOr just use one:\n# Option 1: Ruff only (simpler)\nruff check src/ --fix && ruff format src/\n\n# Option 2: Black only for formatting\nruff check src/ --fix && black src/\n\n\n\nProblem:\n$ mypy src/module.py --strict\nFound 47 errors in 1 file\nSolution: Gradual typing\n# Start without --strict\nmypy src/module.py\n\n# Add types incrementally\n# Then enable strict module-by-module in pyproject.toml:\n[[tool.mypy.overrides]]\nmodule = \"src.module\"\ndisallow_untyped_defs = true\n\n\n\nProblem:\n$ pytest tests/  # ✓ Passes locally\n# CI fails on same tests\nCommon causes:\n\nMissing dependencies in CI\n# Check your CI install matches local:\npip install -e \".[dev]\"  # Not just -e .\nEnvironment differences\n# Test in clean environment locally:\npython -m venv test_env\nsource test_env/bin/activate\npip install -e \".[dev]\"\npytest tests/\ndeactivate\nRandom seeds not set\n# In stochastic tests:\n@pytest.fixture(autouse=True)\ndef set_random_seed():\n    np.random.seed(42)\n    torch.manual_seed(42)\n\n\n\n\n\n\n\n\nruff check .                    # Check all\nruff check . --fix             # Auto-fix\nruff check . --select F        # Only pyflakes rules\nruff check . --fix --unsafe-fixes  # Apply risky fixes too\nruff format .                  # Format\nruff format . --check          # Check formatting\n\n\n\nblack .                        # Format all\nblack . --check               # Check only\nblack . --diff                # Show changes\nblack file.py                 # Format one file\n\n\n\nmypy src/                     # Check all\nmypy src/ --strict            # Strict mode\nmypy src/ --show-error-codes  # Show error codes\nmypy file.py                  # Check one file\nmypy src/ --html-report ./mypy-html  # HTML report\n\n\n\npytest                        # Run all\npytest -v                     # Verbose\npytest -x                     # Stop at first failure\npytest -k \"test_name\"         # Run matching tests\npytest --lf                   # Run last failed\npytest --cov=src              # With coverage\npytest -m \"not slow\"          # Skip slow tests\n\n\n\nbandit -r src/                # Scan all\nbandit -r src/ -ll            # High severity only\nbandit -r src/ -f json        # JSON output\n\n\n\npylint src/                   # Check all\npylint src/ --score=y         # Show score\npylint file.py                # Check one file\n\n\n\n\n\nCreate Makefile:\n.PHONY: format check test clean install\n\n# Auto-fix and format\nformat:\n    ruff check src/ tests/ --fix\n    ruff format src/ tests/\n    black src/ tests/\n\n# Check code quality (no changes)\ncheck:\n    ruff check src/ tests/\n    black --check src/ tests/\n    mypy src/ --ignore-missing-imports\n\n# Run tests\ntest:\n    pytest tests/ -v\n\n# Full test with coverage\ntest-cov:\n    pytest tests/ --cov=src --cov-report=html --cov-report=term-missing\n\n# Quick test (stop at first failure)\ntest-quick:\n    pytest tests/ -x --tb=short\n\n# Clean build artifacts\nclean:\n    rm -rf build/ dist/ *.egg-info .pytest_cache .mypy_cache .ruff_cache htmlcov\n    find . -type d -name __pycache__ -exec rm -rf {} +\n    find . -type f -name \"*.pyc\" -delete\n\n# Install dev dependencies\ninstall:\n    pip install -e \".[dev]\"\n\n# Full quality check\nquality: format check test-cov\n    @echo \"✓ All quality checks passed!\"\n\n# Pre-commit check\npre-commit: format\n    pytest tests/ -x --tb=short\n    @echo \"✓ Ready to commit!\"\n\n# CI simulation\nci: check test-cov\n    bandit -r src/\n    python -m build\n    @echo \"✓ CI checks passed!\"\nUsage:\nmake format          # Auto-fix everything\nmake check           # Check without changes\nmake test            # Run tests\nmake quality         # Full quality check\nmake pre-commit      # Quick pre-commit check\nmake ci              # Simulate CI locally\n\n\n\n\nWhen time is limited, prioritize:\n\n\n\nRuff check + fix: Catches real bugs, fast\nPytest: Ensures functionality\nBlack/Ruff format: Consistent code\n\n\n\n\n\nMypy: Catches type errors (if you’re using types)\nCoverage: Ensure tests cover new code\n\n\n\n\n\nPylint: Deep analysis (run weekly)\nBandit: Security scan (run before releases)\nSafety: Dependency scan (run monthly)\n\n\n\n\n\n\nPrint this and keep it handy:\n╔═══════════════════════════════════════════════════════════╗\n║        ControlDESymulation Development Tools              ║\n╠═══════════════════════════════════════════════════════════╣\n║                                                           ║\n║  QUICK FIX:                                              ║\n║    ruff check src/ --fix && ruff format src/             ║\n║                                                           ║\n║  FULL CHECK:                                             ║\n║    make quality                                          ║\n║                                                           ║\n║  BEFORE COMMIT:                                          ║\n║    make pre-commit                                       ║\n║                                                           ║\n║  TEST ONE MODULE:                                        ║\n║    pytest tests/unit/module_test.py -v                   ║\n║                                                           ║\n║  TYPE CHECK:                                             ║\n║    mypy src/module.py                                    ║\n║                                                           ║\n║  COVERAGE:                                               ║\n║    pytest tests/ --cov=src --cov-report=html             ║\n║                                                           ║\n╚═══════════════════════════════════════════════════════════╝\n\n\n\n\n\n\n# Focus on critical issues first\nruff check src/ --select F,E  # Only errors, not style\n\n# Fix auto-fixable\nruff check src/ --fix\n\n# Then address remaining\nruff check src/\n\n\n\n# Check one file at a time\nmypy src/types/core.py\n\n# Ignore external packages\nmypy src/ --ignore-missing-imports\n\n# Use less strict mode initially\nmypy src/  # Without --strict\n\n\n\n# Run in parallel\npytest tests/ -n auto  # Requires pytest-xdist\n\n# Skip slow tests\npytest tests/ -m \"not slow\"\n\n# Profile tests\npytest tests/ --durations=10  # Show 10 slowest tests\n\n\n\n# Skip hooks once\ngit commit --no-verify\n\n# Disable hooks temporarily\npre-commit uninstall\n\n# Re-enable\npre-commit install\n\n\n\n\n\n\nSet up pre-commit hooks: pre-commit install\nAdd Makefile: Copy the Makefile above\nCreate quality check script: Save scripts/quality-check.sh\nConfigure IDE: Add VS Code settings\nRun baseline check: make quality\nFix issues incrementally: One module at a time\n\nStart with the quick iteration cycle and gradually incorporate more tools as you get comfortable!"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#table-of-contents",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#table-of-contents",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Quick Reference\nDaily Development Workflow\nTool-by-Tool Guide\nIterative Quality Improvement\nCI/CD Integration\nIDE Integration\nTroubleshooting"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#quick-reference",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#quick-reference",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "# Format and fix everything\nruff check src/ --fix && ruff format src/ && black src/\n\n# Full quality check (no changes)\nruff check src/ && black --check src/ && mypy src/ && pytest tests/\n\n# Pre-commit (everything)\nruff check src/ tests/ --fix && ruff format src/ tests/ && black src/ tests/ && mypy src/ && pytest tests/ -x\n\n\n\n\n\n\nTool\nPurpose\nSpeed\nAuto-Fix\n\n\n\n\nRuff\nLinting (errors, style, imports)\n⚡ Blazing\n✅ Yes\n\n\nBlack\nCode formatting\nFast\n✅ Yes\n\n\nisort\nImport sorting\nFast\n✅ Yes (but use Ruff)\n\n\nMypy\nType checking\nMedium\n❌ No\n\n\nPytest\nTesting\nVaries\n❌ No\n\n\nBandit\nSecurity scanning\nFast\n❌ No\n\n\nPylint\nAdvanced linting\nSlow\n❌ No\n\n\nFlake8\nClassic linting\nMedium\n❌ No (but use Ruff)"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#daily-development-workflow",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#daily-development-workflow",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "# 1. Pull latest changes\ngit pull origin main\n\n# 2. Quick health check\nruff check src/ && mypy src/ --ignore-missing-imports\n\n# 3. Run tests to ensure everything works\npytest tests/ -x --tb=short\n\n\n\n# After writing/modifying code:\n\n# Step 1: Auto-fix obvious issues (imports, formatting)\nruff check src/ --fix\n\n# Step 2: Format code\nruff format src/\n\n# Step 3: Check what's left\nruff check src/\n\n# Step 4: Fix remaining issues manually\n# (edit code based on ruff output)\n\n# Step 5: Type check\nmypy src/\n\n# Step 6: Run relevant tests\npytest tests/unit/your_module_test.py -v\n\n\n\n# Full check pipeline\nruff check src/ tests/ --fix          # Fix auto-fixable\nruff format src/ tests/               # Format\nblack src/ tests/                     # Ensure Black compliance\nmypy src/                             # Type check\npytest tests/ --tb=short              # Run all tests\n\n# If all pass:\ngit add -A\ngit commit -m \"Your descriptive message\"\n\n\n\n# Simulate CI locally\nruff check src/ tests/\nblack --check src/ tests/\nmypy src/ --ignore-missing-imports\npytest tests/ --cov=src --cov-report=term-missing"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#ruff-primary-linter",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#ruff-primary-linter",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Finds bugs (unused variables, undefined names)\nEnforces style (PEP 8, naming conventions)\nSorts imports\nSuggests modern Python idioms\nCatches security issues\n\n\n\n\n# Check for issues\nruff check src/\n\n# Fix auto-fixable issues\nruff check src/ --fix\n\n# Show what would be fixed (preview)\nruff check src/ --fix --diff\n\n# Check specific rules\nruff check src/ --select F,E    # Only Pyflakes and pycodestyle errors\n\n# Ignore specific rules temporarily\nruff check src/ --ignore E501   # Ignore line length\n\n\n\nUnused imports:\n$ ruff check src/module.py\nsrc/module.py:5:1: F401 [*] `numpy` imported but unused\n\n# Auto-fix:\n$ ruff check src/module.py --fix\nImport sorting:\n$ ruff check src/module.py\nsrc/module.py:1:1: I001 [*] Import block is un-sorted or un-formatted\n\n# Auto-fix:\n$ ruff check src/module.py --select I --fix\nComplexity issues:\n$ ruff check src/module.py --select C90\nsrc/module.py:42:1: C901 `complex_function` is too complex (15 &gt; 15)\n\n# Manual fix required - refactor the function\n\n\n\n# See what each category does:\nruff rule E501   # Line too long\nruff rule F401   # Unused import\nruff rule I001   # Import sorting\nruff rule B008   # Do not perform function calls in argument defaults\nruff rule N802   # Function name should be lowercase\nruff rule S101   # Use of assert\nruff rule PLR0913 # Too many arguments\n\n\n\n# Format code (Black-compatible)\nruff format src/\n\n# Check if formatted (CI mode)\nruff format src/ --check\n\n# See changes without applying\nruff format src/ --diff"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#black-code-formatter",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#black-code-formatter",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Formats code to Black’s opinionated style\nEnforces consistent formatting across codebase\n100% deterministic (same input → same output)\n\n\n\n\n# Format files (modifies in-place)\nblack src/\n\n# Check if files are formatted (no changes)\nblack --check src/\n\n# Show what would change\nblack --diff src/\n\n# Format specific file\nblack src/systems/base/core/continuous_system_base.py\n\n\n\n[tool.black]\nline-length = 100  # Your choice (default is 88)\ntarget-version = [\"py39\", \"py310\", \"py311\", \"py312\"]\n\n\n\nBefore committing:\n# Format everything\nblack src/ tests/\n\n# Verify\nblack --check src/ tests/\nFormat only changed files:\n# Get changed Python files\ngit diff --name-only --diff-filter=AM | grep \"\\.py$\" | xargs black\nCheck formatting in CI:\n# This is what runs in GitHub Actions\nblack --check src/ tests/"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#mypy-type-checker",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#mypy-type-checker",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Static type analysis (finds type errors without running code)\nCatches bugs before runtime\nImproves IDE autocomplete\nDocuments function contracts\n\n\n\n\n# Check all source code\nmypy src/\n\n# Check with explanations\nmypy src/ --show-error-codes --pretty\n\n# Check specific module\nmypy src/systems/base/core/\n\n# Generate HTML report\nmypy src/ --html-report mypy-report\n\n\n\n\n\nStart with your type definitions:\n# These should be fully typed first\nmypy src/types/core.py --strict\nmypy src/types/backends.py --strict\nmypy src/types/trajectories.py --strict\nFix all issues, then update config:\n[[tool.mypy.overrides]]\nmodule = \"src.types.*\"\ndisallow_untyped_defs = true\n\n\n\nType your abstract base classes:\nmypy src/systems/base/core/continuous_system_base.py --strict\nmypy src/systems/base/numerical_integration/integrator_base.py --strict\nAdd type hints:\nfrom typing import Protocol, TypeVar, Generic\nfrom src.types.core import StateVector, ControlVector\n\nclass IntegratorBase:\n    def __init__(\n        self, \n        system: ContinuousSystemBase,\n        dt: float,\n        backend: str = \"numpy\"\n    ) -&gt; None:\n        self.system = system\n        self.dt = dt\n        self.backend = backend\n    \n    def step(\n        self, \n        x: StateVector, \n        u: Optional[ControlVector] = None,\n        dt: Optional[float] = None\n    ) -&gt; StateVector:\n        ...\n\n\n\nType concrete classes:\nmypy src/systems/base/numerical_integration/stochastic/ --strict\n\n\n\nOnce most code is typed:\n[tool.mypy]\ndisallow_untyped_defs = true\ndisallow_any_generics = true\ndisallow_untyped_calls = true\n\n\n\n\nOptional values:\nfrom typing import Optional\n\ndef step(self, x: StateVector, u: Optional[ControlVector] = None) -&gt; StateVector:\n    if u is None:\n        u = np.zeros(self.nu)\n    return x + self.dt * self.f(x, u)\nUnion types:\nfrom typing import Union\nimport torch\nimport jax.numpy as jnp\n\nArrayLike = Union[np.ndarray, torch.Tensor, jnp.ndarray]\n\ndef to_numpy(x: ArrayLike) -&gt; np.ndarray:\n    if isinstance(x, np.ndarray):\n        return x\n    elif isinstance(x, torch.Tensor):\n        return x.detach().cpu().numpy()\n    else:  # JAX\n        return np.asarray(x)\nProtocol types (duck typing with type safety):\nfrom typing import Protocol\n\nclass Integrable(Protocol):\n    nx: int\n    nu: int\n    \n    def __call__(\n        self, \n        x: StateVector, \n        u: Optional[ControlVector],\n        t: float\n    ) -&gt; StateVector:\n        ...\n\ndef create_integrator(system: Integrable, dt: float) -&gt; IntegratorBase:\n    # Mypy ensures system has nx, nu, and __call__\n    return EulerIntegrator(system, dt)\nGeneric types:\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T', np.ndarray, torch.Tensor)\n\nclass Backend(Generic[T]):\n    def zeros(self, shape: Tuple[int, ...]) -&gt; T:\n        ...\n\n\n\nIssue: Library has no type stubs\n$ mypy src/module.py\nsrc/module.py:5: error: Library stubs not installed for \"scipy\"\n\n# Solution: Already configured!\n[[tool.mypy.overrides]]\nmodule = [\"scipy.*\", \"plotly.*\", ...]\nignore_missing_imports = true\nIssue: Can’t infer type\n# Error: Need type annotation\nresult = some_complex_operation()  # ❌\n\n# Fix: Add explicit type\nresult: StateVector = some_complex_operation()  # ✓\n\n# Or: Add return type to function\ndef some_complex_operation() -&gt; StateVector:\n    ...\nIssue: Type too strict\n# If mypy is being too strict temporarily:\nx = complex_tensor_operation()  # type: ignore[assignment]\n\n# Better: Fix the actual type issue\nx: torch.Tensor = complex_tensor_operation()"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#pytest-testing",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#pytest-testing",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "# Run all tests\npytest tests/\n\n# Run with verbose output\npytest tests/ -v\n\n# Run specific test file\npytest tests/unit/integrator_unit_tests/stochastic/diffrax_sde_integrator_test.py\n\n# Run specific test\npytest tests/unit/core_class_unit_tests/discretized_system_tests/discretized_system_test.py::TestStepMethodFixedStep::test_step_advances_state\n\n# Run tests matching pattern\npytest tests/ -k \"sde\" -v\n\n# Stop at first failure\npytest tests/ -x\n\n# Show local variables on failure\npytest tests/ -l\n\n# Run with coverage\npytest tests/ --cov=src --cov-report=html\n\n# Run only fast tests (skip slow)\npytest tests/ -m \"not slow\"\n\n\n\n# Run only unit tests\npytest tests/ -m unit\n\n# Skip GPU tests\npytest tests/ -m \"not gpu\"\n\n# Run JAX-specific tests only\npytest tests/ -m jax\n\n# Combine markers\npytest tests/ -m \"unit and not slow\"\n\n\n\n# While developing a feature:\n\n# 1. Run related tests continuously\npytest tests/unit/your_module/ -v --tb=short\n\n# 2. Run with auto-rerun on file changes (install pytest-watch)\npip install pytest-watch\nptw tests/unit/your_module/\n\n# 3. When tests pass, run full suite\npytest tests/\n\n# 4. Check coverage\npytest tests/ --cov=src --cov-report=term-missing\n# Look for untested code and add tests"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#bandit-security-scanner",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#bandit-security-scanner",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Finds security vulnerabilities\nChecks for dangerous patterns\nValidates cryptographic usage\nDetects hardcoded secrets\n\n\n\n\n# Scan all code\nbandit -r src/\n\n# Scan with config (uses your pyproject.toml)\nbandit -r src/ -c pyproject.toml\n\n# Output to file\nbandit -r src/ -f json -o bandit-report.json\n\n# Only high severity\nbandit -r src/ -ll\n\n\n\n# B301: Pickle is insecure\nimport pickle  # ❌ Bandit warns\n\n# Better:\nimport json    # ✓\n\n# B608: SQL injection risk\nquery = f\"SELECT * FROM users WHERE id={user_id}\"  # ❌\n\n# Better:\nquery = \"SELECT * FROM users WHERE id=?\"  # ✓ Use parameterized queries"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#safety-dependency-vulnerability-scanner",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#safety-dependency-vulnerability-scanner",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Scans dependencies for known vulnerabilities\nChecks against CVE database\nAlerts to outdated packages with security issues\n\n\n\n\n# Scan current environment\nsafety check\n\n# Scan requirements file\nsafety check -r requirements.txt\n\n# JSON output\nsafety check --json\n\n# Continue even if vulnerabilities found\nsafety check --continue-on-error"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#pylint-advanced-linter",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#pylint-advanced-linter",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "More comprehensive linting than Ruff\nChecks code complexity\nFinds design issues\nSlower but more thorough\n\n\n\n\n# Check all code\npylint src/\n\n# Check specific module\npylint src/systems/base/\n\n# Generate report\npylint src/ --output-format=json &gt; pylint-report.json\n\n# Score only\npylint src/ --score=y\n\n\n\n\nRuff: Daily development (fast feedback)\nPylint: Periodic deep checks (before releases)"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#coverage-test-coverage",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#coverage-test-coverage",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "# Run with coverage\npytest tests/ --cov=src\n\n# HTML report (detailed)\npytest tests/ --cov=src --cov-report=html\n# Opens in htmlcov/index.html\n\n# Show missing lines\npytest tests/ --cov=src --cov-report=term-missing\n\n# Fail if coverage below threshold\npytest tests/ --cov=src --cov-fail-under=80\n\n\n\n$ pytest tests/ --cov=src --cov-report=term-missing\n\nName                                  Stmts   Miss  Cover   Missing\n-------------------------------------------------------------------\nsrc/__init__.py                          12      2    83%   45-46\nsrc/systems/base/core/continuous.py     156     23    85%   89-92, 145-156\n-------------------------------------------------------------------\nTOTAL                                  2847    234    92%\nWhat to do: - &lt;80% coverage: Add tests for untested code - Missing critical paths: Add tests for error handling - 100% coverage: Great, but don’t obsess (diminishing returns)"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#iterative-quality-improvement",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#iterative-quality-improvement",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Step 1: Write code with basic types\n# my_new_integrator.py\nfrom src.types.core import StateVector, ControlVector\nfrom typing import Optional\n\nclass MyIntegrator:\n    def __init__(self, system, dt: float):\n        self.system = system\n        self.dt = dt\n    \n    def step(self, x: StateVector, u: Optional[ControlVector]) -&gt; StateVector:\n        # Implementation\n        return x  # placeholder\nStep 2: Auto-fix basic issues\n# Fix imports, basic style\nruff check src/systems/my_new_integrator.py --fix\n\n# Format\nruff format src/systems/my_new_integrator.py\nStep 3: Check for issues\n# Lint\nruff check src/systems/my_new_integrator.py\n\n# Type check\nmypy src/systems/my_new_integrator.py --strict\nStep 4: Fix reported issues\n# Mypy says: Missing return type\ndef step(self, x, u):  # ❌\n    ...\n\n# Fix:\ndef step(self, x: StateVector, u: Optional[ControlVector]) -&gt; StateVector:  # ✓\n    ...\nStep 5: Write tests\n# Create test file\ntouch tests/unit/my_new_integrator_test.py\n\n# Run tests as you write them\npytest tests/unit/my_new_integrator_test.py -v\nStep 6: Check coverage\npytest tests/unit/my_new_integrator_test.py --cov=src/systems/my_new_integrator\n# Aim for &gt;90%\n\n\n\nStep 1: Establish baseline\n# Run all checks, save output\nruff check src/old_module.py &gt; ruff-before.txt\nmypy src/old_module.py &gt; mypy-before.txt\npytest tests/unit/old_module_test.py --cov &gt; coverage-before.txt\nStep 2: Auto-fix what you can\nruff check src/old_module.py --fix\nruff format src/old_module.py\nStep 3: Add type hints incrementally\n# Start with function signatures (inputs/outputs)\ndef my_function(x, u):  # Before\n    return x + u\n\ndef my_function(x: StateVector, u: ControlVector) -&gt; StateVector:  # After\n    return x + u\nStep 4: Run tests after each change\n# Ensure refactoring doesn't break anything\npytest tests/unit/old_module_test.py -v\nStep 5: Compare improvement\nruff check src/old_module.py &gt; ruff-after.txt\nmypy src/old_module.py &gt; mypy-after.txt\npytest tests/unit/old_module_test.py --cov &gt; coverage-after.txt\n\n# Compare\ndiff ruff-before.txt ruff-after.txt\n\n\n\nStep 1: Check current coverage\npytest tests/ --cov=src --cov-report=html\n# Open htmlcov/index.html\n# Click on modules with &lt;80% coverage\nStep 2: Add tests for uncovered lines\n# Coverage report shows lines 45-52 not covered\n# These are error handling paths\n\ndef test_error_handling():\n    \"\"\"Test that invalid input raises ValueError.\"\"\"\n    integrator = MyIntegrator(system, dt=-0.01)  # Invalid dt\n    \n    with pytest.raises(ValueError, match=\"dt must be positive\"):\n        integrator.step(x0, u0)\nStep 3: Add edge case tests\n# Test boundary conditions\ndef test_zero_state():\n    result = integrator.step(np.zeros(nx), None)\n    assert result.shape == (nx,)\n\ndef test_large_dt():\n    integrator = MyIntegrator(system, dt=1.0)  # Unusually large\n    result = integrator.step(x0, u0)\n    assert np.all(np.isfinite(result))\nStep 4: Re-check coverage\npytest tests/unit/my_test.py --cov=src/my_module --cov-report=term-missing"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#cicd-integration",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#cicd-integration",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Your .github/workflows/ci.yml runs these checks automatically.\n\n\n# Run exactly what CI runs\n#!/bin/bash\n\necho \"=== Installing dependencies ===\"\npip install -e \".[dev]\"\n\necho \"=== Linting with ruff ===\"\nruff check src/ tests/\n\necho \"=== Format check with black ===\"\nblack --check src/ tests/\n\necho \"=== Type checking with mypy ===\"\nmypy src/ --ignore-missing-imports\n\necho \"=== Running tests ===\"\npytest tests/ -v --cov=src --cov-report=xml --cov-report=term-missing\n\necho \"=== Security scan ===\"\nbandit -r src/\n\necho \"=== Building package ===\"\npython -m build\n\necho \"=== All checks passed! ===\"\nSave as scripts/ci-local.sh, make executable:\nchmod +x scripts/ci-local.sh\n./scripts/ci-local.sh\n\n\n\nCreate .pre-commit-config.yaml:\nrepos:\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.14.10\n    hooks:\n      # Run linter\n      - id: ruff\n        args: [--fix]\n      # Run formatter\n      - id: ruff-format\n\n  - repo: https://github.com/psf/black\n    rev: 25.11.0\n    hooks:\n      - id: black\n        language_version: python3.9\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.19.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all]\n        args: [--ignore-missing-imports]\nInstall and use:\n# Install hooks\npre-commit install\n\n# Run manually on all files\npre-commit run --all-files\n\n# Run on staged files (automatic when you commit)\ngit commit -m \"message\"  # Hooks run automatically\n\n# Skip hooks (when needed)\ngit commit -m \"message\" --no-verify"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#ide-integration",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#ide-integration",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Install extensions: 1. Python (Microsoft) 2. Pylance (Microsoft) - includes mypy-like checking 3. Ruff (Astral Software) 4. Test Explorer\nSettings (.vscode/settings.json):\n{\n  // Ruff\n  \"[python]\": {\n    \"editor.defaultFormatter\": \"charliermarsh.ruff\",\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.ruff\": \"explicit\",\n      \"source.organizeImports.ruff\": \"explicit\"\n    }\n  },\n  \n  // Mypy\n  \"python.linting.mypyEnabled\": true,\n  \"python.linting.mypyArgs\": [\n    \"--config-file=pyproject.toml\",\n    \"--ignore-missing-imports\"\n  ],\n  \n  // Pytest\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\n    \"tests\"\n  ],\n  \n  // Type checking\n  \"python.analysis.typeCheckingMode\": \"basic\"\n}\nUsage: - Save file → Auto-formats with Ruff - Hover over code → See type information - Problems panel → Shows linting/type errors - Test explorer → Run/debug tests\n\n\n\nBuilt-in support: - Settings → Tools → Black → Enable - Settings → Tools → External Tools → Add Ruff - Settings → Editor → Inspections → Enable mypy\nKeyboard shortcuts: - Ctrl+Alt+L: Reformat code - Ctrl+Alt+Shift+L: Reformat options - Alt+Enter: Quick fixes"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#comprehensive-quality-check-script",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#comprehensive-quality-check-script",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Create scripts/quality-check.sh:\n#!/bin/bash\n# Comprehensive quality check for ControlDESymulation\n\nset -e  # Exit on error\n\nFAILED=0\n\necho \"╔═══════════════════════════════════════════════════════╗\"\necho \"║     ControlDESymulation Quality Check                 ║\"\necho \"╚═══════════════════════════════════════════════════════╝\"\necho \"\"\n\n# ============================================================================\n# 1. Ruff Linting\n# ============================================================================\necho \"→ Running Ruff linter...\"\nif ruff check src/ tests/; then\n    echo \"✓ Ruff: No linting issues\"\nelse\n    echo \"✗ Ruff: Linting issues found\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 2. Ruff Formatting\n# ============================================================================\necho \"→ Checking Ruff formatting...\"\nif ruff format src/ tests/ --check; then\n    echo \"✓ Ruff Format: Code is formatted\"\nelse\n    echo \"✗ Ruff Format: Code needs formatting\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 3. Black Formatting\n# ============================================================================\necho \"→ Checking Black formatting...\"\nif black --check src/ tests/; then\n    echo \"✓ Black: Code is formatted\"\nelse\n    echo \"✗ Black: Code needs formatting\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 4. Mypy Type Checking\n# ============================================================================\necho \"→ Running Mypy type checker...\"\nif mypy src/ --ignore-missing-imports; then\n    echo \"✓ Mypy: No type errors\"\nelse\n    echo \"✗ Mypy: Type errors found\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 5. Pytest Tests\n# ============================================================================\necho \"→ Running pytest...\"\nif pytest tests/ --tb=short -q; then\n    echo \"✓ Pytest: All tests passed\"\nelse\n    echo \"✗ Pytest: Some tests failed\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 6. Coverage Check\n# ============================================================================\necho \"→ Checking test coverage...\"\nif pytest tests/ --cov=src --cov-report=term-missing --cov-fail-under=80 -q; then\n    echo \"✓ Coverage: ≥80%\"\nelse\n    echo \"✗ Coverage: &lt;80%\"\n    FAILED=1\nfi\necho \"\"\n\n# ============================================================================\n# 7. Security Scan (Optional)\n# ============================================================================\necho \"→ Running Bandit security scan...\"\nif bandit -r src/ -ll -q; then\n    echo \"✓ Bandit: No security issues\"\nelse\n    echo \"⚠ Bandit: Potential security issues (review manually)\"\n    # Don't fail on bandit warnings\nfi\necho \"\"\n\n# ============================================================================\n# Summary\n# ============================================================================\necho \"╔═══════════════════════════════════════════════════════╗\"\nif [ $FAILED -eq 0 ]; then\n    echo \"║  ✓ All quality checks passed!                        ║\"\n    echo \"╚═══════════════════════════════════════════════════════╝\"\n    exit 0\nelse\n    echo \"║  ✗ Some quality checks failed                        ║\"\n    echo \"╚═══════════════════════════════════════════════════════╝\"\n    exit 1\nfi\nMake executable and run:\nchmod +x scripts/quality-check.sh\n./scripts/quality-check.sh"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#auto-fix-everything-script",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#auto-fix-everything-script",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Create scripts/auto-fix.sh:\n#!/bin/bash\n# Auto-fix all fixable issues\n\necho \"🔧 Auto-fixing code quality issues...\"\necho \"\"\n\n# 1. Ruff fixes (imports, style, simple bugs)\necho \"→ Ruff auto-fix...\"\nruff check src/ tests/ --fix\necho \"\"\n\n# 2. Ruff format\necho \"→ Ruff format...\"\nruff format src/ tests/\necho \"\"\n\n# 3. Black format (for compatibility)\necho \"→ Black format...\"\nblack src/ tests/\necho \"\"\n\n# 4. Check what's left\necho \"→ Remaining issues:\"\nruff check src/ tests/\necho \"\"\n\necho \"✓ Auto-fix complete!\"\necho \"  Manual fixes needed for:\"\necho \"  - Type errors (mypy)\"\necho \"  - Complex linting issues (ruff)\"\necho \"  - Test failures (pytest)\""
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#recommended-development-cycles",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#recommended-development-cycles",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "# Fast feedback loop - runs in ~2-5 seconds\nruff check src/your_module.py --fix\nmypy src/your_module.py\npytest tests/unit/your_module_test.py -x\n\n\n\n# More thorough - runs in ~30-60 seconds\nruff check src/ tests/ --fix\nruff format src/ tests/\nblack src/ tests/\nmypy src/\npytest tests/ -x --tb=short\n\n\n\n# Comprehensive - runs in ~2-5 minutes\n./scripts/quality-check.sh\n\n# Plus additional checks:\npylint src/ --score=y\nbandit -r src/\nsafety check\npytest tests/ --cov=src --cov-report=html"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#fixing-common-issues",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#fixing-common-issues",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Problem:\n$ ruff format src/\n$ black --check src/\nwould reformat src/module.py\nSolution: Black is more opinionated. Use Black as the final authority:\nruff check src/ --fix    # Fix linting\nruff format src/          # Ruff format\nblack src/                # Black format (final)\nOr just use one:\n# Option 1: Ruff only (simpler)\nruff check src/ --fix && ruff format src/\n\n# Option 2: Black only for formatting\nruff check src/ --fix && black src/\n\n\n\nProblem:\n$ mypy src/module.py --strict\nFound 47 errors in 1 file\nSolution: Gradual typing\n# Start without --strict\nmypy src/module.py\n\n# Add types incrementally\n# Then enable strict module-by-module in pyproject.toml:\n[[tool.mypy.overrides]]\nmodule = \"src.module\"\ndisallow_untyped_defs = true\n\n\n\nProblem:\n$ pytest tests/  # ✓ Passes locally\n# CI fails on same tests\nCommon causes:\n\nMissing dependencies in CI\n# Check your CI install matches local:\npip install -e \".[dev]\"  # Not just -e .\nEnvironment differences\n# Test in clean environment locally:\npython -m venv test_env\nsource test_env/bin/activate\npip install -e \".[dev]\"\npytest tests/\ndeactivate\nRandom seeds not set\n# In stochastic tests:\n@pytest.fixture(autouse=True)\ndef set_random_seed():\n    np.random.seed(42)\n    torch.manual_seed(42)"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#tool-cheat-sheet",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#tool-cheat-sheet",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "ruff check .                    # Check all\nruff check . --fix             # Auto-fix\nruff check . --select F        # Only pyflakes rules\nruff check . --fix --unsafe-fixes  # Apply risky fixes too\nruff format .                  # Format\nruff format . --check          # Check formatting\n\n\n\nblack .                        # Format all\nblack . --check               # Check only\nblack . --diff                # Show changes\nblack file.py                 # Format one file\n\n\n\nmypy src/                     # Check all\nmypy src/ --strict            # Strict mode\nmypy src/ --show-error-codes  # Show error codes\nmypy file.py                  # Check one file\nmypy src/ --html-report ./mypy-html  # HTML report\n\n\n\npytest                        # Run all\npytest -v                     # Verbose\npytest -x                     # Stop at first failure\npytest -k \"test_name\"         # Run matching tests\npytest --lf                   # Run last failed\npytest --cov=src              # With coverage\npytest -m \"not slow\"          # Skip slow tests\n\n\n\nbandit -r src/                # Scan all\nbandit -r src/ -ll            # High severity only\nbandit -r src/ -f json        # JSON output\n\n\n\npylint src/                   # Check all\npylint src/ --score=y         # Show score\npylint file.py                # Check one file"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#makefile-for-common-tasks",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#makefile-for-common-tasks",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Create Makefile:\n.PHONY: format check test clean install\n\n# Auto-fix and format\nformat:\n    ruff check src/ tests/ --fix\n    ruff format src/ tests/\n    black src/ tests/\n\n# Check code quality (no changes)\ncheck:\n    ruff check src/ tests/\n    black --check src/ tests/\n    mypy src/ --ignore-missing-imports\n\n# Run tests\ntest:\n    pytest tests/ -v\n\n# Full test with coverage\ntest-cov:\n    pytest tests/ --cov=src --cov-report=html --cov-report=term-missing\n\n# Quick test (stop at first failure)\ntest-quick:\n    pytest tests/ -x --tb=short\n\n# Clean build artifacts\nclean:\n    rm -rf build/ dist/ *.egg-info .pytest_cache .mypy_cache .ruff_cache htmlcov\n    find . -type d -name __pycache__ -exec rm -rf {} +\n    find . -type f -name \"*.pyc\" -delete\n\n# Install dev dependencies\ninstall:\n    pip install -e \".[dev]\"\n\n# Full quality check\nquality: format check test-cov\n    @echo \"✓ All quality checks passed!\"\n\n# Pre-commit check\npre-commit: format\n    pytest tests/ -x --tb=short\n    @echo \"✓ Ready to commit!\"\n\n# CI simulation\nci: check test-cov\n    bandit -r src/\n    python -m build\n    @echo \"✓ CI checks passed!\"\nUsage:\nmake format          # Auto-fix everything\nmake check           # Check without changes\nmake test            # Run tests\nmake quality         # Full quality check\nmake pre-commit      # Quick pre-commit check\nmake ci              # Simulate CI locally"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#tool-priority-guide",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#tool-priority-guide",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "When time is limited, prioritize:\n\n\n\nRuff check + fix: Catches real bugs, fast\nPytest: Ensures functionality\nBlack/Ruff format: Consistent code\n\n\n\n\n\nMypy: Catches type errors (if you’re using types)\nCoverage: Ensure tests cover new code\n\n\n\n\n\nPylint: Deep analysis (run weekly)\nBandit: Security scan (run before releases)\nSafety: Dependency scan (run monthly)"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#quick-reference-card",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#quick-reference-card",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Print this and keep it handy:\n╔═══════════════════════════════════════════════════════════╗\n║        ControlDESymulation Development Tools              ║\n╠═══════════════════════════════════════════════════════════╣\n║                                                           ║\n║  QUICK FIX:                                              ║\n║    ruff check src/ --fix && ruff format src/             ║\n║                                                           ║\n║  FULL CHECK:                                             ║\n║    make quality                                          ║\n║                                                           ║\n║  BEFORE COMMIT:                                          ║\n║    make pre-commit                                       ║\n║                                                           ║\n║  TEST ONE MODULE:                                        ║\n║    pytest tests/unit/module_test.py -v                   ║\n║                                                           ║\n║  TYPE CHECK:                                             ║\n║    mypy src/module.py                                    ║\n║                                                           ║\n║  COVERAGE:                                               ║\n║    pytest tests/ --cov=src --cov-report=html             ║\n║                                                           ║\n╚═══════════════════════════════════════════════════════════╝"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#troubleshooting",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#troubleshooting",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "# Focus on critical issues first\nruff check src/ --select F,E  # Only errors, not style\n\n# Fix auto-fixable\nruff check src/ --fix\n\n# Then address remaining\nruff check src/\n\n\n\n# Check one file at a time\nmypy src/types/core.py\n\n# Ignore external packages\nmypy src/ --ignore-missing-imports\n\n# Use less strict mode initially\nmypy src/  # Without --strict\n\n\n\n# Run in parallel\npytest tests/ -n auto  # Requires pytest-xdist\n\n# Skip slow tests\npytest tests/ -m \"not slow\"\n\n# Profile tests\npytest tests/ --durations=10  # Show 10 slowest tests\n\n\n\n# Skip hooks once\ngit commit --no-verify\n\n# Disable hooks temporarily\npre-commit uninstall\n\n# Re-enable\npre-commit install"
  },
  {
    "objectID": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#next-steps",
    "href": "personal_reference/DEVELOPMENT_TOOLS_GUIDE.html#next-steps",
    "title": "ControlDESymulation Development Tools Guide",
    "section": "",
    "text": "Set up pre-commit hooks: pre-commit install\nAdd Makefile: Copy the Makefile above\nCreate quality check script: Save scripts/quality-check.sh\nConfigure IDE: Add VS Code settings\nRun baseline check: make quality\nFix issues incrementally: One module at a time\n\nStart with the quick iteration cycle and gradually incorporate more tools as you get comfortable!"
  },
  {
    "objectID": "api/delegation_layer/delegation_layer_text.html",
    "href": "api/delegation_layer/delegation_layer_text.html",
    "title": "Delegation Layer Architecture (Text Diagram)",
    "section": "",
    "text": "═══════════════════════════════════════════════════════════════════════\n                    DELEGATION LAYER ARCHITECTURE\n═══════════════════════════════════════════════════════════════════════\n\n                         UI FRAMEWORK SYSTEMS\n                    ┌──────────────────────────────┐\n                    │  SymbolicSystemBase          │\n                    │  ContinuousSymbolicSystem    │\n                    │  DiscreteSymbolicSystem      │\n                    │  StochasticSystems           │\n                    └──────────┬───────────────────┘\n                               │\n                               │ COMPOSES (not inherits!)\n                               │\n                ┌──────────────┴───────────────┐\n                ↓                              ↓\n┏━━━━━━━━━━━━━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃   CORE UTILITIES        ┃      ┃ DETERMINISTIC EVAL      ┃\n┃   (Universal)           ┃      ┃ (ODE Systems)           ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ BackendManager          ┃      ┃ DynamicsEvaluator       ┃\n┃ • Multi-backend support ┃      ┃ • Forward dynamics      ┃\n┃ • Device management     ┃      ┃ • dx/dt = f(x, u)       ┃\n┃ • Array conversion      ┃      ┃ • Batched evaluation    ┃\n┃   545 lines              ┃      ┃   576 lines             ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ CodeGenerator           ┃      ┃ LinearizationEngine     ┃\n┃ • Symbolic → numerical  ┃      ┃ • Jacobian computation  ┃\n┃ • Function caching      ┃      ┃ • A = ∂f/∂x, B = ∂f/∂u  ┃\n┃ • Multi-backend compile ┃      ┃ • Higher-order systems  ┃\n┃   565 lines              ┃      ┃   907 lines             ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ EquilibriumHandler      ┃      ┃ ObservationEngine       ┃\n┃ • Named equilibria      ┃      ┃ • Output evaluation     ┃\n┃ • Verification          ┃      ┃ • y = h(x)              ┃\n┃ • Metadata storage      ┃      ┃ • C = ∂h/∂x             ┃\n┃   221 lines              ┃      ┃   628 lines             ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\n┃ SymbolicValidator       ┃\n┃ • System validation     ┃\n┃ • Dimension checks      ┃\n┃ • Error detection       ┃\n┃   718 lines              ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\n                ↓\n┏━━━━━━━━━━━━━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ STOCHASTIC SUPPORT      ┃      ┃ LOW-LEVEL UTILITIES     ┃\n┃ (SDE Systems)           ┃      ┃                         ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ DiffusionHandler        ┃      ┃ codegen_utils           ┃\n┃ • Diffusion generation  ┃      ┃ • SymPy → code          ┃\n┃ • g(x, u) matrix        ┃      ┃ • CSE optimization      ┃\n┃ • Noise optimization    ┃      ┃ • Backend-specific      ┃\n┃   1069 lines             ┃      ┃   733 lines             ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\n┃ NoiseCharacterizer      ┃\n┃ • Automatic analysis    ┃\n┃ • Noise type detection  ┃\n┃ • Solver recommendations┃\n┃   692 lines              ┃\n┣━━━━━━━━━━━━━━━━━━━━━━━━━┫\n┃ SDEValidator            ┃\n┃ • SDE validation        ┃\n┃ • Diffusion checks      ┃\n┃ • Type verification     ┃\n┃   544 lines              ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\n═══════════════════════════════════════════════════════════════════════\n                        COMPOSITION PATTERN\n═══════════════════════════════════════════════════════════════════════\n\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        \n        # Core utilities (from SymbolicSystemBase)\n        self.backend = BackendManager(...)          ✓\n        self._code_gen = CodeGenerator(...)         ✓\n        self.equilibria = EquilibriumHandler(...)   ✓\n        self._validator = SymbolicValidator()       ✓\n        \n        # Deterministic evaluators (added here)\n        self._dynamics = DynamicsEvaluator(...)     ✓\n        self._linearization = LinearizationEngine(...)  ✓\n        self._observation = ObservationEngine(...)  ✓\n\n\nclass ContinuousStochasticSystem(ContinuousSymbolicSystem):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Inherits all deterministic utilities above\n        \n        # Add stochastic support\n        self.diffusion_handler = DiffusionHandler(...)      ✓\n        self.noise_characteristics = NoiseCharacterizer()   ✓\n        self._sde_validator = SDEValidator()               ✓\n\n\n═══════════════════════════════════════════════════════════════════════\n                        DEPENDENCY GRAPH\n═══════════════════════════════════════════════════════════════════════\n\n┌────────────────┐\n│ UI Framework   │\n│ Systems        │\n└───────┬────────┘\n        │\n        ├──&gt; BackendManager\n        │\n        ├──&gt; CodeGenerator ──┬──&gt; BackendManager\n        │                    └──&gt; codegen_utils\n        │\n        ├──&gt; EquilibriumHandler\n        │\n        ├──&gt; SymbolicValidator\n        │\n        ├──&gt; DynamicsEvaluator ──┬──&gt; CodeGenerator\n        │                        └──&gt; BackendManager\n        │\n        ├──&gt; LinearizationEngine ──┬──&gt; CodeGenerator\n        │                          └──&gt; BackendManager\n        │\n        ├──&gt; ObservationEngine ──┬──&gt; CodeGenerator\n        │                        └──&gt; BackendManager\n        │\n        └──&gt; (if stochastic)\n             ├──&gt; DiffusionHandler ──┬──&gt; CodeGenerator\n             │                       └──&gt; BackendManager\n             │\n             ├──&gt; NoiseCharacterizer\n             │\n             └──&gt; SDEValidator\n\n\n═══════════════════════════════════════════════════════════════════════\n                        LAYER BREAKDOWN\n═══════════════════════════════════════════════════════════════════════\n\n┌─────────────────────────┬────────┬─────────────────────────────────┐\n│ Component               │ Lines  │ Purpose                         │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ CORE UTILITIES          │        │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ BackendManager          │   545  │ Multi-backend array handling    │\n│ CodeGenerator           │   565  │ Symbolic → numerical compile    │\n│ EquilibriumHandler      │   221  │ Named equilibrium management    │\n│ SymbolicValidator       │   718  │ System definition validation    │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ Subtotal                │ 2,049  │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ DETERMINISTIC EVAL      │        │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ DynamicsEvaluator       │   576  │ Forward dynamics evaluation     │\n│ LinearizationEngine     │   907  │ Jacobian computation            │\n│ ObservationEngine       │   628  │ Output evaluation               │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ Subtotal                │ 2,111  │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ STOCHASTIC SUPPORT      │        │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ DiffusionHandler        │ 1,069  │ Diffusion matrix generation     │\n│ NoiseCharacterizer      │   692  │ Automatic noise analysis        │\n│ SDEValidator            │   544  │ SDE-specific validation         │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ Subtotal                │ 2,305  │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ LOW-LEVEL UTILITIES     │        │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ codegen_utils           │   733  │ SymPy code generation           │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ Subtotal                │   733  │                                 │\n├─────────────────────────┼────────┼─────────────────────────────────┤\n│ TOTAL                   │ 7,198  │                                 │\n└─────────────────────────┴────────┴─────────────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        KEY RESPONSIBILITIES\n═══════════════════════════════════════════════════════════════════════\n\nBackendManager:\n    ✓ Detect backend from array type\n    ✓ Convert arrays between backends\n    ✓ Manage devices (CPU, CUDA, TPU)\n    ✓ Backend availability checking\n\nCodeGenerator:\n    ✓ Generate f(x, u) → dx/dt functions\n    ✓ Generate h(x) → y functions\n    ✓ Generate Jacobians: A, B, C\n    ✓ Per-backend caching\n    ✓ Symbolic optimization\n\nEquilibriumHandler:\n    ✓ Store named equilibria\n    ✓ Backend-neutral storage\n    ✓ On-demand conversion\n    ✓ Verification with tolerance\n    ✓ Metadata management\n\nSymbolicValidator:\n    ✓ Validate state/control variables\n    ✓ Check symbolic dimensions\n    ✓ Verify parameter types\n    ✓ Ensure system order compatibility\n    ✓ Clear error messages\n\nDynamicsEvaluator:\n    ✓ Evaluate dx/dt = f(x, u)\n    ✓ Handle autonomous systems (u=None)\n    ✓ Batched evaluation\n    ✓ Performance tracking\n    ✓ Backend dispatch\n\nLinearizationEngine:\n    ✓ Compute A = ∂f/∂x, B = ∂f/∂u\n    ✓ Continuous and discrete Jacobians\n    ✓ Higher-order state-space construction\n    ✓ Symbolic and numerical modes\n    ✓ Backend-agnostic\n\nObservationEngine:\n    ✓ Evaluate y = h(x)\n    ✓ Compute C = ∂h/∂x\n    ✓ Batched output evaluation\n    ✓ Multi-backend support\n\nDiffusionHandler:\n    ✓ Generate g(x, u) diffusion matrix\n    ✓ Noise structure optimization\n    ✓ Stratonovich corrections\n    ✓ Additive/diagonal/scalar specialization\n\nNoiseCharacterizer:\n    ✓ Automatic noise type detection\n    ✓ Structure analysis (additive, diagonal, etc.)\n    ✓ Solver recommendations per backend\n    ✓ Noise statistics\n\nSDEValidator:\n    ✓ Validate diffusion dimensions\n    ✓ Check SDE type (Itô vs Stratonovich)\n    ✓ Verify compatibility with drift\n    ✓ Ensure finite expressions\n\ncodegen_utils:\n    ✓ SymPy Matrix → callable function\n    ✓ Common subexpression elimination\n    ✓ Backend-specific optimizations\n    ✓ NumPy/PyTorch/JAX code generation\n\n\n═══════════════════════════════════════════════════════════════════════\n                        DESIGN BENEFITS\n═══════════════════════════════════════════════════════════════════════\n\n✓ SINGLE RESPONSIBILITY\n  Each utility does ONE thing well\n\n✓ COMPOSITION OVER INHERITANCE\n  Systems compose utilities, don't inherit\n\n✓ REUSABILITY\n  Utilities can be used independently\n\n✓ TESTABILITY\n  Each component tested in isolation\n\n✓ FLEXIBILITY\n  Easy to add new utilities\n\n✓ PERFORMANCE\n  Caching and lazy initialization\n\n✓ MULTI-BACKEND\n  Seamless NumPy/PyTorch/JAX switching\n\n✓ TYPE SAFETY\n  TypedDict and semantic types throughout\n\n✓ MAINTAINABILITY\n  Clear separation of concerns\n\n✓ EXTENSIBILITY\n  Composition enables new features\n\n\n═══════════════════════════════════════════════════════════════════════\n\n\nTotal: 7,198 lines across 11 focused utility classes\nCore Philosophy: Composition over inheritance\nKey Pattern: Each system composes the utilities it needs rather than inheriting a monolithic base\nResult: Clean, testable, flexible architecture with clear separation of concerns"
  },
  {
    "objectID": "api/delegation_layer/delegation_layer_text.html#summary",
    "href": "api/delegation_layer/delegation_layer_text.html#summary",
    "title": "Delegation Layer Architecture (Text Diagram)",
    "section": "",
    "text": "Total: 7,198 lines across 11 focused utility classes\nCore Philosophy: Composition over inheritance\nKey Pattern: Each system composes the utilities it needs rather than inheriting a monolithic base\nResult: Clean, testable, flexible architecture with clear separation of concerns"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "The Delegation Layer provides specialized services through composition. Systems compose these utilities rather than inheriting from them.\n\n\n\n\n\nPurpose: Multi-backend array handling\n# Access via system\nmgr = system.backend\n\n# Detect backend from array\nbackend = mgr.detect(array)  # 'numpy', 'torch', 'jax'\n\n# Convert between backends\nx_torch = mgr.to_backend(x_numpy, 'torch')\nx_jax = mgr.to_backend(x_torch, 'jax')\nx_numpy = mgr.to_backend(x_jax, 'numpy')\n\n# Device placement (GPU)\nx_cuda = mgr.to_device(x_torch, 'cuda:0')\n\n# Set defaults\nmgr.set_default('torch', device='cuda:0')\n\n# Temporary backend switch\nwith mgr.use_backend('jax'):\n    # Operations use JAX\n    result = compute()\n\n# Check available backends\nprint(mgr.available_backends)  # ['numpy', 'torch', 'jax']\nProperties:\nmgr.default_backend     # Current default\nmgr.preferred_device    # Current device\nmgr.available_backends  # List of available\n\n\n\n\nPurpose: Symbolic → numerical code generation with caching\n# Access via system (private)\ncode_gen = system._code_gen\n\n# Generate dynamics function (cached)\nf_numpy = code_gen.generate_dynamics('numpy')\nf_torch = code_gen.generate_dynamics('torch')\nf_jax = code_gen.generate_dynamics('jax', jit=True)\n\n# Generate Jacobians\nA_func = code_gen.generate_jacobian_A('numpy')\nB_func = code_gen.generate_jacobian_B('numpy')\n\n# Output function (if system has outputs)\nh_func = code_gen.generate_output('numpy')\nC_func = code_gen.generate_jacobian_C('numpy')\n\n# Compile all backends at once\ntimings = code_gen.compile_all(backends=['numpy', 'torch', 'jax'])\nprint(f\"NumPy: {timings['numpy']:.3f}s\")\nprint(f\"PyTorch: {timings['torch']:.3f}s\")\nprint(f\"JAX: {timings['jax']:.3f}s\")\n\n# Check cache status\nhas_numpy = code_gen.has_dynamics('numpy')\nhas_torch = code_gen.has_dynamics('torch')\n\n# Clear cache (e.g., after parameter change)\ncode_gen.invalidate_cache()\nCaching:\n\nFunctions cached per backend\nAutomatic on first call\nInvalidated on parameter changes\nSymbolic Jacobians computed once, compiled per backend\n\n\n\n\n\nPurpose: Named equilibrium management\n# Access via system\neq = system.equilibria\n\n# Add equilibrium\neq.add(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    metadata={'stability': 'unstable'}\n)\n\n# Add with verification\neq.add(\n    'inverted',\n    x_eq=np.array([0, 0]),\n    u_eq=np.zeros(1),\n    verify_fn=lambda x, u: system(x, u),\n    tol=1e-6,\n    metadata={'stability': 'stable'}\n)\n\n# Get equilibrium in any backend\nx_eq_numpy = eq.get_x('upright', backend='numpy')\nx_eq_torch = eq.get_x('upright', backend='torch')\nx_eq_jax = eq.get_x('upright', backend='jax')\n\n# Get control\nu_eq = eq.get_u('upright', backend='numpy')\n\n# Get both\nx_eq, u_eq = eq.get_both('upright', backend='torch')\n\n# Set default\neq.set_default('upright')\n\n# Get default (no name needed)\nx_eq, u_eq = eq.get_both()  # Uses default\n\n# List all\nnames = eq.list_names()  # ['origin', 'upright', 'inverted']\n\n# Get metadata\nmeta = eq.get_metadata('upright')\nprint(meta['stability'])  # 'unstable'\nprint(meta.get('verified', False))  # True if verified\nAutomatic Features:\n\nOrigin always present at (0, 0)\nDimension validation on add\nFinite value checking (no NaN/Inf)\nBackend-neutral storage (NumPy)\n\n\n\n\n\nPurpose: System definition validation\n# Access via system (used automatically)\nvalidator = system._validator\n\n# Validate system (called automatically in __init__)\nresult = validator.validate(system)\n\nif result['valid']:\n    print(\"System is valid\")\nelse:\n    print(f\"Errors: {result['errors']}\")\n    print(f\"Warnings: {result['warnings']}\")\nWhat It Checks:\n✓ state_vars is list of sp.Symbol\n✓ control_vars is list of sp.Symbol\n✓ _f_sym is sp.Matrix\n✓ _f_sym has correct dimensions\n✓ parameters keys are sp.Symbol (not strings!)\n✓ order divides nx evenly\n✓ _h_sym dimensions (if defined)\n✓ _h_sym doesn't depend on control\nCommon Errors:\n# ❌ String keys in parameters\nself.parameters = {'m': 1.0}  # WRONG!\n\n# ✓ Symbol keys\nself.parameters = {m_sym: 1.0}  # Correct\n\n# ❌ Wrong dimensions\nself._f_sym = sp.Matrix([x, y])  # nx=3, wrong!\n\n# ✓ Correct dimensions\nself._f_sym = sp.Matrix([x, y, z])  # nx=3, correct\n\n\n\n\n\n\n\nPurpose: Forward dynamics evaluation\n# Access via system (private)\ndynamics = system._dynamics\n\n# Single evaluation (usually via system.__call__)\ndx = dynamics.evaluate(x, u, backend='numpy')\n\n# Autonomous system\ndx = dynamics.evaluate(x, backend='numpy')  # u=None\n\n# Batched evaluation\nx_batch = np.random.randn(100, nx)\nu_batch = np.random.randn(100, nu)\ndx_batch = dynamics.evaluate(x_batch, u_batch)\n\n# Get performance statistics\nstats = dynamics.get_stats()\nprint(f\"Evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']:.6f}s\")\nprint(f\"Total time: {stats['total_time']:.3f}s\")\nPerformance Tracking:\n{\n    'count': int,        # Number of evaluations\n    'total_time': float, # Total time (seconds)\n    'avg_time': float,   # Average per evaluation\n    'min_time': float,   # Fastest\n    'max_time': float,   # Slowest\n}\n\n\n\n\nPurpose: Jacobian computation\n# Access via system (private)\nlin = system._linearization\n\n# Continuous linearization (via system.linearize)\nA, B = lin.linearize_continuous(x_eq, u_eq, backend='numpy')\n\n# Discrete linearization\nAd, Bd = lin.linearize_discrete(x_eq, u_eq, backend='numpy')\n\n# Get symbolic Jacobians (computed once)\nA_sym = lin.get_symbolic_A()\nB_sym = lin.get_symbolic_B()\n\n# Pretty print symbolic Jacobians\nlin.print_symbolic_jacobians()\nHigher-Order Systems: For order=2 systems where state is [q, q̇] but only q̈ is returned:\n# System automatically constructs full state-space:\n# [q̇, q̈]ᵀ = A[q, q̇]ᵀ + Bu\n\nA, B = system.linearize(x_eq, u_eq)\n# A is (nx, nx) = (2, 2)\n# B is (nx, nu) = (2, nu)\n\n\n\n\nPurpose: Output evaluation\n# Access via system (private)\nobs = system._observation\n\n# Check if output defined\nif obs.has_output():\n    # Evaluate output\n    y = obs.observe(x, backend='numpy')\n    \n    # Batched output\n    x_batch = np.random.randn(100, nx)\n    y_batch = obs.observe(x_batch)  # (100, ny)\n    \n    # Output Jacobian\n    C = obs.linearize_output(x_eq, backend='numpy')\n\n\n\n\n\n\n\nPurpose: Diffusion matrix generation for SDEs\n# Access via stochastic system\ndiffusion = system.diffusion_handler\n\n# Generate diffusion function (cached)\ng_func = diffusion.generate_diffusion('numpy')\n\n# Evaluate diffusion matrix\ng = diffusion.evaluate_diffusion(x, u, backend='numpy')\n# Returns: (nx, nw) matrix\n\n# Check noise type\nif diffusion.is_additive():\n    # Optimized for additive noise\n    g_const = diffusion.get_additive_matrix()\n    # g doesn't depend on x, u - constant!\n\nif diffusion.is_diagonal():\n    # Diagonal diffusion matrix\n    print(\"Independent noise sources\")\n\n# Stratonovich correction (if sde_type='stratonovich')\ncorrection = diffusion.compute_stratonovich_correction(x, u)\n\n# Number of Wiener processes\nnw = diffusion.nw\n\n\n\n\nPurpose: Automatic noise analysis\n# Access via stochastic system\ncharacteristics = system.noise_characteristics\n\n# Noise properties\nnoise_type = characteristics.noise_type\n# Returns: ADDITIVE, MULTIPLICATIVE_DIAGONAL, etc.\n\nis_additive = characteristics.is_additive\nis_diagonal = characteristics.is_diagonal\nnw = characteristics.nw  # Number of Wiener processes\n\n# Solver recommendations\nsolvers = characteristics.recommend_solvers('torch')\n# For additive: ['heun', 'reversible_heun']\n# For multiplicative: ['euler-maruyama']\n\n# Validation\nif characteristics.is_valid:\n    print(\"Noise structure valid\")\nelse:\n    print(characteristics.validation_message)\nNoise Types:\nADDITIVE                # g(x,u) = constant\nMULTIPLICATIVE_DIAGONAL # g(x,u) diagonal\nMULTIPLICATIVE_SCALAR   # Single Wiener process\nMULTIPLICATIVE_GENERAL  # Full matrix\n\n\n\n\nPurpose: SDE-specific validation\n# Access via stochastic system (used automatically)\nsde_val = system._sde_validator\n\n# Validate (called automatically in __init__)\nresult = sde_val.validate(system)\n\nif result['valid']:\n    print(\"SDE system valid\")\nelse:\n    print(f\"Errors: {result['errors']}\")\nWhat It Checks:\n✓ diffusion_expr is sp.Matrix\n✓ Dimensions: (nx, nw)\n✓ diffusion_expr uses only state_vars, control_vars\n✓ sde_type is 'ito' or 'stratonovich'\n✓ Compatibility with drift\n✓ No division by zero\n\n\n\n\n\n\n\nimport torch\n\n# Switch backend for entire system\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# All operations now use PyTorch/GPU\nx = torch.tensor([[1.0, 0.0]], device='cuda:0')\ndx = system(x, u=None)  # Returns torch.Tensor on cuda:0\n\n# Equilibria automatically converted\nx_eq = system.equilibria.get_x('origin', backend='torch')\n# Returns: torch.Tensor on cuda:0\n\n\n\n# Run many evaluations\nfor i in range(10000):\n    x = np.random.randn(nx)\n    u = np.random.randn(nu)\n    dx = system(x, u)\n\n# Get statistics\nstats = system._dynamics.get_stats()\nprint(f\"Total evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']*1e6:.1f} μs\")\nprint(f\"Evaluations/sec: {stats['count']/stats['total_time']:.0f}\")\n\n\n\n# Compile all backends upfront\ntimings = system._code_gen.compile_all(\n    backends=['numpy', 'torch', 'jax']\n)\n\n# Warmup each backend\nfor backend in ['numpy', 'torch', 'jax']:\n    x = system.backend.to_backend(np.zeros(nx), backend)\n    u = system.backend.to_backend(np.zeros(nu), backend)\n    _ = system._dynamics.evaluate(x, u, backend=backend)\n\nprint(\"All backends compiled and warmed up\")\n\n\n\n# Add multiple equilibria\nequilibria_data = [\n    ('origin', np.zeros(nx), np.zeros(nu), {'stability': 'unstable'}),\n    ('upright', np.array([0, 0]), np.zeros(nu), {'stability': 'stable'}),\n    ('inverted', np.array([np.pi, 0]), np.zeros(nu), {'stability': 'unstable'}),\n]\n\nfor name, x_eq, u_eq, metadata in equilibria_data:\n    system.add_equilibrium(name, x_eq, u_eq, **metadata)\n\n# Linearize at each\nfor name in system.list_equilibria():\n    x_eq, u_eq = system.get_equilibrium(name)\n    A, B = system.linearize(x_eq, u_eq)\n    \n    # Stability analysis\n    eigenvalues = np.linalg.eigvals(A)\n    stable = np.all(np.real(eigenvalues) &lt; 0)  # Continuous\n    \n    print(f\"{name}: {'Stable' if stable else 'Unstable'}\")\n\n\n\n# Create stochastic system\nsde_system = MyStochasticSystem()\n\n# Automatic noise characterization\nnoise = sde_system.noise_characteristics\n\nprint(f\"Noise type: {noise.noise_type}\")\nprint(f\"Additive: {noise.is_additive}\")\nprint(f\"Diagonal: {noise.is_diagonal}\")\nprint(f\"Number of Wiener processes: {noise.nw}\")\n\n# Get solver recommendations\nfor backend in ['numpy', 'torch', 'jax']:\n    if backend in sde_system.backend.available_backends:\n        solvers = noise.recommend_solvers(backend)\n        print(f\"{backend}: {solvers}\")\n\n# Use optimized evaluation for additive noise\nif sde_system.is_additive_noise():\n    # Diffusion is constant - evaluate once\n    g_const = sde_system.diffusion_handler.get_additive_matrix()\n    print(f\"Constant diffusion matrix:\\n{g_const}\")\n\n\n\n\n\n\nProblem:\nself.parameters = {'m': 1.0}  # ❌ String key\nSolution:\nm_sym = sp.symbols('m', positive=True)\nself.parameters = {m_sym: 1.0}  # ✓ Symbol key\n\n\n\nExplanation: This is normal - code generation and compilation happen on first call, then results are cached.\nSolution: Compile upfront if needed:\nsystem._code_gen.compile_all(backends=['numpy', 'torch', 'jax'])\n\n\n\nProblem: Mixing backends in operations\nSolution: Convert to same backend:\nx_torch = system.backend.to_backend(x_numpy, 'torch')\nu_torch = system.backend.to_backend(u_numpy, 'torch')\ndx_torch = system(x_torch, u_torch)\n\n\n\nProblem: Equilibrium not actually at equilibrium\nCheck:\nx_eq = np.array([...])\nu_eq = np.array([...])\n\n# For continuous: should be near zero\ndx = system(x_eq, u_eq)\nprint(f\"Max |f(x,u)|: {np.abs(dx).max()}\")  # Should be &lt; 1e-6\n\n# For discrete: should equal x_eq\nx_next = system.step(x_eq, u_eq)\nprint(f\"Max |f(x,u) - x|: {np.abs(x_next - x_eq).max()}\")\n\n\n\n\n\n\n# Configure backend preferences\nsystem.backend.set_default('torch', device='cuda:0')\n\n# Use different devices for different operations\nwith system.backend.use_device('cuda:1'):\n    # Operations on GPU 1\n    dx = system(x, u)\n\n# Check CUDA availability\nif 'torch' in system.backend.available_backends:\n    import torch\n    if torch.cuda.is_available():\n        system.backend.set_default('torch', device='cuda:0')\n\n\n\n# Get symbolic Jacobians\nA_sym = system._linearization.get_symbolic_A()\nB_sym = system._linearization.get_symbolic_B()\n\n# Simplify\nA_simplified = sp.simplify(A_sym)\n\n# Substitute specific parameter values\nparams = {m_sym: 1.0, k_sym: 10.0}\nA_numerical = A_sym.subs(params)\n\n# Pretty print\nfrom sympy import pprint\npprint(A_sym)\n\n\n\n# Check what's cached\nhas_numpy_f = system._code_gen.has_dynamics('numpy')\nhas_torch_A = system._code_gen.has_jacobian_A('torch')\n\n# Invalidate cache (forces recompilation)\nsystem._code_gen.invalidate_cache()\n\n# Selective invalidation\nsystem._code_gen._f_funcs['numpy'] = None  # Only NumPy\n\n\n\n\ndef test_delegation_layer():\n    \"\"\"Test that delegation layer is properly set up.\"\"\"\n    system = MySystem()\n    \n    # Check core utilities exist\n    assert hasattr(system, 'backend')\n    assert hasattr(system, '_code_gen')\n    assert hasattr(system, 'equilibria')\n    \n    # Check deterministic evaluators\n    assert hasattr(system, '_dynamics')\n    assert hasattr(system, '_linearization')\n    \n    # Test backend manager\n    x = np.array([1.0, 0.0])\n    backend = system.backend.detect(x)\n    assert backend == 'numpy'\n    \n    # Test code generator\n    f = system._code_gen.generate_dynamics('numpy')\n    assert callable(f)\n    \n    # Test equilibrium handler\n    assert 'origin' in system.list_equilibria()\n    \n    print(\"✓ Delegation layer tests passed\")\n\ntest_delegation_layer()\n\n\n\n\nArchitecture: See Delegation_Layer_Architecture.md\nType Definitions: See src/types/\nUI Framework: See UI_Framework_Architecture.md"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#overview",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#overview",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "The Delegation Layer provides specialized services through composition. Systems compose these utilities rather than inheriting from them."
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#core-utilities",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#core-utilities",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "Purpose: Multi-backend array handling\n# Access via system\nmgr = system.backend\n\n# Detect backend from array\nbackend = mgr.detect(array)  # 'numpy', 'torch', 'jax'\n\n# Convert between backends\nx_torch = mgr.to_backend(x_numpy, 'torch')\nx_jax = mgr.to_backend(x_torch, 'jax')\nx_numpy = mgr.to_backend(x_jax, 'numpy')\n\n# Device placement (GPU)\nx_cuda = mgr.to_device(x_torch, 'cuda:0')\n\n# Set defaults\nmgr.set_default('torch', device='cuda:0')\n\n# Temporary backend switch\nwith mgr.use_backend('jax'):\n    # Operations use JAX\n    result = compute()\n\n# Check available backends\nprint(mgr.available_backends)  # ['numpy', 'torch', 'jax']\nProperties:\nmgr.default_backend     # Current default\nmgr.preferred_device    # Current device\nmgr.available_backends  # List of available\n\n\n\n\nPurpose: Symbolic → numerical code generation with caching\n# Access via system (private)\ncode_gen = system._code_gen\n\n# Generate dynamics function (cached)\nf_numpy = code_gen.generate_dynamics('numpy')\nf_torch = code_gen.generate_dynamics('torch')\nf_jax = code_gen.generate_dynamics('jax', jit=True)\n\n# Generate Jacobians\nA_func = code_gen.generate_jacobian_A('numpy')\nB_func = code_gen.generate_jacobian_B('numpy')\n\n# Output function (if system has outputs)\nh_func = code_gen.generate_output('numpy')\nC_func = code_gen.generate_jacobian_C('numpy')\n\n# Compile all backends at once\ntimings = code_gen.compile_all(backends=['numpy', 'torch', 'jax'])\nprint(f\"NumPy: {timings['numpy']:.3f}s\")\nprint(f\"PyTorch: {timings['torch']:.3f}s\")\nprint(f\"JAX: {timings['jax']:.3f}s\")\n\n# Check cache status\nhas_numpy = code_gen.has_dynamics('numpy')\nhas_torch = code_gen.has_dynamics('torch')\n\n# Clear cache (e.g., after parameter change)\ncode_gen.invalidate_cache()\nCaching:\n\nFunctions cached per backend\nAutomatic on first call\nInvalidated on parameter changes\nSymbolic Jacobians computed once, compiled per backend\n\n\n\n\n\nPurpose: Named equilibrium management\n# Access via system\neq = system.equilibria\n\n# Add equilibrium\neq.add(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    metadata={'stability': 'unstable'}\n)\n\n# Add with verification\neq.add(\n    'inverted',\n    x_eq=np.array([0, 0]),\n    u_eq=np.zeros(1),\n    verify_fn=lambda x, u: system(x, u),\n    tol=1e-6,\n    metadata={'stability': 'stable'}\n)\n\n# Get equilibrium in any backend\nx_eq_numpy = eq.get_x('upright', backend='numpy')\nx_eq_torch = eq.get_x('upright', backend='torch')\nx_eq_jax = eq.get_x('upright', backend='jax')\n\n# Get control\nu_eq = eq.get_u('upright', backend='numpy')\n\n# Get both\nx_eq, u_eq = eq.get_both('upright', backend='torch')\n\n# Set default\neq.set_default('upright')\n\n# Get default (no name needed)\nx_eq, u_eq = eq.get_both()  # Uses default\n\n# List all\nnames = eq.list_names()  # ['origin', 'upright', 'inverted']\n\n# Get metadata\nmeta = eq.get_metadata('upright')\nprint(meta['stability'])  # 'unstable'\nprint(meta.get('verified', False))  # True if verified\nAutomatic Features:\n\nOrigin always present at (0, 0)\nDimension validation on add\nFinite value checking (no NaN/Inf)\nBackend-neutral storage (NumPy)\n\n\n\n\n\nPurpose: System definition validation\n# Access via system (used automatically)\nvalidator = system._validator\n\n# Validate system (called automatically in __init__)\nresult = validator.validate(system)\n\nif result['valid']:\n    print(\"System is valid\")\nelse:\n    print(f\"Errors: {result['errors']}\")\n    print(f\"Warnings: {result['warnings']}\")\nWhat It Checks:\n✓ state_vars is list of sp.Symbol\n✓ control_vars is list of sp.Symbol\n✓ _f_sym is sp.Matrix\n✓ _f_sym has correct dimensions\n✓ parameters keys are sp.Symbol (not strings!)\n✓ order divides nx evenly\n✓ _h_sym dimensions (if defined)\n✓ _h_sym doesn't depend on control\nCommon Errors:\n# ❌ String keys in parameters\nself.parameters = {'m': 1.0}  # WRONG!\n\n# ✓ Symbol keys\nself.parameters = {m_sym: 1.0}  # Correct\n\n# ❌ Wrong dimensions\nself._f_sym = sp.Matrix([x, y])  # nx=3, wrong!\n\n# ✓ Correct dimensions\nself._f_sym = sp.Matrix([x, y, z])  # nx=3, correct"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#deterministic-evaluation",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#deterministic-evaluation",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "Purpose: Forward dynamics evaluation\n# Access via system (private)\ndynamics = system._dynamics\n\n# Single evaluation (usually via system.__call__)\ndx = dynamics.evaluate(x, u, backend='numpy')\n\n# Autonomous system\ndx = dynamics.evaluate(x, backend='numpy')  # u=None\n\n# Batched evaluation\nx_batch = np.random.randn(100, nx)\nu_batch = np.random.randn(100, nu)\ndx_batch = dynamics.evaluate(x_batch, u_batch)\n\n# Get performance statistics\nstats = dynamics.get_stats()\nprint(f\"Evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']:.6f}s\")\nprint(f\"Total time: {stats['total_time']:.3f}s\")\nPerformance Tracking:\n{\n    'count': int,        # Number of evaluations\n    'total_time': float, # Total time (seconds)\n    'avg_time': float,   # Average per evaluation\n    'min_time': float,   # Fastest\n    'max_time': float,   # Slowest\n}\n\n\n\n\nPurpose: Jacobian computation\n# Access via system (private)\nlin = system._linearization\n\n# Continuous linearization (via system.linearize)\nA, B = lin.linearize_continuous(x_eq, u_eq, backend='numpy')\n\n# Discrete linearization\nAd, Bd = lin.linearize_discrete(x_eq, u_eq, backend='numpy')\n\n# Get symbolic Jacobians (computed once)\nA_sym = lin.get_symbolic_A()\nB_sym = lin.get_symbolic_B()\n\n# Pretty print symbolic Jacobians\nlin.print_symbolic_jacobians()\nHigher-Order Systems: For order=2 systems where state is [q, q̇] but only q̈ is returned:\n# System automatically constructs full state-space:\n# [q̇, q̈]ᵀ = A[q, q̇]ᵀ + Bu\n\nA, B = system.linearize(x_eq, u_eq)\n# A is (nx, nx) = (2, 2)\n# B is (nx, nu) = (2, nu)\n\n\n\n\nPurpose: Output evaluation\n# Access via system (private)\nobs = system._observation\n\n# Check if output defined\nif obs.has_output():\n    # Evaluate output\n    y = obs.observe(x, backend='numpy')\n    \n    # Batched output\n    x_batch = np.random.randn(100, nx)\n    y_batch = obs.observe(x_batch)  # (100, ny)\n    \n    # Output Jacobian\n    C = obs.linearize_output(x_eq, backend='numpy')"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#stochastic-support",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#stochastic-support",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "Purpose: Diffusion matrix generation for SDEs\n# Access via stochastic system\ndiffusion = system.diffusion_handler\n\n# Generate diffusion function (cached)\ng_func = diffusion.generate_diffusion('numpy')\n\n# Evaluate diffusion matrix\ng = diffusion.evaluate_diffusion(x, u, backend='numpy')\n# Returns: (nx, nw) matrix\n\n# Check noise type\nif diffusion.is_additive():\n    # Optimized for additive noise\n    g_const = diffusion.get_additive_matrix()\n    # g doesn't depend on x, u - constant!\n\nif diffusion.is_diagonal():\n    # Diagonal diffusion matrix\n    print(\"Independent noise sources\")\n\n# Stratonovich correction (if sde_type='stratonovich')\ncorrection = diffusion.compute_stratonovich_correction(x, u)\n\n# Number of Wiener processes\nnw = diffusion.nw\n\n\n\n\nPurpose: Automatic noise analysis\n# Access via stochastic system\ncharacteristics = system.noise_characteristics\n\n# Noise properties\nnoise_type = characteristics.noise_type\n# Returns: ADDITIVE, MULTIPLICATIVE_DIAGONAL, etc.\n\nis_additive = characteristics.is_additive\nis_diagonal = characteristics.is_diagonal\nnw = characteristics.nw  # Number of Wiener processes\n\n# Solver recommendations\nsolvers = characteristics.recommend_solvers('torch')\n# For additive: ['heun', 'reversible_heun']\n# For multiplicative: ['euler-maruyama']\n\n# Validation\nif characteristics.is_valid:\n    print(\"Noise structure valid\")\nelse:\n    print(characteristics.validation_message)\nNoise Types:\nADDITIVE                # g(x,u) = constant\nMULTIPLICATIVE_DIAGONAL # g(x,u) diagonal\nMULTIPLICATIVE_SCALAR   # Single Wiener process\nMULTIPLICATIVE_GENERAL  # Full matrix\n\n\n\n\nPurpose: SDE-specific validation\n# Access via stochastic system (used automatically)\nsde_val = system._sde_validator\n\n# Validate (called automatically in __init__)\nresult = sde_val.validate(system)\n\nif result['valid']:\n    print(\"SDE system valid\")\nelse:\n    print(f\"Errors: {result['errors']}\")\nWhat It Checks:\n✓ diffusion_expr is sp.Matrix\n✓ Dimensions: (nx, nw)\n✓ diffusion_expr uses only state_vars, control_vars\n✓ sde_type is 'ito' or 'stratonovich'\n✓ Compatibility with drift\n✓ No division by zero"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#common-patterns",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#common-patterns",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "import torch\n\n# Switch backend for entire system\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# All operations now use PyTorch/GPU\nx = torch.tensor([[1.0, 0.0]], device='cuda:0')\ndx = system(x, u=None)  # Returns torch.Tensor on cuda:0\n\n# Equilibria automatically converted\nx_eq = system.equilibria.get_x('origin', backend='torch')\n# Returns: torch.Tensor on cuda:0\n\n\n\n# Run many evaluations\nfor i in range(10000):\n    x = np.random.randn(nx)\n    u = np.random.randn(nu)\n    dx = system(x, u)\n\n# Get statistics\nstats = system._dynamics.get_stats()\nprint(f\"Total evaluations: {stats['count']}\")\nprint(f\"Average time: {stats['avg_time']*1e6:.1f} μs\")\nprint(f\"Evaluations/sec: {stats['count']/stats['total_time']:.0f}\")\n\n\n\n# Compile all backends upfront\ntimings = system._code_gen.compile_all(\n    backends=['numpy', 'torch', 'jax']\n)\n\n# Warmup each backend\nfor backend in ['numpy', 'torch', 'jax']:\n    x = system.backend.to_backend(np.zeros(nx), backend)\n    u = system.backend.to_backend(np.zeros(nu), backend)\n    _ = system._dynamics.evaluate(x, u, backend=backend)\n\nprint(\"All backends compiled and warmed up\")\n\n\n\n# Add multiple equilibria\nequilibria_data = [\n    ('origin', np.zeros(nx), np.zeros(nu), {'stability': 'unstable'}),\n    ('upright', np.array([0, 0]), np.zeros(nu), {'stability': 'stable'}),\n    ('inverted', np.array([np.pi, 0]), np.zeros(nu), {'stability': 'unstable'}),\n]\n\nfor name, x_eq, u_eq, metadata in equilibria_data:\n    system.add_equilibrium(name, x_eq, u_eq, **metadata)\n\n# Linearize at each\nfor name in system.list_equilibria():\n    x_eq, u_eq = system.get_equilibrium(name)\n    A, B = system.linearize(x_eq, u_eq)\n    \n    # Stability analysis\n    eigenvalues = np.linalg.eigvals(A)\n    stable = np.all(np.real(eigenvalues) &lt; 0)  # Continuous\n    \n    print(f\"{name}: {'Stable' if stable else 'Unstable'}\")\n\n\n\n# Create stochastic system\nsde_system = MyStochasticSystem()\n\n# Automatic noise characterization\nnoise = sde_system.noise_characteristics\n\nprint(f\"Noise type: {noise.noise_type}\")\nprint(f\"Additive: {noise.is_additive}\")\nprint(f\"Diagonal: {noise.is_diagonal}\")\nprint(f\"Number of Wiener processes: {noise.nw}\")\n\n# Get solver recommendations\nfor backend in ['numpy', 'torch', 'jax']:\n    if backend in sde_system.backend.available_backends:\n        solvers = noise.recommend_solvers(backend)\n        print(f\"{backend}: {solvers}\")\n\n# Use optimized evaluation for additive noise\nif sde_system.is_additive_noise():\n    # Diffusion is constant - evaluate once\n    g_const = sde_system.diffusion_handler.get_additive_matrix()\n    print(f\"Constant diffusion matrix:\\n{g_const}\")"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#troubleshooting",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#troubleshooting",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "Problem:\nself.parameters = {'m': 1.0}  # ❌ String key\nSolution:\nm_sym = sp.symbols('m', positive=True)\nself.parameters = {m_sym: 1.0}  # ✓ Symbol key\n\n\n\nExplanation: This is normal - code generation and compilation happen on first call, then results are cached.\nSolution: Compile upfront if needed:\nsystem._code_gen.compile_all(backends=['numpy', 'torch', 'jax'])\n\n\n\nProblem: Mixing backends in operations\nSolution: Convert to same backend:\nx_torch = system.backend.to_backend(x_numpy, 'torch')\nu_torch = system.backend.to_backend(u_numpy, 'torch')\ndx_torch = system(x_torch, u_torch)\n\n\n\nProblem: Equilibrium not actually at equilibrium\nCheck:\nx_eq = np.array([...])\nu_eq = np.array([...])\n\n# For continuous: should be near zero\ndx = system(x_eq, u_eq)\nprint(f\"Max |f(x,u)|: {np.abs(dx).max()}\")  # Should be &lt; 1e-6\n\n# For discrete: should equal x_eq\nx_next = system.step(x_eq, u_eq)\nprint(f\"Max |f(x,u) - x|: {np.abs(x_next - x_eq).max()}\")"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#advanced-usage",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#advanced-usage",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "# Configure backend preferences\nsystem.backend.set_default('torch', device='cuda:0')\n\n# Use different devices for different operations\nwith system.backend.use_device('cuda:1'):\n    # Operations on GPU 1\n    dx = system(x, u)\n\n# Check CUDA availability\nif 'torch' in system.backend.available_backends:\n    import torch\n    if torch.cuda.is_available():\n        system.backend.set_default('torch', device='cuda:0')\n\n\n\n# Get symbolic Jacobians\nA_sym = system._linearization.get_symbolic_A()\nB_sym = system._linearization.get_symbolic_B()\n\n# Simplify\nA_simplified = sp.simplify(A_sym)\n\n# Substitute specific parameter values\nparams = {m_sym: 1.0, k_sym: 10.0}\nA_numerical = A_sym.subs(params)\n\n# Pretty print\nfrom sympy import pprint\npprint(A_sym)\n\n\n\n# Check what's cached\nhas_numpy_f = system._code_gen.has_dynamics('numpy')\nhas_torch_A = system._code_gen.has_jacobian_A('torch')\n\n# Invalidate cache (forces recompilation)\nsystem._code_gen.invalidate_cache()\n\n# Selective invalidation\nsystem._code_gen._f_funcs['numpy'] = None  # Only NumPy"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#testing-your-utilities",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#testing-your-utilities",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "def test_delegation_layer():\n    \"\"\"Test that delegation layer is properly set up.\"\"\"\n    system = MySystem()\n    \n    # Check core utilities exist\n    assert hasattr(system, 'backend')\n    assert hasattr(system, '_code_gen')\n    assert hasattr(system, 'equilibria')\n    \n    # Check deterministic evaluators\n    assert hasattr(system, '_dynamics')\n    assert hasattr(system, '_linearization')\n    \n    # Test backend manager\n    x = np.array([1.0, 0.0])\n    backend = system.backend.detect(x)\n    assert backend == 'numpy'\n    \n    # Test code generator\n    f = system._code_gen.generate_dynamics('numpy')\n    assert callable(f)\n    \n    # Test equilibrium handler\n    assert 'origin' in system.list_equilibria()\n    \n    print(\"✓ Delegation layer tests passed\")\n\ntest_delegation_layer()"
  },
  {
    "objectID": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#references",
    "href": "api/delegation_layer/Delegation_Layer_Quick_Reference.html#references",
    "title": "Delegation Layer Quick Reference",
    "section": "",
    "text": "Architecture: See Delegation_Layer_Architecture.md\nType Definitions: See src/types/\nUI Framework: See UI_Framework_Architecture.md"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html",
    "href": "api/control_framework/Control_Framework_Architecture.html",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "The Control Framework provides classical control theory algorithms for analysis and synthesis of dynamical systems. It consists of 3 core modules totaling ~1,786 lines organized into a clean 2-layer architecture: pure stateless functions and thin composition wrappers.\n\n\n\nFunctional Design with Composition - The control framework enables:\n\nPure Functions - Stateless algorithms like scipy (design_lqr, analyze_stability)\nThin Wrappers - Minimal composition layer for system integration\nType Safety - TypedDict results for all algorithms\nBackend Consistency - Automatic backend handling from parent system\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Implements classical control theory correctly\nSystem Integration - Clean system.control and system.analysis APIs\n\n# Pure functions - stateless, reusable\nresult = design_lqr(A, B, Q, R, system_type='continuous')\n\n# Composition wrappers - integrate with systems\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n\n\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                         │\n│              (ContinuousSystemBase, DiscreteSystemBase)     │\n│                                                              │\n│  system.control   ──────► ControlSynthesis (388 lines)     │\n│  system.analysis  ──────► SystemAnalysis   (431 lines)     │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ delegates to\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│              PURE FUNCTION LAYER                            │\n│          classical_control_functions.py (967 lines)         │\n│                                                              │\n│  Control Design:          System Analysis:                  │\n│  • design_lqr()          • analyze_stability()             │\n│  • design_kalman()       • analyze_controllability()       │\n│  • design_lqg()          • analyze_observability()         │\n│                                                              │\n│  All functions are stateless, pure, backend-agnostic       │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ returns\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   TYPE LAYER                                │\n│             control_classical.py (542 lines)                │\n│                                                              │\n│  • LQRResult           • StabilityInfo                      │\n│  • KalmanFilterResult  • ControllabilityInfo                │\n│  • LQGResult           • ObservabilityInfo                  │\n└────────────────────────────────────────────────────────────┘\n\n\n\n\n\n\n\nFile: classical_control_functions.py (967 lines)\nPurpose: Stateless algorithms for control design and system analysis\nDesign Philosophy:\n\nPure functions (no side effects, no state)\nWorks like scipy - takes matrices in, returns TypedDict\nBackend conversion handled internally\nMathematical correctness guaranteed\nComprehensive error checking\n\nCategories:\n1. Control Design Functions\ndef design_lqr(\n    A: StateMatrix,\n    B: InputMatrix,\n    Q: StateMatrix,\n    R: InputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQRResult:\n    \"\"\"\n    Design Linear Quadratic Regulator (LQR) controller.\n    \n    Unified interface for continuous and discrete LQR.\n    \n    Mathematical Background:\n        Continuous: Minimize J = ∫₀^∞ (x'Qx + u'Ru + 2x'Nu) dt\n        Discrete:   Minimize J = Σₖ₌₀^∞ (x'Qx + u'Ru + 2x'Nu)\n    \n    Solution via Algebraic Riccati Equation (ARE):\n        Continuous: A'P + PA - PBR⁻¹B'P + Q = 0\n        Discrete:   P = A'PA - A'PB(R + B'PB)⁻¹B'PA + Q\n    \n    Optimal Gain:\n        Continuous: K = R⁻¹B'P\n        Discrete:   K = (R + B'PB)⁻¹B'PA\n    \n    Args:\n        A: State matrix (nx, nx)\n        B: Input matrix (nx, nu)\n        Q: State cost matrix (nx, nx), Q ≥ 0, (Q,A) detectable\n        R: Control cost matrix (nu, nu), R &gt; 0\n        N: Cross-coupling matrix (nx, nu), default None\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        LQRResult with:\n            - gain: Optimal feedback gain K (nu, nx)\n            - cost_to_go: Riccati solution P (nx, nx)\n            - closed_loop_eigenvalues: eig(A - BK)\n            - stability_margin: Stability robustness measure\n    \n    Raises:\n        ValueError: If Q, R dimensions incompatible\n        LinAlgError: If Riccati equation has no stabilizing solution\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; B = np.array([[0], [1]])\n        &gt;&gt;&gt; Q = np.diag([10, 1])\n        &gt;&gt;&gt; R = np.array([[0.1]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; result = design_lqr(A, B, Q, R, system_type='continuous')\n        &gt;&gt;&gt; K = result['gain']\n        &gt;&gt;&gt; A_cl = A - B @ K\n        &gt;&gt;&gt; print(f\"Closed-loop eigenvalues: {result['closed_loop_eigenvalues']}\")\n    \"\"\"\ndef design_kalman_filter(\n    A: StateMatrix,\n    C: OutputMatrix,\n    Q: StateMatrix,\n    R: OutputMatrix,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; KalmanFilterResult:\n    \"\"\"\n    Design Kalman filter for optimal state estimation.\n    \n    System Model:\n        x[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0, Q)\n        y[k] = Cx[k] + v[k],            v ~ N(0, R)\n    \n    Estimator Dynamics:\n        x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \n    Optimal Gain:\n        L = APC'(CPC' + R)⁻¹\n    \n    Riccati Equation:\n        P = A(P - PC'(CPC'+R)⁻¹CP)A' + Q\n    \n    Args:\n        A: State matrix (nx, nx)\n        C: Output matrix (ny, nx)\n        Q: Process noise covariance (nx, nx), Q ≥ 0\n        R: Measurement noise covariance (ny, ny), R &gt; 0\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        KalmanFilterResult with:\n            - gain: Kalman gain L (nx, ny)\n            - error_covariance: Steady-state P (nx, nx)\n            - innovation_covariance: S = CPC' + R (ny, ny)\n            - observer_eigenvalues: eig(A - LC)\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.9]])\n        &gt;&gt;&gt; C = np.array([[1, 0]])\n        &gt;&gt;&gt; Q_proc = 0.01 * np.eye(2)\n        &gt;&gt;&gt; R_meas = np.array([[0.1]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; kalman = design_kalman_filter(A, C, Q_proc, R_meas)\n        &gt;&gt;&gt; L = kalman['gain']\n        &gt;&gt;&gt; print(f\"Observer poles: {kalman['observer_eigenvalues']}\")\n    \"\"\"\ndef design_lqg(\n    A: StateMatrix,\n    B: InputMatrix,\n    C: OutputMatrix,\n    Q_state: StateMatrix,\n    R_control: InputMatrix,\n    Q_process: StateMatrix,\n    R_measurement: OutputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQGResult:\n    \"\"\"\n    Design Linear Quadratic Gaussian (LQG) controller.\n    \n    Combines LQR (optimal control) with Kalman filter (optimal estimation)\n    via the separation principle.\n    \n    Controller: u[k] = -Kx̂[k]\n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \n    Separation Principle:\n        - Design LQR assuming full state available\n        - Design Kalman filter independently\n        - Combine: optimal for linear Gaussian systems\n        - Closed-loop poles = controller poles ∪ observer poles\n    \n    Args:\n        A: State matrix (nx, nx)\n        B: Input matrix (nx, nu)\n        C: Output matrix (ny, nx)\n        Q_state: LQR state cost (nx, nx)\n        R_control: LQR control cost (nu, nu)\n        Q_process: Process noise covariance (nx, nx)\n        R_measurement: Measurement noise covariance (ny, ny)\n        N: Cross-coupling (nx, nu), optional\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        LQGResult with:\n            - control_gain: LQR gain K (nu, nx)\n            - estimator_gain: Kalman gain L (nx, ny)\n            - control_cost_to_go: Controller Riccati P_c\n            - estimation_error_covariance: Estimator Riccati P_e\n            - separation_verified: bool\n            - closed_loop_stable: bool\n            - controller_eigenvalues: eig(A - BK)\n            - estimator_eigenvalues: eig(A - LC)\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.9]])\n        &gt;&gt;&gt; B = np.array([[0], [0.1]])\n        &gt;&gt;&gt; C = np.array([[1, 0]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; lqg = design_lqg(\n        ...     A, B, C,\n        ...     Q_state=np.diag([10, 1]),\n        ...     R_control=np.array([[0.1]]),\n        ...     Q_process=0.01*np.eye(2),\n        ...     R_measurement=np.array([[0.1]])\n        ... )\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; K = lqg['control_gain']\n        &gt;&gt;&gt; L = lqg['estimator_gain']\n        &gt;&gt;&gt; print(f\"LQG stable: {lqg['closed_loop_stable']}\")\n    \"\"\"\n2. System Analysis Functions\ndef analyze_stability(\n    A: StateMatrix,\n    system_type: str = \"continuous\",\n    backend: Backend = \"numpy\"\n) -&gt; StabilityInfo:\n    \"\"\"\n    Analyze system stability via eigenvalue placement.\n    \n    Stability Criteria:\n        Continuous: All Re(λ) &lt; 0 (left half-plane)\n        Discrete:   All |λ| &lt; 1 (inside unit circle)\n    \n    Marginal Stability:\n        Continuous: max Re(λ) ≈ 0\n        Discrete:   max |λ| ≈ 1\n    \n    Args:\n        A: State matrix (nx, nx)\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        StabilityInfo with:\n            - eigenvalues: Complex eigenvalues of A\n            - magnitudes: |λ| for each eigenvalue\n            - max_magnitude: max |λ| (spectral radius)\n            - spectral_radius: Same as max_magnitude\n            - is_stable: Asymptotic stability\n            - is_marginally_stable: On boundary\n            - is_unstable: At least one unstable mode\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; stability = analyze_stability(A, system_type='continuous')\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; if stability['is_stable']:\n        ...     print(f\"Stable! Eigenvalues: {stability['eigenvalues']}\")\n        ...     print(f\"Spectral radius: {stability['spectral_radius']:.3f}\")\n    \"\"\"\ndef analyze_controllability(\n    A: StateMatrix,\n    B: InputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ControllabilityInfo:\n    \"\"\"\n    Test system controllability via rank condition.\n    \n    Controllability Test:\n        rank(C) = nx where C = [B, AB, A²B, ..., Aⁿ⁻¹B]\n    \n    Interpretation:\n        - Controllable: All states can be driven to any value\n        - Uncontrollable: Some states cannot be influenced by control\n    \n    Args:\n        A: State matrix (nx, nx)\n        B: Input matrix (nx, nu)\n        backend: Computational backend\n    \n    Returns:\n        ControllabilityInfo with:\n            - controllability_matrix: C = [B AB ... Aⁿ⁻¹B] (nx, nx*nu)\n            - rank: Rank of controllability matrix\n            - is_controllable: rank == nx\n            - uncontrollable_modes: Eigenvalues of uncontrollable subsystem\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; B = np.array([[0], [1]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; ctrl = analyze_controllability(A, B)\n        &gt;&gt;&gt; print(f\"Controllable: {ctrl['is_controllable']}\")\n        &gt;&gt;&gt; print(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n    \"\"\"\ndef analyze_observability(\n    A: StateMatrix,\n    C: OutputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ObservabilityInfo:\n    \"\"\"\n    Test system observability via rank condition.\n    \n    Observability Test:\n        rank(O) = nx where O = [C; CA; CA²; ...; CAⁿ⁻¹]\n    \n    Interpretation:\n        - Observable: Initial state can be determined from outputs\n        - Unobservable: Some states hidden from measurements\n    \n    Args:\n        A: State matrix (nx, nx)\n        C: Output matrix (ny, nx)\n        backend: Computational backend\n    \n    Returns:\n        ObservabilityInfo with:\n            - observability_matrix: O = [C; CA; ...] (nx*ny, nx)\n            - rank: Rank of observability matrix\n            - is_observable: rank == nx\n            - unobservable_modes: Eigenvalues of unobservable subsystem\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; C = np.array([[1, 0]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; obs = analyze_observability(A, C)\n        &gt;&gt;&gt; print(f\"Observable: {obs['is_observable']}\")\n        &gt;&gt;&gt; print(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n    \"\"\"\nKey Design Features:\n\nPure functions - No state, no side effects\nScipy-like API - Familiar interface for control engineers\nBackend agnostic - Internal conversion to/from NumPy\nComprehensive validation - Dimension checks, positive-definiteness\nRiccati solvers - scipy.linalg.solve_continuous_are/solve_discrete_are\nError handling - Clear exceptions for infeasible problems\nTypedDict returns - Type-safe structured results\n\nInternal Utilities:\ndef _to_numpy(arr, backend: Backend) -&gt; np.ndarray:\n    \"\"\"Convert from any backend to NumPy for scipy.\"\"\"\n\ndef _from_numpy(arr: np.ndarray, backend: Backend):\n    \"\"\"Convert from NumPy back to original backend.\"\"\"\n\n\n\n\n\n\n\nFile: control_synthesis.py (388 lines)\nPurpose: Thin wrapper for control design algorithms\nDesign Philosophy:\n\nComposition not inheritance - Utility held by system, not base class\nNo state - Only stores backend setting from parent\nNo caching - Delegates immediately to pure functions\nClean API - Methods match control theory terminology\n\nArchitecture:\nclass ControlSynthesis:\n    \"\"\"\n    Control synthesis wrapper for system composition.\n    \n    Thin wrapper that routes to pure control design functions while\n    maintaining backend consistency with parent system.\n    \n    Attributes:\n        backend: Backend setting from parent system\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def design_lqr(self, A, B, Q, R, N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqr()\"\"\"\n        from src.control.classical_control_functions import design_lqr\n        return design_lqr(A, B, Q, R, N, system_type, self.backend)\n    \n    def design_kalman(self, A, C, Q, R, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_kalman_filter()\"\"\"\n        from src.control.classical_control_functions import design_kalman_filter\n        return design_kalman_filter(A, C, Q, R, system_type, self.backend)\n    \n    def design_lqg(self, A, B, C, Q_state, R_control, Q_process, R_measurement, N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqg()\"\"\"\n        from src.control.classical_control_functions import design_lqg\n        return design_lqg(A, B, C, Q_state, R_control, Q_process, R_measurement, N, system_type, self.backend)\nIntegration with Systems:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef control(self) -&gt; ControlSynthesis:\n    \"\"\"Access control synthesis utilities.\"\"\"\n    if not hasattr(self, '_control_synthesis'):\n        from src.control.control_synthesis import ControlSynthesis\n        self._control_synthesis = ControlSynthesis(backend=self._default_backend)\n    return self._control_synthesis\nUsage Pattern:\n# Via system composition (typical)\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\n\n# Design controller - backend handled automatically\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = result['gain']\n\n# Control law\nu = -K @ (x - x_eq)\n\n\n\n\nFile: system_analysis.py (431 lines)\nPurpose: Thin wrapper for system analysis algorithms\nDesign Philosophy:\n\nIdentical to ControlSynthesis - Same thin wrapper pattern\nSeparation of concerns - Analysis separate from synthesis\nConsistent interface - Matches control_synthesis.py design\n\nArchitecture:\nclass SystemAnalysis:\n    \"\"\"\n    System analysis wrapper for composition.\n    \n    Thin wrapper that routes to pure system analysis functions while\n    maintaining backend consistency with parent system.\n    \n    Attributes:\n        backend: Backend setting from parent system\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def stability(self, A, system_type='continuous'):\n        \"\"\"Route to classical_control_functions.analyze_stability()\"\"\"\n        from src.control.classical_control_functions import analyze_stability\n        return analyze_stability(A, system_type, self.backend)\n    \n    def controllability(self, A, B):\n        \"\"\"Route to classical_control_functions.analyze_controllability()\"\"\"\n        from src.control.classical_control_functions import analyze_controllability\n        return analyze_controllability(A, B, self.backend)\n    \n    def observability(self, A, C):\n        \"\"\"Route to classical_control_functions.analyze_observability()\"\"\"\n        from src.control.classical_control_functions import analyze_observability\n        return analyze_observability(A, C, self.backend)\nIntegration with Systems:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef analysis(self) -&gt; SystemAnalysis:\n    \"\"\"Access system analysis utilities.\"\"\"\n    if not hasattr(self, '_system_analysis'):\n        from src.control.system_analysis import SystemAnalysis\n        self._system_analysis = SystemAnalysis(backend=self._default_backend)\n    return self._system_analysis\nUsage Pattern:\n# Via system composition (typical)\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Measure position\n\n# Analyze system properties\nstability = system.analysis.stability(A, system_type='continuous')\ncontrollability = system.analysis.controllability(A, B)\nobservability = system.analysis.observability(A, C)\n\n# Check results\nif stability['is_stable']:\n    print(f\"Stable with margin: {stability['stability_margin']:.3f}\")\n\nif controllability['is_controllable'] and observability['is_observable']:\n    print(\"System is minimal (controllable and observable)\")\n\n\n\n\n\n\n\nFile: control_classical.py (542 lines)\nPurpose: TypedDict result types for control algorithms\nSee Type_System_Architecture.md for complete documentation.\nKey Types:\n\nLQRResult - LQR controller design result\nKalmanFilterResult - Kalman filter design result\nLQGResult - LQG controller design result\nStabilityInfo - Stability analysis result\nControllabilityInfo - Controllability test result\nObservabilityInfo - Observability test result\n\n\n\n\n\n\n\n\n\nWhy this architecture?\n# ANTI-PATTERN: Methods on system class (violates SRP)\nclass ContinuousSystemBase:\n    def design_lqr(self, Q, R):\n        # 200+ lines of LQR implementation\n        # Mixes system concerns with control algorithm\n        pass\n\n# GOOD PATTERN: Pure function + composition\n# Pure function (classical_control_functions.py)\ndef design_lqr(A, B, Q, R, system_type, backend):\n    \"\"\"Stateless, testable, reusable.\"\"\"\n    # 200+ lines focused solely on LQR algorithm\n    return LQRResult(...)\n\n# Thin wrapper (control_synthesis.py)\nclass ControlSynthesis:\n    def design_lqr(self, A, B, Q, R, system_type):\n        return design_lqr(A, B, Q, R, system_type, self.backend)\n\n# System integration (continuous_system_base.py)\n@property\ndef control(self) -&gt; ControlSynthesis:\n    return ControlSynthesis(backend=self._default_backend)\nBenefits:\n\n✅ Single Responsibility - Pure functions do one thing\n✅ Testability - Functions easy to unit test\n✅ Reusability - Functions work standalone\n✅ Composition - System uses utilities, doesn’t inherit them\n✅ Maintainability - Changes isolated to function layer\n\n\n\n\ndef design_lqr(..., backend: Backend):\n    \"\"\"Works with NumPy, PyTorch, JAX transparently.\"\"\"\n    \n    # Convert to NumPy for scipy\n    A_np = _to_numpy(A, backend)\n    B_np = _to_numpy(B, backend)\n    \n    # Solve in NumPy (scipy.linalg)\n    P = solve_continuous_are(A_np, B_np, Q_np, R_np)\n    K = np.linalg.solve(R_np, B_np.T @ P)\n    \n    # Convert back to original backend\n    K_result = _from_numpy(K, backend)\n    P_result = _from_numpy(P, backend)\n    \n    return LQRResult(gain=K_result, cost_to_go=P_result, ...)\n\n\n\n# All functions return structured TypedDict\nresult: LQRResult = design_lqr(A, B, Q, R, system_type='continuous')\n\n# IDE autocomplete knows all fields\nK = result['gain']                    # ✓ Valid\nP = result['cost_to_go']              # ✓ Valid\neigs = result['closed_loop_eigenvalues']  # ✓ Valid\nbad = result['nonexistent_key']       # ✗ Type error!\n\n# Type checking prevents errors\ndef apply_control(result: LQRResult) -&gt; np.ndarray:\n    return result['gain']  # ✓ Type checker verifies\n\n\n\n# Same function handles both continuous and discrete\ndef design_lqr(A, B, Q, R, N=None, system_type='discrete', backend='numpy'):\n    \"\"\"Unified interface - system_type selects algorithm.\"\"\"\n    \n    if system_type == 'continuous':\n        # Continuous-time algebraic Riccati equation\n        P = solve_continuous_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R, B.T @ P)\n    elif system_type == 'discrete':\n        # Discrete-time algebraic Riccati equation\n        P = solve_discrete_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R + B.T @ P @ B, B.T @ P @ A)\n    else:\n        raise ValueError(f\"Invalid system_type: {system_type}\")\n    \n    # Rest of implementation identical\n    closed_loop_eigs = np.linalg.eigvals(A - B @ K)\n    \n    return LQRResult(gain=K, cost_to_go=P, ...)\nBenefits:\n\n✅ Single function for both cases\n✅ Less code duplication\n✅ Easier to maintain\n✅ Consistent API across system types\n\n\n\n\n\n\n\n\nContinuous-Time LQR:\nCost Functional:\nJ = ∫₀^∞ (x'Qx + u'Ru + 2x'Nu) dt\nAlgebraic Riccati Equation (ARE):\nA'P + PA - PBR⁻¹B'P + Q - N'R⁻¹N = 0\nOptimal Gain:\nK = R⁻¹(B'P + N')\nClosed-Loop Dynamics:\nẋ = (A - BK)x\nDiscrete-Time LQR:\nCost Functional:\nJ = Σₖ₌₀^∞ (x[k]'Qx[k] + u[k]'Ru[k] + 2x[k]'Nu[k])\nDiscrete ARE:\nP = A'PA - (A'PB + N)(R + B'PB)⁻¹(B'PA + N') + Q\nOptimal Gain:\nK = (R + B'PB)⁻¹(B'PA + N')\nClosed-Loop Dynamics:\nx[k+1] = (A - BK)x[k]\n\n\n\nSystem Model:\nx[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0, Q)\ny[k] = Cx[k] + v[k],            v ~ N(0, R)\nEstimator:\nx̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\nKalman Gain:\nL = APC'(CPC' + R)⁻¹\nError Covariance Riccati Equation:\nP = A(P - PC'(CPC' + R)⁻¹CP)A' + Q\nError Dynamics:\ne[k+1] = (A - LC)e[k] + w[k] - Lv[k]\n\n\n\nSeparation Principle:\n\nDesign LQR assuming full state feedback: u = -Kx\nDesign Kalman filter for state estimation: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\nCombine: u = -Kx̂ (certainty equivalence)\n\nClosed-Loop System:\n[x[k+1]]   [A - BK    BK  ] [x[k] ]   [w[k]]\n[e[k+1]] = [  0     A - LC] [e[k] ] + [w[k] - Lv[k]]\nEigenvalues:\n\nController poles: eig(A - BK)\nObserver poles: eig(A - LC)\nCombined poles: eig(A - BK) ∪ eig(A - LC)\n\nOptimality:\n\nOptimal for linear systems with Gaussian noise\nMinimizes steady-state error covariance\nSeparation holds for linear systems\n\n\n\n\n\n\n\n\nfrom src.systems.examples import Pendulum\nimport numpy as np\n\n# 1. Create system\nsystem = Pendulum(m=1.0, l=0.5, g=9.81, b=0.1)\n\n# 2. Define equilibrium (upright position)\nx_eq = np.array([np.pi, 0])  # [theta, omega]\nu_eq = np.zeros(1)\n\n# 3. Linearize at equilibrium\nA, B = system.linearize(x_eq, u_eq)\n\n# 4. Design LQR controller\nQ = np.diag([10, 1])  # Penalize angle more than velocity\nR = np.array([[0.1]])  # Small control cost\n\nresult = system.control.design_lqr(\n    A, B, Q, R,\n    system_type='continuous'\n)\n\n# 5. Extract gain and verify stability\nK = result['gain']\nprint(f\"LQR gain: {K}\")\nprint(f\"Closed-loop eigenvalues: {result['closed_loop_eigenvalues']}\")\nprint(f\"Stable: {np.all(np.real(result['closed_loop_eigenvalues']) &lt; 0)}\")\n\n# 6. Implement controller\ndef lqr_controller(x, t):\n    return -K @ (x - x_eq)\n\n# 7. Simulate closed-loop\nresult_sim = system.simulate(\n    x0=np.array([np.pi + 0.2, 0]),  # Start near upright\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\n# 1. Same system and linearization\nA, B = system.linearize(x_eq, u_eq)\n\n# 2. Define measurement model (measure angle only)\nC = np.array([[1, 0]])  # Observe theta, not omega\n\n# 3. Define noise covariances\nQ_process = 0.01 * np.eye(2)  # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# 4. Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 5. Extract gain\nL = kalman['gain']\nprint(f\"Kalman gain: {L}\")\nprint(f\"Observer eigenvalues: {kalman['observer_eigenvalues']}\")\n\n# 6. Implement estimator\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Prediction\n    x_hat_pred = A @ x_hat + B @ u[k]\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + np.random.randn() * np.sqrt(0.1)\n    innovation = y_meas - C @ x_hat_pred\n    x_hat = x_hat_pred + L @ innovation\n\n\n\n# 1. Define all matrices\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Partial state measurement\n\n# 2. Design weights\nQ_state = np.diag([10, 1])    # LQR state cost\nR_control = np.array([[0.1]])  # LQR control cost\nQ_process = 0.01 * np.eye(2)  # Kalman process noise\nR_measurement = np.array([[0.1]])  # Kalman measurement noise\n\n# 3. Design LQG\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state, R_control,\n    Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 4. Extract both gains\nK = lqg['control_gain']\nL = lqg['estimator_gain']\n\nprint(f\"LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"Separation verified: {lqg['separation_verified']}\")\n\n# 5. Implement LQG controller\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Control (certainty equivalence)\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Prediction\n    x_hat = A @ x_hat + B @ u[k]\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + measurement_noise[k]\n    innovation = y_meas - C @ x_hat\n    x_hat = x_hat + L @ innovation\n\n\n\n# 1. Linearize system\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])\n\n# 2. Check stability\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Stable: {stability['is_stable']}\")\nprint(f\"Eigenvalues: {stability['eigenvalues']}\")\nprint(f\"Spectral radius: {stability['spectral_radius']:.3f}\")\n\n# 3. Check controllability\nctrl = system.analysis.controllability(A, B)\nprint(f\"Controllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif not ctrl['is_controllable']:\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 4. Check observability\nobs = system.analysis.observability(A, C)\nprint(f\"Observable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\n# 5. Verify conditions for LQR/Kalman\nif ctrl['is_controllable']:\n    print(\"✓ Can design LQR controller\")\nelse:\n    print(\"✗ Cannot design LQR - system not controllable\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"✓ System is minimal - can design LQG controller\")\n\n\n\n\n\nPure Functional Core - Stateless algorithms, easy to test\nThin Wrappers - Minimal composition layer, no business logic\nType Safety - TypedDict results throughout\nBackend Agnostic - NumPy/PyTorch/JAX transparent\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Correct implementation of classical control\nClean Integration - system.control and system.analysis APIs\nUnified Interface - Single function for continuous/discrete\nComprehensive - LQR, Kalman, LQG, stability, controllability, observability\nScipy-like - Familiar API for control engineers\n\nThis control framework is the foundation for classical control theory in ControlDESymulation!"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#overview",
    "href": "api/control_framework/Control_Framework_Architecture.html#overview",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "The Control Framework provides classical control theory algorithms for analysis and synthesis of dynamical systems. It consists of 3 core modules totaling ~1,786 lines organized into a clean 2-layer architecture: pure stateless functions and thin composition wrappers."
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#architecture-philosophy",
    "href": "api/control_framework/Control_Framework_Architecture.html#architecture-philosophy",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "Functional Design with Composition - The control framework enables:\n\nPure Functions - Stateless algorithms like scipy (design_lqr, analyze_stability)\nThin Wrappers - Minimal composition layer for system integration\nType Safety - TypedDict results for all algorithms\nBackend Consistency - Automatic backend handling from parent system\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Implements classical control theory correctly\nSystem Integration - Clean system.control and system.analysis APIs\n\n# Pure functions - stateless, reusable\nresult = design_lqr(A, B, Q, R, system_type='continuous')\n\n# Composition wrappers - integrate with systems\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#framework-layers",
    "href": "api/control_framework/Control_Framework_Architecture.html#framework-layers",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                         │\n│              (ContinuousSystemBase, DiscreteSystemBase)     │\n│                                                              │\n│  system.control   ──────► ControlSynthesis (388 lines)     │\n│  system.analysis  ──────► SystemAnalysis   (431 lines)     │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ delegates to\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│              PURE FUNCTION LAYER                            │\n│          classical_control_functions.py (967 lines)         │\n│                                                              │\n│  Control Design:          System Analysis:                  │\n│  • design_lqr()          • analyze_stability()             │\n│  • design_kalman()       • analyze_controllability()       │\n│  • design_lqg()          • analyze_observability()         │\n│                                                              │\n│  All functions are stateless, pure, backend-agnostic       │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ returns\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   TYPE LAYER                                │\n│             control_classical.py (542 lines)                │\n│                                                              │\n│  • LQRResult           • StabilityInfo                      │\n│  • KalmanFilterResult  • ControllabilityInfo                │\n│  • LQGResult           • ObservabilityInfo                  │\n└────────────────────────────────────────────────────────────┘"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#module-breakdown",
    "href": "api/control_framework/Control_Framework_Architecture.html#module-breakdown",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "File: classical_control_functions.py (967 lines)\nPurpose: Stateless algorithms for control design and system analysis\nDesign Philosophy:\n\nPure functions (no side effects, no state)\nWorks like scipy - takes matrices in, returns TypedDict\nBackend conversion handled internally\nMathematical correctness guaranteed\nComprehensive error checking\n\nCategories:\n1. Control Design Functions\ndef design_lqr(\n    A: StateMatrix,\n    B: InputMatrix,\n    Q: StateMatrix,\n    R: InputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQRResult:\n    \"\"\"\n    Design Linear Quadratic Regulator (LQR) controller.\n    \n    Unified interface for continuous and discrete LQR.\n    \n    Mathematical Background:\n        Continuous: Minimize J = ∫₀^∞ (x'Qx + u'Ru + 2x'Nu) dt\n        Discrete:   Minimize J = Σₖ₌₀^∞ (x'Qx + u'Ru + 2x'Nu)\n    \n    Solution via Algebraic Riccati Equation (ARE):\n        Continuous: A'P + PA - PBR⁻¹B'P + Q = 0\n        Discrete:   P = A'PA - A'PB(R + B'PB)⁻¹B'PA + Q\n    \n    Optimal Gain:\n        Continuous: K = R⁻¹B'P\n        Discrete:   K = (R + B'PB)⁻¹B'PA\n    \n    Args:\n        A: State matrix (nx, nx)\n        B: Input matrix (nx, nu)\n        Q: State cost matrix (nx, nx), Q ≥ 0, (Q,A) detectable\n        R: Control cost matrix (nu, nu), R &gt; 0\n        N: Cross-coupling matrix (nx, nu), default None\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        LQRResult with:\n            - gain: Optimal feedback gain K (nu, nx)\n            - cost_to_go: Riccati solution P (nx, nx)\n            - closed_loop_eigenvalues: eig(A - BK)\n            - stability_margin: Stability robustness measure\n    \n    Raises:\n        ValueError: If Q, R dimensions incompatible\n        LinAlgError: If Riccati equation has no stabilizing solution\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; B = np.array([[0], [1]])\n        &gt;&gt;&gt; Q = np.diag([10, 1])\n        &gt;&gt;&gt; R = np.array([[0.1]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; result = design_lqr(A, B, Q, R, system_type='continuous')\n        &gt;&gt;&gt; K = result['gain']\n        &gt;&gt;&gt; A_cl = A - B @ K\n        &gt;&gt;&gt; print(f\"Closed-loop eigenvalues: {result['closed_loop_eigenvalues']}\")\n    \"\"\"\ndef design_kalman_filter(\n    A: StateMatrix,\n    C: OutputMatrix,\n    Q: StateMatrix,\n    R: OutputMatrix,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; KalmanFilterResult:\n    \"\"\"\n    Design Kalman filter for optimal state estimation.\n    \n    System Model:\n        x[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0, Q)\n        y[k] = Cx[k] + v[k],            v ~ N(0, R)\n    \n    Estimator Dynamics:\n        x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \n    Optimal Gain:\n        L = APC'(CPC' + R)⁻¹\n    \n    Riccati Equation:\n        P = A(P - PC'(CPC'+R)⁻¹CP)A' + Q\n    \n    Args:\n        A: State matrix (nx, nx)\n        C: Output matrix (ny, nx)\n        Q: Process noise covariance (nx, nx), Q ≥ 0\n        R: Measurement noise covariance (ny, ny), R &gt; 0\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        KalmanFilterResult with:\n            - gain: Kalman gain L (nx, ny)\n            - error_covariance: Steady-state P (nx, nx)\n            - innovation_covariance: S = CPC' + R (ny, ny)\n            - observer_eigenvalues: eig(A - LC)\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.9]])\n        &gt;&gt;&gt; C = np.array([[1, 0]])\n        &gt;&gt;&gt; Q_proc = 0.01 * np.eye(2)\n        &gt;&gt;&gt; R_meas = np.array([[0.1]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; kalman = design_kalman_filter(A, C, Q_proc, R_meas)\n        &gt;&gt;&gt; L = kalman['gain']\n        &gt;&gt;&gt; print(f\"Observer poles: {kalman['observer_eigenvalues']}\")\n    \"\"\"\ndef design_lqg(\n    A: StateMatrix,\n    B: InputMatrix,\n    C: OutputMatrix,\n    Q_state: StateMatrix,\n    R_control: InputMatrix,\n    Q_process: StateMatrix,\n    R_measurement: OutputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQGResult:\n    \"\"\"\n    Design Linear Quadratic Gaussian (LQG) controller.\n    \n    Combines LQR (optimal control) with Kalman filter (optimal estimation)\n    via the separation principle.\n    \n    Controller: u[k] = -Kx̂[k]\n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \n    Separation Principle:\n        - Design LQR assuming full state available\n        - Design Kalman filter independently\n        - Combine: optimal for linear Gaussian systems\n        - Closed-loop poles = controller poles ∪ observer poles\n    \n    Args:\n        A: State matrix (nx, nx)\n        B: Input matrix (nx, nu)\n        C: Output matrix (ny, nx)\n        Q_state: LQR state cost (nx, nx)\n        R_control: LQR control cost (nu, nu)\n        Q_process: Process noise covariance (nx, nx)\n        R_measurement: Measurement noise covariance (ny, ny)\n        N: Cross-coupling (nx, nu), optional\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        LQGResult with:\n            - control_gain: LQR gain K (nu, nx)\n            - estimator_gain: Kalman gain L (nx, ny)\n            - control_cost_to_go: Controller Riccati P_c\n            - estimation_error_covariance: Estimator Riccati P_e\n            - separation_verified: bool\n            - closed_loop_stable: bool\n            - controller_eigenvalues: eig(A - BK)\n            - estimator_eigenvalues: eig(A - LC)\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.9]])\n        &gt;&gt;&gt; B = np.array([[0], [0.1]])\n        &gt;&gt;&gt; C = np.array([[1, 0]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; lqg = design_lqg(\n        ...     A, B, C,\n        ...     Q_state=np.diag([10, 1]),\n        ...     R_control=np.array([[0.1]]),\n        ...     Q_process=0.01*np.eye(2),\n        ...     R_measurement=np.array([[0.1]])\n        ... )\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; K = lqg['control_gain']\n        &gt;&gt;&gt; L = lqg['estimator_gain']\n        &gt;&gt;&gt; print(f\"LQG stable: {lqg['closed_loop_stable']}\")\n    \"\"\"\n2. System Analysis Functions\ndef analyze_stability(\n    A: StateMatrix,\n    system_type: str = \"continuous\",\n    backend: Backend = \"numpy\"\n) -&gt; StabilityInfo:\n    \"\"\"\n    Analyze system stability via eigenvalue placement.\n    \n    Stability Criteria:\n        Continuous: All Re(λ) &lt; 0 (left half-plane)\n        Discrete:   All |λ| &lt; 1 (inside unit circle)\n    \n    Marginal Stability:\n        Continuous: max Re(λ) ≈ 0\n        Discrete:   max |λ| ≈ 1\n    \n    Args:\n        A: State matrix (nx, nx)\n        system_type: 'continuous' or 'discrete'\n        backend: Computational backend\n    \n    Returns:\n        StabilityInfo with:\n            - eigenvalues: Complex eigenvalues of A\n            - magnitudes: |λ| for each eigenvalue\n            - max_magnitude: max |λ| (spectral radius)\n            - spectral_radius: Same as max_magnitude\n            - is_stable: Asymptotic stability\n            - is_marginally_stable: On boundary\n            - is_unstable: At least one unstable mode\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; stability = analyze_stability(A, system_type='continuous')\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; if stability['is_stable']:\n        ...     print(f\"Stable! Eigenvalues: {stability['eigenvalues']}\")\n        ...     print(f\"Spectral radius: {stability['spectral_radius']:.3f}\")\n    \"\"\"\ndef analyze_controllability(\n    A: StateMatrix,\n    B: InputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ControllabilityInfo:\n    \"\"\"\n    Test system controllability via rank condition.\n    \n    Controllability Test:\n        rank(C) = nx where C = [B, AB, A²B, ..., Aⁿ⁻¹B]\n    \n    Interpretation:\n        - Controllable: All states can be driven to any value\n        - Uncontrollable: Some states cannot be influenced by control\n    \n    Args:\n        A: State matrix (nx, nx)\n        B: Input matrix (nx, nu)\n        backend: Computational backend\n    \n    Returns:\n        ControllabilityInfo with:\n            - controllability_matrix: C = [B AB ... Aⁿ⁻¹B] (nx, nx*nu)\n            - rank: Rank of controllability matrix\n            - is_controllable: rank == nx\n            - uncontrollable_modes: Eigenvalues of uncontrollable subsystem\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; B = np.array([[0], [1]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; ctrl = analyze_controllability(A, B)\n        &gt;&gt;&gt; print(f\"Controllable: {ctrl['is_controllable']}\")\n        &gt;&gt;&gt; print(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n    \"\"\"\ndef analyze_observability(\n    A: StateMatrix,\n    C: OutputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ObservabilityInfo:\n    \"\"\"\n    Test system observability via rank condition.\n    \n    Observability Test:\n        rank(O) = nx where O = [C; CA; CA²; ...; CAⁿ⁻¹]\n    \n    Interpretation:\n        - Observable: Initial state can be determined from outputs\n        - Unobservable: Some states hidden from measurements\n    \n    Args:\n        A: State matrix (nx, nx)\n        C: Output matrix (ny, nx)\n        backend: Computational backend\n    \n    Returns:\n        ObservabilityInfo with:\n            - observability_matrix: O = [C; CA; ...] (nx*ny, nx)\n            - rank: Rank of observability matrix\n            - is_observable: rank == nx\n            - unobservable_modes: Eigenvalues of unobservable subsystem\n    \n    Examples:\n        &gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n        &gt;&gt;&gt; C = np.array([[1, 0]])\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; obs = analyze_observability(A, C)\n        &gt;&gt;&gt; print(f\"Observable: {obs['is_observable']}\")\n        &gt;&gt;&gt; print(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n    \"\"\"\nKey Design Features:\n\nPure functions - No state, no side effects\nScipy-like API - Familiar interface for control engineers\nBackend agnostic - Internal conversion to/from NumPy\nComprehensive validation - Dimension checks, positive-definiteness\nRiccati solvers - scipy.linalg.solve_continuous_are/solve_discrete_are\nError handling - Clear exceptions for infeasible problems\nTypedDict returns - Type-safe structured results\n\nInternal Utilities:\ndef _to_numpy(arr, backend: Backend) -&gt; np.ndarray:\n    \"\"\"Convert from any backend to NumPy for scipy.\"\"\"\n\ndef _from_numpy(arr: np.ndarray, backend: Backend):\n    \"\"\"Convert from NumPy back to original backend.\"\"\"\n\n\n\n\n\n\n\nFile: control_synthesis.py (388 lines)\nPurpose: Thin wrapper for control design algorithms\nDesign Philosophy:\n\nComposition not inheritance - Utility held by system, not base class\nNo state - Only stores backend setting from parent\nNo caching - Delegates immediately to pure functions\nClean API - Methods match control theory terminology\n\nArchitecture:\nclass ControlSynthesis:\n    \"\"\"\n    Control synthesis wrapper for system composition.\n    \n    Thin wrapper that routes to pure control design functions while\n    maintaining backend consistency with parent system.\n    \n    Attributes:\n        backend: Backend setting from parent system\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def design_lqr(self, A, B, Q, R, N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqr()\"\"\"\n        from src.control.classical_control_functions import design_lqr\n        return design_lqr(A, B, Q, R, N, system_type, self.backend)\n    \n    def design_kalman(self, A, C, Q, R, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_kalman_filter()\"\"\"\n        from src.control.classical_control_functions import design_kalman_filter\n        return design_kalman_filter(A, C, Q, R, system_type, self.backend)\n    \n    def design_lqg(self, A, B, C, Q_state, R_control, Q_process, R_measurement, N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqg()\"\"\"\n        from src.control.classical_control_functions import design_lqg\n        return design_lqg(A, B, C, Q_state, R_control, Q_process, R_measurement, N, system_type, self.backend)\nIntegration with Systems:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef control(self) -&gt; ControlSynthesis:\n    \"\"\"Access control synthesis utilities.\"\"\"\n    if not hasattr(self, '_control_synthesis'):\n        from src.control.control_synthesis import ControlSynthesis\n        self._control_synthesis = ControlSynthesis(backend=self._default_backend)\n    return self._control_synthesis\nUsage Pattern:\n# Via system composition (typical)\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\n\n# Design controller - backend handled automatically\nresult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = result['gain']\n\n# Control law\nu = -K @ (x - x_eq)\n\n\n\n\nFile: system_analysis.py (431 lines)\nPurpose: Thin wrapper for system analysis algorithms\nDesign Philosophy:\n\nIdentical to ControlSynthesis - Same thin wrapper pattern\nSeparation of concerns - Analysis separate from synthesis\nConsistent interface - Matches control_synthesis.py design\n\nArchitecture:\nclass SystemAnalysis:\n    \"\"\"\n    System analysis wrapper for composition.\n    \n    Thin wrapper that routes to pure system analysis functions while\n    maintaining backend consistency with parent system.\n    \n    Attributes:\n        backend: Backend setting from parent system\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def stability(self, A, system_type='continuous'):\n        \"\"\"Route to classical_control_functions.analyze_stability()\"\"\"\n        from src.control.classical_control_functions import analyze_stability\n        return analyze_stability(A, system_type, self.backend)\n    \n    def controllability(self, A, B):\n        \"\"\"Route to classical_control_functions.analyze_controllability()\"\"\"\n        from src.control.classical_control_functions import analyze_controllability\n        return analyze_controllability(A, B, self.backend)\n    \n    def observability(self, A, C):\n        \"\"\"Route to classical_control_functions.analyze_observability()\"\"\"\n        from src.control.classical_control_functions import analyze_observability\n        return analyze_observability(A, C, self.backend)\nIntegration with Systems:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef analysis(self) -&gt; SystemAnalysis:\n    \"\"\"Access system analysis utilities.\"\"\"\n    if not hasattr(self, '_system_analysis'):\n        from src.control.system_analysis import SystemAnalysis\n        self._system_analysis = SystemAnalysis(backend=self._default_backend)\n    return self._system_analysis\nUsage Pattern:\n# Via system composition (typical)\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Measure position\n\n# Analyze system properties\nstability = system.analysis.stability(A, system_type='continuous')\ncontrollability = system.analysis.controllability(A, B)\nobservability = system.analysis.observability(A, C)\n\n# Check results\nif stability['is_stable']:\n    print(f\"Stable with margin: {stability['stability_margin']:.3f}\")\n\nif controllability['is_controllable'] and observability['is_observable']:\n    print(\"System is minimal (controllable and observable)\")\n\n\n\n\n\n\n\nFile: control_classical.py (542 lines)\nPurpose: TypedDict result types for control algorithms\nSee Type_System_Architecture.md for complete documentation.\nKey Types:\n\nLQRResult - LQR controller design result\nKalmanFilterResult - Kalman filter design result\nLQGResult - LQG controller design result\nStabilityInfo - Stability analysis result\nControllabilityInfo - Controllability test result\nObservabilityInfo - Observability test result"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#design-patterns",
    "href": "api/control_framework/Control_Framework_Architecture.html#design-patterns",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "Why this architecture?\n# ANTI-PATTERN: Methods on system class (violates SRP)\nclass ContinuousSystemBase:\n    def design_lqr(self, Q, R):\n        # 200+ lines of LQR implementation\n        # Mixes system concerns with control algorithm\n        pass\n\n# GOOD PATTERN: Pure function + composition\n# Pure function (classical_control_functions.py)\ndef design_lqr(A, B, Q, R, system_type, backend):\n    \"\"\"Stateless, testable, reusable.\"\"\"\n    # 200+ lines focused solely on LQR algorithm\n    return LQRResult(...)\n\n# Thin wrapper (control_synthesis.py)\nclass ControlSynthesis:\n    def design_lqr(self, A, B, Q, R, system_type):\n        return design_lqr(A, B, Q, R, system_type, self.backend)\n\n# System integration (continuous_system_base.py)\n@property\ndef control(self) -&gt; ControlSynthesis:\n    return ControlSynthesis(backend=self._default_backend)\nBenefits:\n\n✅ Single Responsibility - Pure functions do one thing\n✅ Testability - Functions easy to unit test\n✅ Reusability - Functions work standalone\n✅ Composition - System uses utilities, doesn’t inherit them\n✅ Maintainability - Changes isolated to function layer\n\n\n\n\ndef design_lqr(..., backend: Backend):\n    \"\"\"Works with NumPy, PyTorch, JAX transparently.\"\"\"\n    \n    # Convert to NumPy for scipy\n    A_np = _to_numpy(A, backend)\n    B_np = _to_numpy(B, backend)\n    \n    # Solve in NumPy (scipy.linalg)\n    P = solve_continuous_are(A_np, B_np, Q_np, R_np)\n    K = np.linalg.solve(R_np, B_np.T @ P)\n    \n    # Convert back to original backend\n    K_result = _from_numpy(K, backend)\n    P_result = _from_numpy(P, backend)\n    \n    return LQRResult(gain=K_result, cost_to_go=P_result, ...)\n\n\n\n# All functions return structured TypedDict\nresult: LQRResult = design_lqr(A, B, Q, R, system_type='continuous')\n\n# IDE autocomplete knows all fields\nK = result['gain']                    # ✓ Valid\nP = result['cost_to_go']              # ✓ Valid\neigs = result['closed_loop_eigenvalues']  # ✓ Valid\nbad = result['nonexistent_key']       # ✗ Type error!\n\n# Type checking prevents errors\ndef apply_control(result: LQRResult) -&gt; np.ndarray:\n    return result['gain']  # ✓ Type checker verifies\n\n\n\n# Same function handles both continuous and discrete\ndef design_lqr(A, B, Q, R, N=None, system_type='discrete', backend='numpy'):\n    \"\"\"Unified interface - system_type selects algorithm.\"\"\"\n    \n    if system_type == 'continuous':\n        # Continuous-time algebraic Riccati equation\n        P = solve_continuous_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R, B.T @ P)\n    elif system_type == 'discrete':\n        # Discrete-time algebraic Riccati equation\n        P = solve_discrete_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R + B.T @ P @ B, B.T @ P @ A)\n    else:\n        raise ValueError(f\"Invalid system_type: {system_type}\")\n    \n    # Rest of implementation identical\n    closed_loop_eigs = np.linalg.eigvals(A - B @ K)\n    \n    return LQRResult(gain=K, cost_to_go=P, ...)\nBenefits:\n\n✅ Single function for both cases\n✅ Less code duplication\n✅ Easier to maintain\n✅ Consistent API across system types"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#mathematical-algorithms",
    "href": "api/control_framework/Control_Framework_Architecture.html#mathematical-algorithms",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "Continuous-Time LQR:\nCost Functional:\nJ = ∫₀^∞ (x'Qx + u'Ru + 2x'Nu) dt\nAlgebraic Riccati Equation (ARE):\nA'P + PA - PBR⁻¹B'P + Q - N'R⁻¹N = 0\nOptimal Gain:\nK = R⁻¹(B'P + N')\nClosed-Loop Dynamics:\nẋ = (A - BK)x\nDiscrete-Time LQR:\nCost Functional:\nJ = Σₖ₌₀^∞ (x[k]'Qx[k] + u[k]'Ru[k] + 2x[k]'Nu[k])\nDiscrete ARE:\nP = A'PA - (A'PB + N)(R + B'PB)⁻¹(B'PA + N') + Q\nOptimal Gain:\nK = (R + B'PB)⁻¹(B'PA + N')\nClosed-Loop Dynamics:\nx[k+1] = (A - BK)x[k]\n\n\n\nSystem Model:\nx[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0, Q)\ny[k] = Cx[k] + v[k],            v ~ N(0, R)\nEstimator:\nx̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\nKalman Gain:\nL = APC'(CPC' + R)⁻¹\nError Covariance Riccati Equation:\nP = A(P - PC'(CPC' + R)⁻¹CP)A' + Q\nError Dynamics:\ne[k+1] = (A - LC)e[k] + w[k] - Lv[k]\n\n\n\nSeparation Principle:\n\nDesign LQR assuming full state feedback: u = -Kx\nDesign Kalman filter for state estimation: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\nCombine: u = -Kx̂ (certainty equivalence)\n\nClosed-Loop System:\n[x[k+1]]   [A - BK    BK  ] [x[k] ]   [w[k]]\n[e[k+1]] = [  0     A - LC] [e[k] ] + [w[k] - Lv[k]]\nEigenvalues:\n\nController poles: eig(A - BK)\nObserver poles: eig(A - LC)\nCombined poles: eig(A - BK) ∪ eig(A - LC)\n\nOptimality:\n\nOptimal for linear systems with Gaussian noise\nMinimizes steady-state error covariance\nSeparation holds for linear systems"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#usage-workflows",
    "href": "api/control_framework/Control_Framework_Architecture.html#usage-workflows",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "from src.systems.examples import Pendulum\nimport numpy as np\n\n# 1. Create system\nsystem = Pendulum(m=1.0, l=0.5, g=9.81, b=0.1)\n\n# 2. Define equilibrium (upright position)\nx_eq = np.array([np.pi, 0])  # [theta, omega]\nu_eq = np.zeros(1)\n\n# 3. Linearize at equilibrium\nA, B = system.linearize(x_eq, u_eq)\n\n# 4. Design LQR controller\nQ = np.diag([10, 1])  # Penalize angle more than velocity\nR = np.array([[0.1]])  # Small control cost\n\nresult = system.control.design_lqr(\n    A, B, Q, R,\n    system_type='continuous'\n)\n\n# 5. Extract gain and verify stability\nK = result['gain']\nprint(f\"LQR gain: {K}\")\nprint(f\"Closed-loop eigenvalues: {result['closed_loop_eigenvalues']}\")\nprint(f\"Stable: {np.all(np.real(result['closed_loop_eigenvalues']) &lt; 0)}\")\n\n# 6. Implement controller\ndef lqr_controller(x, t):\n    return -K @ (x - x_eq)\n\n# 7. Simulate closed-loop\nresult_sim = system.simulate(\n    x0=np.array([np.pi + 0.2, 0]),  # Start near upright\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\n# 1. Same system and linearization\nA, B = system.linearize(x_eq, u_eq)\n\n# 2. Define measurement model (measure angle only)\nC = np.array([[1, 0]])  # Observe theta, not omega\n\n# 3. Define noise covariances\nQ_process = 0.01 * np.eye(2)  # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# 4. Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 5. Extract gain\nL = kalman['gain']\nprint(f\"Kalman gain: {L}\")\nprint(f\"Observer eigenvalues: {kalman['observer_eigenvalues']}\")\n\n# 6. Implement estimator\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Prediction\n    x_hat_pred = A @ x_hat + B @ u[k]\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + np.random.randn() * np.sqrt(0.1)\n    innovation = y_meas - C @ x_hat_pred\n    x_hat = x_hat_pred + L @ innovation\n\n\n\n# 1. Define all matrices\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Partial state measurement\n\n# 2. Design weights\nQ_state = np.diag([10, 1])    # LQR state cost\nR_control = np.array([[0.1]])  # LQR control cost\nQ_process = 0.01 * np.eye(2)  # Kalman process noise\nR_measurement = np.array([[0.1]])  # Kalman measurement noise\n\n# 3. Design LQG\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state, R_control,\n    Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 4. Extract both gains\nK = lqg['control_gain']\nL = lqg['estimator_gain']\n\nprint(f\"LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"Separation verified: {lqg['separation_verified']}\")\n\n# 5. Implement LQG controller\nx_hat = np.zeros(2)\nfor k in range(N):\n    # Control (certainty equivalence)\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Prediction\n    x_hat = A @ x_hat + B @ u[k]\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + measurement_noise[k]\n    innovation = y_meas - C @ x_hat\n    x_hat = x_hat + L @ innovation\n\n\n\n# 1. Linearize system\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])\n\n# 2. Check stability\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Stable: {stability['is_stable']}\")\nprint(f\"Eigenvalues: {stability['eigenvalues']}\")\nprint(f\"Spectral radius: {stability['spectral_radius']:.3f}\")\n\n# 3. Check controllability\nctrl = system.analysis.controllability(A, B)\nprint(f\"Controllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif not ctrl['is_controllable']:\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 4. Check observability\nobs = system.analysis.observability(A, C)\nprint(f\"Observable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\n# 5. Verify conditions for LQR/Kalman\nif ctrl['is_controllable']:\n    print(\"✓ Can design LQR controller\")\nelse:\n    print(\"✗ Cannot design LQR - system not controllable\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"✓ System is minimal - can design LQG controller\")"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#file-size-summary",
    "href": "api/control_framework/Control_Framework_Architecture.html#file-size-summary",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "Module\nLines\nPurpose\n\n\n\n\nclassical_control_functions.py\n967\nPure stateless algorithms\n\n\ncontrol_synthesis.py\n388\nControl design wrapper\n\n\nsystem_analysis.py\n431\nSystem analysis wrapper\n\n\nTOTAL\n1,786\nComplete framework\n\n\n\nTypes: control_classical.py (542 lines) - documented in Type System"
  },
  {
    "objectID": "api/control_framework/Control_Framework_Architecture.html#key-strengths",
    "href": "api/control_framework/Control_Framework_Architecture.html#key-strengths",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "Pure Functional Core - Stateless algorithms, easy to test\nThin Wrappers - Minimal composition layer, no business logic\nType Safety - TypedDict results throughout\nBackend Agnostic - NumPy/PyTorch/JAX transparent\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Correct implementation of classical control\nClean Integration - system.control and system.analysis APIs\nUnified Interface - Single function for continuous/discrete\nComprehensive - LQR, Kalman, LQG, stability, controllability, observability\nScipy-like - Familiar API for control engineers\n\nThis control framework is the foundation for classical control theory in ControlDESymulation!"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "from src.systems.base import ContinuousSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass MySystem(ContinuousSymbolicSystem):\n    \"\"\"Your custom continuous system.\"\"\"\n    \n    def define_system(self, param1=1.0, param2=2.0):\n        \"\"\"Define symbolic dynamics.\"\"\"\n        # Step 1: Define symbolic variables\n        x1, x2 = sp.symbols('x1 x2', real=True)\n        u = sp.symbols('u', real=True)\n        p1, p2 = sp.symbols('p1 p2', positive=True)\n        \n        # Step 2: Set state and control variables\n        self.state_vars = [x1, x2]\n        self.control_vars = [u]\n        \n        # Step 3: Define dynamics: dx/dt = f(x, u)\n        self._f_sym = sp.Matrix([\n            x2,\n            -p1*x1 - p2*x2 + u\n        ])\n        \n        # Step 4: Set parameters\n        self.parameters = {p1: param1, p2: param2}\n        \n        # Step 5: Set system order (1 for first-order state-space)\n        self.order = 1\n        \n        # Optional: Define output function y = h(x)\n        self._h_sym = sp.Matrix([x1])  # Measure position only\n        self.output_vars = ['y']\n\n# Create and use\nsystem = MySystem(param1=10.0, param2=0.5)\n\n# Evaluate dynamics at a point\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\ndx = system(x, u)  # Returns dx/dt\n\n# Integrate over time\nresult = system.integrate(\n    x0=x,\n    u=None,  # Zero control (autonomous)\n    t_span=(0.0, 10.0),\n    method='RK45'\n)\nt = result['t']\nx_traj = result['y']  # scipy returns (nx, T)\n\n# Linearize at equilibrium\nx_eq = np.zeros(2)\nu_eq = np.zeros(1)\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix:\\n{A}\")\nprint(f\"B matrix:\\n{B}\")\n\n# Simulate with controller\ndef controller(x, t):\n    K = np.array([[-1.0, -2.0]])  # LQR gain\n    return -K @ x\n\nsim_result = system.simulate(\n    x0=x,\n    controller=controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\nfrom src.systems.base import DiscreteSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass MyDiscreteSystem(DiscreteSymbolicSystem):\n    \"\"\"Your custom discrete system.\"\"\"\n    \n    def define_system(self, a=0.9, b=0.1, dt=0.01):\n        \"\"\"Define discrete dynamics.\"\"\"\n        # Define variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        a_sym, b_sym = sp.symbols('a b', real=True)\n        \n        # State and control\n        self.state_vars = [x]\n        self.control_vars = [u]\n        \n        # Discrete dynamics: x[k+1] = f(x[k], u[k])\n        self._f_sym = sp.Matrix([a_sym*x + b_sym*u])\n        \n        # Parameters\n        self.parameters = {a_sym: a, b_sym: b}\n        \n        # CRITICAL: Must set dt for discrete systems!\n        self._dt = dt\n        \n        # System order\n        self.order = 1\n\n# Create and use\nsystem = MyDiscreteSystem(a=0.95, b=0.05, dt=0.1)\n\n# Single step\nx_k = np.array([1.0])\nu_k = np.array([0.5])\nx_next = system.step(x_k, u_k)\n\n# Multi-step simulation\nresult = system.simulate(\n    x0=np.array([1.0]),\n    u_sequence=np.zeros((100, 1)),  # Constant zero control\n    n_steps=100\n)\nstates = result['states']  # (n_steps+1, nx)\ncontrols = result['controls']  # (n_steps, nu)\n\n# Rollout with state feedback\ndef policy(x, k):\n    K = np.array([[-0.8]])\n    return -K @ x\n\nresult = system.rollout(\n    x0=np.array([1.0]),\n    policy=policy,\n    n_steps=100\n)\n\n# Linearize\nAd, Bd = system.linearize(np.zeros(1), np.zeros(1))\neigenvalues = np.linalg.eigvals(Ad)\nis_stable = np.all(np.abs(eigenvalues) &lt; 1)\n\n\n\nfrom src.systems.base import ContinuousStochasticSystem\nimport sympy as sp\nimport numpy as np\n\nclass OrnsteinUhlenbeck(ContinuousStochasticSystem):\n    \"\"\"Ornstein-Uhlenbeck process: mean-reverting stochastic process.\"\"\"\n    \n    def define_system(self, alpha=1.0, sigma=0.5):\n        \"\"\"Define SDE: dx = -alpha*x*dt + sigma*dW\"\"\"\n        # Define variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        alpha_sym = sp.symbols('alpha', positive=True)\n        sigma_sym = sp.symbols('sigma', positive=True)\n        \n        # State and control\n        self.state_vars = [x]\n        self.control_vars = [u]\n        \n        # Drift term: f(x, u) in dx = f*dt + g*dW\n        self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n        \n        # Parameters\n        self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n        self.order = 1\n        \n        # STOCHASTIC: Define diffusion term g(x, u)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        \n        # SDE type: 'ito' or 'stratonovich'\n        self.sde_type = 'ito'\n\n# Create and use\nsystem = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\n# Check noise type (automatic analysis)\nprint(f\"Additive noise: {system.is_additive_noise()}\")  # True\nprint(f\"Noise characteristics: {system.noise_characteristics}\")\n\n# Evaluate drift and diffusion\nx = np.array([1.0])\nu = np.array([0.0])\nf = system.drift(x, u)  # Drift term\ng = system.diffusion(x, u)  # Diffusion matrix\n\n# Integrate SDE\nresult = system.integrate(\n    x0=x,\n    u=None,\n    t_span=(0, 10),\n    method='euler-maruyama',  # SDE integrator\n    dt=0.01  # Required for SDE methods\n)\n\n# Get solver recommendations\nsolvers = system.recommend_solvers(backend='jax')\nprint(f\"Recommended solvers: {solvers}\")\n\n\n\nclass SecondOrderSystem(ContinuousSymbolicSystem):\n    \"\"\"Example: Double integrator (2nd order).\"\"\"\n    \n    def define_system(self, m=1.0):\n        # Physical variable\n        q = sp.symbols('q', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym = sp.symbols('m', positive=True)\n        \n        # State is [q, q_dot] but we define just the physical variable\n        self.state_vars = [q]  # Will be expanded to [q, q_dot]\n        self.control_vars = [u]\n        \n        # Define ONLY highest derivative: q_ddot\n        self._f_sym = sp.Matrix([u / m_sym])\n        \n        self.parameters = {m_sym: m}\n        self.order = 2  # Second-order system!\n\n\n\n\n\n\n# Set default backend\nsystem.set_default_backend('torch')  # 'numpy', 'torch', 'jax'\n\n# Set device\nsystem.set_default_device('cuda:0')  # For GPU\n\n# Check backend\nprint(system._default_backend)\n\n# Convert arrays\nx_torch = system.backend.to_backend(x_numpy, 'torch')\n\n\n\n# Add equilibrium point\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    metadata={'stability': 'unstable'}\n)\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('upright')\n\n# List all equilibria\nnames = system.list_equilibria()  # ['origin', 'upright']\n\n# Set default\nsystem.set_default_equilibrium('upright')\n\n# Get metadata\nmeta = system.get_equilibrium_metadata('upright')\nprint(meta['stability'])  # 'unstable'\n\n\n\n# Save configuration\nsystem.save_config('my_system_config.json')\n\n# Get config dict\nconfig = system.get_config_dict()\nprint(config['parameters'])\n\n\n\n# Get statistics\nstats = system.stats.summary()\nprint(stats)\n\n# Reset statistics\nsystem.stats.reset()\n\n\n\n# Force recompilation (e.g., after parameter change)\nsystem.compile()\n\n# Check if compiled\nif system._is_compiled:\n    print(\"System is compiled\")\n\n\n\n\n\n\n# Create systems with different parameters\nsystems = [MySystem(param1=p) for p in np.linspace(1, 10, 10)]\n\n# Simulate each\nresults = []\nfor sys in systems:\n    result = sys.integrate(x0, u=None, t_span=(0, 10))\n    results.append(result)\n\n\n\n# Design LQR controller\nA, B = system.linearize(x_eq, u_eq)\nQ = np.eye(system.nx)\nR = np.eye(system.nu)\n\nfrom scipy.linalg import solve_continuous_are\nP = solve_continuous_are(A, B, Q, R)\nK = np.linalg.inv(R) @ B.T @ P\n\n# Define controller\ndef lqr_controller(x, t):\n    return -K @ (x - x_eq)\n\n# Simulate\nresult = system.simulate(\n    x0=x0,\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\n# Generate batch of initial conditions\nx_batch = np.random.randn(1000, system.nx)\nu_batch = np.zeros((1000, system.nu))\n\n# Evaluate dynamics for all (vectorized)\ndx_batch = system(x_batch, u_batch)  # Returns (1000, nx)\n\n\n\nimport time\n\nbackends = ['numpy', 'torch', 'jax']\ntimes = {}\n\nfor backend in backends:\n    system.set_default_backend(backend)\n    \n    start = time.time()\n    result = system.integrate(x0, u=None, t_span=(0, 10))\n    times[backend] = time.time() - start\n\nprint(times)  # Compare performance\n\n\n\n\n\n\nSolution: For discrete systems, add self._dt = dt in define_system()\n\n\n\nSolution: For stochastic systems, add self.diffusion_expr = sp.Matrix([...]) in define_system()\n\n\n\nSolution: This is handled internally. If you see it, ensure you’re using the latest version.\n\n\n\nPossible causes:\n\nStiff dynamics → Try stiff solver: method='Radau' or method='BDF'\nToo tight tolerances → Relax: rtol=1e-6, atol=1e-8\nBad initial condition → Check x0 is physically reasonable\n\n\n\n\nPossible causes:\n\nEquilibrium is not valid → Verify f(x_eq, u_eq) ≈ 0 (or = x_eq for discrete)\nSymbolic expressions have division by zero → Check parameter values\n\n\n\n\n\ndef test_my_system():\n    \"\"\"Basic tests for custom system.\"\"\"\n    system = MySystem()\n    \n    # Test 1: Dimensions\n    assert system.nx == 2\n    assert system.nu == 1\n    \n    # Test 2: Evaluation\n    x = np.zeros(system.nx)\n    u = np.zeros(system.nu)\n    dx = system(x, u)\n    assert dx.shape == (system.nx,)\n    \n    # Test 3: Linearization\n    A, B = system.linearize(x, u)\n    assert A.shape == (system.nx, system.nx)\n    assert B.shape == (system.nx, system.nu)\n    \n    # Test 4: Integration\n    result = system.integrate(x, u=None, t_span=(0, 1))\n    assert result['success']\n    \n    print(\"All tests passed!\")\n\ntest_my_system()\n\n\n\n\n\ndef define_system(self):\n    # ... state variables ...\n    \n    # Define custom output\n    self._h_sym = sp.Matrix([\n        self.state_vars[0]**2,  # Nonlinear output\n        sp.sin(self.state_vars[1])\n    ])\n    self.output_vars = ['y1', 'y2']\n\n# Use\ny = system.observe(x)  # Evaluate output\nC = system.linearize_output(x_eq)  # Output Jacobian\n\n\n\n# This requires system to be time-varying\n# Currently, parameters are fixed at initialization\n# For time-varying, use control input u to modulate behavior\n\n\n\n# Create continuous and discrete versions\ncont_sys = MyContinuousSystem()\ndisc_sys = cont_sys.discretize(dt=0.01, method='rk4')\n\n# disc_sys is now a DiscreteSymbolicSystem\n\n\n\n\n\nArchitecture Doc: See UI_Framework_Architecture.md for full details\nType Definitions: See src/types/ for TypedDict definitions\nExamples: See examples/ directory for more complete examples\nTests: See tests/ directory for comprehensive test suites"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html#quick-start-guide",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html#quick-start-guide",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "from src.systems.base import ContinuousSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass MySystem(ContinuousSymbolicSystem):\n    \"\"\"Your custom continuous system.\"\"\"\n    \n    def define_system(self, param1=1.0, param2=2.0):\n        \"\"\"Define symbolic dynamics.\"\"\"\n        # Step 1: Define symbolic variables\n        x1, x2 = sp.symbols('x1 x2', real=True)\n        u = sp.symbols('u', real=True)\n        p1, p2 = sp.symbols('p1 p2', positive=True)\n        \n        # Step 2: Set state and control variables\n        self.state_vars = [x1, x2]\n        self.control_vars = [u]\n        \n        # Step 3: Define dynamics: dx/dt = f(x, u)\n        self._f_sym = sp.Matrix([\n            x2,\n            -p1*x1 - p2*x2 + u\n        ])\n        \n        # Step 4: Set parameters\n        self.parameters = {p1: param1, p2: param2}\n        \n        # Step 5: Set system order (1 for first-order state-space)\n        self.order = 1\n        \n        # Optional: Define output function y = h(x)\n        self._h_sym = sp.Matrix([x1])  # Measure position only\n        self.output_vars = ['y']\n\n# Create and use\nsystem = MySystem(param1=10.0, param2=0.5)\n\n# Evaluate dynamics at a point\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\ndx = system(x, u)  # Returns dx/dt\n\n# Integrate over time\nresult = system.integrate(\n    x0=x,\n    u=None,  # Zero control (autonomous)\n    t_span=(0.0, 10.0),\n    method='RK45'\n)\nt = result['t']\nx_traj = result['y']  # scipy returns (nx, T)\n\n# Linearize at equilibrium\nx_eq = np.zeros(2)\nu_eq = np.zeros(1)\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix:\\n{A}\")\nprint(f\"B matrix:\\n{B}\")\n\n# Simulate with controller\ndef controller(x, t):\n    K = np.array([[-1.0, -2.0]])  # LQR gain\n    return -K @ x\n\nsim_result = system.simulate(\n    x0=x,\n    controller=controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\nfrom src.systems.base import DiscreteSymbolicSystem\nimport sympy as sp\nimport numpy as np\n\nclass MyDiscreteSystem(DiscreteSymbolicSystem):\n    \"\"\"Your custom discrete system.\"\"\"\n    \n    def define_system(self, a=0.9, b=0.1, dt=0.01):\n        \"\"\"Define discrete dynamics.\"\"\"\n        # Define variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        a_sym, b_sym = sp.symbols('a b', real=True)\n        \n        # State and control\n        self.state_vars = [x]\n        self.control_vars = [u]\n        \n        # Discrete dynamics: x[k+1] = f(x[k], u[k])\n        self._f_sym = sp.Matrix([a_sym*x + b_sym*u])\n        \n        # Parameters\n        self.parameters = {a_sym: a, b_sym: b}\n        \n        # CRITICAL: Must set dt for discrete systems!\n        self._dt = dt\n        \n        # System order\n        self.order = 1\n\n# Create and use\nsystem = MyDiscreteSystem(a=0.95, b=0.05, dt=0.1)\n\n# Single step\nx_k = np.array([1.0])\nu_k = np.array([0.5])\nx_next = system.step(x_k, u_k)\n\n# Multi-step simulation\nresult = system.simulate(\n    x0=np.array([1.0]),\n    u_sequence=np.zeros((100, 1)),  # Constant zero control\n    n_steps=100\n)\nstates = result['states']  # (n_steps+1, nx)\ncontrols = result['controls']  # (n_steps, nu)\n\n# Rollout with state feedback\ndef policy(x, k):\n    K = np.array([[-0.8]])\n    return -K @ x\n\nresult = system.rollout(\n    x0=np.array([1.0]),\n    policy=policy,\n    n_steps=100\n)\n\n# Linearize\nAd, Bd = system.linearize(np.zeros(1), np.zeros(1))\neigenvalues = np.linalg.eigvals(Ad)\nis_stable = np.all(np.abs(eigenvalues) &lt; 1)\n\n\n\nfrom src.systems.base import ContinuousStochasticSystem\nimport sympy as sp\nimport numpy as np\n\nclass OrnsteinUhlenbeck(ContinuousStochasticSystem):\n    \"\"\"Ornstein-Uhlenbeck process: mean-reverting stochastic process.\"\"\"\n    \n    def define_system(self, alpha=1.0, sigma=0.5):\n        \"\"\"Define SDE: dx = -alpha*x*dt + sigma*dW\"\"\"\n        # Define variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        alpha_sym = sp.symbols('alpha', positive=True)\n        sigma_sym = sp.symbols('sigma', positive=True)\n        \n        # State and control\n        self.state_vars = [x]\n        self.control_vars = [u]\n        \n        # Drift term: f(x, u) in dx = f*dt + g*dW\n        self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n        \n        # Parameters\n        self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n        self.order = 1\n        \n        # STOCHASTIC: Define diffusion term g(x, u)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        \n        # SDE type: 'ito' or 'stratonovich'\n        self.sde_type = 'ito'\n\n# Create and use\nsystem = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\n# Check noise type (automatic analysis)\nprint(f\"Additive noise: {system.is_additive_noise()}\")  # True\nprint(f\"Noise characteristics: {system.noise_characteristics}\")\n\n# Evaluate drift and diffusion\nx = np.array([1.0])\nu = np.array([0.0])\nf = system.drift(x, u)  # Drift term\ng = system.diffusion(x, u)  # Diffusion matrix\n\n# Integrate SDE\nresult = system.integrate(\n    x0=x,\n    u=None,\n    t_span=(0, 10),\n    method='euler-maruyama',  # SDE integrator\n    dt=0.01  # Required for SDE methods\n)\n\n# Get solver recommendations\nsolvers = system.recommend_solvers(backend='jax')\nprint(f\"Recommended solvers: {solvers}\")\n\n\n\nclass SecondOrderSystem(ContinuousSymbolicSystem):\n    \"\"\"Example: Double integrator (2nd order).\"\"\"\n    \n    def define_system(self, m=1.0):\n        # Physical variable\n        q = sp.symbols('q', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym = sp.symbols('m', positive=True)\n        \n        # State is [q, q_dot] but we define just the physical variable\n        self.state_vars = [q]  # Will be expanded to [q, q_dot]\n        self.control_vars = [u]\n        \n        # Define ONLY highest derivative: q_ddot\n        self._f_sym = sp.Matrix([u / m_sym])\n        \n        self.parameters = {m_sym: m}\n        self.order = 2  # Second-order system!"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html#common-operations",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html#common-operations",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "# Set default backend\nsystem.set_default_backend('torch')  # 'numpy', 'torch', 'jax'\n\n# Set device\nsystem.set_default_device('cuda:0')  # For GPU\n\n# Check backend\nprint(system._default_backend)\n\n# Convert arrays\nx_torch = system.backend.to_backend(x_numpy, 'torch')\n\n\n\n# Add equilibrium point\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    metadata={'stability': 'unstable'}\n)\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('upright')\n\n# List all equilibria\nnames = system.list_equilibria()  # ['origin', 'upright']\n\n# Set default\nsystem.set_default_equilibrium('upright')\n\n# Get metadata\nmeta = system.get_equilibrium_metadata('upright')\nprint(meta['stability'])  # 'unstable'\n\n\n\n# Save configuration\nsystem.save_config('my_system_config.json')\n\n# Get config dict\nconfig = system.get_config_dict()\nprint(config['parameters'])\n\n\n\n# Get statistics\nstats = system.stats.summary()\nprint(stats)\n\n# Reset statistics\nsystem.stats.reset()\n\n\n\n# Force recompilation (e.g., after parameter change)\nsystem.compile()\n\n# Check if compiled\nif system._is_compiled:\n    print(\"System is compiled\")"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html#common-patterns",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html#common-patterns",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "# Create systems with different parameters\nsystems = [MySystem(param1=p) for p in np.linspace(1, 10, 10)]\n\n# Simulate each\nresults = []\nfor sys in systems:\n    result = sys.integrate(x0, u=None, t_span=(0, 10))\n    results.append(result)\n\n\n\n# Design LQR controller\nA, B = system.linearize(x_eq, u_eq)\nQ = np.eye(system.nx)\nR = np.eye(system.nu)\n\nfrom scipy.linalg import solve_continuous_are\nP = solve_continuous_are(A, B, Q, R)\nK = np.linalg.inv(R) @ B.T @ P\n\n# Define controller\ndef lqr_controller(x, t):\n    return -K @ (x - x_eq)\n\n# Simulate\nresult = system.simulate(\n    x0=x0,\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n\n\n# Generate batch of initial conditions\nx_batch = np.random.randn(1000, system.nx)\nu_batch = np.zeros((1000, system.nu))\n\n# Evaluate dynamics for all (vectorized)\ndx_batch = system(x_batch, u_batch)  # Returns (1000, nx)\n\n\n\nimport time\n\nbackends = ['numpy', 'torch', 'jax']\ntimes = {}\n\nfor backend in backends:\n    system.set_default_backend(backend)\n    \n    start = time.time()\n    result = system.integrate(x0, u=None, t_span=(0, 10))\n    times[backend] = time.time() - start\n\nprint(times)  # Compare performance"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html#troubleshooting",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html#troubleshooting",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "Solution: For discrete systems, add self._dt = dt in define_system()\n\n\n\nSolution: For stochastic systems, add self.diffusion_expr = sp.Matrix([...]) in define_system()\n\n\n\nSolution: This is handled internally. If you see it, ensure you’re using the latest version.\n\n\n\nPossible causes:\n\nStiff dynamics → Try stiff solver: method='Radau' or method='BDF'\nToo tight tolerances → Relax: rtol=1e-6, atol=1e-8\nBad initial condition → Check x0 is physically reasonable\n\n\n\n\nPossible causes:\n\nEquilibrium is not valid → Verify f(x_eq, u_eq) ≈ 0 (or = x_eq for discrete)\nSymbolic expressions have division by zero → Check parameter values"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html#testing-your-system",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html#testing-your-system",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "def test_my_system():\n    \"\"\"Basic tests for custom system.\"\"\"\n    system = MySystem()\n    \n    # Test 1: Dimensions\n    assert system.nx == 2\n    assert system.nu == 1\n    \n    # Test 2: Evaluation\n    x = np.zeros(system.nx)\n    u = np.zeros(system.nu)\n    dx = system(x, u)\n    assert dx.shape == (system.nx,)\n    \n    # Test 3: Linearization\n    A, B = system.linearize(x, u)\n    assert A.shape == (system.nx, system.nx)\n    assert B.shape == (system.nx, system.nu)\n    \n    # Test 4: Integration\n    result = system.integrate(x, u=None, t_span=(0, 1))\n    assert result['success']\n    \n    print(\"All tests passed!\")\n\ntest_my_system()"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html#advanced-features",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html#advanced-features",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "def define_system(self):\n    # ... state variables ...\n    \n    # Define custom output\n    self._h_sym = sp.Matrix([\n        self.state_vars[0]**2,  # Nonlinear output\n        sp.sin(self.state_vars[1])\n    ])\n    self.output_vars = ['y1', 'y2']\n\n# Use\ny = system.observe(x)  # Evaluate output\nC = system.linearize_output(x_eq)  # Output Jacobian\n\n\n\n# This requires system to be time-varying\n# Currently, parameters are fixed at initialization\n# For time-varying, use control input u to modulate behavior\n\n\n\n# Create continuous and discrete versions\ncont_sys = MyContinuousSystem()\ndisc_sys = cont_sys.discretize(dt=0.01, method='rk4')\n\n# disc_sys is now a DiscreteSymbolicSystem"
  },
  {
    "objectID": "api/ui_framework/UI_Framework_Quick_Reference.html#references",
    "href": "api/ui_framework/UI_Framework_Quick_Reference.html#references",
    "title": "ControlDESymulation UI Framework Quick Reference",
    "section": "",
    "text": "Architecture Doc: See UI_Framework_Architecture.md for full details\nType Definitions: See src/types/ for TypedDict definitions\nExamples: See examples/ directory for more complete examples\nTests: See tests/ directory for comprehensive test suites"
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html",
    "href": "api/ControlDESymulation_Design_Philosophy.html",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic specification and multi-backend simulation of nonlinear dynamical systems. It embodies a type-driven, composition-based architecture that achieves three seemingly contradictory goals simultaneously:\n\nMathematical Rigor - Proper control theory, stochastic processes, and linearization\nSoftware Engineering Excellence - Clean architecture, zero duplication, extensive testing\nMulti-Backend Performance - Seamless NumPy/PyTorch/JAX with GPU/XLA support\n\nThe library consists of ~36,500 lines across 39 core files organized into 4 architectural layers, serving researchers in control theory, robotics, and machine learning.\n\n\n\n\n\nPrinciple: Types are not just annotations—they are the architecture.\nThe entire framework is built on a foundational type system (6,500 lines, 200+ types) that provides:\n\nSemantic Clarity: StateVector, GainMatrix instead of np.ndarray\nType Safety: Static checking via mypy/pyright catches errors before runtime\nIDE Support: Autocomplete knows result['t'] exists and is TimePoints\nSelf-Documentation: Type signatures encode mathematical constraints\n\n# Compare:\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# vs:\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u\nImpact: Every function signature is a mini-specification. New developers understand code by reading types.\n\n\n\n\nPrinciple: Systems compose specialized utilities rather than inheriting monolithic bases.\nTraditional OOP would create deep inheritance hierarchies. We rejected this in favor of composition via delegation:\n# NOT this (deep inheritance):\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator, ...):\n    pass  # 50 methods, unclear responsibilities\n\n# YES this (composition):\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()       # Multi-backend support\n        self._code_gen = CodeGenerator()      # Symbolic → numerical\n        self._dynamics = DynamicsEvaluator()  # Forward evaluation\n        self._linearization = LinearizationEngine()  # Jacobians\n        self.equilibria = EquilibriumHandler()  # Named equilibria\nBenefits:\n\nSingle Responsibility: Each utility does one thing well\nTestability: Test utilities in isolation\nReusability: Use BackendManager anywhere\nClarity: Explicit dependencies\nFlexibility: Easy to swap implementations\n\nException: We DO use cooperative multiple inheritance in the UI framework—but only at the top level where it provides genuine value (avoiding duplication while maintaining clean interfaces).\n\n\n\n\nPrinciple: Write once, run on NumPy/PyTorch/JAX without code changes.\nSupporting multiple backends is not a feature—it’s a design constraint that forces better architecture:\n# Same code works with all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # x can be np.ndarray, torch.Tensor, or jax.Array\n    return -K @ x  # Works with all!\n\n# Backend switching is trivial\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\nArchitectural Implications:\n\nArrayLike Union Type: All array types accept Union[np.ndarray, torch.Tensor, jnp.ndarray]\nBackendManager Utility: Centralized backend detection and conversion\nPer-Backend Caching: Code generated once per backend, then cached\nDevice Management: Automatic GPU placement when available\n\nResult: Users can start with NumPy for prototyping, switch to PyTorch for neural ODEs, or JAX for optimization—with zero code changes.\n\n\n\n\nPrinciple: Every line of code should exist in exactly one place.\nWe eliminated ~1,800 lines of duplication between continuous and discrete systems through strategic abstraction:\nBefore: Continuous and discrete systems each had:\n\nParameter handling (200 lines × 2)\nBackend management (250 lines × 2)\nCode generation (300 lines × 2)\nSymbolic validation (350 lines × 2)\nConfiguration persistence (200 lines × 2)\n\nAfter: SymbolicSystemBase provides shared functionality:\n\nAll parameter logic: ONE implementation\nAll backend logic: ONE BackendManager\nAll code generation: ONE CodeGenerator\nAll validation: ONE SymbolicValidator\n\nHow: Cooperative multiple inheritance with clear layer separation:\nLayer 0: SymbolicSystemBase (shared foundation)\nLayer 1: ContinuousSystemBase, DiscreteSystemBase (time-domain specific)\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem (multiple inheritance)\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem (add stochasticity)\nThis isn’t inheritance for convenience—it’s strategic abstraction to eliminate duplication while maintaining clarity.\n\n\n\n\nPrinciple: Never return plain dictionaries—use TypedDict for structure and safety.\n# BAD: Plain dict (no IDE support, no type checking)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# GOOD: TypedDict (type-safe, self-documenting)\ndef integrate() -&gt; IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\nBenefits:\n\nType checker ensures all required fields present\nIDE autocompletes field names\nDocumentation embedded in type definition\nOptional fields clearly marked (total=False)\nRefactoring safe (rename propagates)\n\nUsed Throughout:\n\nIntegrationResult - ODE integration\nSDEIntegrationResult - SDE integration\n\nExecutionStats - Performance metrics\nValidationResult - System validation\nBackendConfig - Configuration\n\n\n\n\n\nPrinciple: Define interfaces via Protocol (structural typing) not inheritance.\nProtocols enable duck typing with type safety:\nfrom typing import Protocol\n\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Any class satisfying this structure is a dynamical system.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    \n    @property\n    def nu(self) -&gt; int: ...\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\n# No inheritance needed!\nclass MySystem:  # Doesn't inherit from anything\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property  \n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # Type checker approves!\nBenefits:\n\nNo inheritance coupling\nStructural subtyping (like Go interfaces)\nEasy to implement interfaces\nCompose protocols naturally\nThird-party types work automatically\n\n\n\n\n\nPrinciple: Hide complexity behind simple factory methods.\nCreating integrators involves choosing backends, methods, and configurations. Factories simplify:\n# Instead of this complexity:\nif backend == 'numpy':\n    if method == 'RK45':\n        return ScipyIntegrator(system, method='RK45', rtol=1e-6)\n    elif method == 'Tsit5':\n        return DiffEqPyIntegrator(system, algorithm='Tsit5')\nelif backend == 'torch':\n    return TorchDiffEqIntegrator(system, method='dopri5')\n# ... 50 more cases\n\n# We provide this simplicity:\nintegrator = IntegratorFactory.auto(system)\n# or\nintegrator = IntegratorFactory.for_production(system)\n# or  \nintegrator = IntegratorFactory.for_neural_ode(system)\nFactory Methods:\n\nauto() - Best for system/backend\nfor_production() - LSODA/AutoTsit5\nfor_optimization() - JAX tsit5\nfor_neural_ode() - PyTorch dopri5\nfor_julia() - Highest performance\ncreate() - Full control\n\nResult: Simple interface for common cases, full control when needed.\n\n\n\n\nPrinciple: Names should convey mathematical meaning, not implementation details.\nGood Semantic Names:\n\nStateVector not ArrayLike - conveys it’s a state\nGainMatrix not Matrix - conveys it’s for feedback control\nDynamicsEvaluator not FunctionCaller - conveys purpose\nLinearizationEngine not JacobianComputer - conveys operation\n\nBad Implementation Names:\n\ndata - what data?\narr1, arr2 - meaningless\ncompute() - compute what?\nprocess_stuff() - what stuff?\n\nImpact: Code reads like mathematical papers. Control theorists immediately understand.\n\n\n\n\nPrinciple: Simple things should be simple, complex things should be possible.\nLevel 1 - Simple (Beginner):\nfrom controldesymulation.examples import Pendulum\n\nsystem = Pendulum()\nresult = system.simulate(x0, u=None, t_span=(0, 10))\nLevel 2 - Intermediate:\nfrom controldesymulation import ContinuousSymbolicSystem\nimport sympy as sp\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\nLevel 3 - Advanced (Expert):\n# Multi-backend, custom integrator, GPU acceleration\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\nintegrator = IntegratorFactory.create(\n    system,\n    backend='torch',\n    method='dopri5',\n    rtol=1e-9,\n    atol=1e-11,\n    adjoint=True  # Memory-efficient gradients\n)\n\nresult = integrator.integrate(\n    x0=torch.tensor([[1.0, 0.0]], device='cuda:0'),\n    u_func=lambda t, x: neural_controller(t, x),\n    t_span=(0.0, 10.0),\n    dense_output=True\n)\nPrinciple Applied:\n\nDefault arguments for common cases\nProgressive power through optional parameters\nExpert features available but not mandatory\n\n\n\n\n\n\nThe library consists of 4 distinct architectural layers, each with clear responsibilities:\n\n\nPurpose: Foundational types and structured results\nFiles: 7 modules, 6,481 lines, 200+ types\nKey Components:\n\ncore.py - Vectors, matrices, functions\nbackends.py - Backend enums, configs\ntrajectories.py - Time series results\nlinearization.py - Jacobian types\nsymbolic.py - SymPy integration\nprotocols.py - Abstract interfaces\nutilities.py - Type guards, helpers\n\nDesign Principles:\n\nSemantic over structural naming\nBackend-agnostic unions\nTypedDict for all results\nProtocol-based interfaces\n\nImpact: Every layer above uses these types. Changes here propagate everywhere—so we keep them stable and well-designed.\n\n\n\n\nPurpose: Specialized utilities via composition\nFiles: 11 modules, 7,198 lines\nKey Components:\nCore Utilities:\n\nBackendManager (545 lines) - Multi-backend support\nCodeGenerator (565 lines) - Symbolic → numerical\nEquilibriumHandler (221 lines) - Named equilibria\nSymbolicValidator (718 lines) - System validation\n\nDeterministic Services:\n\nDynamicsEvaluator (576 lines) - Forward dynamics\nLinearizationEngine (907 lines) - Jacobians\nObservationEngine (628 lines) - Output evaluation\n\nStochastic Services:\n\nDiffusionHandler (1,069 lines) - SDE diffusion\nNoiseCharacterizer (692 lines) - Noise analysis\nSDEValidator (544 lines) - SDE validation\n\nLow-Level:\n\ncodegen_utils (733 lines) - SymPy code generation\n\nDesign Principles:\n\nSingle responsibility per utility\nComposition not inheritance\nDependency injection\nLazy initialization with caching\n\nImpact: UI framework composes these utilities. Each utility is independently testable and reusable.\n\n\n\n\nPurpose: Multi-backend numerical integration\nFiles: 13 modules, ~10,000 lines\nKey Components:\nDeterministic (ODE):\n\nIntegratorBase (512 lines) - Abstract interface\nIntegratorFactory (1,267 lines) - Creation\nScipyIntegrator (~620 lines) - NumPy scipy\nTorchDiffEqIntegrator (~800 lines) - PyTorch GPU\nDiffraxIntegrator (~700 lines) - JAX XLA\nDiffEqPyIntegrator (~900 lines) - Julia solvers\nFixedStepIntegrators (~600 lines) - Manual methods\n\nStochastic (SDE):\n\nSDEIntegratorBase (1,080 lines) - SDE interface\nSDEIntegratorFactory (~1,000 lines) - SDE creation\nTorchSDEIntegrator (~800 lines) - PyTorch SDE\nDiffraxSDEIntegrator (~750 lines) - JAX SDE\nDiffEqPySDEIntegrator (~850 lines) - Julia SDE\nCustomBrownianPath (160 lines) - Custom noise\n\nDesign Principles:\n\nFactory pattern for creation\nUnified result types (TypedDict)\nBackend abstraction\nPerformance tracking\n\nSupported Methods: 40+ integration methods across 4 backends\nImpact: Users get production-grade integration with simple interfaces. Backend switching is trivial.\n\n\n\n\nPurpose: Symbolic system definition and high-level interface\nFiles: 8 modules, 12,820 lines\nKey Components:\nLayer 0 - Foundation:\n\nSymbolicSystemBase (1,678 lines) - Time-agnostic base\n\nSymbolic variables/parameters\nCode generation orchestration\nBackend management\nEquilibrium handling\nConfig persistence\n\n\nLayer 1 - Time-Domain Bases:\n\nContinuousSystemBase (915 lines) - Continuous interface\nDiscreteSystemBase (487 lines) - Discrete interface\n\nLayer 2 - Concrete Implementations:\n\nContinuousSymbolicSystem (1,318 lines) - Continuous ODE\nDiscreteSymbolicSystem (1,020 lines) - Discrete map\n\nLayer 3 - Stochastic Extensions:\n\nContinuousStochasticSystem (1,103 lines) - Continuous SDE\nDiscreteStochasticSystem (1,383 lines) - Discrete stochastic\n\nSpecial:\n\nDiscretizedSystem (4,916 lines) - Continuous → discrete\n\nDesign Principles:\n\nCooperative multiple inheritance (strategic, not arbitrary)\nZero code duplication\nTemplate method pattern\nComposition for utilities\n\nImpact: Users define systems symbolically with clean interfaces. Framework handles all complexity.\n\n\n\n\n\n\n\nWhere: All system base classes\nHow: Base class defines workflow, subclasses fill in details\nclass SymbolicSystemBase(ABC):\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\nBenefit: Consistent initialization workflow. Users only implement define_system().\n\n\n\n\nWhere: IntegratorFactory, SDEIntegratorFactory\nHow: Factory methods create appropriate concrete classes\nclass IntegratorFactory:\n    @classmethod\n    def create(cls, system, backend, method, **opts):\n        \"\"\"Create appropriate integrator based on inputs.\"\"\"\n        if backend == 'numpy':\n            if method in SCIPY_METHODS:\n                return ScipyIntegrator(system, method, **opts)\n            elif method in JULIA_METHODS:\n                return DiffEqPyIntegrator(system, method, **opts)\n        elif backend == 'torch':\n            return TorchDiffEqIntegrator(system, method, **opts)\n        # ...\n    \n    @classmethod\n    def auto(cls, system):\n        \"\"\"Best integrator for system.\"\"\"\n        backend = system.backend.default_backend\n        method = cls._BACKEND_DEFAULTS[backend]\n        return cls.create(system, backend, method)\nBenefit: Users get right integrator without knowing details.\n\n\n\n\nWhere: Integration methods\nHow: Different algorithms (strategies) with same interface\n# All integrators implement same interface\nclass IntegratorBase(ABC):\n    @abstractmethod\n    def integrate(self, x0, u_func, t_span) -&gt; IntegrationResult:\n        pass\n\n# Different strategies\nintegrator = ScipyIntegrator(system, method='RK45')  # Strategy 1\nintegrator = DiffraxIntegrator(system, method='tsit5')  # Strategy 2\n\n# Same interface\nresult = integrator.integrate(x0, u_func, t_span)\nBenefit: Swap integration methods without code changes.\n\n\n\n\nWhere: All delegation layer utilities\nHow: Dependencies injected via constructor\nclass DynamicsEvaluator:\n    def __init__(\n        self,\n        system: SymbolicSystemBase,\n        code_gen: CodeGenerator,\n        backend_mgr: BackendManager\n    ):\n        # Dependencies injected, not created internally\n        self.system = system\n        self.code_gen = code_gen\n        self.backend_mgr = backend_mgr\nBenefit: Easy to test (mock dependencies), clear dependencies.\n\n\n\n\nWhere: Code generation, function compilation\nHow: Generate/compile on first use, cache result\nclass CodeGenerator:\n    def generate_dynamics(self, backend):\n        # Check cache first\n        if self._f_funcs[backend] is not None:\n            return self._f_funcs[backend]  # Instant\n        \n        # Generate only if needed\n        func = self._compile_dynamics(backend)\n        \n        # Cache for next time\n        self._f_funcs[backend] = func\n        return func\nBenefit: Fast startup, compile only what’s needed.\n\n\n\n\nWhere: Performance statistics, validation\nHow: Utilities track events and report statistics\nclass DynamicsEvaluator:\n    def evaluate(self, x, u):\n        start = time.time()\n        result = self._f_func(x, u)\n        elapsed = time.time() - start\n        \n        # Update statistics\n        self._stats['count'] += 1\n        self._stats['total_time'] += elapsed\n        \n        return result\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        return self._stats\nBenefit: Built-in performance monitoring.\n\n\n\n\n\n\n\nThe library implements proper control theory:\n1. State-Space Representation\nContinuous:\n  dx/dt = f(x, u, t)\n  y = h(x, t)\n\nDiscrete:\n  x[k+1] = f(x[k], u[k])\n  y[k] = h(x[k])\n2. Linearization\nδẋ = A·δx + B·δu  (continuous)\nδx[k+1] = Ad·δx[k] + Bd·δu[k]  (discrete)\n\nwhere:\n  A = ∂f/∂x (state Jacobian)\n  B = ∂f/∂u (control Jacobian)\n3. Higher-Order Systems\nFor order n system q⁽ⁿ⁾ = f(q, q̇, ..., q⁽ⁿ⁻¹⁾, u):\n  State: x = [q, q̇, ..., q⁽ⁿ⁻¹⁾]ᵀ\n  Dynamics: ẋ = [q̇, q̈, ..., q⁽ⁿ⁾]ᵀ\n4. Stochastic Processes\nSDE (Itô): dx = f(x,u)dt + g(x,u)dW\nSDE (Stratonovich): dx = f(x,u)dt + g(x,u)∘dW\n\nNoise types:\n  - Additive: g(x,u) = G (constant)\n  - Multiplicative: g depends on x or u\n  - Diagonal: Independent noise channels\n  - Scalar: Single Wiener process\n\n\n\nODE Solvers (40+ methods):\n\nExplicit RK: RK45, Tsit5, Vern9, dopri5\nImplicit: Radau, BDF, Rodas5\nAuto-stiffness: LSODA, AutoTsit5\nFixed-step: Euler, RK4, Midpoint\n\nSDE Solvers:\n\nEuler-Maruyama (strong 0.5)\nMilstein (strong 1.0, diagonal)\nHeun (strong 1.0, additive)\nStochastic RK methods\n\n\n\n\n\n\n\n\nThree-Level Cache:\n\nSymbolic Cache: Jacobians computed once symbolically\nPer-Backend Cache: Compiled functions per backend\nEquilibrium Cache: Linearizations at equilibria\n\nExample:\n# First call: symbolic computation + compilation\nA, B = system.linearize(x_eq, u_eq)  # ~100ms\n\n# Second call: cached\nA, B = system.linearize(x_eq, u_eq)  # ~0.001ms (100,000x faster!)\n\n\n\nNumPy:\n\nCommon subexpression elimination (CSE)\nFast numerical modules\nVectorized operations\n\nPyTorch:\n\nSymbolic simplification before codegen\nGPU tensor operations\nAutomatic differentiation\nAdjoint method for memory\n\nJAX:\n\nJIT compilation via jax.jit\nXLA optimization\nPure functional style\nAutomatic vectorization (vmap)\n\n\n\n\nAll evaluators support batched operations:\n# Single evaluation\ndx = system(x, u)  # x: (nx,), u: (nu,) → dx: (nx,)\n\n# Batched evaluation (100x speedup over loop)\ndx_batch = system(x_batch, u_batch)  \n# x: (100, nx), u: (100, nu) → dx: (100, nx)\n\n\n\nPyTorch:\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\nx = torch.tensor([[1.0, 0.0]], device='cuda:0')\ndx = system(x, u)  # Computed on GPU\nJAX:\nsystem.set_default_backend('jax')\n\nx = jnp.array([1.0, 0.0])\ndx = jax.jit(system)(x, u)  # XLA compiled, GPU if available\n\n\n\n\n\n\n\nTypes guide what to test:\ndef test_dynamics_signature():\n    \"\"\"Type annotations specify contract.\"\"\"\n    x: StateVector = np.array([1.0, 0.0])\n    u: ControlVector = np.array([0.5])\n    \n    dx: StateVector = system(x, u)\n    \n    assert isinstance(dx, np.ndarray)\n    assert dx.shape == (system.nx,)\n\n\n\nTest mathematical properties:\ndef test_linearization_is_linear():\n    \"\"\"Linearization should be linear in δx and δu.\"\"\"\n    A, B = system.linearize(x_eq, u_eq)\n    \n    δx1, δx2 = np.random.randn(2, nx)\n    δu = np.zeros(nu)\n    \n    # Linearity: f(αx₁ + βx₂) = αf(x₁) + βf(x₂)\n    α, β = 0.3, 0.7\n    \n    lhs = A @ (α*δx1 + β*δx2)\n    rhs = α*(A @ δx1) + β*(A @ δx2)\n    \n    np.testing.assert_allclose(lhs, rhs)\n\n\n\nSame results across backends:\ndef test_backend_consistency():\n    \"\"\"NumPy, PyTorch, JAX should agree.\"\"\"\n    x_np = np.array([1.0, 0.0])\n    \n    dx_np = system(x_np, backend='numpy')\n    dx_torch = system(torch.tensor(x_np), backend='torch')\n    dx_jax = system(jnp.array(x_np), backend='jax')\n    \n    np.testing.assert_allclose(dx_np, dx_torch.numpy())\n    np.testing.assert_allclose(dx_np, np.array(dx_jax))\n\n\n\nCritical numerical values frozen:\ndef test_pendulum_energy_conservation():\n    \"\"\"Known system should have expected behavior.\"\"\"\n    system = Pendulum(m=1.0, l=1.0, g=9.81)\n    \n    # Energy should be conserved (no damping)\n    E0 = compute_energy(x0)\n    x_final = system.simulate(x0, u=None, t_span=(0, 10))[-1]\n    E_final = compute_energy(x_final)\n    \n    np.testing.assert_allclose(E0, E_final, rtol=1e-6)\n\n\n\n\n\n\n\nCode should be readable without comments:\n# Bad\ndef f(x, u, m):  # What is this?\n    return x[1], -m*x[0] + u\n\n# Good  \ndef compute_dynamics(\n    state: StateVector,\n    control: ControlVector,\n    stiffness: float\n) -&gt; StateVector:\n    \"\"\"\n    Compute dynamics for mass-spring system.\n    \n    Args:\n        state: [position, velocity]\n        control: Applied force\n        stiffness: Spring constant k\n    \n    Returns:\n        [velocity, acceleration]\n    \"\"\"\n    position, velocity = state\n    force = control\n    acceleration = -stiffness * position + force\n    return np.array([velocity, acceleration])\n\n\n\nEvery public function has usage examples:\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; DeterministicLinearization:\n    \"\"\"\n    Compute linearization at equilibrium.\n    \n    Returns state and control Jacobians (A, B).\n    \n    Examples\n    --------\n    &gt;&gt;&gt; # Linearize at origin\n    &gt;&gt;&gt; A, B = system.linearize(\n    ...     x_eq=np.zeros(2),\n    ...     u_eq=np.zeros(1)\n    ... )\n    &gt;&gt;&gt; print(A.shape)  # (2, 2)\n    &gt;&gt;&gt; print(B.shape)  # (2, 1)\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; # Check stability\n    &gt;&gt;&gt; eigenvalues = np.linalg.eigvals(A)\n    &gt;&gt;&gt; stable = np.all(np.real(eigenvalues) &lt; 0)\n    \"\"\"\n\n\n\nExplain theory behind code:\n\"\"\"\nLinearization Engine for Dynamical Systems\n\nMathematical Background\n-----------------------\nFor a nonlinear system:\n    dx/dt = f(x, u)\n\nThe linearization at (x_eq, u_eq) is:\n    δẋ = A·δx + B·δu\n\nwhere:\n    A = ∂f/∂x|(x_eq, u_eq) ∈ ℝⁿˣˣⁿˣ  (State Jacobian)\n    B = ∂f/∂u|(x_eq, u_eq) ∈ ℝⁿˣˣⁿᵘ  (Control Jacobian)\n\nThis enables:\n- Stability analysis via eigenvalues of A\n- LQR controller design\n- Observer design (Kalman filter)\n- Small-signal analysis\n\"\"\"\n\n\n\nHigh-level guides (like this one!) explain design philosophy and patterns.\n\n\n\n\n\n\n\nDetect errors as early as possible with clear messages:\n# Bad\ndef compute(x):\n    return x[5]  # IndexError: vague\n\n# Good\ndef compute(state: StateVector) -&gt; float:\n    if len(state) &lt; 6:\n        raise ValueError(\n            f\"State must have at least 6 elements for this computation. \"\n            f\"Got {len(state)} elements: {state}\"\n        )\n    return state[5]\n\n\n\nCatch errors during __init__, not during use:\nclass System(SymbolicSystemBase):\n    def define_system(self):\n        # Bad parameter type\n        self.parameters = {'m': 1.0}  # String key!\n        \n# Validation catches this immediately:\n# ValueError: Parameter keys must be Symbol, not str.\n# Found string key: 'm'\n# Use: m_sym = sp.symbols('m'); parameters = {m_sym: 1.0}\n\n\n\nUse type annotations + mypy to catch errors before running:\n$ mypy src/\nerror: Argument 1 to \"compute\" has incompatible type \"List[float]\"; \nexpected \"ndarray[Any, dtype[Any]]\"\n\n\n\nInclude context and solutions:\nif x.shape[0] != self.nx:\n    raise ValueError(\n        f\"State dimension mismatch.\\n\"\n        f\"Expected: {self.nx} (from system definition)\\n\"\n        f\"Got: {x.shape[0]} (from input)\\n\"\n        f\"State: {x}\\n\"\n        f\"Hint: Check that state vector has correct dimension.\"\n    )\n\n\n\n\n\nThe architecture provides clear extension points:\n\n\nclass MyCustomSystem(SymbolicSystemBase):\n    \"\"\"Just implement define_system().\"\"\"\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n        self.parameters = {...}\n\n\n\nclass MyIntegrator(IntegratorBase):\n    \"\"\"Implement abstract methods.\"\"\"\n    def step(self, x, u, dt):\n        # Single step logic\n        pass\n    \n    def integrate(self, x0, u_func, t_span):\n        # Multi-step logic\n        return IntegrationResult(...)\n\n\n\nclass MyUtility:\n    \"\"\"Independent utility via composition.\"\"\"\n    def __init__(self, system):\n        self.system = system\n    \n    def my_operation(self):\n        # Custom operation\n        pass\n\n# Use via composition\nsystem._my_utility = MyUtility(system)\n\n\n\n# 1. Add to Backend type\nBackend = Literal[\"numpy\", \"torch\", \"jax\", \"my_backend\"]\n\n# 2. Extend BackendManager\nclass BackendManager:\n    def _convert_to_backend(self, arr, backend):\n        if backend == \"my_backend\":\n            return my_backend.array(arr)\n        # ...\n\n# 3. Add to codegen_utils\ndef generate_function(expr, vars, backend):\n    if backend == \"my_backend\":\n        return my_backend.lambdify(...)\n    # ...\n\n\n\n\n\n\n\nDecision: Use cooperative multiple inheritance ONLY in UI framework Layer 2\nRationale:\n\nPro: Eliminates ~1,800 lines of duplication\nPro: Clean interfaces (ContinuousSymbolicSystem has both symbolic and continuous capabilities)\nPro: Python’s MRO handles it correctly with super()\nCon: Can be confusing if overused\nCon: Requires careful design\n\nWhy Limited Use: We restrict it to where it provides genuine value—the top-level system classes that need to inherit both symbolic machinery and time-domain interfaces.\n\n\n\nDecision: Use TypedDict for results, not dataclass\nRationale:\n\nPro: Compatible with plain dictionaries (gradual typing)\nPro: No runtime overhead\nPro: Works with JSON serialization\nCon: Not as pythonic as dataclass\nCon: No default values (use total=False instead)\n\nWhy TypedDict: Integration results come from external libraries (scipy, etc.) as dictionaries. TypedDict lets us type them without conversion.\n\n\n\nDecision: Support NumPy, PyTorch, JAX (not TensorFlow)\nRationale:\n\nNumPy: Universal, stable, CPU\nPyTorch: Neural networks, GPU, mature ecosystem\nJAX: Functional, JIT, XLA, research-friendly\nTensorFlow: Skipped due to complexity, declining use in research\n\nWhy These Three: Cover 95% of use cases with minimal complexity.\n\n\n\nDecision: Use SymPy (not custom symbolic engine)\nRationale:\n\nPro: Mature, well-tested symbolic math\nPro: Excellent documentation\nPro: Large community\nCon: Can be slow for very large systems\nCon: Limited control over simplification\n\nWhy SymPy: Reinventing symbolic math is not our value proposition. SymPy is battle-tested.\n\n\n\nDecision: pytest (not unittest)\nRationale:\n\nPro: Less boilerplate\nPro: Better fixtures\nPro: Parametrized tests\nPro: Better assertions\n\nWhy pytest: Industry standard, developer-friendly.\n\n\n\n\n\n\n\n\nClassical Control Theory\n\nStability, controllability, and observability metrics\nKalman Filter, Luenberger Observer design\nLinear Quadratic (Gaussian) Regulator control design\nCallable controllers\n\nVisualization\n\nPlotting using Plotly\n\nTrajectory visualization across all variables\nPhase portrait visualization in two or three dimensions\n\n\n\n\n\n\n\nRL Environment Synthesis\n\nInterfaces that satisfy Gymnasium library conventions\nExport of Gymnasium and/or PyBullet environments from symbolically defined dynamics\n\nSynthetic Data Generation\n\nClasses and methods for the generation and export of synthetic physical data in standard formats\n\nDiscretization:\n\nExact (matrix exponential)\nTustin (bilinear transform)\nForward/backward Euler\nZero-order hold\n\nParameter and Uncertainty Estimation\n\nSystem identification\nBayesian inference\nAdaptive control\nConformal methods\nSobol indices\nMorris screening\n\nNeural Controller Design\n\nProtocol interface for backend-agnostic functionality\nNeural controller training\nNeural certificate function construction and verification\n\nLyapunov, barrier, contraction metric\n\nForward and backward reachability analysis\n\nModel Predictive Control (MPC)\n\nReceding horizon optimization\nConstraint handling\nReal-time capable\nIntegration with do-mpc, CasADi, acados\n\nAdvanced Stochastic\n\nParticle filters\nStochastic MPC\nNoisy measurement models\nOther robust and/or stochastic control\n\nSystem Composition\n\nConnector protocol interfaces to couple multiple subsystems\n\n\n\n\n\n\nHybrid Systems\n\nSwitched dynamics\nHybrid automata\nJump/flow dynamics\n\nDistributed Systems\n\nMulti-agent dynamics\nNetwork topology\nConsensus protocols\n\nDelay Systems\n\nTime-delayed feedback\nDDE integration\nDelayed stability analysis\n\nPDE Systems\n\nSpatiotemporal dynamics\nFinite/discrete element methods\nSpectral methods\n\n\n\n\n\n\n\nControlDESymulation demonstrates that mathematical rigor, software engineering excellence, and multi-backend performance are not competing goals—they are mutually reinforcing when built on a foundation of:\n\nType-Driven Design - Types are architecture\nComposition Over Inheritance - Build with utilities\nBackend Agnosticism - Write once, run anywhere\nZero Duplication - Strategic abstraction\nStructured Results - TypedDict everywhere\nProtocol Interfaces - Duck typing with safety\nFactory Patterns - Hide complexity\nSemantic Naming - Code reads like math\n\nThe result is a library where:\n\nControl theorists find familiar mathematics\nSoftware engineers find clean architecture\nML researchers find GPU acceleration\nStudents find gentle learning curves\nExperts find power and flexibility\n\n36,500 lines of code organized into 4 architectural layers, implementing 200+ types and 40+ integration methods—all serving a single vision: symbolic dynamical systems done right."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#executive-summary",
    "href": "api/ControlDESymulation_Design_Philosophy.html#executive-summary",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic specification and multi-backend simulation of nonlinear dynamical systems. It embodies a type-driven, composition-based architecture that achieves three seemingly contradictory goals simultaneously:\n\nMathematical Rigor - Proper control theory, stochastic processes, and linearization\nSoftware Engineering Excellence - Clean architecture, zero duplication, extensive testing\nMulti-Backend Performance - Seamless NumPy/PyTorch/JAX with GPU/XLA support\n\nThe library consists of ~36,500 lines across 39 core files organized into 4 architectural layers, serving researchers in control theory, robotics, and machine learning."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#core-design-philosophy",
    "href": "api/ControlDESymulation_Design_Philosophy.html#core-design-philosophy",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Principle: Types are not just annotations—they are the architecture.\nThe entire framework is built on a foundational type system (6,500 lines, 200+ types) that provides:\n\nSemantic Clarity: StateVector, GainMatrix instead of np.ndarray\nType Safety: Static checking via mypy/pyright catches errors before runtime\nIDE Support: Autocomplete knows result['t'] exists and is TimePoints\nSelf-Documentation: Type signatures encode mathematical constraints\n\n# Compare:\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# vs:\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u\nImpact: Every function signature is a mini-specification. New developers understand code by reading types.\n\n\n\n\nPrinciple: Systems compose specialized utilities rather than inheriting monolithic bases.\nTraditional OOP would create deep inheritance hierarchies. We rejected this in favor of composition via delegation:\n# NOT this (deep inheritance):\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator, ...):\n    pass  # 50 methods, unclear responsibilities\n\n# YES this (composition):\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()       # Multi-backend support\n        self._code_gen = CodeGenerator()      # Symbolic → numerical\n        self._dynamics = DynamicsEvaluator()  # Forward evaluation\n        self._linearization = LinearizationEngine()  # Jacobians\n        self.equilibria = EquilibriumHandler()  # Named equilibria\nBenefits:\n\nSingle Responsibility: Each utility does one thing well\nTestability: Test utilities in isolation\nReusability: Use BackendManager anywhere\nClarity: Explicit dependencies\nFlexibility: Easy to swap implementations\n\nException: We DO use cooperative multiple inheritance in the UI framework—but only at the top level where it provides genuine value (avoiding duplication while maintaining clean interfaces).\n\n\n\n\nPrinciple: Write once, run on NumPy/PyTorch/JAX without code changes.\nSupporting multiple backends is not a feature—it’s a design constraint that forces better architecture:\n# Same code works with all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # x can be np.ndarray, torch.Tensor, or jax.Array\n    return -K @ x  # Works with all!\n\n# Backend switching is trivial\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\nArchitectural Implications:\n\nArrayLike Union Type: All array types accept Union[np.ndarray, torch.Tensor, jnp.ndarray]\nBackendManager Utility: Centralized backend detection and conversion\nPer-Backend Caching: Code generated once per backend, then cached\nDevice Management: Automatic GPU placement when available\n\nResult: Users can start with NumPy for prototyping, switch to PyTorch for neural ODEs, or JAX for optimization—with zero code changes.\n\n\n\n\nPrinciple: Every line of code should exist in exactly one place.\nWe eliminated ~1,800 lines of duplication between continuous and discrete systems through strategic abstraction:\nBefore: Continuous and discrete systems each had:\n\nParameter handling (200 lines × 2)\nBackend management (250 lines × 2)\nCode generation (300 lines × 2)\nSymbolic validation (350 lines × 2)\nConfiguration persistence (200 lines × 2)\n\nAfter: SymbolicSystemBase provides shared functionality:\n\nAll parameter logic: ONE implementation\nAll backend logic: ONE BackendManager\nAll code generation: ONE CodeGenerator\nAll validation: ONE SymbolicValidator\n\nHow: Cooperative multiple inheritance with clear layer separation:\nLayer 0: SymbolicSystemBase (shared foundation)\nLayer 1: ContinuousSystemBase, DiscreteSystemBase (time-domain specific)\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem (multiple inheritance)\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem (add stochasticity)\nThis isn’t inheritance for convenience—it’s strategic abstraction to eliminate duplication while maintaining clarity.\n\n\n\n\nPrinciple: Never return plain dictionaries—use TypedDict for structure and safety.\n# BAD: Plain dict (no IDE support, no type checking)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# GOOD: TypedDict (type-safe, self-documenting)\ndef integrate() -&gt; IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\nBenefits:\n\nType checker ensures all required fields present\nIDE autocompletes field names\nDocumentation embedded in type definition\nOptional fields clearly marked (total=False)\nRefactoring safe (rename propagates)\n\nUsed Throughout:\n\nIntegrationResult - ODE integration\nSDEIntegrationResult - SDE integration\n\nExecutionStats - Performance metrics\nValidationResult - System validation\nBackendConfig - Configuration\n\n\n\n\n\nPrinciple: Define interfaces via Protocol (structural typing) not inheritance.\nProtocols enable duck typing with type safety:\nfrom typing import Protocol\n\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Any class satisfying this structure is a dynamical system.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    \n    @property\n    def nu(self) -&gt; int: ...\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\n# No inheritance needed!\nclass MySystem:  # Doesn't inherit from anything\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property  \n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # Type checker approves!\nBenefits:\n\nNo inheritance coupling\nStructural subtyping (like Go interfaces)\nEasy to implement interfaces\nCompose protocols naturally\nThird-party types work automatically\n\n\n\n\n\nPrinciple: Hide complexity behind simple factory methods.\nCreating integrators involves choosing backends, methods, and configurations. Factories simplify:\n# Instead of this complexity:\nif backend == 'numpy':\n    if method == 'RK45':\n        return ScipyIntegrator(system, method='RK45', rtol=1e-6)\n    elif method == 'Tsit5':\n        return DiffEqPyIntegrator(system, algorithm='Tsit5')\nelif backend == 'torch':\n    return TorchDiffEqIntegrator(system, method='dopri5')\n# ... 50 more cases\n\n# We provide this simplicity:\nintegrator = IntegratorFactory.auto(system)\n# or\nintegrator = IntegratorFactory.for_production(system)\n# or  \nintegrator = IntegratorFactory.for_neural_ode(system)\nFactory Methods:\n\nauto() - Best for system/backend\nfor_production() - LSODA/AutoTsit5\nfor_optimization() - JAX tsit5\nfor_neural_ode() - PyTorch dopri5\nfor_julia() - Highest performance\ncreate() - Full control\n\nResult: Simple interface for common cases, full control when needed.\n\n\n\n\nPrinciple: Names should convey mathematical meaning, not implementation details.\nGood Semantic Names:\n\nStateVector not ArrayLike - conveys it’s a state\nGainMatrix not Matrix - conveys it’s for feedback control\nDynamicsEvaluator not FunctionCaller - conveys purpose\nLinearizationEngine not JacobianComputer - conveys operation\n\nBad Implementation Names:\n\ndata - what data?\narr1, arr2 - meaningless\ncompute() - compute what?\nprocess_stuff() - what stuff?\n\nImpact: Code reads like mathematical papers. Control theorists immediately understand.\n\n\n\n\nPrinciple: Simple things should be simple, complex things should be possible.\nLevel 1 - Simple (Beginner):\nfrom controldesymulation.examples import Pendulum\n\nsystem = Pendulum()\nresult = system.simulate(x0, u=None, t_span=(0, 10))\nLevel 2 - Intermediate:\nfrom controldesymulation import ContinuousSymbolicSystem\nimport sympy as sp\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\nLevel 3 - Advanced (Expert):\n# Multi-backend, custom integrator, GPU acceleration\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\nintegrator = IntegratorFactory.create(\n    system,\n    backend='torch',\n    method='dopri5',\n    rtol=1e-9,\n    atol=1e-11,\n    adjoint=True  # Memory-efficient gradients\n)\n\nresult = integrator.integrate(\n    x0=torch.tensor([[1.0, 0.0]], device='cuda:0'),\n    u_func=lambda t, x: neural_controller(t, x),\n    t_span=(0.0, 10.0),\n    dense_output=True\n)\nPrinciple Applied:\n\nDefault arguments for common cases\nProgressive power through optional parameters\nExpert features available but not mandatory"
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#architectural-layers",
    "href": "api/ControlDESymulation_Design_Philosophy.html#architectural-layers",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "The library consists of 4 distinct architectural layers, each with clear responsibilities:\n\n\nPurpose: Foundational types and structured results\nFiles: 7 modules, 6,481 lines, 200+ types\nKey Components:\n\ncore.py - Vectors, matrices, functions\nbackends.py - Backend enums, configs\ntrajectories.py - Time series results\nlinearization.py - Jacobian types\nsymbolic.py - SymPy integration\nprotocols.py - Abstract interfaces\nutilities.py - Type guards, helpers\n\nDesign Principles:\n\nSemantic over structural naming\nBackend-agnostic unions\nTypedDict for all results\nProtocol-based interfaces\n\nImpact: Every layer above uses these types. Changes here propagate everywhere—so we keep them stable and well-designed.\n\n\n\n\nPurpose: Specialized utilities via composition\nFiles: 11 modules, 7,198 lines\nKey Components:\nCore Utilities:\n\nBackendManager (545 lines) - Multi-backend support\nCodeGenerator (565 lines) - Symbolic → numerical\nEquilibriumHandler (221 lines) - Named equilibria\nSymbolicValidator (718 lines) - System validation\n\nDeterministic Services:\n\nDynamicsEvaluator (576 lines) - Forward dynamics\nLinearizationEngine (907 lines) - Jacobians\nObservationEngine (628 lines) - Output evaluation\n\nStochastic Services:\n\nDiffusionHandler (1,069 lines) - SDE diffusion\nNoiseCharacterizer (692 lines) - Noise analysis\nSDEValidator (544 lines) - SDE validation\n\nLow-Level:\n\ncodegen_utils (733 lines) - SymPy code generation\n\nDesign Principles:\n\nSingle responsibility per utility\nComposition not inheritance\nDependency injection\nLazy initialization with caching\n\nImpact: UI framework composes these utilities. Each utility is independently testable and reusable.\n\n\n\n\nPurpose: Multi-backend numerical integration\nFiles: 13 modules, ~10,000 lines\nKey Components:\nDeterministic (ODE):\n\nIntegratorBase (512 lines) - Abstract interface\nIntegratorFactory (1,267 lines) - Creation\nScipyIntegrator (~620 lines) - NumPy scipy\nTorchDiffEqIntegrator (~800 lines) - PyTorch GPU\nDiffraxIntegrator (~700 lines) - JAX XLA\nDiffEqPyIntegrator (~900 lines) - Julia solvers\nFixedStepIntegrators (~600 lines) - Manual methods\n\nStochastic (SDE):\n\nSDEIntegratorBase (1,080 lines) - SDE interface\nSDEIntegratorFactory (~1,000 lines) - SDE creation\nTorchSDEIntegrator (~800 lines) - PyTorch SDE\nDiffraxSDEIntegrator (~750 lines) - JAX SDE\nDiffEqPySDEIntegrator (~850 lines) - Julia SDE\nCustomBrownianPath (160 lines) - Custom noise\n\nDesign Principles:\n\nFactory pattern for creation\nUnified result types (TypedDict)\nBackend abstraction\nPerformance tracking\n\nSupported Methods: 40+ integration methods across 4 backends\nImpact: Users get production-grade integration with simple interfaces. Backend switching is trivial.\n\n\n\n\nPurpose: Symbolic system definition and high-level interface\nFiles: 8 modules, 12,820 lines\nKey Components:\nLayer 0 - Foundation:\n\nSymbolicSystemBase (1,678 lines) - Time-agnostic base\n\nSymbolic variables/parameters\nCode generation orchestration\nBackend management\nEquilibrium handling\nConfig persistence\n\n\nLayer 1 - Time-Domain Bases:\n\nContinuousSystemBase (915 lines) - Continuous interface\nDiscreteSystemBase (487 lines) - Discrete interface\n\nLayer 2 - Concrete Implementations:\n\nContinuousSymbolicSystem (1,318 lines) - Continuous ODE\nDiscreteSymbolicSystem (1,020 lines) - Discrete map\n\nLayer 3 - Stochastic Extensions:\n\nContinuousStochasticSystem (1,103 lines) - Continuous SDE\nDiscreteStochasticSystem (1,383 lines) - Discrete stochastic\n\nSpecial:\n\nDiscretizedSystem (4,916 lines) - Continuous → discrete\n\nDesign Principles:\n\nCooperative multiple inheritance (strategic, not arbitrary)\nZero code duplication\nTemplate method pattern\nComposition for utilities\n\nImpact: Users define systems symbolically with clean interfaces. Framework handles all complexity."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#design-patterns-used",
    "href": "api/ControlDESymulation_Design_Philosophy.html#design-patterns-used",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Where: All system base classes\nHow: Base class defines workflow, subclasses fill in details\nclass SymbolicSystemBase(ABC):\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\nBenefit: Consistent initialization workflow. Users only implement define_system().\n\n\n\n\nWhere: IntegratorFactory, SDEIntegratorFactory\nHow: Factory methods create appropriate concrete classes\nclass IntegratorFactory:\n    @classmethod\n    def create(cls, system, backend, method, **opts):\n        \"\"\"Create appropriate integrator based on inputs.\"\"\"\n        if backend == 'numpy':\n            if method in SCIPY_METHODS:\n                return ScipyIntegrator(system, method, **opts)\n            elif method in JULIA_METHODS:\n                return DiffEqPyIntegrator(system, method, **opts)\n        elif backend == 'torch':\n            return TorchDiffEqIntegrator(system, method, **opts)\n        # ...\n    \n    @classmethod\n    def auto(cls, system):\n        \"\"\"Best integrator for system.\"\"\"\n        backend = system.backend.default_backend\n        method = cls._BACKEND_DEFAULTS[backend]\n        return cls.create(system, backend, method)\nBenefit: Users get right integrator without knowing details.\n\n\n\n\nWhere: Integration methods\nHow: Different algorithms (strategies) with same interface\n# All integrators implement same interface\nclass IntegratorBase(ABC):\n    @abstractmethod\n    def integrate(self, x0, u_func, t_span) -&gt; IntegrationResult:\n        pass\n\n# Different strategies\nintegrator = ScipyIntegrator(system, method='RK45')  # Strategy 1\nintegrator = DiffraxIntegrator(system, method='tsit5')  # Strategy 2\n\n# Same interface\nresult = integrator.integrate(x0, u_func, t_span)\nBenefit: Swap integration methods without code changes.\n\n\n\n\nWhere: All delegation layer utilities\nHow: Dependencies injected via constructor\nclass DynamicsEvaluator:\n    def __init__(\n        self,\n        system: SymbolicSystemBase,\n        code_gen: CodeGenerator,\n        backend_mgr: BackendManager\n    ):\n        # Dependencies injected, not created internally\n        self.system = system\n        self.code_gen = code_gen\n        self.backend_mgr = backend_mgr\nBenefit: Easy to test (mock dependencies), clear dependencies.\n\n\n\n\nWhere: Code generation, function compilation\nHow: Generate/compile on first use, cache result\nclass CodeGenerator:\n    def generate_dynamics(self, backend):\n        # Check cache first\n        if self._f_funcs[backend] is not None:\n            return self._f_funcs[backend]  # Instant\n        \n        # Generate only if needed\n        func = self._compile_dynamics(backend)\n        \n        # Cache for next time\n        self._f_funcs[backend] = func\n        return func\nBenefit: Fast startup, compile only what’s needed.\n\n\n\n\nWhere: Performance statistics, validation\nHow: Utilities track events and report statistics\nclass DynamicsEvaluator:\n    def evaluate(self, x, u):\n        start = time.time()\n        result = self._f_func(x, u)\n        elapsed = time.time() - start\n        \n        # Update statistics\n        self._stats['count'] += 1\n        self._stats['total_time'] += elapsed\n        \n        return result\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        return self._stats\nBenefit: Built-in performance monitoring."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#mathematical-rigor",
    "href": "api/ControlDESymulation_Design_Philosophy.html#mathematical-rigor",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "The library implements proper control theory:\n1. State-Space Representation\nContinuous:\n  dx/dt = f(x, u, t)\n  y = h(x, t)\n\nDiscrete:\n  x[k+1] = f(x[k], u[k])\n  y[k] = h(x[k])\n2. Linearization\nδẋ = A·δx + B·δu  (continuous)\nδx[k+1] = Ad·δx[k] + Bd·δu[k]  (discrete)\n\nwhere:\n  A = ∂f/∂x (state Jacobian)\n  B = ∂f/∂u (control Jacobian)\n3. Higher-Order Systems\nFor order n system q⁽ⁿ⁾ = f(q, q̇, ..., q⁽ⁿ⁻¹⁾, u):\n  State: x = [q, q̇, ..., q⁽ⁿ⁻¹⁾]ᵀ\n  Dynamics: ẋ = [q̇, q̈, ..., q⁽ⁿ⁾]ᵀ\n4. Stochastic Processes\nSDE (Itô): dx = f(x,u)dt + g(x,u)dW\nSDE (Stratonovich): dx = f(x,u)dt + g(x,u)∘dW\n\nNoise types:\n  - Additive: g(x,u) = G (constant)\n  - Multiplicative: g depends on x or u\n  - Diagonal: Independent noise channels\n  - Scalar: Single Wiener process\n\n\n\nODE Solvers (40+ methods):\n\nExplicit RK: RK45, Tsit5, Vern9, dopri5\nImplicit: Radau, BDF, Rodas5\nAuto-stiffness: LSODA, AutoTsit5\nFixed-step: Euler, RK4, Midpoint\n\nSDE Solvers:\n\nEuler-Maruyama (strong 0.5)\nMilstein (strong 1.0, diagonal)\nHeun (strong 1.0, additive)\nStochastic RK methods"
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#performance-considerations",
    "href": "api/ControlDESymulation_Design_Philosophy.html#performance-considerations",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Three-Level Cache:\n\nSymbolic Cache: Jacobians computed once symbolically\nPer-Backend Cache: Compiled functions per backend\nEquilibrium Cache: Linearizations at equilibria\n\nExample:\n# First call: symbolic computation + compilation\nA, B = system.linearize(x_eq, u_eq)  # ~100ms\n\n# Second call: cached\nA, B = system.linearize(x_eq, u_eq)  # ~0.001ms (100,000x faster!)\n\n\n\nNumPy:\n\nCommon subexpression elimination (CSE)\nFast numerical modules\nVectorized operations\n\nPyTorch:\n\nSymbolic simplification before codegen\nGPU tensor operations\nAutomatic differentiation\nAdjoint method for memory\n\nJAX:\n\nJIT compilation via jax.jit\nXLA optimization\nPure functional style\nAutomatic vectorization (vmap)\n\n\n\n\nAll evaluators support batched operations:\n# Single evaluation\ndx = system(x, u)  # x: (nx,), u: (nu,) → dx: (nx,)\n\n# Batched evaluation (100x speedup over loop)\ndx_batch = system(x_batch, u_batch)  \n# x: (100, nx), u: (100, nu) → dx: (100, nx)\n\n\n\nPyTorch:\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\nx = torch.tensor([[1.0, 0.0]], device='cuda:0')\ndx = system(x, u)  # Computed on GPU\nJAX:\nsystem.set_default_backend('jax')\n\nx = jnp.array([1.0, 0.0])\ndx = jax.jit(system)(x, u)  # XLA compiled, GPU if available"
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#testing-philosophy",
    "href": "api/ControlDESymulation_Design_Philosophy.html#testing-philosophy",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Types guide what to test:\ndef test_dynamics_signature():\n    \"\"\"Type annotations specify contract.\"\"\"\n    x: StateVector = np.array([1.0, 0.0])\n    u: ControlVector = np.array([0.5])\n    \n    dx: StateVector = system(x, u)\n    \n    assert isinstance(dx, np.ndarray)\n    assert dx.shape == (system.nx,)\n\n\n\nTest mathematical properties:\ndef test_linearization_is_linear():\n    \"\"\"Linearization should be linear in δx and δu.\"\"\"\n    A, B = system.linearize(x_eq, u_eq)\n    \n    δx1, δx2 = np.random.randn(2, nx)\n    δu = np.zeros(nu)\n    \n    # Linearity: f(αx₁ + βx₂) = αf(x₁) + βf(x₂)\n    α, β = 0.3, 0.7\n    \n    lhs = A @ (α*δx1 + β*δx2)\n    rhs = α*(A @ δx1) + β*(A @ δx2)\n    \n    np.testing.assert_allclose(lhs, rhs)\n\n\n\nSame results across backends:\ndef test_backend_consistency():\n    \"\"\"NumPy, PyTorch, JAX should agree.\"\"\"\n    x_np = np.array([1.0, 0.0])\n    \n    dx_np = system(x_np, backend='numpy')\n    dx_torch = system(torch.tensor(x_np), backend='torch')\n    dx_jax = system(jnp.array(x_np), backend='jax')\n    \n    np.testing.assert_allclose(dx_np, dx_torch.numpy())\n    np.testing.assert_allclose(dx_np, np.array(dx_jax))\n\n\n\nCritical numerical values frozen:\ndef test_pendulum_energy_conservation():\n    \"\"\"Known system should have expected behavior.\"\"\"\n    system = Pendulum(m=1.0, l=1.0, g=9.81)\n    \n    # Energy should be conserved (no damping)\n    E0 = compute_energy(x0)\n    x_final = system.simulate(x0, u=None, t_span=(0, 10))[-1]\n    E_final = compute_energy(x_final)\n    \n    np.testing.assert_allclose(E0, E_final, rtol=1e-6)"
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#documentation-philosophy",
    "href": "api/ControlDESymulation_Design_Philosophy.html#documentation-philosophy",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Code should be readable without comments:\n# Bad\ndef f(x, u, m):  # What is this?\n    return x[1], -m*x[0] + u\n\n# Good  \ndef compute_dynamics(\n    state: StateVector,\n    control: ControlVector,\n    stiffness: float\n) -&gt; StateVector:\n    \"\"\"\n    Compute dynamics for mass-spring system.\n    \n    Args:\n        state: [position, velocity]\n        control: Applied force\n        stiffness: Spring constant k\n    \n    Returns:\n        [velocity, acceleration]\n    \"\"\"\n    position, velocity = state\n    force = control\n    acceleration = -stiffness * position + force\n    return np.array([velocity, acceleration])\n\n\n\nEvery public function has usage examples:\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; DeterministicLinearization:\n    \"\"\"\n    Compute linearization at equilibrium.\n    \n    Returns state and control Jacobians (A, B).\n    \n    Examples\n    --------\n    &gt;&gt;&gt; # Linearize at origin\n    &gt;&gt;&gt; A, B = system.linearize(\n    ...     x_eq=np.zeros(2),\n    ...     u_eq=np.zeros(1)\n    ... )\n    &gt;&gt;&gt; print(A.shape)  # (2, 2)\n    &gt;&gt;&gt; print(B.shape)  # (2, 1)\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; # Check stability\n    &gt;&gt;&gt; eigenvalues = np.linalg.eigvals(A)\n    &gt;&gt;&gt; stable = np.all(np.real(eigenvalues) &lt; 0)\n    \"\"\"\n\n\n\nExplain theory behind code:\n\"\"\"\nLinearization Engine for Dynamical Systems\n\nMathematical Background\n-----------------------\nFor a nonlinear system:\n    dx/dt = f(x, u)\n\nThe linearization at (x_eq, u_eq) is:\n    δẋ = A·δx + B·δu\n\nwhere:\n    A = ∂f/∂x|(x_eq, u_eq) ∈ ℝⁿˣˣⁿˣ  (State Jacobian)\n    B = ∂f/∂u|(x_eq, u_eq) ∈ ℝⁿˣˣⁿᵘ  (Control Jacobian)\n\nThis enables:\n- Stability analysis via eigenvalues of A\n- LQR controller design\n- Observer design (Kalman filter)\n- Small-signal analysis\n\"\"\"\n\n\n\nHigh-level guides (like this one!) explain design philosophy and patterns."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#error-handling-philosophy",
    "href": "api/ControlDESymulation_Design_Philosophy.html#error-handling-philosophy",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Detect errors as early as possible with clear messages:\n# Bad\ndef compute(x):\n    return x[5]  # IndexError: vague\n\n# Good\ndef compute(state: StateVector) -&gt; float:\n    if len(state) &lt; 6:\n        raise ValueError(\n            f\"State must have at least 6 elements for this computation. \"\n            f\"Got {len(state)} elements: {state}\"\n        )\n    return state[5]\n\n\n\nCatch errors during __init__, not during use:\nclass System(SymbolicSystemBase):\n    def define_system(self):\n        # Bad parameter type\n        self.parameters = {'m': 1.0}  # String key!\n        \n# Validation catches this immediately:\n# ValueError: Parameter keys must be Symbol, not str.\n# Found string key: 'm'\n# Use: m_sym = sp.symbols('m'); parameters = {m_sym: 1.0}\n\n\n\nUse type annotations + mypy to catch errors before running:\n$ mypy src/\nerror: Argument 1 to \"compute\" has incompatible type \"List[float]\"; \nexpected \"ndarray[Any, dtype[Any]]\"\n\n\n\nInclude context and solutions:\nif x.shape[0] != self.nx:\n    raise ValueError(\n        f\"State dimension mismatch.\\n\"\n        f\"Expected: {self.nx} (from system definition)\\n\"\n        f\"Got: {x.shape[0]} (from input)\\n\"\n        f\"State: {x}\\n\"\n        f\"Hint: Check that state vector has correct dimension.\"\n    )"
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#extension-points",
    "href": "api/ControlDESymulation_Design_Philosophy.html#extension-points",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "The architecture provides clear extension points:\n\n\nclass MyCustomSystem(SymbolicSystemBase):\n    \"\"\"Just implement define_system().\"\"\"\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n        self.parameters = {...}\n\n\n\nclass MyIntegrator(IntegratorBase):\n    \"\"\"Implement abstract methods.\"\"\"\n    def step(self, x, u, dt):\n        # Single step logic\n        pass\n    \n    def integrate(self, x0, u_func, t_span):\n        # Multi-step logic\n        return IntegrationResult(...)\n\n\n\nclass MyUtility:\n    \"\"\"Independent utility via composition.\"\"\"\n    def __init__(self, system):\n        self.system = system\n    \n    def my_operation(self):\n        # Custom operation\n        pass\n\n# Use via composition\nsystem._my_utility = MyUtility(system)\n\n\n\n# 1. Add to Backend type\nBackend = Literal[\"numpy\", \"torch\", \"jax\", \"my_backend\"]\n\n# 2. Extend BackendManager\nclass BackendManager:\n    def _convert_to_backend(self, arr, backend):\n        if backend == \"my_backend\":\n            return my_backend.array(arr)\n        # ...\n\n# 3. Add to codegen_utils\ndef generate_function(expr, vars, backend):\n    if backend == \"my_backend\":\n        return my_backend.lambdify(...)\n    # ..."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#trade-offs-and-decisions",
    "href": "api/ControlDESymulation_Design_Philosophy.html#trade-offs-and-decisions",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Decision: Use cooperative multiple inheritance ONLY in UI framework Layer 2\nRationale:\n\nPro: Eliminates ~1,800 lines of duplication\nPro: Clean interfaces (ContinuousSymbolicSystem has both symbolic and continuous capabilities)\nPro: Python’s MRO handles it correctly with super()\nCon: Can be confusing if overused\nCon: Requires careful design\n\nWhy Limited Use: We restrict it to where it provides genuine value—the top-level system classes that need to inherit both symbolic machinery and time-domain interfaces.\n\n\n\nDecision: Use TypedDict for results, not dataclass\nRationale:\n\nPro: Compatible with plain dictionaries (gradual typing)\nPro: No runtime overhead\nPro: Works with JSON serialization\nCon: Not as pythonic as dataclass\nCon: No default values (use total=False instead)\n\nWhy TypedDict: Integration results come from external libraries (scipy, etc.) as dictionaries. TypedDict lets us type them without conversion.\n\n\n\nDecision: Support NumPy, PyTorch, JAX (not TensorFlow)\nRationale:\n\nNumPy: Universal, stable, CPU\nPyTorch: Neural networks, GPU, mature ecosystem\nJAX: Functional, JIT, XLA, research-friendly\nTensorFlow: Skipped due to complexity, declining use in research\n\nWhy These Three: Cover 95% of use cases with minimal complexity.\n\n\n\nDecision: Use SymPy (not custom symbolic engine)\nRationale:\n\nPro: Mature, well-tested symbolic math\nPro: Excellent documentation\nPro: Large community\nCon: Can be slow for very large systems\nCon: Limited control over simplification\n\nWhy SymPy: Reinventing symbolic math is not our value proposition. SymPy is battle-tested.\n\n\n\nDecision: pytest (not unittest)\nRationale:\n\nPro: Less boilerplate\nPro: Better fixtures\nPro: Parametrized tests\nPro: Better assertions\n\nWhy pytest: Industry standard, developer-friendly."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#future-directions",
    "href": "api/ControlDESymulation_Design_Philosophy.html#future-directions",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Classical Control Theory\n\nStability, controllability, and observability metrics\nKalman Filter, Luenberger Observer design\nLinear Quadratic (Gaussian) Regulator control design\nCallable controllers\n\nVisualization\n\nPlotting using Plotly\n\nTrajectory visualization across all variables\nPhase portrait visualization in two or three dimensions\n\n\n\n\n\n\n\nRL Environment Synthesis\n\nInterfaces that satisfy Gymnasium library conventions\nExport of Gymnasium and/or PyBullet environments from symbolically defined dynamics\n\nSynthetic Data Generation\n\nClasses and methods for the generation and export of synthetic physical data in standard formats\n\nDiscretization:\n\nExact (matrix exponential)\nTustin (bilinear transform)\nForward/backward Euler\nZero-order hold\n\nParameter and Uncertainty Estimation\n\nSystem identification\nBayesian inference\nAdaptive control\nConformal methods\nSobol indices\nMorris screening\n\nNeural Controller Design\n\nProtocol interface for backend-agnostic functionality\nNeural controller training\nNeural certificate function construction and verification\n\nLyapunov, barrier, contraction metric\n\nForward and backward reachability analysis\n\nModel Predictive Control (MPC)\n\nReceding horizon optimization\nConstraint handling\nReal-time capable\nIntegration with do-mpc, CasADi, acados\n\nAdvanced Stochastic\n\nParticle filters\nStochastic MPC\nNoisy measurement models\nOther robust and/or stochastic control\n\nSystem Composition\n\nConnector protocol interfaces to couple multiple subsystems\n\n\n\n\n\n\nHybrid Systems\n\nSwitched dynamics\nHybrid automata\nJump/flow dynamics\n\nDistributed Systems\n\nMulti-agent dynamics\nNetwork topology\nConsensus protocols\n\nDelay Systems\n\nTime-delayed feedback\nDDE integration\nDelayed stability analysis\n\nPDE Systems\n\nSpatiotemporal dynamics\nFinite/discrete element methods\nSpectral methods"
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#conclusion",
    "href": "api/ControlDESymulation_Design_Philosophy.html#conclusion",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "ControlDESymulation demonstrates that mathematical rigor, software engineering excellence, and multi-backend performance are not competing goals—they are mutually reinforcing when built on a foundation of:\n\nType-Driven Design - Types are architecture\nComposition Over Inheritance - Build with utilities\nBackend Agnosticism - Write once, run anywhere\nZero Duplication - Strategic abstraction\nStructured Results - TypedDict everywhere\nProtocol Interfaces - Duck typing with safety\nFactory Patterns - Hide complexity\nSemantic Naming - Code reads like math\n\nThe result is a library where:\n\nControl theorists find familiar mathematics\nSoftware engineers find clean architecture\nML researchers find GPU acceleration\nStudents find gentle learning curves\nExperts find power and flexibility\n\n36,500 lines of code organized into 4 architectural layers, implementing 200+ types and 40+ integration methods—all serving a single vision: symbolic dynamical systems done right."
  },
  {
    "objectID": "api/ControlDESymulation_Design_Philosophy.html#appendix-statistics-summary",
    "href": "api/ControlDESymulation_Design_Philosophy.html#appendix-statistics-summary",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "Layer\nFiles\nLines\nPurpose\n\n\n\n\nType System\n7\n6,481\nFoundational types\n\n\nDelegation Layer\n11\n7,198\nService composition\n\n\nIntegration Framework\n13\n~10,000\nNumerical methods\n\n\nUI Framework\n8\n12,820\nUser interface\n\n\nTOTAL\n39\n~36,500\nComplete system\n\n\n\n\n\n\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nVector Types\n15+\nStateVector, ControlVector\n\n\nMatrix Types\n30+\nStateMatrix, GainMatrix\n\n\nFunction Types\n10+\nDynamicsFunction, ControlPolicy\n\n\nBackend Types\n20+\nBackend, Device, NoiseType\n\n\nTrajectory Types\n15+\nStateTrajectory, IntegrationResult\n\n\nLinearization Types\n15+\nDeterministicLinearization\n\n\nSymbolic Types\n10+\nSymbolicExpression\n\n\nProtocol Types\n20+\nDynamicalSystemProtocol\n\n\nUtility Types\n20+\nExecutionStats, TypeGuards\n\n\nTypedDict Results\n15+\nIntegrationResult\n\n\nTOTAL\n200+\nComplete type system\n\n\n\n\n\n\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nNumPy (scipy)\n6\nRK45, LSODA, BDF, Radau\n\n\nNumPy (Julia)\n20+\nTsit5, Vern9, Rodas5, AutoTsit5\n\n\nPyTorch\n8\ndopri5, dopri8, adaptive_heun\n\n\nJAX\n8\ntsit5, dopri5, heun, ralston\n\n\nFixed-step\n3\neuler, midpoint, rk4\n\n\nSDE Methods\n10+\neuler-maruyama, milstein, heun\n\n\nTOTAL\n55+\nComprehensive coverage\n\n\n\n\n\n\n\n\n\nPattern\nCount\nWhere Used\n\n\n\n\nTemplate Method\n8\nAll system base classes\n\n\nFactory Method\n2\nIntegrator/SDE factories\n\n\nStrategy\n55+\nAll integration methods\n\n\nDependency Injection\n11\nAll delegation utilities\n\n\nLazy Initialization\n7\nCode generation, caching\n\n\nObserver\n5\nPerformance statistics\n\n\nProtocol\n20+\nAll structural interfaces\n\n\n\nThe numbers tell the story: a comprehensive, well-architected library built on solid design principles."
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html",
    "href": "api/type_system/Type_System_Quick_Reference.html",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "# Core types\nfrom src.types.core import (\n    StateVector,\n    ControlVector,\n    StateMatrix,\n    InputMatrix,\n    GainMatrix,\n)\n\n# Backend types\nfrom src.types.backends import Backend, Device, IntegrationMethod\n\n# Result types\nfrom src.types.trajectories import (\n    IntegrationResult,\n    StateTrajectory,\n    TimePoints,\n)\n\n# Linearization types\nfrom src.types.linearization import (\n    LinearizationResult,\n    DeterministicLinearization,\n)\n\n# Control types\nfrom src.types.control_classical import (\n    LQRResult,\n    KalmanFilterResult,\n    LQGResult,\n    StabilityInfo,\n    ControllabilityInfo,\n    ObservabilityInfo,\n)\n\n\n\n\n\n\n# State vector (x)\nx: StateVector = np.array([1.0, 0.0])\n\n# Control vector (u)\nu: ControlVector = np.array([0.5])\n\n# Output vector (y)\ny: OutputVector = system.observe(x)\n\n# Noise vector (w)\nw: NoiseVector = np.random.randn(nw)\n\n# Equilibrium point\nx_eq: EquilibriumState = np.zeros(nx)\nu_eq: EquilibriumControl = np.zeros(nu)\n\n# State derivative\ndx: TimeDerivative = system(x, u)\n\n# State deviation\nδx: StateIncrement = x - x_eq\nδu: ControlIncrement = u - u_eq\n\n\n\n# Dynamics matrices\nA: StateMatrix = system.linearize(x_eq, u_eq)[0]  # ∂f/∂x (nx, nx)\nB: InputMatrix = system.linearize(x_eq, u_eq)[1]  # ∂f/∂u (nx, nu)\n\n# Observation matrices\nC: OutputMatrix = np.eye(nx)                       # ∂h/∂x (ny, nx)\nD: FeedthroughMatrix = np.zeros((ny, nu))         # Direct feedthrough\n\n# Control matrices\nK: GainMatrix = design_lqr(A, B, Q, R)            # Feedback gain (nu, nx)\nQ: CostMatrix = np.eye(nx)                        # State cost (nx, nx)\nR: ControlCostMatrix = np.eye(nu)                 # Control cost (nu, nu)\n\n# Stochastic matrices\nG: DiffusionMatrix = sde_system.diffusion(x, u)   # Noise (nx, nw)\nP: CovarianceMatrix = np.eye(nx)                  # Covariance (nx, nx)\n\n\n\n# Time values\nt: ScalarLike = 0.0\ndt: ScalarLike = 0.01\n\n# Dimensions\nnx: IntegerLike = 3\nnu: IntegerLike = 1\nny: IntegerLike = 2\nnw: IntegerLike = 1\n\n# System properties\norder: int = 2  # Second-order system\n\n\n\n\n\n\n# Backend type\nbackend: Backend = 'numpy'  # or 'torch', 'jax'\n\n# Device type\ndevice: Device = 'cuda:0'   # or 'cpu', 'mps'\n\n# Configuration\nconfig: BackendConfig = {\n    'backend': 'torch',\n    'device': 'cuda:0',\n    'dtype': 'float32'\n}\n\n\n\n# ODE methods\nmethod: IntegrationMethod = 'RK45'     # scipy\nmethod: IntegrationMethod = 'dopri5'   # torch/jax\nmethod: IntegrationMethod = 'Tsit5'    # Julia\n\n# SDE methods\nsde_method: str = 'euler-maruyama'\nsde_method: str = 'milstein'\nsde_method: str = 'heun'\n\n# Fixed-step methods\nfixed_method: str = 'rk4'\nfixed_method: str = 'euler'\n\n\n\nfrom src.types.backends import NoiseType, SDEType, ConvergenceType\n\n# Noise structure\nnoise_type = NoiseType.ADDITIVE\nnoise_type = NoiseType.MULTIPLICATIVE_DIAGONAL\n\n# SDE interpretation\nsde_type: SDEType = 'ito'\nsde_type: SDEType = 'stratonovich'\n\n# Convergence type\nconvergence: ConvergenceType = ConvergenceType.STRONG\nconvergence: ConvergenceType = ConvergenceType.WEAK\n\n\n\n\n\n\n# State trajectory\ntrajectory: StateTrajectory = system.simulate(x0, u_seq, steps=100)\n# Shape: (101, nx) - includes t=0\n\n# Batched trajectories\nbatch_traj: StateTrajectory = system.simulate_batch(x0_batch, u_seq)\n# Shape: (T, batch, nx)\n\n# Control sequence\nu_seq: ControlSequence = np.zeros((100, nu))\n# Shape: (T, nu)\n\n# Time points\ntime: TimePoints = np.linspace(0, 10, 101)\n# Shape: (T,)\n\n# Time span\nt_span: TimeSpan = (0.0, 10.0)\n\n# Extract components\nposition = trajectory[:, 0]  # First state component\nvelocity = trajectory[:, 1]  # Second state component\n\n\n\n# ODE integration\nresult: IntegrationResult = integrator.integrate(\n    x0=np.array([1.0, 0.0]),\n    u_func=lambda t, x: np.zeros(1),\n    t_span=(0.0, 10.0)\n)\n\n# Access fields\nt: TimePoints = result['t']\nx: StateTrajectory = result['x']\nsuccess: bool = result['success']\nnfev: int = result['nfev']\nsolver: str = result['solver']\n\n# Optional fields (adaptive)\nif 'njev' in result:\n    njev: int = result['njev']\n\n# SDE integration\nsde_result: SDEIntegrationResult = sde_integrator.integrate(\n    x0, u_func, t_span\n)\n\n# SDE-specific fields\ndiffusion_evals: int = sde_result['diffusion_evals']\nnoise_samples: NoiseVector = sde_result['noise_samples']\nn_paths: int = sde_result['n_paths']\n\n\n\n# Deterministic linearization\nA, B = system.linearize(x_eq, u_eq)\n# A: StateMatrix (nx, nx)\n# B: InputMatrix (nx, nu)\n\n# Type annotation\nresult: DeterministicLinearization = system.linearize(x_eq, u_eq)\n\n# Stochastic linearization\nA, B, G = sde_system.linearize(x_eq, u_eq)\n# G: DiffusionMatrix (nx, nw)\n\n# Type annotation\nresult: StochasticLinearization = sde_system.linearize(x_eq, u_eq)\n\n# Polymorphic handling\nresult: LinearizationResult = system.linearize(x_eq, u_eq)\nA, B = result[0], result[1]\nif len(result) == 3:\n    G = result[2]  # Stochastic\n\n# Output linearization\nC, D = system.linearized_observation(x_eq, u_eq)\n# C: OutputMatrix (ny, nx)\n# D: FeedthroughMatrix (ny, nu)\n\n# Full state-space\nA, B, C, D = system.full_linearization(x_eq, u_eq)\n\n\n\nfrom src.types.control_classical import (\n    LQRResult,\n    KalmanFilterResult,\n    LQGResult,\n    StabilityInfo,\n    ControllabilityInfo,\n    ObservabilityInfo,\n)\n\n# LQR controller design\nA, B = system.linearize(x_eq, u_eq)\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\n\nresult: LQRResult = system.control.design_lqr(\n    A, B, Q, R,\n    system_type='continuous'\n)\n\n# Access LQR result fields\nK: GainMatrix = result['gain']                    # Feedback gain (nu, nx)\nP: CovarianceMatrix = result['cost_to_go']        # Riccati solution (nx, nx)\neigs: np.ndarray = result['closed_loop_eigenvalues']  # (A-BK) eigenvalues\nmargin: float = result['stability_margin']        # Phase/gain margin\n\n# Check stability\nis_stable = np.all(np.real(eigs) &lt; 0)  # Continuous\nis_stable = np.all(np.abs(eigs) &lt; 1)   # Discrete\n\n# Kalman filter design\nC = np.array([[1, 0]])\nQ_proc = 0.01 * np.eye(2)\nR_meas = np.array([[0.1]])\n\nkalman: KalmanFilterResult = system.control.design_kalman(\n    A, C, Q_proc, R_meas,\n    system_type='discrete'\n)\n\n# Access Kalman result fields\nL: GainMatrix = kalman['gain']                     # Kalman gain (nx, ny)\nP_est: CovarianceMatrix = kalman['error_covariance']  # Error cov (nx, nx)\nS: CovarianceMatrix = kalman['innovation_covariance']  # Innovation (ny, ny)\nobs_eigs: np.ndarray = kalman['observer_eigenvalues']  # (A-LC) eigenvalues\n\n# LQG controller (combined)\nlqg: LQGResult = system.control.design_lqg(\n    A, B, C,\n    Q, R,           # LQR weights\n    Q_proc, R_meas,  # Kalman noise\n    system_type='discrete'\n)\n\n# Access LQG result fields\nK_lqr: GainMatrix = lqg['control_gain']           # LQR gain (nu, nx)\nL_kf: GainMatrix = lqg['estimator_gain']          # Kalman gain (nx, ny)\nP_ctrl: CovarianceMatrix = lqg['control_cost_to_go']  # Controller Riccati\nP_est: CovarianceMatrix = lqg['estimation_error_covariance']  # Estimator Riccati\nstable: bool = lqg['closed_loop_stable']          # Overall stability\nseparated: bool = lqg['separation_verified']      # Separation principle\nctrl_eigs: np.ndarray = lqg['controller_eigenvalues']  # (A-BK) eigenvalues\nest_eigs: np.ndarray = lqg['estimator_eigenvalues']    # (A-LC) eigenvalues\n\n\n\n# Stability analysis\nstability: StabilityInfo = analyze_stability(A, system_type='continuous')\n\n# Access stability fields\neigs: np.ndarray = stability['eigenvalues']          # Complex eigenvalues\nmags: np.ndarray = stability['magnitudes']           # |λ| values\nmax_mag: float = stability['max_magnitude']          # Spectral radius\nrho: float = stability['spectral_radius']            # Same as max_magnitude\nis_stable: bool = stability['is_stable']             # Asymptotically stable\nis_marginal: bool = stability['is_marginally_stable']  # On stability boundary\nis_unstable: bool = stability['is_unstable']         # Unstable\n\n# Controllability analysis\nctrl: ControllabilityInfo = analyze_controllability(A, B)\n\n# Access controllability fields\nC_matrix: ControllabilityMatrix = ctrl['controllability_matrix']  # (nx, nx*nu)\nrank: int = ctrl['rank']                             # Rank of C_matrix\ncontrollable: bool = ctrl['is_controllable']         # rank == nx\nif 'uncontrollable_modes' in ctrl:\n    uncontrol_modes: np.ndarray = ctrl['uncontrollable_modes']  # Eigenvalues\n\n# Observability analysis\nobs: ObservabilityInfo = analyze_observability(A, C)\n\n# Access observability fields\nO_matrix: ObservabilityMatrix = obs['observability_matrix']  # (nx*ny, nx)\nrank: int = obs['rank']                              # Rank of O_matrix\nobservable: bool = obs['is_observable']              # rank == nx\nif 'unobservable_modes' in obs:\n    unobs_modes: np.ndarray = obs['unobservable_modes']  # Eigenvalues\n\n\n\n\nimport sympy as sp\nfrom src.types.symbolic import (\n    SymbolicVariable,\n    SymbolicVector,\n    DynamicsExpression,\n    ParameterDict,\n)\n\n# Variables\nx, v = sp.symbols('x v', real=True)\nu = sp.symbols('u', real=True)\n\n# Parameters\nm, k = sp.symbols('m k', positive=True)\nparams: ParameterDict = {m: 1.0, k: 10.0}\n\n# Dynamics expression\nf_sym: DynamicsExpression = sp.Matrix([\n    v,\n    -k*x/m + u/m\n])\n\n# Output expression\nh_sym: OutputExpression = sp.Matrix([x])\n\n# Diffusion expression\ng_sym: DiffusionExpression = sp.Matrix([[0], [0.1]])\n\n\n\n\n\nfrom src.types.protocols import (\n    DynamicalSystemProtocol,\n    ContinuousSystemProtocol,\n    StochasticSystemProtocol,\n)\n\n# Use in type hints\ndef analyze(system: DynamicalSystemProtocol):\n    \"\"\"Works with any system satisfying the protocol.\"\"\"\n    print(f\"State dim: {system.nx}\")\n    print(f\"Control dim: {system.nu}\")\n    dx = system(np.zeros(system.nx), np.zeros(system.nu))\n\n# No inheritance needed!\nclass MySystem:\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property\n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally\nsystem: DynamicalSystemProtocol = MySystem()\nanalyze(system)  # Works!\n\n\n\nfrom src.types.utilities import (\n    is_numpy,\n    is_torch,\n    is_jax,\n    is_batched,\n    get_batch_size,\n    ExecutionStats,\n)\n\n# Type guards\nx = torch.tensor([1.0, 0.0])\nif is_torch(x):\n    # Type narrowed to torch.Tensor\n    x_cuda = x.cuda()\n\n# Shape utilities\nx_batch = np.random.randn(100, 2)\nif is_batched(x_batch):\n    batch_size = get_batch_size(x_batch)  # 100\n\n# Performance tracking\nstats: ExecutionStats = {\n    'count': 1000,\n    'total_time': 0.5,\n    'avg_time': 0.0005,\n    'min_time': 0.0003,\n    'max_time': 0.001\n}\n\n\n\n\n\n\ndef compute_control(\n    x: StateVector,\n    K: GainMatrix,\n    x_eq: EquilibriumState\n) -&gt; ControlVector:\n    \"\"\"Compute LQR feedback control.\"\"\"\n    return -K @ (x - x_eq)\n\n# Usage\nx = np.array([1.0, 0.5])\nK = np.array([[1.0, 0.5]])\nx_eq = np.zeros(2)\nu = compute_control(x, K, x_eq)  # Type-safe!\n\n\n\ndef dynamics(\n    x: StateVector,\n    u: ControlVector,\n    backend: Backend\n) -&gt; StateVector:\n    \"\"\"Works with NumPy, PyTorch, JAX.\"\"\"\n    # Backend-specific operations auto-detected\n    if backend == 'torch':\n        return torch.sin(x) + u\n    elif backend == 'jax':\n        return jnp.sin(x) + u\n    else:\n        return np.sin(x) + u\n\n\n\ndef integrate_and_analyze(\n    system,\n    x0: StateVector,\n    t_span: TimeSpan\n) -&gt; Dict[str, Any]:\n    \"\"\"Integration with structured output.\"\"\"\n    result: IntegrationResult = system.integrate(\n        x0, lambda t, x: np.zeros(system.nu), t_span\n    )\n    \n    return {\n        'trajectory': result['x'],\n        'time': result['t'],\n        'success': result['success'],\n        'performance': {\n            'nfev': result['nfev'],\n            'time': result['integration_time']\n        }\n    }\n\n\n\ndef stability_analysis(\n    system: Union[ContinuousSystemProtocol, StochasticSystemProtocol],\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Dict[str, Any]:\n    \"\"\"Works with deterministic AND stochastic systems.\"\"\"\n    result: LinearizationResult = system.linearize(x_eq, u_eq)\n    \n    A = result[0]\n    eigenvalues = np.linalg.eigvals(A)\n    \n    analysis = {\n        'eigenvalues': eigenvalues,\n        'stable': np.all(np.real(eigenvalues) &lt; 0),\n        'is_stochastic': len(result) == 3\n    }\n    \n    if len(result) == 3:\n        G = result[2]\n        analysis['process_noise_cov'] = G @ G.T\n    \n    return analysis\n\n\n\nfrom src.types.utilities import is_batched\n\ndef process(x: StateVector) -&gt; StateVector:\n    \"\"\"Handle both single and batched inputs.\"\"\"\n    if is_batched(x):\n        # x has shape (batch, nx)\n        batch_size = get_batch_size(x)\n        result = np.array([process_single(x[i]) for i in range(batch_size)])\n    else:\n        # x has shape (nx,)\n        result = process_single(x)\n    \n    return result\n\n\n\n\n\n\n# Install mypy\npip install mypy\n\n# Check types\nmypy src/\n\n# Strict mode\nmypy --strict src/systems/\n\n\n\n# Install pyright\nnpm install -g pyright\n\n# Check types\npyright src/\n\n\n\nError: Incompatible types\n# Bad\nx: StateVector = [1.0, 0.0]  # List, not array\n\n# Good\nx: StateVector = np.array([1.0, 0.0])\nError: Missing required key\n# Bad (missing 'success')\nresult: IntegrationResult = {'t': t, 'x': x}\n\n# Good\nresult: IntegrationResult = {\n    't': t,\n    'x': x,\n    'success': True,\n    'message': 'Integration succeeded',\n    'nfev': 100,\n    'nsteps': 50,\n    'integration_time': 0.5,\n    'solver': 'RK45'\n}\nError: Wrong shape\n# Type hint documents expected shape\ndef compute(A: StateMatrix, x: StateVector) -&gt; StateVector:\n    # A should be (nx, nx), x should be (nx,)\n    return A @ x\n\n# Bad\nA = np.array([[1, 2]])  # (1, 2) - wrong shape!\n\n# Good\nA = np.array([[1, 2], [3, 4]])  # (2, 2) - correct!\n\n\n\n\n\n\nfrom typing_extensions import TypedDict\n\nclass SimulationConfig(TypedDict, total=False):\n    \"\"\"Custom simulation configuration.\"\"\"\n    x0: StateVector\n    t_span: TimeSpan\n    method: IntegrationMethod\n    rtol: float\n    atol: float\n\n# Usage\nconfig: SimulationConfig = {\n    'x0': np.array([1.0, 0.0]),\n    't_span': (0.0, 10.0),\n    'method': 'RK45'\n}\n\n\n\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T', np.ndarray, torch.Tensor, jnp.ndarray)\n\nclass Trajectory(Generic[T]):\n    \"\"\"Generic trajectory for any backend.\"\"\"\n    def __init__(self, data: T):\n        self.data = data\n    \n    def get_final_state(self) -&gt; T:\n        return self.data[-1]\n\n# Usage\nnp_traj = Trajectory[np.ndarray](np_data)\ntorch_traj = Trajectory[torch.Tensor](torch_data)\n\n\n\nfrom src.types.protocols import (\n    DynamicalSystemProtocol,\n    ObservableSystemProtocol,\n)\n\nclass FullSystem(DynamicalSystemProtocol, ObservableSystemProtocol, Protocol):\n    \"\"\"Combined protocol.\"\"\"\n    pass\n\ndef process(system: FullSystem):\n    \"\"\"Requires both dynamics and observation.\"\"\"\n    x = np.zeros(system.nx)\n    dx = system(x, np.zeros(system.nu))\n    y = system.observe(x)\n\n\n\n\ndef test_dynamics_signature():\n    \"\"\"Test that dynamics has correct signature.\"\"\"\n    system = MySystem()\n    \n    x: StateVector = np.array([1.0, 0.0])\n    u: ControlVector = np.array([0.5])\n    \n    # Type checker ensures this is valid\n    dx: StateVector = system(x, u)\n    \n    # Runtime checks\n    assert isinstance(dx, np.ndarray)\n    assert dx.shape == (system.nx,)\n\ndef test_integration_result():\n    \"\"\"Test integration result structure.\"\"\"\n    result: IntegrationResult = integrator.integrate(x0, u_func, t_span)\n    \n    # Type checker ensures these keys exist\n    assert result['success']\n    assert result['t'].shape[0] == result['x'].shape[0]\n    assert result['solver'] == 'RK45'\n\n\n\n\nArchitecture: See Type_System_Architecture.md\nCore Types: See src/types/core.py\nBackend Types: See src/types/backends.py\nResult Types: See src/types/trajectories.py\nControl Types: See src/types/control_classical.py\nProtocols: See src/types/protocols.py"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#quick-start",
    "href": "api/type_system/Type_System_Quick_Reference.html#quick-start",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "# Core types\nfrom src.types.core import (\n    StateVector,\n    ControlVector,\n    StateMatrix,\n    InputMatrix,\n    GainMatrix,\n)\n\n# Backend types\nfrom src.types.backends import Backend, Device, IntegrationMethod\n\n# Result types\nfrom src.types.trajectories import (\n    IntegrationResult,\n    StateTrajectory,\n    TimePoints,\n)\n\n# Linearization types\nfrom src.types.linearization import (\n    LinearizationResult,\n    DeterministicLinearization,\n)\n\n# Control types\nfrom src.types.control_classical import (\n    LQRResult,\n    KalmanFilterResult,\n    LQGResult,\n    StabilityInfo,\n    ControllabilityInfo,\n    ObservabilityInfo,\n)"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#foundational-types",
    "href": "api/type_system/Type_System_Quick_Reference.html#foundational-types",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "# State vector (x)\nx: StateVector = np.array([1.0, 0.0])\n\n# Control vector (u)\nu: ControlVector = np.array([0.5])\n\n# Output vector (y)\ny: OutputVector = system.observe(x)\n\n# Noise vector (w)\nw: NoiseVector = np.random.randn(nw)\n\n# Equilibrium point\nx_eq: EquilibriumState = np.zeros(nx)\nu_eq: EquilibriumControl = np.zeros(nu)\n\n# State derivative\ndx: TimeDerivative = system(x, u)\n\n# State deviation\nδx: StateIncrement = x - x_eq\nδu: ControlIncrement = u - u_eq\n\n\n\n# Dynamics matrices\nA: StateMatrix = system.linearize(x_eq, u_eq)[0]  # ∂f/∂x (nx, nx)\nB: InputMatrix = system.linearize(x_eq, u_eq)[1]  # ∂f/∂u (nx, nu)\n\n# Observation matrices\nC: OutputMatrix = np.eye(nx)                       # ∂h/∂x (ny, nx)\nD: FeedthroughMatrix = np.zeros((ny, nu))         # Direct feedthrough\n\n# Control matrices\nK: GainMatrix = design_lqr(A, B, Q, R)            # Feedback gain (nu, nx)\nQ: CostMatrix = np.eye(nx)                        # State cost (nx, nx)\nR: ControlCostMatrix = np.eye(nu)                 # Control cost (nu, nu)\n\n# Stochastic matrices\nG: DiffusionMatrix = sde_system.diffusion(x, u)   # Noise (nx, nw)\nP: CovarianceMatrix = np.eye(nx)                  # Covariance (nx, nx)\n\n\n\n# Time values\nt: ScalarLike = 0.0\ndt: ScalarLike = 0.01\n\n# Dimensions\nnx: IntegerLike = 3\nnu: IntegerLike = 1\nny: IntegerLike = 2\nnw: IntegerLike = 1\n\n# System properties\norder: int = 2  # Second-order system"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#backend-types",
    "href": "api/type_system/Type_System_Quick_Reference.html#backend-types",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "# Backend type\nbackend: Backend = 'numpy'  # or 'torch', 'jax'\n\n# Device type\ndevice: Device = 'cuda:0'   # or 'cpu', 'mps'\n\n# Configuration\nconfig: BackendConfig = {\n    'backend': 'torch',\n    'device': 'cuda:0',\n    'dtype': 'float32'\n}\n\n\n\n# ODE methods\nmethod: IntegrationMethod = 'RK45'     # scipy\nmethod: IntegrationMethod = 'dopri5'   # torch/jax\nmethod: IntegrationMethod = 'Tsit5'    # Julia\n\n# SDE methods\nsde_method: str = 'euler-maruyama'\nsde_method: str = 'milstein'\nsde_method: str = 'heun'\n\n# Fixed-step methods\nfixed_method: str = 'rk4'\nfixed_method: str = 'euler'\n\n\n\nfrom src.types.backends import NoiseType, SDEType, ConvergenceType\n\n# Noise structure\nnoise_type = NoiseType.ADDITIVE\nnoise_type = NoiseType.MULTIPLICATIVE_DIAGONAL\n\n# SDE interpretation\nsde_type: SDEType = 'ito'\nsde_type: SDEType = 'stratonovich'\n\n# Convergence type\nconvergence: ConvergenceType = ConvergenceType.STRONG\nconvergence: ConvergenceType = ConvergenceType.WEAK"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#domain-types",
    "href": "api/type_system/Type_System_Quick_Reference.html#domain-types",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "# State trajectory\ntrajectory: StateTrajectory = system.simulate(x0, u_seq, steps=100)\n# Shape: (101, nx) - includes t=0\n\n# Batched trajectories\nbatch_traj: StateTrajectory = system.simulate_batch(x0_batch, u_seq)\n# Shape: (T, batch, nx)\n\n# Control sequence\nu_seq: ControlSequence = np.zeros((100, nu))\n# Shape: (T, nu)\n\n# Time points\ntime: TimePoints = np.linspace(0, 10, 101)\n# Shape: (T,)\n\n# Time span\nt_span: TimeSpan = (0.0, 10.0)\n\n# Extract components\nposition = trajectory[:, 0]  # First state component\nvelocity = trajectory[:, 1]  # Second state component\n\n\n\n# ODE integration\nresult: IntegrationResult = integrator.integrate(\n    x0=np.array([1.0, 0.0]),\n    u_func=lambda t, x: np.zeros(1),\n    t_span=(0.0, 10.0)\n)\n\n# Access fields\nt: TimePoints = result['t']\nx: StateTrajectory = result['x']\nsuccess: bool = result['success']\nnfev: int = result['nfev']\nsolver: str = result['solver']\n\n# Optional fields (adaptive)\nif 'njev' in result:\n    njev: int = result['njev']\n\n# SDE integration\nsde_result: SDEIntegrationResult = sde_integrator.integrate(\n    x0, u_func, t_span\n)\n\n# SDE-specific fields\ndiffusion_evals: int = sde_result['diffusion_evals']\nnoise_samples: NoiseVector = sde_result['noise_samples']\nn_paths: int = sde_result['n_paths']\n\n\n\n# Deterministic linearization\nA, B = system.linearize(x_eq, u_eq)\n# A: StateMatrix (nx, nx)\n# B: InputMatrix (nx, nu)\n\n# Type annotation\nresult: DeterministicLinearization = system.linearize(x_eq, u_eq)\n\n# Stochastic linearization\nA, B, G = sde_system.linearize(x_eq, u_eq)\n# G: DiffusionMatrix (nx, nw)\n\n# Type annotation\nresult: StochasticLinearization = sde_system.linearize(x_eq, u_eq)\n\n# Polymorphic handling\nresult: LinearizationResult = system.linearize(x_eq, u_eq)\nA, B = result[0], result[1]\nif len(result) == 3:\n    G = result[2]  # Stochastic\n\n# Output linearization\nC, D = system.linearized_observation(x_eq, u_eq)\n# C: OutputMatrix (ny, nx)\n# D: FeedthroughMatrix (ny, nu)\n\n# Full state-space\nA, B, C, D = system.full_linearization(x_eq, u_eq)\n\n\n\nfrom src.types.control_classical import (\n    LQRResult,\n    KalmanFilterResult,\n    LQGResult,\n    StabilityInfo,\n    ControllabilityInfo,\n    ObservabilityInfo,\n)\n\n# LQR controller design\nA, B = system.linearize(x_eq, u_eq)\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\n\nresult: LQRResult = system.control.design_lqr(\n    A, B, Q, R,\n    system_type='continuous'\n)\n\n# Access LQR result fields\nK: GainMatrix = result['gain']                    # Feedback gain (nu, nx)\nP: CovarianceMatrix = result['cost_to_go']        # Riccati solution (nx, nx)\neigs: np.ndarray = result['closed_loop_eigenvalues']  # (A-BK) eigenvalues\nmargin: float = result['stability_margin']        # Phase/gain margin\n\n# Check stability\nis_stable = np.all(np.real(eigs) &lt; 0)  # Continuous\nis_stable = np.all(np.abs(eigs) &lt; 1)   # Discrete\n\n# Kalman filter design\nC = np.array([[1, 0]])\nQ_proc = 0.01 * np.eye(2)\nR_meas = np.array([[0.1]])\n\nkalman: KalmanFilterResult = system.control.design_kalman(\n    A, C, Q_proc, R_meas,\n    system_type='discrete'\n)\n\n# Access Kalman result fields\nL: GainMatrix = kalman['gain']                     # Kalman gain (nx, ny)\nP_est: CovarianceMatrix = kalman['error_covariance']  # Error cov (nx, nx)\nS: CovarianceMatrix = kalman['innovation_covariance']  # Innovation (ny, ny)\nobs_eigs: np.ndarray = kalman['observer_eigenvalues']  # (A-LC) eigenvalues\n\n# LQG controller (combined)\nlqg: LQGResult = system.control.design_lqg(\n    A, B, C,\n    Q, R,           # LQR weights\n    Q_proc, R_meas,  # Kalman noise\n    system_type='discrete'\n)\n\n# Access LQG result fields\nK_lqr: GainMatrix = lqg['control_gain']           # LQR gain (nu, nx)\nL_kf: GainMatrix = lqg['estimator_gain']          # Kalman gain (nx, ny)\nP_ctrl: CovarianceMatrix = lqg['control_cost_to_go']  # Controller Riccati\nP_est: CovarianceMatrix = lqg['estimation_error_covariance']  # Estimator Riccati\nstable: bool = lqg['closed_loop_stable']          # Overall stability\nseparated: bool = lqg['separation_verified']      # Separation principle\nctrl_eigs: np.ndarray = lqg['controller_eigenvalues']  # (A-BK) eigenvalues\nest_eigs: np.ndarray = lqg['estimator_eigenvalues']    # (A-LC) eigenvalues\n\n\n\n# Stability analysis\nstability: StabilityInfo = analyze_stability(A, system_type='continuous')\n\n# Access stability fields\neigs: np.ndarray = stability['eigenvalues']          # Complex eigenvalues\nmags: np.ndarray = stability['magnitudes']           # |λ| values\nmax_mag: float = stability['max_magnitude']          # Spectral radius\nrho: float = stability['spectral_radius']            # Same as max_magnitude\nis_stable: bool = stability['is_stable']             # Asymptotically stable\nis_marginal: bool = stability['is_marginally_stable']  # On stability boundary\nis_unstable: bool = stability['is_unstable']         # Unstable\n\n# Controllability analysis\nctrl: ControllabilityInfo = analyze_controllability(A, B)\n\n# Access controllability fields\nC_matrix: ControllabilityMatrix = ctrl['controllability_matrix']  # (nx, nx*nu)\nrank: int = ctrl['rank']                             # Rank of C_matrix\ncontrollable: bool = ctrl['is_controllable']         # rank == nx\nif 'uncontrollable_modes' in ctrl:\n    uncontrol_modes: np.ndarray = ctrl['uncontrollable_modes']  # Eigenvalues\n\n# Observability analysis\nobs: ObservabilityInfo = analyze_observability(A, C)\n\n# Access observability fields\nO_matrix: ObservabilityMatrix = obs['observability_matrix']  # (nx*ny, nx)\nrank: int = obs['rank']                              # Rank of O_matrix\nobservable: bool = obs['is_observable']              # rank == nx\nif 'unobservable_modes' in obs:\n    unobs_modes: np.ndarray = obs['unobservable_modes']  # Eigenvalues"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#symbolic-types",
    "href": "api/type_system/Type_System_Quick_Reference.html#symbolic-types",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "import sympy as sp\nfrom src.types.symbolic import (\n    SymbolicVariable,\n    SymbolicVector,\n    DynamicsExpression,\n    ParameterDict,\n)\n\n# Variables\nx, v = sp.symbols('x v', real=True)\nu = sp.symbols('u', real=True)\n\n# Parameters\nm, k = sp.symbols('m k', positive=True)\nparams: ParameterDict = {m: 1.0, k: 10.0}\n\n# Dynamics expression\nf_sym: DynamicsExpression = sp.Matrix([\n    v,\n    -k*x/m + u/m\n])\n\n# Output expression\nh_sym: OutputExpression = sp.Matrix([x])\n\n# Diffusion expression\ng_sym: DiffusionExpression = sp.Matrix([[0], [0.1]])"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#structural-types",
    "href": "api/type_system/Type_System_Quick_Reference.html#structural-types",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "from src.types.protocols import (\n    DynamicalSystemProtocol,\n    ContinuousSystemProtocol,\n    StochasticSystemProtocol,\n)\n\n# Use in type hints\ndef analyze(system: DynamicalSystemProtocol):\n    \"\"\"Works with any system satisfying the protocol.\"\"\"\n    print(f\"State dim: {system.nx}\")\n    print(f\"Control dim: {system.nu}\")\n    dx = system(np.zeros(system.nx), np.zeros(system.nu))\n\n# No inheritance needed!\nclass MySystem:\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property\n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally\nsystem: DynamicalSystemProtocol = MySystem()\nanalyze(system)  # Works!\n\n\n\nfrom src.types.utilities import (\n    is_numpy,\n    is_torch,\n    is_jax,\n    is_batched,\n    get_batch_size,\n    ExecutionStats,\n)\n\n# Type guards\nx = torch.tensor([1.0, 0.0])\nif is_torch(x):\n    # Type narrowed to torch.Tensor\n    x_cuda = x.cuda()\n\n# Shape utilities\nx_batch = np.random.randn(100, 2)\nif is_batched(x_batch):\n    batch_size = get_batch_size(x_batch)  # 100\n\n# Performance tracking\nstats: ExecutionStats = {\n    'count': 1000,\n    'total_time': 0.5,\n    'avg_time': 0.0005,\n    'min_time': 0.0003,\n    'max_time': 0.001\n}"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#common-patterns",
    "href": "api/type_system/Type_System_Quick_Reference.html#common-patterns",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "def compute_control(\n    x: StateVector,\n    K: GainMatrix,\n    x_eq: EquilibriumState\n) -&gt; ControlVector:\n    \"\"\"Compute LQR feedback control.\"\"\"\n    return -K @ (x - x_eq)\n\n# Usage\nx = np.array([1.0, 0.5])\nK = np.array([[1.0, 0.5]])\nx_eq = np.zeros(2)\nu = compute_control(x, K, x_eq)  # Type-safe!\n\n\n\ndef dynamics(\n    x: StateVector,\n    u: ControlVector,\n    backend: Backend\n) -&gt; StateVector:\n    \"\"\"Works with NumPy, PyTorch, JAX.\"\"\"\n    # Backend-specific operations auto-detected\n    if backend == 'torch':\n        return torch.sin(x) + u\n    elif backend == 'jax':\n        return jnp.sin(x) + u\n    else:\n        return np.sin(x) + u\n\n\n\ndef integrate_and_analyze(\n    system,\n    x0: StateVector,\n    t_span: TimeSpan\n) -&gt; Dict[str, Any]:\n    \"\"\"Integration with structured output.\"\"\"\n    result: IntegrationResult = system.integrate(\n        x0, lambda t, x: np.zeros(system.nu), t_span\n    )\n    \n    return {\n        'trajectory': result['x'],\n        'time': result['t'],\n        'success': result['success'],\n        'performance': {\n            'nfev': result['nfev'],\n            'time': result['integration_time']\n        }\n    }\n\n\n\ndef stability_analysis(\n    system: Union[ContinuousSystemProtocol, StochasticSystemProtocol],\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Dict[str, Any]:\n    \"\"\"Works with deterministic AND stochastic systems.\"\"\"\n    result: LinearizationResult = system.linearize(x_eq, u_eq)\n    \n    A = result[0]\n    eigenvalues = np.linalg.eigvals(A)\n    \n    analysis = {\n        'eigenvalues': eigenvalues,\n        'stable': np.all(np.real(eigenvalues) &lt; 0),\n        'is_stochastic': len(result) == 3\n    }\n    \n    if len(result) == 3:\n        G = result[2]\n        analysis['process_noise_cov'] = G @ G.T\n    \n    return analysis\n\n\n\nfrom src.types.utilities import is_batched\n\ndef process(x: StateVector) -&gt; StateVector:\n    \"\"\"Handle both single and batched inputs.\"\"\"\n    if is_batched(x):\n        # x has shape (batch, nx)\n        batch_size = get_batch_size(x)\n        result = np.array([process_single(x[i]) for i in range(batch_size)])\n    else:\n        # x has shape (nx,)\n        result = process_single(x)\n    \n    return result"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#type-checking",
    "href": "api/type_system/Type_System_Quick_Reference.html#type-checking",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "# Install mypy\npip install mypy\n\n# Check types\nmypy src/\n\n# Strict mode\nmypy --strict src/systems/\n\n\n\n# Install pyright\nnpm install -g pyright\n\n# Check types\npyright src/\n\n\n\nError: Incompatible types\n# Bad\nx: StateVector = [1.0, 0.0]  # List, not array\n\n# Good\nx: StateVector = np.array([1.0, 0.0])\nError: Missing required key\n# Bad (missing 'success')\nresult: IntegrationResult = {'t': t, 'x': x}\n\n# Good\nresult: IntegrationResult = {\n    't': t,\n    'x': x,\n    'success': True,\n    'message': 'Integration succeeded',\n    'nfev': 100,\n    'nsteps': 50,\n    'integration_time': 0.5,\n    'solver': 'RK45'\n}\nError: Wrong shape\n# Type hint documents expected shape\ndef compute(A: StateMatrix, x: StateVector) -&gt; StateVector:\n    # A should be (nx, nx), x should be (nx,)\n    return A @ x\n\n# Bad\nA = np.array([[1, 2]])  # (1, 2) - wrong shape!\n\n# Good\nA = np.array([[1, 2], [3, 4]])  # (2, 2) - correct!"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#advanced-usage",
    "href": "api/type_system/Type_System_Quick_Reference.html#advanced-usage",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "from typing_extensions import TypedDict\n\nclass SimulationConfig(TypedDict, total=False):\n    \"\"\"Custom simulation configuration.\"\"\"\n    x0: StateVector\n    t_span: TimeSpan\n    method: IntegrationMethod\n    rtol: float\n    atol: float\n\n# Usage\nconfig: SimulationConfig = {\n    'x0': np.array([1.0, 0.0]),\n    't_span': (0.0, 10.0),\n    'method': 'RK45'\n}\n\n\n\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T', np.ndarray, torch.Tensor, jnp.ndarray)\n\nclass Trajectory(Generic[T]):\n    \"\"\"Generic trajectory for any backend.\"\"\"\n    def __init__(self, data: T):\n        self.data = data\n    \n    def get_final_state(self) -&gt; T:\n        return self.data[-1]\n\n# Usage\nnp_traj = Trajectory[np.ndarray](np_data)\ntorch_traj = Trajectory[torch.Tensor](torch_data)\n\n\n\nfrom src.types.protocols import (\n    DynamicalSystemProtocol,\n    ObservableSystemProtocol,\n)\n\nclass FullSystem(DynamicalSystemProtocol, ObservableSystemProtocol, Protocol):\n    \"\"\"Combined protocol.\"\"\"\n    pass\n\ndef process(system: FullSystem):\n    \"\"\"Requires both dynamics and observation.\"\"\"\n    x = np.zeros(system.nx)\n    dx = system(x, np.zeros(system.nu))\n    y = system.observe(x)"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#testing-with-types",
    "href": "api/type_system/Type_System_Quick_Reference.html#testing-with-types",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "def test_dynamics_signature():\n    \"\"\"Test that dynamics has correct signature.\"\"\"\n    system = MySystem()\n    \n    x: StateVector = np.array([1.0, 0.0])\n    u: ControlVector = np.array([0.5])\n    \n    # Type checker ensures this is valid\n    dx: StateVector = system(x, u)\n    \n    # Runtime checks\n    assert isinstance(dx, np.ndarray)\n    assert dx.shape == (system.nx,)\n\ndef test_integration_result():\n    \"\"\"Test integration result structure.\"\"\"\n    result: IntegrationResult = integrator.integrate(x0, u_func, t_span)\n    \n    # Type checker ensures these keys exist\n    assert result['success']\n    assert result['t'].shape[0] == result['x'].shape[0]\n    assert result['solver'] == 'RK45'"
  },
  {
    "objectID": "api/type_system/Type_System_Quick_Reference.html#references",
    "href": "api/type_system/Type_System_Quick_Reference.html#references",
    "title": "Type System Quick Reference",
    "section": "",
    "text": "Architecture: See Type_System_Architecture.md\nCore Types: See src/types/core.py\nBackend Types: See src/types/backends.py\nResult Types: See src/types/trajectories.py\nControl Types: See src/types/control_classical.py\nProtocols: See src/types/protocols.py"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "from src.systems.base.numerical_integration import IntegratorFactory\n\n# Let the factory choose the best integrator\nintegrator = IntegratorFactory.auto(system)\n\n# Integrate\nresult = integrator.integrate(\n    x0=np.array([1.0, 0.0]),\n    u_func=lambda t, x: np.zeros(1),\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"Success: {result['success']}\")\nprint(f\"Method: {result['solver']}\")\n\n\n\n# Create with specific method\nintegrator = IntegratorFactory.create(\n    system,\n    backend='numpy',\n    method='RK45',\n    rtol=1e-6,\n    atol=1e-8\n)\n\n\n\n# For production\nintegrator = IntegratorFactory.for_production(system)\n\n# For optimization (JAX)\nintegrator = IntegratorFactory.for_optimization(system)\n\n# For neural ODEs (PyTorch)\nintegrator = IntegratorFactory.for_neural_ode(system)\n\n# For Julia (highest performance)\nintegrator = IntegratorFactory.for_julia(system, algorithm='Vern9')\n\n\n\n\n\n\n# Adaptive non-stiff\nIntegratorFactory.create(system, backend='numpy', method='RK45')   # General\nIntegratorFactory.create(system, backend='numpy', method='RK23')   # Fast\nIntegratorFactory.create(system, backend='numpy', method='DOP853') # Accurate\n\n# Adaptive stiff\nIntegratorFactory.create(system, backend='numpy', method='Radau')  # Stiff\nIntegratorFactory.create(system, backend='numpy', method='BDF')    # Very stiff\nIntegratorFactory.create(system, backend='numpy', method='LSODA')  # Auto-stiffness ⭐\n\n\n\n# High-order explicit\nIntegratorFactory.create(system, backend='numpy', method='Tsit5')  # 5th order ⭐\nIntegratorFactory.create(system, backend='numpy', method='Vern9')  # 9th order\nIntegratorFactory.create(system, backend='numpy', method='DP8')    # Dormand-Prince 8\n\n# Rosenbrock (stiff)\nIntegratorFactory.create(system, backend='numpy', method='Rodas5')  # Best stiff ⭐\nIntegratorFactory.create(system, backend='numpy', method='Rosenbrock23')\n\n# Auto-switching\nIntegratorFactory.create(system, backend='numpy', method='AutoTsit5(Rosenbrock23())')\n\n\n\n# Adaptive methods\nIntegratorFactory.create(system, backend='torch', method='dopri5')  # 5(4) ⭐\nIntegratorFactory.create(system, backend='torch', method='dopri8')  # 8\nIntegratorFactory.create(system, backend='torch', method='bosh3')   # 3\n\n# With adjoint for memory efficiency\nintegrator = TorchDiffEqIntegrator(\n    system,\n    method='dopri5',\n    adjoint=True  # For neural ODEs\n)\n\n\n\n# Adaptive methods\nIntegratorFactory.create(system, backend='jax', method='tsit5')   # Best ⭐\nIntegratorFactory.create(system, backend='jax', method='dopri5')  # Alternative\nIntegratorFactory.create(system, backend='jax', method='dopri8')  # High accuracy\n\n\n\n# Simple methods\nIntegratorFactory.create(system, backend='numpy', method='rk4', dt=0.01)\nIntegratorFactory.create(system, backend='numpy', method='euler', dt=0.01)\nIntegratorFactory.create(system, backend='numpy', method='midpoint', dt=0.01)\n\n\n\n\n\n\nfrom src.systems.base.numerical_integration.stochastic import SDEIntegratorFactory\n\n# Automatic selection based on noise type\nintegrator = SDEIntegratorFactory.auto(sde_system)\n\n# Specific method\nintegrator = SDEIntegratorFactory.create(\n    sde_system,\n    backend='torch',\n    method='heun',\n    dt=0.01,\n    seed=42\n)\n\n\n\nresult = integrator.integrate(\n    x0=np.array([1.0]),\n    u_func=lambda t, x: None,  # Autonomous\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"SDE type: {result['sde_type']}\")\nprint(f\"Noise type: {result['noise_type']}\")\nprint(f\"Diffusion evals: {result['diffusion_evals']}\")\n\n\n\n# Multiple trajectories for statistics\nresult = integrator.integrate_monte_carlo(\n    x0=np.array([1.0]),\n    u_func=lambda t, x: None,\n    t_span=(0.0, 10.0),\n    n_paths=1000  # 1000 trajectories\n)\n\n# Get statistics\nfrom src.systems.base.numerical_integration.sde_integrator_base import (\n    get_trajectory_statistics\n)\nstats = get_trajectory_statistics(result)\n\nprint(f\"Mean: {stats['mean'][-1]}\")\nprint(f\"Std: {stats['std'][-1]}\")\nprint(f\"Median: {stats['median'][-1]}\")\n\n\n\nimport jax.numpy as jnp\nfrom src.systems.base.numerical_integration.stochastic.custom_brownian import (\n    CustomBrownianPath\n)\n\n# Zero noise for testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(0.0, 0.01, dW)\n\n# Use in integration\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 1),\n    brownian_path=brownian\n)\n\n\n\n\n\n\nimport torch\n\n# Set system to use PyTorch backend\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# Create integrator\nintegrator = IntegratorFactory.create(\n    system,\n    backend='torch',\n    method='dopri5'\n)\n\n# Data on GPU\nx0 = torch.tensor([[1.0, 0.0]], device='cuda:0')\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n# Result is on GPU\nassert result['x'].device.type == 'cuda'\n\n\n\n# Julia Vern9 with tight tolerances\nintegrator = IntegratorFactory.for_julia(\n    system,\n    algorithm='Vern9',  # 9th order\n    reltol=1e-12,\n    abstol=1e-14\n)\n\nresult = integrator.integrate(x0, u_func, t_span=(0, 100))\nprint(f\"Function evaluations: {result['nfev']}\")\n\n\n\n# Option 1: scipy BDF\nintegrator = IntegratorFactory.create(\n    system,\n    backend='numpy',\n    method='BDF',\n    rtol=1e-8,\n    atol=1e-10\n)\n\n# Option 2: Julia Rodas5 (better performance)\nintegrator = IntegratorFactory.for_julia(\n    system,\n    algorithm='Rodas5'\n)\n\n# Option 3: Auto-switching\nintegrator = IntegratorFactory.create(\n    system,\n    backend='numpy',\n    method='AutoTsit5(Rosenbrock23())'\n)\n\n\n\n# Request dense output\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    dense_output=True\n)\n\nif result.get('dense_output'):\n    # Evaluate at arbitrary times\n    t_fine = np.linspace(0, 10, 10000)\n    x_fine = result['sol'](t_fine)\n\n\n\n# Evaluate at specific times\nt_eval = np.linspace(0, 10, 1001)  # 1001 uniform points\n\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    t_eval=t_eval\n)\n\nassert len(result['t']) == 1001\n\n\n\n# Controlled system\nu_func = lambda t, x: -K @ x  # State feedback\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n# Autonomous system (nu=0)\nu_func = lambda t, x: None  # No control\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n# Time-varying control\ndef u_func(t, x):\n    return np.array([np.sin(t)])\n\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\nimport torch\nfrom torch import nn\n\nclass NeuralODE(nn.Module):\n    def __init__(self, system):\n        super().__init__()\n        self.system = system\n        self.integrator = IntegratorFactory.for_neural_ode(system)\n    \n    def forward(self, x0, t_span):\n        result = self.integrator.integrate(\n            x0, \n            u_func=lambda t, x: torch.zeros(1),\n            t_span=t_span\n        )\n        return result['x']\n\n# Use in training loop\nmodel = NeuralODE(system)\noptimizer = torch.optim.Adam(model.parameters())\n\nfor epoch in range(100):\n    x_pred = model(x0, t_span=(0, 1))\n    loss = criterion(x_pred, x_true)\n    loss.backward()\n    optimizer.step()\n\n\n\n\n\n\n\n\n\nSystem\nRecommended\n\n\n\n\nNon-stiff ODE\nRK45, Tsit5, dopri5\n\n\nStiff ODE\nBDF, Radau, Rodas5\n\n\nUnknown stiffness\nLSODA, AutoTsit5(...)\n\n\nHigh accuracy\nVern9, DOP853\n\n\nSimple/Educational\nrk4, euler\n\n\nAdditive noise SDE\nheun (strong order 1.0)\n\n\nGeneral SDE\neuler-maruyama\n\n\n\n\n\n\n\n\n\nBackend\nBest For\nBest Method\n\n\n\n\nNumPy (scipy)\nGeneral use\nLSODA\n\n\nNumPy (Julia)\nPerformance\nTsit5, Vern9\n\n\nPyTorch\nNeural ODEs\ndopri5 (adjoint)\n\n\nJAX\nOptimization\ntsit5\n\n\n\n\n\n\n\n\n\nUse Case\nFactory Method\n\n\n\n\nGeneral\nIntegratorFactory.auto(system)\n\n\nProduction\nIntegratorFactory.for_production(system)\n\n\nOptimization\nIntegratorFactory.for_optimization(system)\n\n\nNeural ODE\nIntegratorFactory.for_neural_ode(system)\n\n\nHighest accuracy\nIntegratorFactory.for_julia(system, 'Vern9')\n\n\nMonte Carlo SDE\nSDEIntegratorFactory.for_monte_carlo(...)\n\n\n\n\n\n\n\n\n\nresult = {\n    't': array,              # Time points (T,)\n    'x': array,              # State trajectory (T, nx)\n    'success': bool,         # Integration succeeded\n    'message': str,          # Status message\n    'nfev': int,             # Function evaluations\n    'nsteps': int,           # Integration steps\n    'integration_time': float,  # Wall time (seconds)\n    'solver': str,           # Integrator name\n    \n    # Optional (adaptive):\n    'njev': int,             # Jacobian evaluations\n    'nlu': int,              # LU decompositions\n    'status': int,           # Status code\n    'sol': object,           # Dense output\n}\n\n\n\nresult = {\n    # All ODE fields, plus:\n    'diffusion_evals': int,     # Diffusion calls\n    'noise_samples': array,     # Brownian increments\n    'n_paths': int,             # Number of trajectories\n    'convergence_type': str,    # 'strong' or 'weak'\n    'sde_type': str,            # 'ito' or 'stratonovich'\n    'noise_type': str,          # 'additive', etc.\n}\n\n\n\n\n\n\nSolutions:\n\nStiff system → Use stiff solver: method='BDF' or method='Radau'\nIncrease max steps: max_steps=100000\nLoosen tolerances: rtol=1e-5, atol=1e-7\n\n\n\n\nSolutions:\n\nUse Julia: IntegratorFactory.for_julia(system, 'Tsit5')\nUse GPU: backend='torch' with device='cuda:0'\nLoosen tolerances: rtol=1e-4, atol=1e-6\nTry fixed-step: method='rk4', dt=0.01\n\n\n\n\nSolutions:\n\nTighten tolerances: rtol=1e-9, atol=1e-11\nUse high-order method: method='Vern9' or method='DOP853'\nProvide t_eval with dense grid\n\n\n\n\nSolutions:\n\nIncrease Monte Carlo paths: n_paths=10000\nReduce time step: dt=0.001\nUse higher-order method: method='heun' (for additive noise)\nSet seed for reproducibility: seed=42\n\n\n\n\nSolutions:\n\nUse adjoint method: adjoint=True (PyTorch)\nReduce batch size / number of paths\nUse checkpointing (if available)\nSwitch to CPU: backend='numpy'\n\n\n\n\n\n\n\ndef impact_event(t, x):\n    \"\"\"Detect when velocity crosses zero.\"\"\"\n    return x[1]  # velocity\n\nimpact_event.terminal = True  # Stop at event\nimpact_event.direction = -1   # Negative crossing\n\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    events=impact_event\n)\n\nif result.get('t_events'):\n    print(f\"Impact at t = {result['t_events'][0]}\")\n\n\n\n# Backend-specific options\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    \n    # Scipy options\n    max_step=0.1,          # Maximum step size\n    first_step=0.001,      # Initial step\n    vectorized=True,       # Vectorized evaluation\n    \n    # JAX options\n    solver_kwargs={\n        'max_steps': 10000,\n        'adjoint': 'checkpoint'\n    }\n)\n\n\n\n# Check integrator statistics\nprint(f\"Function evaluations: {integrator._stats['total_fev']}\")\nprint(f\"Total steps: {integrator._stats['total_steps']}\")\nprint(f\"Total time: {integrator._stats['total_time']:.3f}s\")\n\n\n\n\ndef test_integration():\n    \"\"\"Basic integration test.\"\"\"\n    system = MySystem()\n    integrator = IntegratorFactory.auto(system)\n    \n    x0 = np.array([1.0, 0.0])\n    u_func = lambda t, x: np.zeros(1)\n    \n    result = integrator.integrate(x0, u_func, t_span=(0, 1))\n    \n    # Check success\n    assert result['success'], f\"Integration failed: {result['message']}\"\n    \n    # Check shape\n    assert result['x'].shape[1] == system.nx\n    \n    # Check time points\n    assert result['t'][0] == 0.0\n    assert result['t'][-1] &lt;= 1.0\n    \n    print(\"✓ Integration test passed\")\n\ntest_integration()\n\n\n\n\nArchitecture: See Integration_Framework_Architecture.md\nType Definitions: See src/types/trajectories.py\nBackend Info: See src/types/backends.py\nSystem Interface: See continuous_system_base.py"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#quick-start",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#quick-start",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "from src.systems.base.numerical_integration import IntegratorFactory\n\n# Let the factory choose the best integrator\nintegrator = IntegratorFactory.auto(system)\n\n# Integrate\nresult = integrator.integrate(\n    x0=np.array([1.0, 0.0]),\n    u_func=lambda t, x: np.zeros(1),\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"Success: {result['success']}\")\nprint(f\"Method: {result['solver']}\")\n\n\n\n# Create with specific method\nintegrator = IntegratorFactory.create(\n    system,\n    backend='numpy',\n    method='RK45',\n    rtol=1e-6,\n    atol=1e-8\n)\n\n\n\n# For production\nintegrator = IntegratorFactory.for_production(system)\n\n# For optimization (JAX)\nintegrator = IntegratorFactory.for_optimization(system)\n\n# For neural ODEs (PyTorch)\nintegrator = IntegratorFactory.for_neural_ode(system)\n\n# For Julia (highest performance)\nintegrator = IntegratorFactory.for_julia(system, algorithm='Vern9')"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#available-methods",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#available-methods",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "# Adaptive non-stiff\nIntegratorFactory.create(system, backend='numpy', method='RK45')   # General\nIntegratorFactory.create(system, backend='numpy', method='RK23')   # Fast\nIntegratorFactory.create(system, backend='numpy', method='DOP853') # Accurate\n\n# Adaptive stiff\nIntegratorFactory.create(system, backend='numpy', method='Radau')  # Stiff\nIntegratorFactory.create(system, backend='numpy', method='BDF')    # Very stiff\nIntegratorFactory.create(system, backend='numpy', method='LSODA')  # Auto-stiffness ⭐\n\n\n\n# High-order explicit\nIntegratorFactory.create(system, backend='numpy', method='Tsit5')  # 5th order ⭐\nIntegratorFactory.create(system, backend='numpy', method='Vern9')  # 9th order\nIntegratorFactory.create(system, backend='numpy', method='DP8')    # Dormand-Prince 8\n\n# Rosenbrock (stiff)\nIntegratorFactory.create(system, backend='numpy', method='Rodas5')  # Best stiff ⭐\nIntegratorFactory.create(system, backend='numpy', method='Rosenbrock23')\n\n# Auto-switching\nIntegratorFactory.create(system, backend='numpy', method='AutoTsit5(Rosenbrock23())')\n\n\n\n# Adaptive methods\nIntegratorFactory.create(system, backend='torch', method='dopri5')  # 5(4) ⭐\nIntegratorFactory.create(system, backend='torch', method='dopri8')  # 8\nIntegratorFactory.create(system, backend='torch', method='bosh3')   # 3\n\n# With adjoint for memory efficiency\nintegrator = TorchDiffEqIntegrator(\n    system,\n    method='dopri5',\n    adjoint=True  # For neural ODEs\n)\n\n\n\n# Adaptive methods\nIntegratorFactory.create(system, backend='jax', method='tsit5')   # Best ⭐\nIntegratorFactory.create(system, backend='jax', method='dopri5')  # Alternative\nIntegratorFactory.create(system, backend='jax', method='dopri8')  # High accuracy\n\n\n\n# Simple methods\nIntegratorFactory.create(system, backend='numpy', method='rk4', dt=0.01)\nIntegratorFactory.create(system, backend='numpy', method='euler', dt=0.01)\nIntegratorFactory.create(system, backend='numpy', method='midpoint', dt=0.01)"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#stochastic-sde-integration",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#stochastic-sde-integration",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "from src.systems.base.numerical_integration.stochastic import SDEIntegratorFactory\n\n# Automatic selection based on noise type\nintegrator = SDEIntegratorFactory.auto(sde_system)\n\n# Specific method\nintegrator = SDEIntegratorFactory.create(\n    sde_system,\n    backend='torch',\n    method='heun',\n    dt=0.01,\n    seed=42\n)\n\n\n\nresult = integrator.integrate(\n    x0=np.array([1.0]),\n    u_func=lambda t, x: None,  # Autonomous\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"SDE type: {result['sde_type']}\")\nprint(f\"Noise type: {result['noise_type']}\")\nprint(f\"Diffusion evals: {result['diffusion_evals']}\")\n\n\n\n# Multiple trajectories for statistics\nresult = integrator.integrate_monte_carlo(\n    x0=np.array([1.0]),\n    u_func=lambda t, x: None,\n    t_span=(0.0, 10.0),\n    n_paths=1000  # 1000 trajectories\n)\n\n# Get statistics\nfrom src.systems.base.numerical_integration.sde_integrator_base import (\n    get_trajectory_statistics\n)\nstats = get_trajectory_statistics(result)\n\nprint(f\"Mean: {stats['mean'][-1]}\")\nprint(f\"Std: {stats['std'][-1]}\")\nprint(f\"Median: {stats['median'][-1]}\")\n\n\n\nimport jax.numpy as jnp\nfrom src.systems.base.numerical_integration.stochastic.custom_brownian import (\n    CustomBrownianPath\n)\n\n# Zero noise for testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(0.0, 0.01, dW)\n\n# Use in integration\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 1),\n    brownian_path=brownian\n)"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#common-patterns",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#common-patterns",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "import torch\n\n# Set system to use PyTorch backend\nsystem.set_default_backend('torch')\nsystem.set_default_device('cuda:0')\n\n# Create integrator\nintegrator = IntegratorFactory.create(\n    system,\n    backend='torch',\n    method='dopri5'\n)\n\n# Data on GPU\nx0 = torch.tensor([[1.0, 0.0]], device='cuda:0')\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n# Result is on GPU\nassert result['x'].device.type == 'cuda'\n\n\n\n# Julia Vern9 with tight tolerances\nintegrator = IntegratorFactory.for_julia(\n    system,\n    algorithm='Vern9',  # 9th order\n    reltol=1e-12,\n    abstol=1e-14\n)\n\nresult = integrator.integrate(x0, u_func, t_span=(0, 100))\nprint(f\"Function evaluations: {result['nfev']}\")\n\n\n\n# Option 1: scipy BDF\nintegrator = IntegratorFactory.create(\n    system,\n    backend='numpy',\n    method='BDF',\n    rtol=1e-8,\n    atol=1e-10\n)\n\n# Option 2: Julia Rodas5 (better performance)\nintegrator = IntegratorFactory.for_julia(\n    system,\n    algorithm='Rodas5'\n)\n\n# Option 3: Auto-switching\nintegrator = IntegratorFactory.create(\n    system,\n    backend='numpy',\n    method='AutoTsit5(Rosenbrock23())'\n)\n\n\n\n# Request dense output\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    dense_output=True\n)\n\nif result.get('dense_output'):\n    # Evaluate at arbitrary times\n    t_fine = np.linspace(0, 10, 10000)\n    x_fine = result['sol'](t_fine)\n\n\n\n# Evaluate at specific times\nt_eval = np.linspace(0, 10, 1001)  # 1001 uniform points\n\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    t_eval=t_eval\n)\n\nassert len(result['t']) == 1001\n\n\n\n# Controlled system\nu_func = lambda t, x: -K @ x  # State feedback\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n# Autonomous system (nu=0)\nu_func = lambda t, x: None  # No control\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\n# Time-varying control\ndef u_func(t, x):\n    return np.array([np.sin(t)])\n\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\nimport torch\nfrom torch import nn\n\nclass NeuralODE(nn.Module):\n    def __init__(self, system):\n        super().__init__()\n        self.system = system\n        self.integrator = IntegratorFactory.for_neural_ode(system)\n    \n    def forward(self, x0, t_span):\n        result = self.integrator.integrate(\n            x0, \n            u_func=lambda t, x: torch.zeros(1),\n            t_span=t_span\n        )\n        return result['x']\n\n# Use in training loop\nmodel = NeuralODE(system)\noptimizer = torch.optim.Adam(model.parameters())\n\nfor epoch in range(100):\n    x_pred = model(x0, t_span=(0, 1))\n    loss = criterion(x_pred, x_true)\n    loss.backward()\n    optimizer.step()"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#integrator-selection-guide",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#integrator-selection-guide",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "System\nRecommended\n\n\n\n\nNon-stiff ODE\nRK45, Tsit5, dopri5\n\n\nStiff ODE\nBDF, Radau, Rodas5\n\n\nUnknown stiffness\nLSODA, AutoTsit5(...)\n\n\nHigh accuracy\nVern9, DOP853\n\n\nSimple/Educational\nrk4, euler\n\n\nAdditive noise SDE\nheun (strong order 1.0)\n\n\nGeneral SDE\neuler-maruyama\n\n\n\n\n\n\n\n\n\nBackend\nBest For\nBest Method\n\n\n\n\nNumPy (scipy)\nGeneral use\nLSODA\n\n\nNumPy (Julia)\nPerformance\nTsit5, Vern9\n\n\nPyTorch\nNeural ODEs\ndopri5 (adjoint)\n\n\nJAX\nOptimization\ntsit5\n\n\n\n\n\n\n\n\n\nUse Case\nFactory Method\n\n\n\n\nGeneral\nIntegratorFactory.auto(system)\n\n\nProduction\nIntegratorFactory.for_production(system)\n\n\nOptimization\nIntegratorFactory.for_optimization(system)\n\n\nNeural ODE\nIntegratorFactory.for_neural_ode(system)\n\n\nHighest accuracy\nIntegratorFactory.for_julia(system, 'Vern9')\n\n\nMonte Carlo SDE\nSDEIntegratorFactory.for_monte_carlo(...)"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#integration-result-fields",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#integration-result-fields",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "result = {\n    't': array,              # Time points (T,)\n    'x': array,              # State trajectory (T, nx)\n    'success': bool,         # Integration succeeded\n    'message': str,          # Status message\n    'nfev': int,             # Function evaluations\n    'nsteps': int,           # Integration steps\n    'integration_time': float,  # Wall time (seconds)\n    'solver': str,           # Integrator name\n    \n    # Optional (adaptive):\n    'njev': int,             # Jacobian evaluations\n    'nlu': int,              # LU decompositions\n    'status': int,           # Status code\n    'sol': object,           # Dense output\n}\n\n\n\nresult = {\n    # All ODE fields, plus:\n    'diffusion_evals': int,     # Diffusion calls\n    'noise_samples': array,     # Brownian increments\n    'n_paths': int,             # Number of trajectories\n    'convergence_type': str,    # 'strong' or 'weak'\n    'sde_type': str,            # 'ito' or 'stratonovich'\n    'noise_type': str,          # 'additive', etc.\n}"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#troubleshooting",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#troubleshooting",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "Solutions:\n\nStiff system → Use stiff solver: method='BDF' or method='Radau'\nIncrease max steps: max_steps=100000\nLoosen tolerances: rtol=1e-5, atol=1e-7\n\n\n\n\nSolutions:\n\nUse Julia: IntegratorFactory.for_julia(system, 'Tsit5')\nUse GPU: backend='torch' with device='cuda:0'\nLoosen tolerances: rtol=1e-4, atol=1e-6\nTry fixed-step: method='rk4', dt=0.01\n\n\n\n\nSolutions:\n\nTighten tolerances: rtol=1e-9, atol=1e-11\nUse high-order method: method='Vern9' or method='DOP853'\nProvide t_eval with dense grid\n\n\n\n\nSolutions:\n\nIncrease Monte Carlo paths: n_paths=10000\nReduce time step: dt=0.001\nUse higher-order method: method='heun' (for additive noise)\nSet seed for reproducibility: seed=42\n\n\n\n\nSolutions:\n\nUse adjoint method: adjoint=True (PyTorch)\nReduce batch size / number of paths\nUse checkpointing (if available)\nSwitch to CPU: backend='numpy'"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#advanced-features",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#advanced-features",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "def impact_event(t, x):\n    \"\"\"Detect when velocity crosses zero.\"\"\"\n    return x[1]  # velocity\n\nimpact_event.terminal = True  # Stop at event\nimpact_event.direction = -1   # Negative crossing\n\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    events=impact_event\n)\n\nif result.get('t_events'):\n    print(f\"Impact at t = {result['t_events'][0]}\")\n\n\n\n# Backend-specific options\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10),\n    \n    # Scipy options\n    max_step=0.1,          # Maximum step size\n    first_step=0.001,      # Initial step\n    vectorized=True,       # Vectorized evaluation\n    \n    # JAX options\n    solver_kwargs={\n        'max_steps': 10000,\n        'adjoint': 'checkpoint'\n    }\n)\n\n\n\n# Check integrator statistics\nprint(f\"Function evaluations: {integrator._stats['total_fev']}\")\nprint(f\"Total steps: {integrator._stats['total_steps']}\")\nprint(f\"Total time: {integrator._stats['total_time']:.3f}s\")"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#testing-your-integration",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#testing-your-integration",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "def test_integration():\n    \"\"\"Basic integration test.\"\"\"\n    system = MySystem()\n    integrator = IntegratorFactory.auto(system)\n    \n    x0 = np.array([1.0, 0.0])\n    u_func = lambda t, x: np.zeros(1)\n    \n    result = integrator.integrate(x0, u_func, t_span=(0, 1))\n    \n    # Check success\n    assert result['success'], f\"Integration failed: {result['message']}\"\n    \n    # Check shape\n    assert result['x'].shape[1] == system.nx\n    \n    # Check time points\n    assert result['t'][0] == 0.0\n    assert result['t'][-1] &lt;= 1.0\n    \n    print(\"✓ Integration test passed\")\n\ntest_integration()"
  },
  {
    "objectID": "api/integration_framework/Integration_Framework_Quick_Reference.html#references",
    "href": "api/integration_framework/Integration_Framework_Quick_Reference.html#references",
    "title": "Numerical Integration Framework Quick Reference",
    "section": "",
    "text": "Architecture: See Integration_Framework_Architecture.md\nType Definitions: See src/types/trajectories.py\nBackend Info: See src/types/backends.py\nSystem Interface: See continuous_system_base.py"
  },
  {
    "objectID": "api/integration_framework/integration_framework_text.html",
    "href": "api/integration_framework/integration_framework_text.html",
    "title": "Numerical Integration Framework Architecture",
    "section": "",
    "text": "═══════════════════════════════════════════════════════════════════════\n                    INTEGRATION FRAMEWORK ARCHITECTURE\n═══════════════════════════════════════════════════════════════════════\n\n                          ┌──────────────────────┐\n                          │  IntegratorBase      │\n                          │  (Abstract Base)     │\n                          │  512 lines           │\n                          └──────────┬───────────┘\n                                     │\n                     ┌───────────────┼───────────────┐\n                     │                               │\n         ┌───────────▼───────────┐      ┌───────────▼───────────┐\n         │  IntegratorFactory    │      │  SDEIntegratorBase    │\n         │  (Creates ODE)        │      │  (SDE Extension)      │\n         │  1,267 lines          │      │  1,080 lines          │\n         └───────────┬───────────┘      └───────────┬───────────┘\n                     │                               │\n         ┌───────────┴────────────┐      ┌───────────▼───────────┐\n         │                        │      │  SDEIntegratorFactory │\n         ▼                        │      │  (Creates SDE)        │\n  ┌─────────────┐                │      │  1,000 lines          │\n  │ Scipy       │                │      └───────────┬───────────┘\n  │ Integrator  │                │                  │\n  │ 620 lines   │                │      ┌───────────┴────────────┐\n  └─────────────┘                │      │                        │\n                                 ▼      ▼                        ▼\n  ┌─────────────┐         ┌─────────────┐         ┌─────────────┐\n  │ TorchDiffEq │         │ TorchSDE    │         │ DiffraxSDE  │\n  │ Integrator  │         │ Integrator  │         │ Integrator  │\n  │ 800 lines   │         │ 800 lines   │         │ 750 lines   │\n  └─────────────┘         └─────────────┘         └─────────────┘\n         │                        ▲                        ▲\n  ┌─────────────┐                │                        │\n  │ Diffrax     │         ┌─────────────┐         ┌─────────────┐\n  │ Integrator  │         │ DiffEqPySDE │         │ Custom      │\n  │ 700 lines   │         │ Integrator  │         │ Brownian    │\n  └─────────────┘         │ 850 lines   │         │ 160 lines   │\n         │                └─────────────┘         └─────────────┘\n  ┌─────────────┐\n  │ DiffEqPy    │\n  │ Integrator  │\n  │ 900 lines   │\n  └─────────────┘\n         │\n  ┌─────────────┐\n  │ FixedStep   │\n  │ Integrators │\n  │ 600 lines   │\n  └─────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        TRACK BREAKDOWN\n═══════════════════════════════════════════════════════════════════════\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ TRACK 1: DETERMINISTIC ODE INTEGRATION                            ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nIntegratorBase (512 lines)\n│\n├─&gt; IntegratorFactory (1,267 lines) ────&gt; Creates integrators\n│   │\n│   ├─&gt; ScipyIntegrator (620 lines)\n│   │   └─&gt; Methods: RK45, RK23, DOP853, Radau, BDF, LSODA\n│   │\n│   ├─&gt; TorchDiffEqIntegrator (800 lines)\n│   │   └─&gt; Methods: dopri5, dopri8, adaptive_heun, bosh3\n│   │\n│   ├─&gt; DiffraxIntegrator (700 lines)\n│   │   └─&gt; Methods: tsit5, dopri5, dopri8, heun, ralston\n│   │\n│   ├─&gt; DiffEqPyIntegrator (900 lines)\n│   │   └─&gt; Methods: Tsit5, Vern9, Rodas5, AutoTsit5(...)\n│   │\n│   └─&gt; FixedStepIntegrators (600 lines)\n│       └─&gt; Methods: euler, midpoint, rk4\n\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ TRACK 2: STOCHASTIC SDE INTEGRATION                               ┃\n┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\n\nSDEIntegratorBase (1,080 lines) ─extends─&gt; IntegratorBase\n│\n├─&gt; SDEIntegratorFactory (1,000 lines) ────&gt; Creates SDE integrators\n│   │\n│   ├─&gt; TorchSDEIntegrator (800 lines)\n│   │   └─&gt; Methods: euler, heun, srk, reversible_heun\n│   │\n│   ├─&gt; DiffraxSDEIntegrator (750 lines)\n│   │   └─&gt; Methods: euler, heun, reversible_heun\n│   │   └─&gt; Uses: CustomBrownianPath (160 lines)\n│   │\n│   └─&gt; DiffEqPySDEIntegrator (850 lines)\n│       └─&gt; Methods: Euler-Maruyama, Milstein, etc.\n\n\n═══════════════════════════════════════════════════════════════════════\n                        BACKEND SUPPORT\n═══════════════════════════════════════════════════════════════════════\n\n┌─────────────┬──────────────────────────┬────────────────────────┐\n│ Backend     │ ODE Integrators          │ SDE Integrators        │\n├─────────────┼──────────────────────────┼────────────────────────┤\n│ NumPy       │ • ScipyIntegrator        │ (Limited)              │\n│             │ • DiffEqPyIntegrator     │ • DiffEqPySDEIntegrator│\n│             │ • FixedStepIntegrators   │                        │\n├─────────────┼──────────────────────────┼────────────────────────┤\n│ PyTorch     │ • TorchDiffEqIntegrator  │ • TorchSDEIntegrator   │\n│             │ • FixedStepIntegrators   │                        │\n├─────────────┼──────────────────────────┼────────────────────────┤\n│ JAX         │ • DiffraxIntegrator      │ • DiffraxSDEIntegrator │\n│             │ • FixedStepIntegrators   │                        │\n└─────────────┴──────────────────────────┴────────────────────────┘\n\n\n═══════════════════════════════════════════════════════════════════════\n                        METHOD CATEGORIES\n═══════════════════════════════════════════════════════════════════════\n\nADAPTIVE (ODE)                    FIXED-STEP (ODE)\n├─ Non-Stiff                     ├─ euler\n│  • RK45 (scipy)                │  • Order 1\n│  • Tsit5 (Julia)               │  • All backends\n│  • dopri5 (PyTorch/JAX)        ├─ midpoint\n├─ Stiff                         │  • Order 2\n│  • BDF (scipy)                 │  • All backends\n│  • Radau (scipy)               └─ rk4\n│  • Rodas5 (Julia)                 • Order 4\n└─ Auto-Stiffness                   • All backends\n   • LSODA (scipy)\n   • AutoTsit5 (Julia)          STOCHASTIC (SDE)\n                                 ├─ Euler-Maruyama\nHIGH ACCURACY                    │  • Strong order 0.5\n├─ Vern9 (Julia)                 │  • All noise types\n│  • 9th order                   ├─ Heun\n├─ DOP853 (scipy)                │  • Strong order 1.0\n│  • 8th order                   │  • Additive noise\n└─ dopri8 (PyTorch/JAX)          ├─ Milstein\n   • 8th order                   │  • Strong order 1.0\n                                 │  • Diagonal noise\n                                 └─ SRK\n                                    • Various orders\n\n\n═══════════════════════════════════════════════════════════════════════\n                        RESULT TYPES\n═══════════════════════════════════════════════════════════════════════\n\nIntegrationResult (ODE):         SDEIntegrationResult (SDE):\n├─ t: Time points (T,)           ├─ (All ODE fields)\n├─ x: States (T, nx)             ├─ diffusion_evals: int\n├─ success: bool                 ├─ noise_samples: array\n├─ message: str                  ├─ n_paths: int\n├─ nfev: int                     ├─ convergence_type: str\n├─ nsteps: int                   ├─ sde_type: str\n├─ integration_time: float       └─ noise_type: str\n├─ solver: str\n└─ (Optional: njev, nlu, sol)\n\n\n═══════════════════════════════════════════════════════════════════════\n                        USAGE FLOW\n═══════════════════════════════════════════════════════════════════════\n\n1. CREATE SYSTEM\n   └─&gt; system = MySystem()\n\n2. CREATE INTEGRATOR\n   ├─&gt; IntegratorFactory.auto(system)              [Automatic]\n   ├─&gt; IntegratorFactory.for_production(system)    [LSODA/AutoTsit5]\n   ├─&gt; IntegratorFactory.for_optimization(system)  [JAX tsit5]\n   └─&gt; IntegratorFactory.create(system, ...)       [Custom]\n\n3. INTEGRATE\n   └─&gt; result = integrator.integrate(x0, u_func, t_span)\n\n4. ANALYZE RESULT\n   ├─&gt; result['t']          # Time points\n   ├─&gt; result['x']          # State trajectory\n   ├─&gt; result['success']    # Success flag\n   └─&gt; result['solver']     # Method used\n\n\n═══════════════════════════════════════════════════════════════════════\n\n\n\nFactory Pattern - Automatic integrator selection\nMulti-Backend - NumPy, PyTorch, JAX seamlessly\nDual Track - Separate ODE and SDE implementations\nTypedDict Results - Type-safe, IDE-friendly\nPerformance - GPU, XLA, Julia for speed\nFlexibility - 40+ methods across backends\nMonte Carlo - Built-in multi-trajectory simulation\n\n\n\n\nDeterministic: ~5,400 lines Stochastic: ~4,640 lines"
  },
  {
    "objectID": "api/integration_framework/integration_framework_text.html#key-design-features",
    "href": "api/integration_framework/integration_framework_text.html#key-design-features",
    "title": "Numerical Integration Framework Architecture",
    "section": "",
    "text": "Factory Pattern - Automatic integrator selection\nMulti-Backend - NumPy, PyTorch, JAX seamlessly\nDual Track - Separate ODE and SDE implementations\nTypedDict Results - Type-safe, IDE-friendly\nPerformance - GPU, XLA, Julia for speed\nFlexibility - 40+ methods across backends\nMonte Carlo - Built-in multi-trajectory simulation"
  },
  {
    "objectID": "api/integration_framework/integration_framework_text.html#total-line-count-10000-lines",
    "href": "api/integration_framework/integration_framework_text.html#total-line-count-10000-lines",
    "title": "Numerical Integration Framework Architecture",
    "section": "",
    "text": "Deterministic: ~5,400 lines Stochastic: ~4,640 lines"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "from src.systems.examples import Pendulum\nimport numpy as np\n\n# Create system\nsystem = Pendulum()\n\n# Simulate\nresult = system.integrate(\n    x0=np.array([0.5, 0]),\n    u=None,\n    t_span=(0, 10)\n)\n\n# Plot trajectory\nfig = system.plotter.plot_trajectory(\n    result['t'],\n    result['x'],\n    state_names=['θ', 'ω'],\n    theme='publication'\n)\nfig.show()\n\n# Save to HTML\nfig.write_html('trajectory.html')\n\n\n\n# 2D phase portrait\nfig = system.phase_plotter.plot_2d(\n    x=result['x'],\n    state_names=('θ', 'ω'),\n    show_direction=True,\n    theme='publication'\n)\nfig.show()\n\n# With vector field\ndef pendulum_field(theta, omega):\n    return omega, -np.sin(theta) - 0.1*omega\n\nfig = system.phase_plotter.plot_2d(\n    x=result['x'],\n    vector_field=pendulum_field,\n    equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n    theme='publication'\n)\n\n\n\n# Linearize and design LQR\nx_eq = np.array([np.pi, 0])\nu_eq = np.zeros(1)\nA, B = system.linearize(x_eq, u_eq)\n\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Plot eigenvalues\nfig = system.control_plotter.plot_eigenvalue_map(\n    lqr['closed_loop_eigenvalues'],\n    system_type='continuous',\n    theme='publication'\n)\nfig.show()\n\n\n\n# Simulate with controller\ndef lqr_controller(x, t):\n    return -lqr['gain'] @ (x - x_eq)\n\nresult = system.simulate(\n    x0=np.array([np.pi + 0.2, 0]),\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n# Plot state and control\nfig = system.plotter.plot_state_and_control(\n    result['t'],\n    result['x'],\n    result['u'],\n    state_names=['θ', 'ω'],\n    control_names=['Torque'],\n    theme='publication'\n)\n\n\n\n\n\n\n\nfrom src.visualization.trajectory_plotter import TrajectoryPlotter\n\nplotter = TrajectoryPlotter(backend='numpy')\n\n# Single trajectory\nt = np.linspace(0, 10, 100)\nx = np.random.randn(100, 2)\n\nfig = plotter.plot_trajectory(\n    t, x,\n    state_names=['x₁', 'x₂'],\n    theme='default'\n)\nfig.show()\n\n\n\n# Multiple trajectories\nn_batch = 20\nx_batch = np.random.randn(n_batch, 100, 2)\n\n# Automatically shows mean ± std\nfig = plotter.plot_trajectory(\n    t, x_batch,\n    state_names=['x₁', 'x₂'],\n    show_std=True,  # Show std deviation bands\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\n\n\n\n# State + control subplots\nfig = plotter.plot_state_and_control(\n    t=result['t'],\n    x=result['x'],  # (T, nx)\n    u=result['u'],  # (T, nu)\n    state_names=['Position', 'Velocity'],\n    control_names=['Force'],\n    color_scheme='plotly',\n    theme='default'\n)\n\n\n\n# Compare different controllers\nresults = {\n    'LQR Q=10': system.simulate(...),\n    'LQR Q=100': system.simulate(...),\n    'Open-loop': system.simulate(...)\n}\n\nfig = plotter.plot_comparison(\n    results,\n    state_names=['θ', 'ω'],\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\n\n\n\n\n\n\n\nfrom src.visualization.phase_portrait import PhasePortraitPlotter\n\nplotter = PhasePortraitPlotter(backend='numpy')\n\n# Basic 2D phase portrait\nfig = plotter.plot_2d(\n    x=trajectory,  # (T, 2) or (T, nx) with state_indices\n    state_names=('x₁', 'x₂'),\n    theme='default'\n)\nfig.show()\n\n\n\n# Show trajectory direction\nfig = plotter.plot_2d(\n    x=trajectory,\n    state_names=('θ', 'ω'),\n    show_direction=True,  # Adds arrows\n    theme='publication'\n)\n\n\n\n# Add vector field (quiver plot)\ndef dynamics(x1, x2):\n    \"\"\"Return (dx1/dt, dx2/dt)\"\"\"\n    return x2, -x1 - 0.1*x2\n\nfig = plotter.plot_2d(\n    x=trajectory,\n    vector_field=dynamics,\n    state_names=('Position', 'Velocity'),\n    theme='publication'\n)\n\n\n\n# Mark equilibrium points\nequilibria = [\n    np.array([0, 0]),      # Stable equilibrium\n    np.array([np.pi, 0])   # Unstable equilibrium\n]\n\nfig = plotter.plot_2d(\n    x=trajectory,\n    equilibria=equilibria,\n    vector_field=dynamics,\n    show_direction=True,\n    theme='publication'\n)\n\n\n\n# 3D phase space\nfig = plotter.plot_3d(\n    x=trajectory_3d,  # (T, 3)\n    state_names=('x', 'y', 'z'),\n    theme='dark'\n)\nfig.show()\n\n# Lorenz attractor example\nfig = plotter.plot_3d(\n    x=lorenz_trajectory,\n    state_names=('x', 'y', 'z'),\n    equilibria=[np.zeros(3)],\n    theme='publication'\n)\n\n\n\n# Highlight periodic orbits\nfig = plotter.plot_limit_cycle(\n    x=vdp_trajectory,\n    state_indices=(0, 1),\n    highlight_period=6.28,  # If known\n    theme='publication'\n)\n\n\n\n\n\n\n\nfrom src.visualization.control_plots import ControlPlotter\n\nplotter = ControlPlotter(backend='numpy')\n\n# Continuous system\nfig = plotter.plot_eigenvalue_map(\n    eigenvalues=lqr['closed_loop_eigenvalues'],\n    system_type='continuous',  # Shows left half-plane\n    show_stability_region=True,\n    theme='publication'\n)\n\n# Discrete system\nfig = plotter.plot_eigenvalue_map(\n    eigenvalues=discrete_poles,\n    system_type='discrete',  # Shows unit circle\n    theme='publication'\n)\n\n\n\n# Compare LQR gains for different Q weights\ngains = {}\nfor q_scale in [1, 10, 100, 1000]:\n    Q_scaled = q_scale * Q\n    result = system.control.design_lqr(A, B, Q_scaled, R)\n    gains[f'Q={q_scale}'] = result['gain']\n\nfig = plotter.plot_gain_comparison(\n    gains,\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\n\n\n\n# Monitor iterative Riccati solver\nP_history = []  # Collect P at each iteration\n\nfig = plotter.plot_riccati_convergence(\n    P_history,\n    theme='publication'\n)\n\n\n\n# Compute controllability Gramian\nfrom scipy.linalg import solve_continuous_lyapunov\n\nW_c = solve_continuous_lyapunov(A, -B @ B.T)\n\nfig = plotter.plot_controllability_gramian(\n    W_c,\n    state_names=['x₁', 'x₂'],\n    theme='publication'\n)\n\n\n\n# Compute observability Gramian\nW_o = solve_continuous_lyapunov(A.T, -C.T @ C)\n\nfig = plotter.plot_observability_gramian(\n    W_o,\n    state_names=['x₁', 'x₂'],\n    theme='publication'\n)\n\n\n\nfrom scipy import signal\n\n# Closed-loop system\nA_cl = A - B @ K\nC = np.array([[1, 0]])  # Measure first state\nD = np.zeros((1, 1))\n\nsys = signal.StateSpace(A_cl, B, C, D)\nt, y = signal.step(sys)\n\nfig = plotter.plot_step_response(\n    t, y,\n    show_metrics=True,  # Annotate rise time, overshoot, etc.\n    theme='publication'\n)\n\n\n\nt, y = signal.impulse(sys)\n\nfig = plotter.plot_impulse_response(\n    t, y,\n    show_decay=True,  # Show exponential decay envelope\n    theme='publication'\n)\n\n\n\nomega, mag, phase = signal.bode(sys)\n\nfig = plotter.plot_frequency_response(\n    omega, mag, phase,\n    show_margins=True,  # Show gain/phase margins\n    theme='publication'\n)\n\n\n\n# Frequency response\nomega = np.logspace(-2, 2, 1000)\ns = 1j * omega\nH = np.array([C @ np.linalg.solve(s[i]*np.eye(2) - A, B) for i in range(len(s))])\n\nfig = plotter.plot_nyquist(\n    real=np.real(H.flatten()),\n    imag=np.imag(H.flatten()),\n    show_unit_circle=True,\n    theme='publication'\n)\n\n\n\n# Compute pole paths for varying gain\ngains = np.linspace(0, 10, 100)\npole_paths = np.zeros((len(gains), 2), dtype=complex)\n\nfor i, k in enumerate(gains):\n    pole_paths[i, :] = np.linalg.eigvals(A - k * B @ K)\n\nfig = plotter.plot_root_locus(\n    pole_paths,\n    gains,\n    system_type='continuous',\n    theme='publication'\n)\n\n\n\n\n\n\n\nfrom src.visualization.themes import PlotThemes\n\n# Default theme (white background)\nfig = plotter.plot_trajectory(t, x, theme='default')\n\n# Publication theme (Times New Roman, high contrast)\nfig = plotter.plot_trajectory(t, x, theme='publication')\n\n# Dark theme (dark background)\nfig = plotter.plot_trajectory(t, x, theme='dark')\n\n# Apply theme to existing figure\nfig = PlotThemes.apply_theme(fig, theme='publication')\n\n\n\nfrom src.visualization.themes import ColorSchemes\n\n# Get colors from predefined scheme\ncolors = ColorSchemes.get_colors('plotly', n_colors=5)\ncolors = ColorSchemes.get_colors('d3', n_colors=5)\ncolors = ColorSchemes.get_colors('colorblind_safe', n_colors=5)\ncolors = ColorSchemes.get_colors('tableau', n_colors=5)\n\n# Use in plots\nfig = plotter.plot_trajectory(\n    t, x,\n    color_scheme='colorblind_safe'\n)\n\n\n\nCategorical (for distinct categories):\n\n'plotly' - Default Plotly colors (10 colors)\n'd3' - D3.js Category10 (10 colors)\n'colorblind_safe' - Wong palette (8 colors, accessible)\n'tableau' - Tableau 10 palette (10 colors)\n\nSequential (for heatmaps):\n\n'sequential_blue' - Blue gradient (9 colors)\n'sequential_green' - Green gradient (9 colors)\n\nDiverging (for signed data):\n\n'diverging_red_blue' - Red-blue scale (11 colors)\n'diverging_purple_green' - Purple-green scale (11 colors)\n\n\n\n\nfrom src.visualization.themes import lighten_color, darken_color, interpolate_colors\n\n# Lighten a color\nlight_blue = lighten_color('#1f77b4', amount=0.5)\n\n# Darken a color\ndark_blue = darken_color('#1f77b4', amount=0.5)\n\n# Create gradient\ngradient = interpolate_colors('#1f77b4', '#ff7f0e', n=10)\n\n\n\n\n\n\n\n# Single configuration for publication\nfig = system.plotter.plot_trajectory(\n    result['t'],\n    result['x'],\n    state_names=['θ', 'ω'],\n    color_scheme='colorblind_safe',  # Accessible\n    theme='publication',              # Professional style\n    title='Pendulum Response'\n)\n\n# Export\nfig.write_html('figure.html')\nfig.write_image('figure.pdf')  # Requires kaleido\nfig.write_image('figure.png', width=1200, height=800, scale=2)\n\n\n\nfrom plotly.subplots import make_subplots\n\n# Create custom subplot layout\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=('State 1', 'State 2', 'Control', 'Phase Portrait'),\n    specs=[[{'type': 'scatter'}, {'type': 'scatter'}],\n           [{'type': 'scatter'}, {'type': 'scatter'}]]\n)\n\n# Add traces\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['x'][:, 0], name='x₁'),\n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['x'][:, 1], name='x₂'),\n    row=1, col=2\n)\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['u'][:, 0], name='u'),\n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(x=result['x'][:, 0], y=result['x'][:, 1], name='Phase'),\n    row=2, col=2\n)\n\n# Apply theme\nfig = PlotThemes.apply_theme(fig, theme='publication')\n\n\n\n# Monte Carlo simulation\nn_runs = 50\nx_batch = np.zeros((n_runs, len(t), 2))\n\nfor i in range(n_runs):\n    x0_noisy = x0 + 0.1 * np.random.randn(2)\n    result = system.integrate(x0_noisy, u=None, t_span=(0, 10))\n    x_batch[i] = result['x']\n\n# Plot all runs (mean ± std automatically)\nfig = system.plotter.plot_trajectory(\n    t, x_batch,\n    state_names=['θ', 'ω'],\n    show_std=True,\n    theme='publication'\n)\n\n# Or plot all individual runs\nfig = go.Figure()\nfor i in range(n_runs):\n    fig.add_trace(go.Scatter(\n        x=t,\n        y=x_batch[i, :, 0],\n        mode='lines',\n        line=dict(color='blue', width=0.5),\n        opacity=0.3,\n        showlegend=(i == 0),\n        name='Individual runs' if i == 0 else ''\n    ))\n\nfig = PlotThemes.apply_theme(fig, theme='publication')\n\n\n\n# Create interactive dashboard with multiple views\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=(\n        'Time-Domain Response',\n        'Phase Portrait',\n        'Control Input',\n        'Eigenvalue Map'\n    )\n)\n\n# Time domain\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['x'][:, 0], name='State'),\n    row=1, col=1\n)\n\n# Phase portrait\nfig.add_trace(\n    go.Scatter(x=result['x'][:, 0], y=result['x'][:, 1], \n               mode='lines+markers', name='Trajectory'),\n    row=1, col=2\n)\n\n# Control\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['u'][:, 0], name='Control'),\n    row=2, col=1\n)\n\n# Eigenvalues\neigs = lqr['closed_loop_eigenvalues']\nfig.add_trace(\n    go.Scatter(x=np.real(eigs), y=np.imag(eigs),\n               mode='markers', marker=dict(size=10), name='Poles'),\n    row=2, col=2\n)\n\nfig.update_layout(height=800, showlegend=True)\nfig = PlotThemes.apply_theme(fig, theme='publication')\nfig.show()\n\n\n\n# Animated trajectory\nframes = []\nfor i in range(0, len(t), 5):  # Every 5th point\n    frame = go.Frame(\n        data=[go.Scatter(\n            x=result['x'][:i, 0],\n            y=result['x'][:i, 1],\n            mode='lines+markers',\n            marker=dict(size=8)\n        )],\n        name=str(i)\n    )\n    frames.append(frame)\n\nfig = go.Figure(\n    data=[go.Scatter(x=[], y=[], mode='lines+markers')],\n    frames=frames\n)\n\nfig.update_layout(\n    updatemenus=[{\n        'type': 'buttons',\n        'buttons': [\n            {'label': 'Play', 'method': 'animate',\n             'args': [None, {'frame': {'duration': 50}}]},\n            {'label': 'Pause', 'method': 'animate',\n             'args': [[None], {'frame': {'duration': 0}, 'mode': 'immediate'}]}\n        ]\n    }]\n)\n\nfig = PlotThemes.apply_theme(fig, theme='dark')\n\n\n\nimport torch\nimport jax.numpy as jnp\n\n# NumPy system\nsystem_np = Pendulum()\nresult_np = system_np.integrate(x0_np, u=None, t_span=(0, 10))\nfig = system_np.plotter.plot_trajectory(result_np['t'], result_np['x'])\n\n# PyTorch system (on GPU)\nsystem_torch = Pendulum()\nsystem_torch.set_default_backend('torch')\nsystem_torch.set_default_device('cuda:0')\nx0_torch = torch.tensor(x0_np, device='cuda:0')\nresult_torch = system_torch.integrate(x0_torch, u=None, t_span=(0, 10))\n\n# Plotter handles conversion automatically\nfig = system_torch.plotter.plot_trajectory(\n    result_torch['t'],  # Automatically converts GPU tensor to NumPy\n    result_torch['x'],\n    theme='publication'\n)\n\n# JAX system\nsystem_jax = Pendulum()\nsystem_jax.set_default_backend('jax')\nx0_jax = jnp.array(x0_np)\nresult_jax = system_jax.integrate(x0_jax, u=None, t_span=(0, 10))\n\n# Also handles JAX arrays\nfig = system_jax.plotter.plot_trajectory(\n    result_jax['t'],\n    result_jax['x'],\n    theme='publication'\n)\n\n\n\n\n\n\n\nPossible Causes:\n\nData shape incorrect\nAll NaN/Inf values\nEmpty arrays\n\nSolutions:\n# Check data\nprint(f\"t shape: {t.shape}\")\nprint(f\"x shape: {x.shape}\")\nprint(f\"t range: [{t[0]}, {t[-1]}]\")\nprint(f\"x range: [{x.min()}, {x.max()}]\")\nprint(f\"NaN count: {np.isnan(x).sum()}\")\n\n# Verify dimensions\nassert t.ndim == 1, \"t must be 1D\"\nassert x.ndim in [2, 3], \"x must be 2D or 3D\"\nif x.ndim == 2:\n    assert x.shape[0] == len(t), \"First dimension must match time\"\n\n\n\nProblem:\n# This doesn't work\nfig = plotter.plot_trajectory(t, x)\nPlotThemes.apply_theme(fig, theme='publication')  # Returns new figure!\nfig.show()  # Shows old figure without theme\nSolution:\n# Correct: Capture returned figure\nfig = plotter.plot_trajectory(t, x)\nfig = PlotThemes.apply_theme(fig, theme='publication')\nfig.show()\n\n# Or use theme parameter directly\nfig = plotter.plot_trajectory(t, x, theme='publication')\nfig.show()\n\n\n\nCheck:\n# Ensure show_std=True\nfig = plotter.plot_trajectory(\n    t, x_batch,\n    show_std=True  # Must be True for std bands\n)\n\n# Verify batch dimension\nprint(f\"Shape: {x_batch.shape}\")\n# Should be (n_batch, T, nx), not (T, nx)\n\n\n\nProblem: Too many traces, colors repeat\nSolution:\n# Use larger color scheme\nfig = plotter.plot_comparison(\n    many_results,\n    color_scheme='plotly'  # 10 colors instead of default\n)\n\n# Or create custom colors\nfrom src.visualization.themes import interpolate_colors\n\ncustom_colors = interpolate_colors('#1f77b4', '#ff7f0e', n=20)\n# Use in manual plotting\n\n\n\nCheck browser compatibility:\n# Ensure using modern browser\n# Chrome, Firefox, Safari all support WebGL\n\n# Try different renderer\nfig.show(renderer='browser')  # Opens in default browser\nfig.show(renderer='notebook')  # For Jupyter\n\n\n\nSolution:\n# Install kaleido\n# pip install kaleido\n\n# Then export\nfig.write_image('figure.pdf')\nfig.write_image('figure.png', width=1200, height=800, scale=2)\n\n\n\n\n\nFor cases where you need plotting without a system object:\nfrom src.visualization.trajectory_plotter import TrajectoryPlotter\nfrom src.visualization.phase_portrait import PhasePortraitPlotter\nfrom src.visualization.control_plots import ControlPlotter\n\n# Create plotters\ntraj_plotter = TrajectoryPlotter(backend='numpy', theme='publication')\nphase_plotter = PhasePortraitPlotter(backend='numpy', theme='publication')\ncontrol_plotter = ControlPlotter(backend='numpy', theme='publication')\n\n# Use directly\nfig = traj_plotter.plot_trajectory(t, x, state_names=['x₁', 'x₂'])\nfig = phase_plotter.plot_2d(x, state_names=('x₁', 'x₂'))\nfig = control_plotter.plot_eigenvalue_map(eigenvalues, system_type='continuous')\n\n\n\n\n\n\n# Define custom colors\nCUSTOM_COLORS = [\n    '#1B9E77',  # Teal\n    '#D95F02',  # Orange\n    '#7570B3',  # Purple\n    '#E7298A',  # Pink\n    '#66A61E',  # Green\n]\n\n# Use in plotting\nfig = go.Figure()\nfor i, (name, result) in enumerate(results.items()):\n    fig.add_trace(go.Scatter(\n        x=result['t'],\n        y=result['x'][:, 0],\n        name=name,\n        line=dict(color=CUSTOM_COLORS[i % len(CUSTOM_COLORS)])\n    ))\n\n\n\n# Define custom theme dictionary\nCUSTOM_THEME = {\n    'template': 'simple_white',\n    'font_family': 'Helvetica, sans-serif',\n    'font_size': 13,\n    'title_font_size': 17,\n    'axis_line_color': '#333',\n    'grid_color': '#DDD',\n    'background_color': '#FAFAFA',\n}\n\n# Apply manually\nfig.update_layout(\n    template=CUSTOM_THEME['template'],\n    font=dict(\n        family=CUSTOM_THEME['font_family'],\n        size=CUSTOM_THEME['font_size']\n    ),\n    title_font_size=CUSTOM_THEME['title_font_size'],\n    # ... etc\n)\n\n\n\n# Fine-grained control over subplots\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=('State 1', 'State 2', 'Control', 'Phase'),\n    horizontal_spacing=0.15,\n    vertical_spacing=0.12,\n    row_heights=[0.6, 0.4],\n    column_widths=[0.5, 0.5]\n)\n\n# Update individual subplot axes\nfig.update_xaxes(title_text=\"Time (s)\", row=1, col=1)\nfig.update_yaxes(title_text=\"Angle (rad)\", row=1, col=1)\n\n\n\n\n\n\n\n# Good: Consistent theming\nfig1 = plotter.plot_trajectory(t, x, theme='publication')\nfig2 = plotter.plot_2d(x, theme='publication')\n\n# Bad: Inconsistent default themes\nfig1 = plotter.plot_trajectory(t, x)  # Default theme\nfig2 = plotter.plot_2d(x, theme='dark')  # Different theme\n\n\n\n# For publications and presentations\nfig = plotter.plot_comparison(\n    results,\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\n\n\n\n# Good: Clear labels\nfig = plotter.plot_trajectory(\n    t, x,\n    state_names=['Angle (rad)', 'Angular Velocity (rad/s)'],\n    title='Pendulum Response to Initial Condition'\n)\n\n# Bad: Generic labels\nfig = plotter.plot_trajectory(t, x)  # x1, x2, etc.\n\n\n\n# Save interactive HTML\nfig.write_html('figure_interactive.html')\n\n# Save static images\nfig.write_image('figure.pdf')  # For papers\nfig.write_image('figure.png', width=1200, height=800, scale=2)  # For slides\n\n\n\n\n\n\nArchitecture: See Visualization_Framework_Architecture.md for complete details\nTheming: See src/visualization/themes.py\nPlotters: See src/visualization/trajectory_plotter.py, phase_portrait.py, control_plots.py\nPlotly Documentation: https://plotly.com/python/"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#quick-start",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#quick-start",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "from src.systems.examples import Pendulum\nimport numpy as np\n\n# Create system\nsystem = Pendulum()\n\n# Simulate\nresult = system.integrate(\n    x0=np.array([0.5, 0]),\n    u=None,\n    t_span=(0, 10)\n)\n\n# Plot trajectory\nfig = system.plotter.plot_trajectory(\n    result['t'],\n    result['x'],\n    state_names=['θ', 'ω'],\n    theme='publication'\n)\nfig.show()\n\n# Save to HTML\nfig.write_html('trajectory.html')\n\n\n\n# 2D phase portrait\nfig = system.phase_plotter.plot_2d(\n    x=result['x'],\n    state_names=('θ', 'ω'),\n    show_direction=True,\n    theme='publication'\n)\nfig.show()\n\n# With vector field\ndef pendulum_field(theta, omega):\n    return omega, -np.sin(theta) - 0.1*omega\n\nfig = system.phase_plotter.plot_2d(\n    x=result['x'],\n    vector_field=pendulum_field,\n    equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n    theme='publication'\n)\n\n\n\n# Linearize and design LQR\nx_eq = np.array([np.pi, 0])\nu_eq = np.zeros(1)\nA, B = system.linearize(x_eq, u_eq)\n\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Plot eigenvalues\nfig = system.control_plotter.plot_eigenvalue_map(\n    lqr['closed_loop_eigenvalues'],\n    system_type='continuous',\n    theme='publication'\n)\nfig.show()\n\n\n\n# Simulate with controller\ndef lqr_controller(x, t):\n    return -lqr['gain'] @ (x - x_eq)\n\nresult = system.simulate(\n    x0=np.array([np.pi + 0.2, 0]),\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\n# Plot state and control\nfig = system.plotter.plot_state_and_control(\n    result['t'],\n    result['x'],\n    result['u'],\n    state_names=['θ', 'ω'],\n    control_names=['Torque'],\n    theme='publication'\n)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#trajectory-plotting",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#trajectory-plotting",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "from src.visualization.trajectory_plotter import TrajectoryPlotter\n\nplotter = TrajectoryPlotter(backend='numpy')\n\n# Single trajectory\nt = np.linspace(0, 10, 100)\nx = np.random.randn(100, 2)\n\nfig = plotter.plot_trajectory(\n    t, x,\n    state_names=['x₁', 'x₂'],\n    theme='default'\n)\nfig.show()\n\n\n\n# Multiple trajectories\nn_batch = 20\nx_batch = np.random.randn(n_batch, 100, 2)\n\n# Automatically shows mean ± std\nfig = plotter.plot_trajectory(\n    t, x_batch,\n    state_names=['x₁', 'x₂'],\n    show_std=True,  # Show std deviation bands\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\n\n\n\n# State + control subplots\nfig = plotter.plot_state_and_control(\n    t=result['t'],\n    x=result['x'],  # (T, nx)\n    u=result['u'],  # (T, nu)\n    state_names=['Position', 'Velocity'],\n    control_names=['Force'],\n    color_scheme='plotly',\n    theme='default'\n)\n\n\n\n# Compare different controllers\nresults = {\n    'LQR Q=10': system.simulate(...),\n    'LQR Q=100': system.simulate(...),\n    'Open-loop': system.simulate(...)\n}\n\nfig = plotter.plot_comparison(\n    results,\n    state_names=['θ', 'ω'],\n    color_scheme='colorblind_safe',\n    theme='publication'\n)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#phase-portrait-plotting",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#phase-portrait-plotting",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "from src.visualization.phase_portrait import PhasePortraitPlotter\n\nplotter = PhasePortraitPlotter(backend='numpy')\n\n# Basic 2D phase portrait\nfig = plotter.plot_2d(\n    x=trajectory,  # (T, 2) or (T, nx) with state_indices\n    state_names=('x₁', 'x₂'),\n    theme='default'\n)\nfig.show()\n\n\n\n# Show trajectory direction\nfig = plotter.plot_2d(\n    x=trajectory,\n    state_names=('θ', 'ω'),\n    show_direction=True,  # Adds arrows\n    theme='publication'\n)\n\n\n\n# Add vector field (quiver plot)\ndef dynamics(x1, x2):\n    \"\"\"Return (dx1/dt, dx2/dt)\"\"\"\n    return x2, -x1 - 0.1*x2\n\nfig = plotter.plot_2d(\n    x=trajectory,\n    vector_field=dynamics,\n    state_names=('Position', 'Velocity'),\n    theme='publication'\n)\n\n\n\n# Mark equilibrium points\nequilibria = [\n    np.array([0, 0]),      # Stable equilibrium\n    np.array([np.pi, 0])   # Unstable equilibrium\n]\n\nfig = plotter.plot_2d(\n    x=trajectory,\n    equilibria=equilibria,\n    vector_field=dynamics,\n    show_direction=True,\n    theme='publication'\n)\n\n\n\n# 3D phase space\nfig = plotter.plot_3d(\n    x=trajectory_3d,  # (T, 3)\n    state_names=('x', 'y', 'z'),\n    theme='dark'\n)\nfig.show()\n\n# Lorenz attractor example\nfig = plotter.plot_3d(\n    x=lorenz_trajectory,\n    state_names=('x', 'y', 'z'),\n    equilibria=[np.zeros(3)],\n    theme='publication'\n)\n\n\n\n# Highlight periodic orbits\nfig = plotter.plot_limit_cycle(\n    x=vdp_trajectory,\n    state_indices=(0, 1),\n    highlight_period=6.28,  # If known\n    theme='publication'\n)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#control-analysis-plots",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#control-analysis-plots",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "from src.visualization.control_plots import ControlPlotter\n\nplotter = ControlPlotter(backend='numpy')\n\n# Continuous system\nfig = plotter.plot_eigenvalue_map(\n    eigenvalues=lqr['closed_loop_eigenvalues'],\n    system_type='continuous',  # Shows left half-plane\n    show_stability_region=True,\n    theme='publication'\n)\n\n# Discrete system\nfig = plotter.plot_eigenvalue_map(\n    eigenvalues=discrete_poles,\n    system_type='discrete',  # Shows unit circle\n    theme='publication'\n)\n\n\n\n# Compare LQR gains for different Q weights\ngains = {}\nfor q_scale in [1, 10, 100, 1000]:\n    Q_scaled = q_scale * Q\n    result = system.control.design_lqr(A, B, Q_scaled, R)\n    gains[f'Q={q_scale}'] = result['gain']\n\nfig = plotter.plot_gain_comparison(\n    gains,\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\n\n\n\n# Monitor iterative Riccati solver\nP_history = []  # Collect P at each iteration\n\nfig = plotter.plot_riccati_convergence(\n    P_history,\n    theme='publication'\n)\n\n\n\n# Compute controllability Gramian\nfrom scipy.linalg import solve_continuous_lyapunov\n\nW_c = solve_continuous_lyapunov(A, -B @ B.T)\n\nfig = plotter.plot_controllability_gramian(\n    W_c,\n    state_names=['x₁', 'x₂'],\n    theme='publication'\n)\n\n\n\n# Compute observability Gramian\nW_o = solve_continuous_lyapunov(A.T, -C.T @ C)\n\nfig = plotter.plot_observability_gramian(\n    W_o,\n    state_names=['x₁', 'x₂'],\n    theme='publication'\n)\n\n\n\nfrom scipy import signal\n\n# Closed-loop system\nA_cl = A - B @ K\nC = np.array([[1, 0]])  # Measure first state\nD = np.zeros((1, 1))\n\nsys = signal.StateSpace(A_cl, B, C, D)\nt, y = signal.step(sys)\n\nfig = plotter.plot_step_response(\n    t, y,\n    show_metrics=True,  # Annotate rise time, overshoot, etc.\n    theme='publication'\n)\n\n\n\nt, y = signal.impulse(sys)\n\nfig = plotter.plot_impulse_response(\n    t, y,\n    show_decay=True,  # Show exponential decay envelope\n    theme='publication'\n)\n\n\n\nomega, mag, phase = signal.bode(sys)\n\nfig = plotter.plot_frequency_response(\n    omega, mag, phase,\n    show_margins=True,  # Show gain/phase margins\n    theme='publication'\n)\n\n\n\n# Frequency response\nomega = np.logspace(-2, 2, 1000)\ns = 1j * omega\nH = np.array([C @ np.linalg.solve(s[i]*np.eye(2) - A, B) for i in range(len(s))])\n\nfig = plotter.plot_nyquist(\n    real=np.real(H.flatten()),\n    imag=np.imag(H.flatten()),\n    show_unit_circle=True,\n    theme='publication'\n)\n\n\n\n# Compute pole paths for varying gain\ngains = np.linspace(0, 10, 100)\npole_paths = np.zeros((len(gains), 2), dtype=complex)\n\nfor i, k in enumerate(gains):\n    pole_paths[i, :] = np.linalg.eigvals(A - k * B @ K)\n\nfig = plotter.plot_root_locus(\n    pole_paths,\n    gains,\n    system_type='continuous',\n    theme='publication'\n)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#theming-and-customization",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#theming-and-customization",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "from src.visualization.themes import PlotThemes\n\n# Default theme (white background)\nfig = plotter.plot_trajectory(t, x, theme='default')\n\n# Publication theme (Times New Roman, high contrast)\nfig = plotter.plot_trajectory(t, x, theme='publication')\n\n# Dark theme (dark background)\nfig = plotter.plot_trajectory(t, x, theme='dark')\n\n# Apply theme to existing figure\nfig = PlotThemes.apply_theme(fig, theme='publication')\n\n\n\nfrom src.visualization.themes import ColorSchemes\n\n# Get colors from predefined scheme\ncolors = ColorSchemes.get_colors('plotly', n_colors=5)\ncolors = ColorSchemes.get_colors('d3', n_colors=5)\ncolors = ColorSchemes.get_colors('colorblind_safe', n_colors=5)\ncolors = ColorSchemes.get_colors('tableau', n_colors=5)\n\n# Use in plots\nfig = plotter.plot_trajectory(\n    t, x,\n    color_scheme='colorblind_safe'\n)\n\n\n\nCategorical (for distinct categories):\n\n'plotly' - Default Plotly colors (10 colors)\n'd3' - D3.js Category10 (10 colors)\n'colorblind_safe' - Wong palette (8 colors, accessible)\n'tableau' - Tableau 10 palette (10 colors)\n\nSequential (for heatmaps):\n\n'sequential_blue' - Blue gradient (9 colors)\n'sequential_green' - Green gradient (9 colors)\n\nDiverging (for signed data):\n\n'diverging_red_blue' - Red-blue scale (11 colors)\n'diverging_purple_green' - Purple-green scale (11 colors)\n\n\n\n\nfrom src.visualization.themes import lighten_color, darken_color, interpolate_colors\n\n# Lighten a color\nlight_blue = lighten_color('#1f77b4', amount=0.5)\n\n# Darken a color\ndark_blue = darken_color('#1f77b4', amount=0.5)\n\n# Create gradient\ngradient = interpolate_colors('#1f77b4', '#ff7f0e', n=10)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#common-patterns",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#common-patterns",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "# Single configuration for publication\nfig = system.plotter.plot_trajectory(\n    result['t'],\n    result['x'],\n    state_names=['θ', 'ω'],\n    color_scheme='colorblind_safe',  # Accessible\n    theme='publication',              # Professional style\n    title='Pendulum Response'\n)\n\n# Export\nfig.write_html('figure.html')\nfig.write_image('figure.pdf')  # Requires kaleido\nfig.write_image('figure.png', width=1200, height=800, scale=2)\n\n\n\nfrom plotly.subplots import make_subplots\n\n# Create custom subplot layout\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=('State 1', 'State 2', 'Control', 'Phase Portrait'),\n    specs=[[{'type': 'scatter'}, {'type': 'scatter'}],\n           [{'type': 'scatter'}, {'type': 'scatter'}]]\n)\n\n# Add traces\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['x'][:, 0], name='x₁'),\n    row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['x'][:, 1], name='x₂'),\n    row=1, col=2\n)\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['u'][:, 0], name='u'),\n    row=2, col=1\n)\nfig.add_trace(\n    go.Scatter(x=result['x'][:, 0], y=result['x'][:, 1], name='Phase'),\n    row=2, col=2\n)\n\n# Apply theme\nfig = PlotThemes.apply_theme(fig, theme='publication')\n\n\n\n# Monte Carlo simulation\nn_runs = 50\nx_batch = np.zeros((n_runs, len(t), 2))\n\nfor i in range(n_runs):\n    x0_noisy = x0 + 0.1 * np.random.randn(2)\n    result = system.integrate(x0_noisy, u=None, t_span=(0, 10))\n    x_batch[i] = result['x']\n\n# Plot all runs (mean ± std automatically)\nfig = system.plotter.plot_trajectory(\n    t, x_batch,\n    state_names=['θ', 'ω'],\n    show_std=True,\n    theme='publication'\n)\n\n# Or plot all individual runs\nfig = go.Figure()\nfor i in range(n_runs):\n    fig.add_trace(go.Scatter(\n        x=t,\n        y=x_batch[i, :, 0],\n        mode='lines',\n        line=dict(color='blue', width=0.5),\n        opacity=0.3,\n        showlegend=(i == 0),\n        name='Individual runs' if i == 0 else ''\n    ))\n\nfig = PlotThemes.apply_theme(fig, theme='publication')\n\n\n\n# Create interactive dashboard with multiple views\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=(\n        'Time-Domain Response',\n        'Phase Portrait',\n        'Control Input',\n        'Eigenvalue Map'\n    )\n)\n\n# Time domain\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['x'][:, 0], name='State'),\n    row=1, col=1\n)\n\n# Phase portrait\nfig.add_trace(\n    go.Scatter(x=result['x'][:, 0], y=result['x'][:, 1], \n               mode='lines+markers', name='Trajectory'),\n    row=1, col=2\n)\n\n# Control\nfig.add_trace(\n    go.Scatter(x=result['t'], y=result['u'][:, 0], name='Control'),\n    row=2, col=1\n)\n\n# Eigenvalues\neigs = lqr['closed_loop_eigenvalues']\nfig.add_trace(\n    go.Scatter(x=np.real(eigs), y=np.imag(eigs),\n               mode='markers', marker=dict(size=10), name='Poles'),\n    row=2, col=2\n)\n\nfig.update_layout(height=800, showlegend=True)\nfig = PlotThemes.apply_theme(fig, theme='publication')\nfig.show()\n\n\n\n# Animated trajectory\nframes = []\nfor i in range(0, len(t), 5):  # Every 5th point\n    frame = go.Frame(\n        data=[go.Scatter(\n            x=result['x'][:i, 0],\n            y=result['x'][:i, 1],\n            mode='lines+markers',\n            marker=dict(size=8)\n        )],\n        name=str(i)\n    )\n    frames.append(frame)\n\nfig = go.Figure(\n    data=[go.Scatter(x=[], y=[], mode='lines+markers')],\n    frames=frames\n)\n\nfig.update_layout(\n    updatemenus=[{\n        'type': 'buttons',\n        'buttons': [\n            {'label': 'Play', 'method': 'animate',\n             'args': [None, {'frame': {'duration': 50}}]},\n            {'label': 'Pause', 'method': 'animate',\n             'args': [[None], {'frame': {'duration': 0}, 'mode': 'immediate'}]}\n        ]\n    }]\n)\n\nfig = PlotThemes.apply_theme(fig, theme='dark')\n\n\n\nimport torch\nimport jax.numpy as jnp\n\n# NumPy system\nsystem_np = Pendulum()\nresult_np = system_np.integrate(x0_np, u=None, t_span=(0, 10))\nfig = system_np.plotter.plot_trajectory(result_np['t'], result_np['x'])\n\n# PyTorch system (on GPU)\nsystem_torch = Pendulum()\nsystem_torch.set_default_backend('torch')\nsystem_torch.set_default_device('cuda:0')\nx0_torch = torch.tensor(x0_np, device='cuda:0')\nresult_torch = system_torch.integrate(x0_torch, u=None, t_span=(0, 10))\n\n# Plotter handles conversion automatically\nfig = system_torch.plotter.plot_trajectory(\n    result_torch['t'],  # Automatically converts GPU tensor to NumPy\n    result_torch['x'],\n    theme='publication'\n)\n\n# JAX system\nsystem_jax = Pendulum()\nsystem_jax.set_default_backend('jax')\nx0_jax = jnp.array(x0_np)\nresult_jax = system_jax.integrate(x0_jax, u=None, t_span=(0, 10))\n\n# Also handles JAX arrays\nfig = system_jax.plotter.plot_trajectory(\n    result_jax['t'],\n    result_jax['x'],\n    theme='publication'\n)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#troubleshooting",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#troubleshooting",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "Possible Causes:\n\nData shape incorrect\nAll NaN/Inf values\nEmpty arrays\n\nSolutions:\n# Check data\nprint(f\"t shape: {t.shape}\")\nprint(f\"x shape: {x.shape}\")\nprint(f\"t range: [{t[0]}, {t[-1]}]\")\nprint(f\"x range: [{x.min()}, {x.max()}]\")\nprint(f\"NaN count: {np.isnan(x).sum()}\")\n\n# Verify dimensions\nassert t.ndim == 1, \"t must be 1D\"\nassert x.ndim in [2, 3], \"x must be 2D or 3D\"\nif x.ndim == 2:\n    assert x.shape[0] == len(t), \"First dimension must match time\"\n\n\n\nProblem:\n# This doesn't work\nfig = plotter.plot_trajectory(t, x)\nPlotThemes.apply_theme(fig, theme='publication')  # Returns new figure!\nfig.show()  # Shows old figure without theme\nSolution:\n# Correct: Capture returned figure\nfig = plotter.plot_trajectory(t, x)\nfig = PlotThemes.apply_theme(fig, theme='publication')\nfig.show()\n\n# Or use theme parameter directly\nfig = plotter.plot_trajectory(t, x, theme='publication')\nfig.show()\n\n\n\nCheck:\n# Ensure show_std=True\nfig = plotter.plot_trajectory(\n    t, x_batch,\n    show_std=True  # Must be True for std bands\n)\n\n# Verify batch dimension\nprint(f\"Shape: {x_batch.shape}\")\n# Should be (n_batch, T, nx), not (T, nx)\n\n\n\nProblem: Too many traces, colors repeat\nSolution:\n# Use larger color scheme\nfig = plotter.plot_comparison(\n    many_results,\n    color_scheme='plotly'  # 10 colors instead of default\n)\n\n# Or create custom colors\nfrom src.visualization.themes import interpolate_colors\n\ncustom_colors = interpolate_colors('#1f77b4', '#ff7f0e', n=20)\n# Use in manual plotting\n\n\n\nCheck browser compatibility:\n# Ensure using modern browser\n# Chrome, Firefox, Safari all support WebGL\n\n# Try different renderer\nfig.show(renderer='browser')  # Opens in default browser\nfig.show(renderer='notebook')  # For Jupyter\n\n\n\nSolution:\n# Install kaleido\n# pip install kaleido\n\n# Then export\nfig.write_image('figure.pdf')\nfig.write_image('figure.png', width=1200, height=800, scale=2)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#direct-plotter-usage-without-system",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#direct-plotter-usage-without-system",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "For cases where you need plotting without a system object:\nfrom src.visualization.trajectory_plotter import TrajectoryPlotter\nfrom src.visualization.phase_portrait import PhasePortraitPlotter\nfrom src.visualization.control_plots import ControlPlotter\n\n# Create plotters\ntraj_plotter = TrajectoryPlotter(backend='numpy', theme='publication')\nphase_plotter = PhasePortraitPlotter(backend='numpy', theme='publication')\ncontrol_plotter = ControlPlotter(backend='numpy', theme='publication')\n\n# Use directly\nfig = traj_plotter.plot_trajectory(t, x, state_names=['x₁', 'x₂'])\nfig = phase_plotter.plot_2d(x, state_names=('x₁', 'x₂'))\nfig = control_plotter.plot_eigenvalue_map(eigenvalues, system_type='continuous')"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#advanced-customization",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#advanced-customization",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "# Define custom colors\nCUSTOM_COLORS = [\n    '#1B9E77',  # Teal\n    '#D95F02',  # Orange\n    '#7570B3',  # Purple\n    '#E7298A',  # Pink\n    '#66A61E',  # Green\n]\n\n# Use in plotting\nfig = go.Figure()\nfor i, (name, result) in enumerate(results.items()):\n    fig.add_trace(go.Scatter(\n        x=result['t'],\n        y=result['x'][:, 0],\n        name=name,\n        line=dict(color=CUSTOM_COLORS[i % len(CUSTOM_COLORS)])\n    ))\n\n\n\n# Define custom theme dictionary\nCUSTOM_THEME = {\n    'template': 'simple_white',\n    'font_family': 'Helvetica, sans-serif',\n    'font_size': 13,\n    'title_font_size': 17,\n    'axis_line_color': '#333',\n    'grid_color': '#DDD',\n    'background_color': '#FAFAFA',\n}\n\n# Apply manually\nfig.update_layout(\n    template=CUSTOM_THEME['template'],\n    font=dict(\n        family=CUSTOM_THEME['font_family'],\n        size=CUSTOM_THEME['font_size']\n    ),\n    title_font_size=CUSTOM_THEME['title_font_size'],\n    # ... etc\n)\n\n\n\n# Fine-grained control over subplots\nfig = make_subplots(\n    rows=2, cols=2,\n    subplot_titles=('State 1', 'State 2', 'Control', 'Phase'),\n    horizontal_spacing=0.15,\n    vertical_spacing=0.12,\n    row_heights=[0.6, 0.4],\n    column_widths=[0.5, 0.5]\n)\n\n# Update individual subplot axes\nfig.update_xaxes(title_text=\"Time (s)\", row=1, col=1)\nfig.update_yaxes(title_text=\"Angle (rad)\", row=1, col=1)"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#best-practices",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#best-practices",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "# Good: Consistent theming\nfig1 = plotter.plot_trajectory(t, x, theme='publication')\nfig2 = plotter.plot_2d(x, theme='publication')\n\n# Bad: Inconsistent default themes\nfig1 = plotter.plot_trajectory(t, x)  # Default theme\nfig2 = plotter.plot_2d(x, theme='dark')  # Different theme\n\n\n\n# For publications and presentations\nfig = plotter.plot_comparison(\n    results,\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\n\n\n\n# Good: Clear labels\nfig = plotter.plot_trajectory(\n    t, x,\n    state_names=['Angle (rad)', 'Angular Velocity (rad/s)'],\n    title='Pendulum Response to Initial Condition'\n)\n\n# Bad: Generic labels\nfig = plotter.plot_trajectory(t, x)  # x1, x2, etc.\n\n\n\n# Save interactive HTML\nfig.write_html('figure_interactive.html')\n\n# Save static images\nfig.write_image('figure.pdf')  # For papers\nfig.write_image('figure.png', width=1200, height=800, scale=2)  # For slides"
  },
  {
    "objectID": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#references",
    "href": "api/visualization_framework/Visualization_Framework_Quick_Reference.html#references",
    "title": "Visualization Framework Quick Reference",
    "section": "",
    "text": "Architecture: See Visualization_Framework_Architecture.md for complete details\nTheming: See src/visualization/themes.py\nPlotters: See src/visualization/trajectory_plotter.py, phase_portrait.py, control_plots.py\nPlotly Documentation: https://plotly.com/python/"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ControlDESymulation",
    "section": "",
    "text": "A comprehensive control systems simulation framework with symbolic dynamical systems and multi-backend numerical execution.\n\n\n\nWrite Once, Run Anywhere: Define systems symbolically, execute on any backend (NumPy/PyTorch/JAX)\nNo Backend Lock-in: Switch between CPU, GPU, or TPU without changing your code\nGradient-Aware: Automatic differentiation support for learned controllers and neural ODEs\nType-Safe: Comprehensive type hints for better IDE support and fewer bugs\nResearch to Production: Prototype in NumPy, scale with JAX, integrate with PyTorch models\n\n\n\n\n\nSymbolic Specification: Define systems using SymPy with automatic code generation\nMulti-Backend Support: Seamlessly switch between NumPy, PyTorch, JAX, and Julia\nDual Time Domains: Full support for both continuous-time (ODEs/SDEs) and discrete-time systems\nStochastic Systems: First-class support for stochastic differential equations (SDEs)\n40+ Integration Methods: Adaptive and fixed-step solvers from scipy, torchdiffeq, diffrax, and DiffEqPy\nType Safety: Comprehensive TypedDict definitions with IDE autocomplete support\nGPU Acceleration: Native PyTorch and JAX support for GPU-based simulations\nZero Code Duplication: Clean 4-layer architecture with composition over inheritance\nProduction Ready: Extensive test coverage, comprehensive documentation, CI/CD workflows\n\n\n\n\n\nComposition Over Inheritance - Delegate to specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX/Julia\nType-Driven Design - Comprehensive TypedDict definitions\nZero Code Duplication - Shared functionality in base classes\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance First - Multi-backend support enables GPU and XLA acceleration\n\n\n\n\n\nInstallation Guide (not yet written)\nBasic Tutorial (not yet written)\nSDE Integration (not yet written)\n\n\n\n\nBrowse our examples gallery (not yet written) to see ControlDESymulation in action."
  },
  {
    "objectID": "index.html#key-benefits",
    "href": "index.html#key-benefits",
    "title": "ControlDESymulation",
    "section": "",
    "text": "Write Once, Run Anywhere: Define systems symbolically, execute on any backend (NumPy/PyTorch/JAX)\nNo Backend Lock-in: Switch between CPU, GPU, or TPU without changing your code\nGradient-Aware: Automatic differentiation support for learned controllers and neural ODEs\nType-Safe: Comprehensive type hints for better IDE support and fewer bugs\nResearch to Production: Prototype in NumPy, scale with JAX, integrate with PyTorch models"
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "ControlDESymulation",
    "section": "",
    "text": "Symbolic Specification: Define systems using SymPy with automatic code generation\nMulti-Backend Support: Seamlessly switch between NumPy, PyTorch, JAX, and Julia\nDual Time Domains: Full support for both continuous-time (ODEs/SDEs) and discrete-time systems\nStochastic Systems: First-class support for stochastic differential equations (SDEs)\n40+ Integration Methods: Adaptive and fixed-step solvers from scipy, torchdiffeq, diffrax, and DiffEqPy\nType Safety: Comprehensive TypedDict definitions with IDE autocomplete support\nGPU Acceleration: Native PyTorch and JAX support for GPU-based simulations\nZero Code Duplication: Clean 4-layer architecture with composition over inheritance\nProduction Ready: Extensive test coverage, comprehensive documentation, CI/CD workflows"
  },
  {
    "objectID": "index.html#design-principles",
    "href": "index.html#design-principles",
    "title": "ControlDESymulation",
    "section": "",
    "text": "Composition Over Inheritance - Delegate to specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX/Julia\nType-Driven Design - Comprehensive TypedDict definitions\nZero Code Duplication - Shared functionality in base classes\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance First - Multi-backend support enables GPU and XLA acceleration"
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "ControlDESymulation",
    "section": "",
    "text": "Installation Guide (not yet written)\nBasic Tutorial (not yet written)\nSDE Integration (not yet written)"
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "ControlDESymulation",
    "section": "",
    "text": "Browse our examples gallery (not yet written) to see ControlDESymulation in action."
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Installation\nBasic Usage"
  },
  {
    "objectID": "tutorials/index.html#getting-started",
    "href": "tutorials/index.html#getting-started",
    "title": "Tutorials",
    "section": "",
    "text": "Installation\nBasic Usage"
  },
  {
    "objectID": "tutorials/index.html#core-concepts",
    "href": "tutorials/index.html#core-concepts",
    "title": "Tutorials",
    "section": "Core Concepts",
    "text": "Core Concepts\n\nDynamical Systems\nSDE Integration\nBackend Selection"
  },
  {
    "objectID": "tutorials/index.html#advanced-topics",
    "href": "tutorials/index.html#advanced-topics",
    "title": "Tutorials",
    "section": "Advanced Topics",
    "text": "Advanced Topics\n\nVisualization Guide"
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "API Structural Reference",
    "section": "",
    "text": "ControlDESymulation Design Philosophy"
  },
  {
    "objectID": "api/index.html#quick-reference-guides",
    "href": "api/index.html#quick-reference-guides",
    "title": "API Structural Reference",
    "section": "Quick Reference Guides",
    "text": "Quick Reference Guides\n\nUI Framework\nDelegation Layer\nIntegration Framework\nControl Framework\nVisualization Framework\nType System"
  },
  {
    "objectID": "api/index.html#architecture",
    "href": "api/index.html#architecture",
    "title": "API Structural Reference",
    "section": "Architecture",
    "text": "Architecture\n\nUI Framework\nDelegation Layer\nIntegration Framework\nControl Framework\nVisualization Framework\nType System"
  },
  {
    "objectID": "examples/simple_symbolic_pendulum.html",
    "href": "examples/simple_symbolic_pendulum.html",
    "title": "ControlDESymulation",
    "section": "",
    "text": "# TODO: Change once API regarding exports stabilizes\nimport sys\nfrom pathlib import Path\nsys.path.insert(0, str(Path.cwd().parent.parent))\n\nimport numpy as np\nimport sympy as sp\nfrom src.systems.base.core.continuous_symbolic_system import ContinuousSymbolicSystem\n\n\nclass SymbolicPendulum(ContinuousSymbolicSystem):\n    def define_system(\n        self,\n        m_val: float = 1.0,\n        l_val: float = 1.0,\n        beta_val: float = 1.0,\n        g_val: float = 9.81,\n    ):\n        \"\"\"First order model of a pendulum\"\"\"\n        # define the symbolic variables\n        theta, theta_dot = sp.symbols(\"theta theta_dot\", real=True)\n        u = sp.symbols(\"u\", real=True)\n        m, l, beta, g = sp.symbols(\"m l beta g\", real=True, positive=True)\n\n        # add the variables to the system fields properly\n        self.parameters = {m: m_val, l: l_val, beta: beta_val, g: g_val}\n        self.state_vars = [theta, theta_dot]\n        self.control_vars = [u]\n        self.order = 1\n\n        # define the dynamics of the system\n        ml2 = m * l * l\n        self._f_sym = sp.Matrix(\n            [theta_dot, (-beta / ml2) * theta_dot + (g / l) * sp.sin(theta) + u / ml2],\n        )\n        self._h_sym = sp.Matrix([theta])\n\n    def setup_equilibria(self):\n        # method to add equilibria to the system automatically after initialization\n\n        # add the stable equilibrium where the pendulum is hanging down\n        self.add_equilibrium(\n            'downward',\n            x_eq=np.array([0.0, 0.0]),\n            u_eq=np.array([0.0]),\n            verify=True\n            )\n\n        # add the unstable equilibrium where the pendulum is inverted\n        self.add_equilibrium(\n            'inverted',\n            x_eq=np.array([np.pi, 0.0]),\n            u_eq=np.array([0.0]),\n            stability='unstable',\n            notes='Requires active control'\n            )\n\n# Instantiate the system\npendulum = SymbolicPendulum()\n\n# Initial conditions\nx0 = np.array([1.0, 0.0])\n\n\n# Integrate a trajectory with auto-selection of\n# relevant arguments\npendulum_integration_result = pendulum.integrate(\n        x0=x0,\n        t_span = (0.0, 15.0)\n    )\nprint(pendulum_integration_result['x'])\n\n[[ 1.00000000e+00  0.00000000e+00]\n [ 1.00000594e+00  9.89506734e-03]\n [ 1.00071537e+00  1.08212210e-01]\n [ 1.01616061e+00  5.07153694e-01]\n [ 1.06848383e+00  1.02955621e+00]\n [ 1.17671541e+00  1.63677770e+00]\n [ 1.36135156e+00  2.32255220e+00]\n [ 1.64282360e+00  3.05918535e+00]\n [ 2.03894953e+00  3.75224346e+00]\n [ 2.39769093e+00  4.10243396e+00]\n [ 2.77307091e+00  4.19097647e+00]\n [ 3.12306614e+00  3.99941533e+00]\n [ 3.44946098e+00  3.54918825e+00]\n [ 3.74593616e+00  2.85135623e+00]\n [ 3.98806126e+00  1.95098168e+00]\n [ 4.13669483e+00  1.01563199e+00]\n [ 4.19214004e+00  1.63426037e-01]\n [ 4.17347014e+00 -5.71812199e-01]\n [ 4.09367426e+00 -1.21935449e+00]\n [ 3.89225819e+00 -1.94846312e+00]\n [ 3.66106240e+00 -2.34050770e+00]\n [ 3.40784356e+00 -2.47861435e+00]\n [ 3.17389337e+00 -2.38305962e+00]\n [ 2.96897566e+00 -2.11414159e+00]\n [ 2.79926395e+00 -1.72230825e+00]\n [ 2.67127049e+00 -1.26032604e+00]\n [ 2.58714906e+00 -7.77560678e-01]\n [ 2.54434775e+00 -3.12898845e-01]\n [ 2.53608001e+00  5.07841521e-02]\n [ 2.55031914e+00  3.90350203e-01]\n [ 2.58942501e+00  7.22758516e-01]\n [ 2.66407238e+00  1.05276262e+00]\n [ 2.78164690e+00  1.32743586e+00]\n [ 2.94512832e+00  1.47578887e+00]\n [ 3.08421902e+00  1.45352558e+00]\n [ 3.21433212e+00  1.31539210e+00]\n [ 3.32106277e+00  1.09880058e+00]\n [ 3.40230554e+00  8.37045783e-01]\n [ 3.45809888e+00  5.56885977e-01]\n [ 3.48993697e+00  2.80434884e-01]\n [ 3.50053139e+00  5.09671269e-02]\n [ 3.49674851e+00 -1.66095391e-01]\n [ 3.48105039e+00 -3.51975133e-01]\n [ 3.44797609e+00 -5.47171599e-01]\n [ 3.39399482e+00 -7.22457494e-01]\n [ 3.31494794e+00 -8.50723292e-01]\n [ 3.22077512e+00 -8.89284590e-01]\n [ 3.14100846e+00 -8.44438658e-01]\n [ 3.06863211e+00 -7.38563533e-01]\n [ 3.01140032e+00 -5.95521072e-01]\n [ 2.96957184e+00 -4.33122275e-01]\n [ 2.94254937e+00 -2.65558171e-01]\n [ 2.92902536e+00 -1.04779569e-01]\n [ 2.92657197e+00  2.01954892e-02]\n [ 2.93124397e+00  1.37399426e-01]\n [ 2.94381246e+00  2.52539973e-01]\n [ 2.96726311e+00  3.66214231e-01]\n [ 3.00344566e+00  4.62821844e-01]\n [ 3.05523559e+00  5.25590050e-01]\n [ 3.10954797e+00  5.30498766e-01]\n [ 3.15545890e+00  4.92294699e-01]\n [ 3.19630834e+00  4.21061512e-01]\n [ 3.22798460e+00  3.30837703e-01]\n [ 3.25047003e+00  2.31595009e-01]\n [ 3.26425451e+00  1.31376405e-01]\n [ 3.27026348e+00  3.69817622e-02]\n [ 3.27032022e+00 -3.43047605e-02]\n [ 3.26666050e+00 -9.86728336e-02]\n [ 3.25761244e+00 -1.69084140e-01]\n [ 3.24181592e+00 -2.35664155e-01]\n [ 3.21815604e+00 -2.89725638e-01]\n [ 3.18429553e+00 -3.20362152e-01]\n [ 3.15309066e+00 -3.15024789e-01]\n [ 3.12425170e+00 -2.83201790e-01]\n [ 3.10139564e+00 -2.35289018e-01]\n [ 3.08426522e+00 -1.78385638e-01]\n [ 3.07261108e+00 -1.17822972e-01]\n [ 3.06604485e+00 -5.81409399e-02]\n [ 3.06391073e+00 -3.19254554e-03]\n [ 3.06520910e+00  4.35237186e-02]\n [ 3.06927926e+00  8.53220221e-02]\n [ 3.07718395e+00  1.27126526e-01]\n [ 3.08955775e+00  1.63244849e-01]\n [ 3.10726627e+00  1.88035031e-01]\n [ 3.12816580e+00  1.92641150e-01]\n [ 3.14514919e+00  1.79958412e-01]\n [ 3.16033354e+00  1.54737449e-01]\n [ 3.17212690e+00  1.22261680e-01]\n [ 3.18054391e+00  8.62211126e-02]\n [ 3.18575878e+00  4.95671531e-02]\n [ 3.18809120e+00  1.47877291e-02]\n [ 3.18815692e+00 -1.23013864e-02]\n [ 3.18669387e+00 -3.72472605e-02]\n [ 3.18318709e+00 -6.32930745e-02]\n [ 3.17716500e+00 -8.74168199e-02]\n [ 3.16823847e+00 -1.06481427e-01]\n [ 3.15542108e+00 -1.16344724e-01]\n [ 3.14425889e+00 -1.12974432e-01]\n [ 3.13402907e+00 -1.00361978e-01]\n [ 3.12597354e+00 -8.22061579e-02]\n [ 3.12001933e+00 -6.10201956e-02]\n [ 3.11607217e+00 -3.87168038e-02]\n [ 3.11397966e+00 -1.69135780e-02]\n [ 3.11349387e+00  3.03959580e-03]\n [ 3.11424836e+00  1.99722041e-02]\n [ 3.11619328e+00  3.59527477e-02]\n [ 3.11965933e+00  5.09455024e-02]\n [ 3.12486174e+00  6.29970672e-02]\n [ 3.13227772e+00  6.97647228e-02]\n [ 3.13924900e+00  6.85030107e-02]\n [ 3.14565047e+00  6.12201209e-02]\n [ 3.15066718e+00  5.03702462e-02]\n [ 3.15438222e+00  3.75522333e-02]\n [ 3.15685855e+00  2.39480995e-02]\n [ 3.15818359e+00  1.05557129e-02]\n [ 3.15849886e+00 -1.80105467e-03]\n [ 3.15800914e+00 -1.24488409e-02]\n [ 3.15674425e+00 -2.23848531e-02]\n [ 3.15452235e+00 -3.14861594e-02]\n [ 3.15121844e+00 -3.85760631e-02]\n [ 3.14649146e+00 -4.21343003e-02]\n [ 3.14235443e+00 -4.07366153e-02]\n [ 3.13858943e+00 -3.58599955e-02]\n [ 3.13566035e+00 -2.89428967e-02]\n [ 3.13353222e+00 -2.09315167e-02]\n [ 3.13216692e+00 -1.25372147e-02]\n [ 3.13150744e+00 -4.35425333e-03]\n [ 3.13146523e+00  3.13701267e-03]\n [ 3.13191792e+00  9.56471022e-03]\n [ 3.13291978e+00  1.56785138e-02]\n [ 3.13455026e+00  2.08957463e-02]\n [ 3.13689673e+00  2.44761263e-02]\n [ 3.13982748e+00  2.52470715e-02]\n [ 3.14218397e+00  2.34303798e-02]\n [ 3.14426409e+00  1.97920700e-02]\n [ 3.14583987e+00  1.51377795e-02]\n [ 3.14692072e+00  9.99961667e-03]\n [ 3.14753235e+00  4.79139280e-03]\n [ 3.14771625e+00 -1.48573647e-04]\n [ 3.14753131e+00 -4.55749185e-03]\n [ 3.14700120e+00 -8.51894725e-03]\n [ 3.14607679e+00 -1.19584262e-02]\n [ 3.14471960e+00 -1.44243935e-02]\n [ 3.14274700e+00 -1.52168659e-02]\n [ 3.14126140e+00 -1.41278918e-02]\n [ 3.13995878e+00 -1.18463742e-02]\n [ 3.13898608e+00 -8.91326674e-03]\n [ 3.13833357e+00 -5.67398777e-03]\n [ 3.13798480e+00 -2.39361634e-03]\n [ 3.13791522e+00  7.11147546e-04]\n [ 3.13809130e+00  3.47172962e-03]\n [ 3.13851094e+00  5.92296315e-03]\n [ 3.13919510e+00  7.88956976e-03]\n [ 3.14017196e+00  9.05833852e-03]\n [ 3.14130633e+00  8.96353596e-03]\n [ 3.14216969e+00  7.94709126e-03]\n [ 3.14289295e+00  6.27958460e-03]\n [ 3.14340223e+00  4.29235799e-03]\n [ 3.14370360e+00  2.19249329e-03]\n [ 3.14380909e+00  1.42118141e-04]\n [ 3.14373581e+00 -1.72700778e-03]\n [ 3.14349560e+00 -3.35269744e-03]\n [ 3.14308031e+00 -4.65416671e-03]\n [ 3.14248032e+00 -5.43142294e-03]\n [ 3.14176893e+00 -5.39588036e-03]\n [ 3.14121794e+00 -4.73355729e-03]\n [ 3.14076496e+00 -3.63636789e-03]\n [ 3.14045888e+00 -2.33820167e-03]\n [ 3.14029426e+00 -9.80680528e-04]\n [ 3.14026291e+00  3.24928130e-04]\n [ 3.14035388e+00  1.48587367e-03]\n [ 3.14056313e+00  2.45203169e-03]\n [ 3.14089131e+00  3.11823585e-03]\n [ 3.14115298e+00  3.31057078e-03]]\n\n\n\nSTATE_NAMES = ['angle', 'angular velocity']\ntrajectory_plot = pendulum.plot(\n    result=pendulum_integration_result,\n    state_names = STATE_NAMES\n)\ntrajectory_plot.show()\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nupright_point = pendulum.get_equilibrium('inverted')\ndownward_point = pendulum.get_equilibrium('downward')\nprint(upright_point)\nprint(downward_point)\nphase_portrait = pendulum.phase_plotter.plot_2d(\n    x=pendulum_integration_result['x'],\n    state_names = STATE_NAMES,\n    show_direction = True,\n    equilibria=[upright_point, \n                downward_point]\n)\nphase_portrait.show()\n# TODO: fix issue with equilibria not being marked on the plot\n\n(array([3.14159265, 0.        ]), array([0.]))\n(array([0., 0.]), array([0.]))\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json"
  }
]