[
  {
    "objectID": "tutorials/installation.html",
    "href": "tutorials/installation.html",
    "title": "Installation Guide",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic dynamical systems with multi-backend support. This guide covers installation methods, backend configuration, and verification steps.",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-overview",
    "href": "tutorials/installation.html#sec-overview",
    "title": "Installation Guide",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic dynamical systems with multi-backend support. This guide covers installation methods, backend configuration, and verification steps.",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-requirements",
    "href": "tutorials/installation.html#sec-requirements",
    "title": "Installation Guide",
    "section": "Requirements",
    "text": "Requirements\n\nSystem Requirements\n\nPython 3.9 or higher\npip package manager\n(Optional) GPU with CUDA support for PyTorch/JAX acceleration\n\n\n\nCore Dependencies\nThe library requires:\n\nnumpy - Core numerical operations\nscipy - Scientific computing and integration\nsympy - Symbolic mathematics\nmatplotlib - Visualization\n\n\n\nOptional Backend Dependencies\n\nPyTorch: torch - For automatic differentiation and GPU acceleration\nJAX: jax, jaxlib - For high-performance numerical computing and JIT compilation",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-installation-methods",
    "href": "tutorials/installation.html#sec-installation-methods",
    "title": "Installation Guide",
    "section": "Installation Methods",
    "text": "Installation Methods\n\nStandard Installation (NumPy Only)\nFor basic functionality with NumPy backend:\npip install cdesym\nThis installs the core library with NumPy support, suitable for most educational and prototyping applications.\n\n\nInstallation with PyTorch Backend\nFor neural network integration and GPU acceleration:\npip install \"cdesym[torch]\"\nFor specific CUDA versions, install PyTorch first:\n# Example: CUDA 11.8\npip install torch --index-url https://download.pytorch.org/whl/cu118\npip install \"cdesym[torch]\"\n\n\nInstallation with JAX Backend\nFor high-performance computing and JIT compilation:\npip install \"cdesym[jax]\"\nFor GPU support with JAX:\n# CUDA 12\npip install \"cdesym[jax]\" \"jax[cuda12]\"\n\n# CUDA 11\npip install \"cdesym[jax]\" \"jax[cuda11]\"\n\n\nInstallation with Julia DifferentialEquations.jl and DiffEqPy\nFor support for Julia DifferentialEquations.jl support, first install Julia and add it to the environment path so that it can be discovered. Then, install and pre-compile DifferentialEquations.jl.\nOnce that is done, then execute the following:\npip install \"cdesym[julia]\"\n\n\nDevelopment Installation\nTo install from source for development or to access the latest features:\ngit clone https://github.com/yourusername/ControlDESymulation.git\ncd ControlDESymulation\npip install -e .\nThe -e flag installs in editable mode, allowing you to modify the source code without reinstalling.\n\n\nInstalling All Backends\nFor full functionality with all backends (including Julia support):\nFirst install Julia and DifferentialEquations.jl, then\npip install \"cdesym[torch,jax,julia]\"\n\n\nOther options\nThese flags will install core library dependencies PLUS\npip install \"cdesym[viz]\"\nPlotly, matplotlib, and seaborn\npip install \"cdesym[control]\"\nPython control library\npip install \"cdesym[optimization]\"\nCVXPY, Clarabel, OSPQ, SCS, CasADi (for future functionality)\npip install \"cdesym[dev]\"\nPytest and many associated Pytest extensions, Coverage.py, Mutmut, Black, isort, ruff, mypy and extensions, flake8, pylint, bandit, safety, pre-commit, radon, pydeps types-requests, types-setuptools, build, twine, setuptools, and wheel\npip install \"cdesym[docs]\"\nSphinx and associated extensions, myst-parser\npip install \"cdesym[notebooks]\"\nJupyter, JupyterLab, IPyKernel, IPyWidgets, Notebook, and IPython",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-backend-configuration",
    "href": "tutorials/installation.html#sec-backend-configuration",
    "title": "Installation Guide",
    "section": "Backend Configuration",
    "text": "Backend Configuration\n\nSetting the Default Backend\nControlDESymulation automatically detects available backends. You can explicitly set the backend:\nfrom cdesym import DynamicalSystem\n\n# Using NumPy (default)\nsystem = DynamicalSystem(..., backend='numpy')\n\n# Using PyTorch\nsystem = DynamicalSystem(..., backend='torch')\n\n# Using JAX\nsystem = DynamicalSystem(..., backend='jax')\n\n\nBackend Priority\nWhen no backend is specified, the library searches in order:\n\nJAX (if available)\nPyTorch (if available)\nNumPy (always available)\n\n\n\nChecking Available Backends\nfrom cdesym.backends import get_available_backends\n\nprint(get_available_backends())\n# Output: ['numpy', 'torch', 'jax']",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-verification",
    "href": "tutorials/installation.html#sec-verification",
    "title": "Installation Guide",
    "section": "Verification",
    "text": "Verification\n\nBasic Installation Check\nVerify the installation:\nimport cdesym\nprint(cdesym.__version__)\n\n\nTesting Backend Functionality\nTest each backend with a simple system:\nimport sympy as sp\nfrom cdesym import DynamicalSystem\n\n# Define symbolic variables\nx, y = sp.symbols('x y')\n\n# Define a simple system: dx/dt = -x, dy/dt = -y\ndynamics = sp.Matrix([-x, -y])\nstate_vars = sp.Matrix([x, y])\n\n# Test NumPy backend\nsystem_np = DynamicalSystem(\n    dynamics=dynamics,\n    state_vars=state_vars,\n    backend='numpy'\n)\n\n# Test simulation\nt_span = (0, 5)\ninitial_state = [1.0, 1.0]\nresult = system_np.simulate(t_span, initial_state)\nprint(f\"NumPy backend: {len(result.t)} time points\")\n\n# Test PyTorch backend (if available)\ntry:\n    system_torch = DynamicalSystem(\n        dynamics=dynamics,\n        state_vars=state_vars,\n        backend='torch'\n    )\n    print(\"PyTorch backend: Available\")\nexcept ImportError:\n    print(\"PyTorch backend: Not available\")\n\n# Test JAX backend (if available)\ntry:\n    system_jax = DynamicalSystem(\n        dynamics=dynamics,\n        state_vars=state_vars,\n        backend='jax'\n    )\n    print(\"JAX backend: Available\")\nexcept ImportError:\n    print(\"JAX backend: Not available\")\n\n\nRunning Test Suite\nIf you have the development installation, run the test suite:\npytest tests/\nFor specific backend tests:\npytest tests/test_numpy_backend.py\npytest tests/test_torch_backend.py\npytest tests/test_jax_backend.py",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-troubleshooting",
    "href": "tutorials/installation.html#sec-troubleshooting",
    "title": "Installation Guide",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nImport Errors\nProblem: ModuleNotFoundError: No module named 'cdesym'\nSolution: Ensure installation completed successfully:\npip list | grep cdesym\n\n\nBackend Not Available\nProblem: “Backend ‘torch’ not available”\nSolution: Install the required backend:\npip install torch\n\n\nCUDA/GPU Issues\nProblem: PyTorch or JAX not utilizing GPU\nSolution: Verify GPU availability:\n# For PyTorch\nimport torch\nprint(torch.cuda.is_available())\n\n# For JAX\nimport jax\nprint(jax.devices())\nInstall appropriate CUDA-enabled versions if needed.\n\n\nSymPy Compatibility\nProblem: Symbolic computation errors\nSolution: Ensure SymPy is up to date:\npip install --upgrade sympy\n\n\nNumerical Integration Warnings\nProblem: Integration warnings during simulation\nSolution: These are typically harmless but can be addressed by: - Adjusting tolerance parameters (atol, rtol) - Using different integration methods - Checking system stability",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-gpu-acceleration-setup",
    "href": "tutorials/installation.html#sec-gpu-acceleration-setup",
    "title": "Installation Guide",
    "section": "GPU Acceleration Setup",
    "text": "GPU Acceleration Setup\n\nPyTorch GPU Configuration\nimport torch\n\n# Check CUDA availability\nif torch.cuda.is_available():\n    device = torch.device('cuda')\n    print(f\"Using GPU: {torch.cuda.get_device_name(0)}\")\nelse:\n    device = torch.device('cpu')\n    print(\"Using CPU\")\n\n# Create system with PyTorch backend\nsystem = DynamicalSystem(..., backend='torch')\n\n# Move tensors to GPU when needed\ninitial_state_gpu = torch.tensor(initial_state).to(device)\n\n\nJAX GPU Configuration\nimport jax\n\n# JAX automatically uses GPU if available\nprint(f\"JAX backend: {jax.default_backend()}\")\nprint(f\"JAX devices: {jax.devices()}\")\n\n# Verify GPU usage\nimport jax.numpy as jnp\nx = jnp.ones(1000)\nprint(x.device())  # Should show GPU device",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-virtual-environment-setup",
    "href": "tutorials/installation.html#sec-virtual-environment-setup",
    "title": "Installation Guide",
    "section": "Virtual Environment Setup",
    "text": "Virtual Environment Setup\n\nUsing venv\n# Create virtual environment\npython -m venv cds_env\n\n# Activate (Linux/Mac)\nsource cds_env/bin/activate\n\n# Activate (Windows)\ncds_env\\Scripts\\activate\n\n# Install ControlDESymulation\npip install cdesym\n\n\nUsing conda\n# Create conda environment\nconda create -n cds_env python=3.12\n\n# Activate environment\nconda activate cds_env\n\n# Install ControlDESymulation\npip install cdesym",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-next-steps",
    "href": "tutorials/installation.html#sec-next-steps",
    "title": "Installation Guide",
    "section": "Next Steps",
    "text": "Next Steps\nAfter successful installation:\n\nReview the Quick Start Guide for basic usage examples\nExplore Tutorials for detailed walkthroughs\nCheck API Reference for comprehensive documentation\nSee Examples Gallery for application demonstrations",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-getting-help",
    "href": "tutorials/installation.html#sec-getting-help",
    "title": "Installation Guide",
    "section": "Getting Help",
    "text": "Getting Help\nIf you encounter issues not covered here:\n\nCheck the GitHub Issues\nReview the FAQ\nJoin the Discussions",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/installation.html#sec-version-information",
    "href": "tutorials/installation.html#sec-version-information",
    "title": "Installation Guide",
    "section": "Version Information",
    "text": "Version Information\nCheck your installed version:\nimport cdesym\nprint(f\"ControlDESymulation version: {cdesym.__version__}\")\nUpdate to the latest version:\npip install --upgrade cdesym",
    "crumbs": [
      "Installation Guide",
      "Installation Guide"
    ]
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Installation\nBasic Usage"
  },
  {
    "objectID": "tutorials/index.html#sec-getting-started",
    "href": "tutorials/index.html#sec-getting-started",
    "title": "Tutorials",
    "section": "",
    "text": "Installation\nBasic Usage"
  },
  {
    "objectID": "tutorials/index.html#sec-core-concepts",
    "href": "tutorials/index.html#sec-core-concepts",
    "title": "Tutorials",
    "section": "Core Concepts",
    "text": "Core Concepts\n\nTODO: Plan and make these"
  },
  {
    "objectID": "tutorials/index.html#sec-advanced-topics",
    "href": "tutorials/index.html#sec-advanced-topics",
    "title": "Tutorials",
    "section": "Advanced Topics",
    "text": "Advanced Topics\n\nTODO: Plan and make these"
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html",
    "href": "architecture/UI_Framework_Architecture.html",
    "title": "UI Framework Architecture",
    "section": "",
    "text": "The UI (User Interface) Framework is Layer 3 of the architecture, consisting of 8 core files organized into a 4-layer hierarchy that provides the user-facing API for defining and working with dynamical systems. This layer eliminates approximately 1,800 lines of code duplication while maintaining clean separation of concerns.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nLayer 0: SymbolicSystemBase - Time-domain agnostic foundation\nLayer 1: ContinuousSystemBase, DiscreteSystemBase - Time-domain interfaces\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem - Concrete implementations\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem - Stochastic extensions\nSpecial: DiscretizedSystem - Continuous → discrete conversion\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nMost users interact with the UI framework at two levels:\n# Level 1: Use built-in systems (simplest)\nfrom cdesym import Pendulum, CartPole, VanDerPol\n\nsystem = Pendulum()\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\n\n# Level 2: Define custom systems (subclass framework)\nfrom cdesym import ContinuousSymbolicSystem\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\nUsers should NOT: - Directly instantiate internal utilities (BackendManager, CodeGenerator, etc.) - Access private attributes (those starting with _) - Override methods other than define_system() and print_equations()\nThe framework automatically composes internal components and exposes functionality through clean public methods. This documentation describes the internal architecture for framework developers.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-overview",
    "href": "architecture/UI_Framework_Architecture.html#sec-overview",
    "title": "UI Framework Architecture",
    "section": "",
    "text": "The UI (User Interface) Framework is Layer 3 of the architecture, consisting of 8 core files organized into a 4-layer hierarchy that provides the user-facing API for defining and working with dynamical systems. This layer eliminates approximately 1,800 lines of code duplication while maintaining clean separation of concerns.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nLayer 0: SymbolicSystemBase - Time-domain agnostic foundation\nLayer 1: ContinuousSystemBase, DiscreteSystemBase - Time-domain interfaces\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem - Concrete implementations\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem - Stochastic extensions\nSpecial: DiscretizedSystem - Continuous → discrete conversion\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nMost users interact with the UI framework at two levels:\n# Level 1: Use built-in systems (simplest)\nfrom cdesym import Pendulum, CartPole, VanDerPol\n\nsystem = Pendulum()\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\n\n# Level 2: Define custom systems (subclass framework)\nfrom cdesym import ContinuousSymbolicSystem\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\nUsers should NOT: - Directly instantiate internal utilities (BackendManager, CodeGenerator, etc.) - Access private attributes (those starting with _) - Override methods other than define_system() and print_equations()\nThe framework automatically composes internal components and exposes functionality through clean public methods. This documentation describes the internal architecture for framework developers.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/UI_Framework_Architecture.html#sec-architecture-philosophy",
    "title": "UI Framework Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nLayered Composition with Strategic Inheritance - The UI framework achieves:\n\nZero Code Duplication - Shared functionality lives in exactly one place\nClean Separation - Each layer has a single, focused responsibility\nProgressive Complexity - Simple systems inherit from basic layers\nType Safety - Comprehensive type annotations throughout\nExtensibility - Clear extension points via define_system()\nBackend Agnosticism - Multi-backend support transparent to users\n\nThe architecture uses cooperative multiple inheritance strategically at Layer 2 to combine symbolic machinery with time-domain interfaces, avoiding the duplication that would occur with composition alone.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-architecture-layers",
    "href": "architecture/UI_Framework_Architecture.html#sec-architecture-layers",
    "title": "UI Framework Architecture",
    "section": "Architecture Layers",
    "text": "Architecture Layers\n┌─────────────────────────────────────────────────────────────┐\n│  Layer 0: SymbolicSystemBase (time-domain agnostic)         │\n│  • Symbolic variables and parameters                        │\n│  • Code generation and backend management                   │\n│  • Equilibrium handling and configuration                   │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n          ┌──────────┴──────────┐\n          │                     │\n┌─────────▼────────┐  ┌─────────▼─────────┐\n│  Layer 1:        │  │  Layer 1:         │\n│  Continuous      │  │  Discrete         │\n│  SystemBase      │  │  SystemBase       │\n│  • dx/dt = f     │  │  • x[k+1] = f     │\n│  • integrate()   │  │  • step()         │\n│  • linearize()   │  │  • simulate()     │\n└─────────┬────────┘  └─────────┬─────────┘\n          │                     │\n    ┌─────┴─────┐         ┌─────┴─────┐\n    │           │         │           │\n┌───▼────┐  ┌───▼────┐ ┌─▼──────┐ ┌──▼──────┐\n│Layer 2:│  │Layer 3:│ │Layer 2:│ │Layer 3: │\n│Cont.   │  │Cont.   │ │Disc.   │ │Disc.    │\n│Symbolic│  │Stoch.  │ │Symbolic│ │Stoch.   │\n│System  │  │System  │ │System  │ │System   │\n└────────┘  └────────┘ └────────┘ └─────────┘",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-0",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-0",
    "title": "UI Framework Architecture",
    "section": "Layer 0: Foundation",
    "text": "Layer 0: Foundation\n\nSymbolicSystemBase: Time-Agnostic Foundation\nFile: symbolic_system_base.py\nThe SymbolicSystemBase provides all symbolic manipulation and backend management functionality, making no assumptions about continuous vs discrete time.\nCore responsibilities:\n\nSymbolic variable management - State, control, and output variables\nParameter handling - Symbolic parameters with numeric values\nCode generation - Symbolic → numerical via CodeGenerator\nBackend management - NumPy/PyTorch/JAX switching via BackendManager\nEquilibrium management - Named equilibria via EquilibriumHandler\nConfiguration persistence - Save/load system definitions\nValidation - Symbolic system validation via SymbolicValidator\n\nKey design patterns:\n\nComposition - Delegates to specialized utilities\nTemplate Method - __init__ orchestrates: define → validate → initialize\nAbstract Methods - Forces subclasses to implement define_system()\n\nWhat Layer 0 does NOT provide:\n\nForward dynamics evaluation (__call__, step)\nTime integration (integrate, simulate)\nLinearization computation\nThese are time-domain specific and live in Layer 1\n\nInternal composition (users never access these directly):\n\n\nCode\nsystem = Pendulum()\n\n# Internal utilities (composed automatically)\nbackend_mgr = system.backend           # BackendManager\ncode_gen = system._code_gen            # CodeGenerator\nequilibria = system.equilibria         # EquilibriumHandler\nvalidator = system._validator          # SymbolicValidator\n\nprint(\"✓ Layer 0 composes internal utilities transparently\")\n\n\nUser-facing Layer 0 methods:\n\n\nCode\n# Backend management\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\n# Equilibrium management\nsystem.add_equilibrium('origin', x_eq=np.zeros(2), u_eq=np.zeros(1))\nx_eq, u_eq = system.get_equilibrium('origin')\nequilibria_list = system.list_equilibria()\n\n# Configuration\n# config = system.save_config('pendulum_config.json')\n# system_loaded = Pendulum.load_config('pendulum_config.json')\n\nprint(f\"System order: {system.order}\")\nprint(f\"State dimension: {system.nx}\")\nprint(f\"Control dimension: {system.nu}\")\n\n\nAbstract methods subclasses must implement:\n@abstractmethod\ndef define_system(self, **params):\n    \"\"\"Define symbolic system components.\n    \n    Must set:\n    - self.state_vars: List[sp.Symbol]\n    - self.control_vars: List[sp.Symbol]\n    - self._f_sym: sp.Matrix (dynamics)\n    - self.parameters: Dict[sp.Symbol, float]\n    - self.order: int\n    \"\"\"\n    pass\n\n@abstractmethod\ndef print_equations(self, simplify: bool = True):\n    \"\"\"Print system equations in readable form.\"\"\"\n    pass",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-1",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-1",
    "title": "UI Framework Architecture",
    "section": "Layer 1: Time-Domain Interfaces",
    "text": "Layer 1: Time-Domain Interfaces\n\nContinuousSystemBase: Continuous-Time Interface\nFile: continuous_system_base.py\nThe ContinuousSystemBase defines the abstract interface for continuous-time systems described by ODEs.\nMathematical form:\n\\[\\frac{dx}{dt} = f(x, u, t)\\]\nCore responsibilities:\n\nDynamics evaluation - Abstract __call__(x, u) for forward dynamics\nNumerical integration - Abstract integrate() with multi-method support\nLinearization - Abstract linearize() for Jacobian computation\nHigh-level simulation - Concrete simulate() with controller support\n\nAbstract methods (Layer 2 implements):\n@abstractmethod\ndef __call__(\n    self, \n    x: StateVector, \n    u: Optional[ControlVector] = None\n) -&gt; StateVector:\n    \"\"\"Evaluate dx/dt = f(x, u).\"\"\"\n    pass\n\n@abstractmethod\ndef integrate(\n    self,\n    x0: StateVector,\n    u: Optional[Union[ControlVector, Callable]] = None,\n    t_span: TimeSpan = (0, 10),\n    **kwargs\n) -&gt; IntegrationResult:\n    \"\"\"Integrate system over time span.\"\"\"\n    pass\n\n@abstractmethod\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute A = ∂f/∂x, B = ∂f/∂u.\"\"\"\n    pass\nConcrete method (provided by Layer 1):\ndef simulate(\n    self,\n    x0: StateVector,\n    controller: Optional[Callable[[float, StateVector], ControlVector]] = None,\n    t_span: TimeSpan = (0, 10),\n    dt: float = 0.01,\n    **kwargs\n) -&gt; Dict[str, np.ndarray]:\n    \"\"\"High-level simulation with regular time grid.\n    \n    Returns\n    -------\n    dict with keys:\n        'time': Regular time points (T,)\n        'states': State trajectory (T, nx)\n        'controls': Control sequence (T, nu)\n    \"\"\"\nUsage example:\n\n\nCode\nsystem = Pendulum()\n\n# Evaluate dynamics (Layer 1 interface)\nx = np.array([0.5, 0.0])\nu = np.array([0.0])\ndx = system(x, u)\nprint(f\"State derivative: {dx}\")\n\n# Integrate (adaptive time grid)\nresult = system.integrate(x, u=None, t_span=(0, 5), method='RK45')\nprint(f\"Integration steps: {result['nsteps']}\")\n\n# Simulate (regular time grid - better for plotting)\nsim_result = system.simulate(x, controller=None, t_span=(0, 5), dt=0.01)\nprint(f\"Simulation time points: {len(sim_result['time'])}\")\n\n# Linearize\nx_eq, u_eq = system.get_equilibrium('origin')\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix: {A.shape}\")\n\n\nKey features:\n\nFlexible control input (None, arrays, or callable controllers)\nMulti-backend integration support (scipy, Julia, PyTorch, JAX)\nDense output and adaptive stepping available\nComprehensive solver diagnostics\n\n\n\nDiscreteSystemBase: Discrete-Time Interface\nFile: discrete_system_base.py\nThe DiscreteSystemBase defines the abstract interface for discrete-time systems.\nMathematical form:\n\\[x[k+1] = f(x[k], u[k], k)\\]\nCore responsibilities:\n\nSingle step - Abstract step(x, u) for one time step\nMulti-step simulation - Abstract simulate() for trajectories\nLinearization - Abstract linearize() for discrete Jacobians\nSampling properties - Concrete dt property and sampling_frequency\n\nAbstract property (must implement):\n@property\n@abstractmethod\ndef dt(self) -&gt; float:\n    \"\"\"Sampling period [seconds].\"\"\"\n    pass\nAbstract methods (Layer 2 implements):\n@abstractmethod\ndef step(\n    self,\n    x: StateVector,\n    u: Optional[ControlVector] = None,\n    k: int = 0\n) -&gt; StateVector:\n    \"\"\"Single time step: x[k] → x[k+1].\"\"\"\n    pass\n\n@abstractmethod\ndef simulate(\n    self,\n    x0: StateVector,\n    u_sequence: Optional[ControlSequence] = None,\n    n_steps: int = 100,\n    **kwargs\n) -&gt; Dict[str, np.ndarray]:\n    \"\"\"Multi-step simulation.\"\"\"\n    pass\n\n@abstractmethod\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute Ad = ∂f/∂x, Bd = ∂f/∂u (discrete Jacobians).\"\"\"\n    pass\nConcrete properties (provided by Layer 1):\n@property\ndef sampling_frequency(self) -&gt; float:\n    \"\"\"Sampling frequency [Hz].\"\"\"\n    return 1.0 / self.dt\nKey conventions:\n\nTime-major ordering - Arrays are (n_steps, nx), not (nx, n_steps)\nControl sequences - Pre-computed controls or None for autonomous systems\nState feedback - rollout() method for policy-based simulation",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-2",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-2",
    "title": "UI Framework Architecture",
    "section": "Layer 2: Concrete Symbolic Implementations",
    "text": "Layer 2: Concrete Symbolic Implementations\n\nContinuousSymbolicSystem: Symbolic + Continuous\nFile: continuous_symbolic_system.py\nInheritance: SymbolicSystemBase + ContinuousSystemBase (cooperative multiple inheritance)\nThe ContinuousSymbolicSystem combines symbolic machinery (Layer 0) with continuous-time execution (Layer 1).\nKey internal components (automatically composed):\n\nDynamicsEvaluator - Evaluates dx/dt = f(x, u)\nLinearizationEngine - Computes A = ∂f/∂x, B = ∂f/∂u\nObservationEngine - Evaluates y = h(x), C = ∂h/∂x\nIntegratorFactory - Creates appropriate ODE solvers\n\nImplemented methods (Layer 1 abstractions):\ndef __call__(\n    self, \n    x: StateVector, \n    u: Optional[ControlVector] = None\n) -&gt; StateVector:\n    \"\"\"Evaluate dx/dt = f(x, u) using DynamicsEvaluator.\"\"\"\n    return self._dynamics.evaluate(x, u, backend=self.backend.default_backend)\n\ndef integrate(\n    self,\n    x0: StateVector,\n    u: Optional[Union[ControlVector, Callable]] = None,\n    t_span: TimeSpan = (0, 10),\n    method: Optional[str] = None,\n    **kwargs\n) -&gt; IntegrationResult:\n    \"\"\"Integrate using IntegratorFactory.\"\"\"\n    # Creates appropriate integrator and delegates\n\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute Jacobians using LinearizationEngine.\"\"\"\n    return self._linearization.linearize_continuous(x_eq, u_eq)\nUser subclass pattern:\n\n\nCode\nclass SpringMassDamper(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0, c=0.5):\n        \"\"\"Define mass-spring-damper system.\"\"\"\n        # Symbolic variables\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n        \n        # System definition\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            v,\n            (-k_sym*x - c_sym*v + u)/m_sym\n        ])\n        self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Mass-Spring-Damper Equations:\")\n        print(\"  dx/dt = v\")\n        print(\"  dv/dt = (-k*x - c*v + u)/m\")\n\n# Use the system\nsystem = SpringMassDamper(m=2.0, k=5.0)\nx0 = np.array([1.0, 0.0])\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\nprint(f\"✓ Custom continuous symbolic system\")\n\n\n\n\nDiscreteSymbolicSystem: Symbolic + Discrete\nFile: discrete_symbolic_system.py\nInheritance: SymbolicSystemBase + DiscreteSystemBase (cooperative multiple inheritance)\nThe DiscreteSymbolicSystem combines symbolic machinery with discrete-time execution.\nKey internal components:\n\nDynamicsEvaluator - Evaluates x[k+1] = f(x[k], u[k])\nLinearizationEngine - Computes Ad = ∂f/∂x, Bd = ∂f/∂u\nObservationEngine - Evaluates y[k] = h(x[k])\n\nCritical requirement:\n\n\n\n\n\n\nImportantRequired: Set self._dt\n\n\n\nDiscrete systems must set self._dt in define_system(). This is the sampling period that defines the discrete-time grid.\n\n\nUser subclass pattern:\n\n\nCode\nclass DiscreteLinearSystem(DiscreteSymbolicSystem):\n    def define_system(self, a=0.9, b=0.1, dt=0.01):\n        \"\"\"Define discrete linear system.\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        a_sym, b_sym = sp.symbols('a b', real=True)\n        \n        # System definition\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([a_sym*x + b_sym*u])\n        self.parameters = {a_sym: a, b_sym: b}\n        self._dt = dt  # REQUIRED for discrete systems!\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Discrete Linear System:\")\n        print(f\"  x[k+1] = a*x[k] + b*u[k]\")\n        print(f\"  dt = {self._dt}s\")\n\n# Use the system\nsystem = DiscreteLinearSystem(a=0.95, dt=0.1)\nx0 = np.array([1.0])\nresult = system.simulate(x0, u_sequence=None, n_steps=50)\nprint(f\"✓ Custom discrete symbolic system\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-3",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-3",
    "title": "UI Framework Architecture",
    "section": "Layer 3: Stochastic Extensions",
    "text": "Layer 3: Stochastic Extensions\n\nContinuousStochasticSystem: SDE Support\nFile: continuous_stochastic_system.py\nInheritance: ContinuousSymbolicSystem (single inheritance - extends deterministic)\nThe ContinuousStochasticSystem adds stochastic differential equation (SDE) support to continuous systems.\nMathematical form:\n\\[dx = f(x, u, t)dt + g(x, u, t)dW\\]\nwhere: - \\(f(x, u, t)\\) - Drift (inherited from parent) - \\(g(x, u, t)\\) - Diffusion matrix (added here) - \\(dW\\) - Brownian motion increments\nAdditional internal components:\n\nDiffusionHandler - Generates and caches diffusion functions\nNoiseCharacterizer - Automatic noise structure analysis\nSDEValidator - SDE-specific validation\nSDEIntegratorFactory - Stochastic integration methods\n\nNoise structure types (auto-detected):\n\n\n\n\n\n\n\n\nType\nStructure\nMeaning\n\n\n\n\nADDITIVE\n\\(g(x,u,t) = \\text{constant}\\)\nNoise intensity independent of state\n\n\nMULTIPLICATIVE\n\\(g\\) depends on state\nState-dependent noise\n\n\nDIAGONAL\n\\(g\\) is diagonal matrix\nIndependent noise channels\n\n\nSCALAR\nSingle Wiener process\n\\(n_w = 1\\)\n\n\nGENERAL\nFull matrix coupling\nCorrelated noise\n\n\n\nAdditional user-facing methods:\ndef drift(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Evaluate drift term f(x, u).\"\"\"\n    \ndef diffusion(self, x: StateVector, u: ControlVector) -&gt; DiffusionMatrix:\n    \"\"\"Evaluate diffusion term g(x, u).\"\"\"\n\ndef is_additive_noise(self) -&gt; bool:\n    \"\"\"Check if noise is additive (state-independent).\"\"\"\n\ndef recommend_solvers(self, backend: Backend) -&gt; List[str]:\n    \"\"\"Recommend integration methods based on noise structure.\"\"\"\nUser subclass pattern:\n\n\nCode\nclass OrnsteinUhlenbeck(ContinuousStochasticSystem):\n    def define_system(self, alpha=1.0, sigma=0.5):\n        \"\"\"Define Ornstein-Uhlenbeck process: dx = -α*x*dt + σ*dW\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        alpha_sym, sigma_sym = sp.symbols('alpha sigma', positive=True)\n        \n        # Drift (deterministic part)\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n        self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion (stochastic part)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'  # or 'stratonovich'\n    \n    def print_equations(self, simplify=True):\n        print(\"Ornstein-Uhlenbeck Process:\")\n        print(\"  dx = -α*x*dt + σ*dW\")\n\n# Use the stochastic system\nsystem = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nprint(f\"Additive noise: {system.is_additive_noise()}\")\nprint(f\"Noise dimension: {system.nw}\")\n\n# Integrate SDE\nx0 = np.array([1.0])\nresult = system.integrate(\n    x0, u=None, t_span=(0, 10), \n    method='EM',  # Euler-Maruyama for SDEs\n    dt=0.01\n)\nprint(f\"✓ Stochastic system integration\")\n\n\n\n\nDiscreteStochasticSystem: Discrete SDE Support\nFile: discrete_stochastic_system.py\nInheritance: DiscreteSymbolicSystem (single inheritance)\nThe DiscreteStochasticSystem adds stochastic difference equation support.\nMathematical form:\n\\[x[k+1] = f(x[k], u[k]) + g(x[k], u[k]) \\cdot w[k]\\]\nwhere: - \\(f(x[k], u[k])\\) - Deterministic dynamics - \\(g(x[k], u[k])\\) - Diffusion matrix - \\(w[k]\\) - Discrete-time noise\nSimilar structure to continuous stochastic but for discrete-time systems.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-special-system",
    "href": "architecture/UI_Framework_Architecture.html#sec-special-system",
    "title": "UI Framework Architecture",
    "section": "Special System: DiscretizedSystem",
    "text": "Special System: DiscretizedSystem\n\nDiscretizedSystem: Continuous → Discrete Conversion\nFile: discretized_system.py\nThe DiscretizedSystem creates discrete-time approximations from continuous systems.\nDiscretization methods:\n\n\n\nMethod\nOrder\nDescription\n\n\n\n\nexact\nN/A\nMatrix exponential (linear systems only)\n\n\neuler\n1\nForward Euler approximation\n\n\nrk4\n4\nFourth-order Runge-Kutta\n\n\ntustin\n2\nBilinear (Tustin) transform\n\n\nbackward\n1\nBackward Euler (implicit)\n\n\nmatched\nN/A\nZero-order hold\n\n\n\nUsage example:\n\n\nCode\n# Start with continuous system\ncontinuous_system = Pendulum()\n\n# Create discrete approximation\nfrom cdesym.systems.base.core.discretized_system import DiscretizedSystem\n\ndiscrete_system = DiscretizedSystem(\n    continuous_system,\n    dt=0.01,\n    method='rk4'\n)\n\n# Use as discrete system\nx_next = discrete_system.step(x, u)\nresult = discrete_system.simulate(x0, u_sequence=None, n_steps=100)\n\n\nKey features:\n\nMultiple discretization methods available\nPreserves symbolic structure when possible\nHandles deterministic and stochastic systems\nAutomatic validation of discretization accuracy",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-design-principles",
    "href": "architecture/UI_Framework_Architecture.html#sec-design-principles",
    "title": "UI Framework Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\n1. Cooperative Multiple Inheritance\nWhere used: Layer 2 (ContinuousSymbolicSystem, DiscreteSymbolicSystem)\nWhy: Combines symbolic machinery (Layer 0) with time-domain interface (Layer 1) without code duplication.\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __init__(self, *args, **kwargs):\n        # Python's MRO ensures correct initialization order\n        super().__init__(*args, **kwargs)\nBenefit: Users get both symbolic capabilities and continuous-time interface in one class.\n\n\n2. Composition Over Inheritance\nInternal utilities composed, not inherited:\nclass SymbolicSystemBase:\n    def __init__(self):\n        # Compose specialized utilities\n        self.backend = BackendManager()\n        self._code_gen = CodeGenerator(self, self.backend)\n        self.equilibria = EquilibriumHandler(self.nx, self.nu)\n        self._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\n        # etc.\nBenefit: Single responsibility, testability, flexibility.\n\n\n3. Template Method Pattern\nBase class orchestrates, subclass fills details:\nclass SymbolicSystemBase:\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\nBenefit: Consistent initialization, clear extension point.\n\n\n4. Separation of Concerns\nEach layer has a single, focused responsibility:\n\nLayer 0: Symbolic manipulation (time-agnostic)\nLayer 1: Time-domain semantics (abstract interfaces)\nLayer 2: Concrete execution (symbolic + time-domain)\nLayer 3: Specialized extensions (stochastic)\n\n\n\n5. Zero Code Duplication\nBefore refactoring: ~1,800 lines duplicated between continuous and discrete systems\nAfter refactoring: All shared functionality in SymbolicSystemBase\nEliminated duplication: - Parameter handling - Backend management - Code generation - Symbolic validation - Equilibrium management - Configuration persistence",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-system-properties",
    "href": "architecture/UI_Framework_Architecture.html#sec-system-properties",
    "title": "UI Framework Architecture",
    "section": "System Properties",
    "text": "System Properties\n\nAutomatic Properties (All Systems)\nAll systems automatically provide these properties:\n\n\nCode\nsystem = Pendulum()\n\n# Dimensions\nprint(f\"State dimension (nx): {system.nx}\")\nprint(f\"Control dimension (nu): {system.nu}\")\nprint(f\"Output dimension (ny): {system.ny}\")\nprint(f\"Physical dimension (nq): {system.nq}\")\nprint(f\"System order: {system.order}\")\n\n# Backend\nprint(f\"Default backend: {system.backend.default_backend}\")\nprint(f\"Device: {system.backend.preferred_device}\")\n\n\n\n\nDiscrete-Only Properties\n# Discrete systems only\ndt: float                    # Sampling period [s]\nsampling_frequency: float    # 1/dt [Hz]\n\n\nStochastic-Only Properties\n# Stochastic systems only\nnw: int                      # Number of Wiener processes\nis_additive_noise() -&gt; bool  # Noise structure check\nis_multiplicative_noise() -&gt; bool",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-backend-support",
    "href": "architecture/UI_Framework_Architecture.html#sec-backend-support",
    "title": "UI Framework Architecture",
    "section": "Backend Support",
    "text": "Backend Support\nAll systems support multi-backend execution transparently:\n\n\n\n\n\n\n\n\nBackend\nExecution\nBest For\n\n\n\n\nNumPy\nCPU\nGeneral purpose, maximum compatibility\n\n\nPyTorch\nCPU/GPU\nNeural networks, GPU acceleration, automatic differentiation\n\n\nJAX\nCPU/GPU/TPU\nOptimization, XLA compilation, functional programming\n\n\nJulia (via DiffEqPy)\nCPU\nHigh-performance ODE/SDE solvers\n\n\n\nSwitching backends:\n\n\nCode\nsystem = Pendulum()\n\n# NumPy (default)\nx_np = np.array([1.0, 0.0])\ndx_np = system(x_np, np.zeros(1))\n\n# Temporary PyTorch\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    dx_torch = system(x_torch, torch.zeros(1))\n    print(f\"PyTorch result type: {type(dx_torch)}\")\n\n# Permanent switch\nsystem.set_default_backend('jax')\nx_jax = jnp.array([1.0, 0.0])\ndx_jax = system(x_jax, jnp.zeros(1))\n\nprint(\"✓ Backend switching is transparent\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-integration-methods",
    "href": "architecture/UI_Framework_Architecture.html#sec-integration-methods",
    "title": "UI Framework Architecture",
    "section": "Integration Methods",
    "text": "Integration Methods\n\nContinuous Systems (ODE Solvers)\n\n\n\n\n\n\n\n\nBackend\nMethods\nExamples\n\n\n\n\nscipy\nAdaptive\nRK45, RK23, DOP853, Radau, BDF, LSODA\n\n\nJulia (DiffEqPy)\nAdaptive\nTsit5, Vern7, Vern9, Rodas5, AutoTsit5\n\n\nJAX (diffrax)\nAdaptive\ndopri5, tsit5, heun\n\n\nPyTorch (torchdiffeq)\nAdaptive\ndopri5, adaptive_heun\n\n\nFixed-step\nAll backends\neuler, rk4, midpoint\n\n\n\n\n\nStochastic Systems (SDE Solvers)\n\n\n\nBackend\nMethods\nConvergence\n\n\n\n\ntorchsde\neuler, milstein, srk\nStrong 0.5-1.0\n\n\ndiffrax\neuler, heun\nStrong 0.5-1.0\n\n\nJulia (DiffEqPy)\nEM, milstein, etc.\nStrong/Weak",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-usage-examples",
    "href": "architecture/UI_Framework_Architecture.html#sec-usage-examples",
    "title": "UI Framework Architecture",
    "section": "Usage Examples",
    "text": "Usage Examples\n\nExample 1: Pendulum (Continuous)\n\n\nCode\nclass SimplePendulum(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, l=0.5, g=9.81, b=0.1):\n        \"\"\"Simple pendulum with damping.\"\"\"\n        # Symbolic variables\n        theta, omega = sp.symbols('theta omega', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, l_sym, g_sym, b_sym = sp.symbols('m l g b', positive=True)\n        \n        # System definition\n        self.state_vars = [theta, omega]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            omega,\n            -(g_sym/l_sym)*sp.sin(theta) - (b_sym/(m_sym*l_sym**2))*omega + u/(m_sym*l_sym**2)\n        ])\n        self.parameters = {m_sym: m, l_sym: l, g_sym: g, b_sym: b}\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Simple Pendulum Equations:\")\n        print(\"  dθ/dt = ω\")\n        print(\"  dω/dt = -(g/l)sin(θ) - (b/ml²)ω + u/(ml²)\")\n\n# Create and use\npendulum = SimplePendulum(m=0.5, l=0.3)\nx0 = np.array([0.1, 0.0])\n\n# Evaluate dynamics\ndx = pendulum(x0, np.zeros(1))\nprint(f\"State derivative: {dx}\")\n\n# Integrate\nresult = pendulum.integrate(x0, u=None, t_span=(0, 5), method='RK45')\nprint(f\"Integration successful: {result['success']}\")\n\n# Linearize\nA, B = pendulum.linearize(np.zeros(2), np.zeros(1))\nprint(f\"Linearization: A shape {A.shape}, B shape {B.shape}\")\n\n\n\n\nExample 2: Linear System (Discrete)\n\n\nCode\nclass DiscreteDoubleIntegrator(DiscreteSymbolicSystem):\n    def define_system(self, dt=0.01):\n        \"\"\"Discrete double integrator.\"\"\"\n        # Symbolic variables\n        p, v = sp.symbols('p v', real=True)\n        u = sp.symbols('u', real=True)\n        dt_sym = sp.symbols('dt', positive=True)\n        \n        # Discrete dynamics (Euler approximation)\n        self.state_vars = [p, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            p + dt_sym * v,\n            v + dt_sym * u\n        ])\n        self.parameters = {dt_sym: dt}\n        self._dt = dt  # REQUIRED!\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Discrete Double Integrator:\")\n        print(\"  p[k+1] = p[k] + dt*v[k]\")\n        print(\"  v[k+1] = v[k] + dt*u[k]\")\n\n# Create and use\nsystem = DiscreteDoubleIntegrator(dt=0.1)\nx0 = np.array([0.0, 0.0])\n\n# Single step\nx_next = system.step(x0, np.array([1.0]))\nprint(f\"Next state: {x_next}\")\n\n# Simulate\nresult = system.simulate(x0, u_sequence=None, n_steps=50)\nprint(f\"Simulation shape: {result['states'].shape}\")\n\n# Linearize\nAd, Bd = system.linearize(np.zeros(2), np.zeros(1))\nprint(f\"Discrete linearization: Ad shape {Ad.shape}\")\n\n\n\n\nExample 3: Stochastic Process\n\n\nCode\nclass BrownianMotion(ContinuousStochasticSystem):\n    def define_system(self, mu=0.0, sigma=1.0):\n        \"\"\"Standard Brownian motion with drift.\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        mu_sym, sigma_sym = sp.symbols('mu sigma', real=True)\n        \n        # Drift term\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[mu_sym + u]])\n        self.parameters = {mu_sym: mu, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion term (additive noise)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'\n    \n    def print_equations(self, simplify=True):\n        print(\"Brownian Motion with Drift:\")\n        print(\"  dx = μ*dt + σ*dW\")\n\n# Create and use\nbrownian = BrownianMotion(mu=0.1, sigma=0.5)\n\n# Check noise properties\nprint(f\"Additive noise: {brownian.is_additive_noise()}\")\nprint(f\"Noise dimension: {brownian.nw}\")\n\n# Drift and diffusion evaluation\nx = np.array([0.5])\nf = brownian.drift(x, np.zeros(1))\ng = brownian.diffusion(x, np.zeros(1))\nprint(f\"Drift: {f}, Diffusion: {g}\")\n\n# Integrate SDE\nx0 = np.array([0.0])\nresult = brownian.integrate(\n    x0, u=None, t_span=(0, 10),\n    method='EM', dt=0.01\n)\nprint(f\"SDE integration complete: {result['success']}\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-key-strengths",
    "href": "architecture/UI_Framework_Architecture.html#sec-key-strengths",
    "title": "UI Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipUI Framework Advantages\n\n\n\n\nClean Separation - Each layer has single responsibility\nZero Duplication - Symbolic machinery shared across all systems\nType Safety - Comprehensive TypedDict definitions throughout\nBackend Flexibility - Seamless NumPy/PyTorch/JAX/Julia switching\nExtensibility - Easy to add new system types via define_system()\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance - Multi-backend support enables GPU acceleration\nUser-Friendly - Simple subclass pattern for custom systems\nDocumentation - Extensive docstrings with mathematical notation\nProduction-Quality - Professional software engineering practices",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#summary",
    "href": "architecture/UI_Framework_Architecture.html#summary",
    "title": "UI Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe UI Framework provides a clean, layered architecture for defining and working with dynamical systems:\n\nLayer 0 provides time-agnostic symbolic foundations\nLayer 1 defines abstract time-domain interfaces\nLayer 2 combines symbolic + time-domain into concrete systems\nLayer 3 extends with stochastic capabilities\n\nUsers interact primarily at Layers 2 and 3 by subclassing ContinuousSymbolicSystem, DiscreteSymbolicSystem, or their stochastic variants. The framework handles all internal complexity transparently, providing a simple define_system() extension point while delivering production-grade functionality.\nThe architecture eliminates ~1,800 lines of code duplication while maintaining clean separation of concerns and type safety throughout.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html",
    "href": "architecture/Integration_Framework_Architecture.html",
    "title": "Integration Framework Architecture",
    "section": "",
    "text": "The ControlDESymulation numerical integration framework provides multi-backend, multi-method support for integrating both deterministic ordinary differential equations (ODEs) and stochastic differential equations (SDEs). The framework consists of 14 core files organized into a clean two-track architecture with a shared method registry.\nKey capabilities:\n\nBackend agnostic: Seamless switching between NumPy, PyTorch, and JAX\n40+ integration methods: From simple Euler to high-order adaptive schemes\nStochastic support: Full SDE integration with noise structure exploitation\nFactory pattern: Automatic method selection based on system properties\nProduction ready: Professional-grade error control and performance tracking\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nMost users should NOT directly instantiate integrators or factories. Instead, use the high-level system interface:\n# Recommended: Use system.integrate() - delegates to appropriate integrator\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nresult = system.integrate(\n    x0=np.array([1.0, 0.0]),\n    method='RK45',  # Optional: framework selects automatically\n    t_span=(0, 10)\n)\n\n# Advanced: Direct integrator access (only when needed for fine control)\nintegrator = IntegratorFactory.auto(system)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\nThe system’s integrate() method automatically handles backend selection, method routing, and integrator lifecycle. Direct integrator instantiation is only needed for advanced use cases requiring explicit integrator reuse or fine-grained control.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-overview",
    "href": "architecture/Integration_Framework_Architecture.html#sec-overview",
    "title": "Integration Framework Architecture",
    "section": "",
    "text": "The ControlDESymulation numerical integration framework provides multi-backend, multi-method support for integrating both deterministic ordinary differential equations (ODEs) and stochastic differential equations (SDEs). The framework consists of 14 core files organized into a clean two-track architecture with a shared method registry.\nKey capabilities:\n\nBackend agnostic: Seamless switching between NumPy, PyTorch, and JAX\n40+ integration methods: From simple Euler to high-order adaptive schemes\nStochastic support: Full SDE integration with noise structure exploitation\nFactory pattern: Automatic method selection based on system properties\nProduction ready: Professional-grade error control and performance tracking\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nMost users should NOT directly instantiate integrators or factories. Instead, use the high-level system interface:\n# Recommended: Use system.integrate() - delegates to appropriate integrator\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nresult = system.integrate(\n    x0=np.array([1.0, 0.0]),\n    method='RK45',  # Optional: framework selects automatically\n    t_span=(0, 10)\n)\n\n# Advanced: Direct integrator access (only when needed for fine control)\nintegrator = IntegratorFactory.auto(system)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\nThe system’s integrate() method automatically handles backend selection, method routing, and integrator lifecycle. Direct integrator instantiation is only needed for advanced use cases requiring explicit integrator reuse or fine-grained control.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-architecture",
    "href": "architecture/Integration_Framework_Architecture.html#sec-architecture",
    "title": "Integration Framework Architecture",
    "section": "Architecture Overview",
    "text": "Architecture Overview\nThe framework follows a dual-track design separating deterministic and stochastic integration, with a shared method registry providing centralized method management:\nShared Infrastructure\n├── MethodRegistry (centralized method normalization and validation)\n│   ├── normalize_method_name() - cross-backend name mapping\n│   ├── validate_method() - backend/system compatibility\n│   ├── is_sde_method() / is_fixed_step() - classification\n│   └── get_available_methods() - method discovery\n│\nTrack 1: Deterministic ODE Integration\n├── IntegratorBase (abstract interface)\n├── IntegratorFactory (method selection via registry)\n├── Backend-Specific Implementations:\n│   ├── ScipyIntegrator (NumPy/SciPy)\n│   ├── TorchDiffEqIntegrator (PyTorch with GPU)\n│   ├── DiffraxIntegrator (JAX with XLA)\n│   └── DiffEqPyIntegrator (Julia via Python)\n└── FixedStepIntegrators (Euler, Heun, Midpoint, RK4)\n\nTrack 2: Stochastic SDE Integration\n├── SDEIntegratorBase (extends IntegratorBase)\n├── SDEIntegratorFactory (SDE-specific creation via registry)\n├── Backend-Specific Implementations:\n│   ├── TorchSDEIntegrator (PyTorch SDEs)\n│   ├── DiffraxSDEIntegrator (JAX SDEs)\n│   └── DiffEqPySDEIntegrator (Julia SDEs)\n└── CustomBrownianPath (deterministic noise for testing)",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-method-registry",
    "href": "architecture/Integration_Framework_Architecture.html#sec-method-registry",
    "title": "Integration Framework Architecture",
    "section": "Method Registry: Centralized Method Management",
    "text": "Method Registry: Centralized Method Management\nFile: method_registry.py\nThe method_registry module serves as the single source of truth for all integration methods across backends. It provides centralized method normalization, validation, and classification for both ODE and SDE integrators.\n\nDesign Philosophy\nBackend Naming Conventions:\n\n\n\n\n\n\n\n\nBackend\nConvention\nExamples\n\n\n\n\nNumPy/Julia (DiffEqPy)\nCapitalized\nEM, Tsit5, SRIW1\n\n\nPyTorch (TorchSDE/TorchDiffEq)\nlowercase\neuler, dopri5, milstein\n\n\nJAX (Diffrax)\nPascalCase\nEuler, ItoMilstein, Tsit5\n\n\n\nCanonical Names:\nUser-friendly aliases that work across all backends (e.g., euler_maruyama, milstein, rk45). These are automatically normalized to backend-specific names.\n\n\nCore Functions\nfrom cdesym.systems.base.numerical_integration.method_registry import (\n    normalize_method_name,\n    validate_method,\n    is_sde_method,\n    is_fixed_step,\n    get_available_methods,\n    get_method_info,\n)\n\n# Normalize canonical names to backend-specific\nnormalize_method_name('euler_maruyama', 'numpy')  # → 'EM'\nnormalize_method_name('euler_maruyama', 'torch')  # → 'euler'\nnormalize_method_name('euler_maruyama', 'jax')    # → 'Euler'\n\n# Validate method/backend/system compatibility\nis_valid, error = validate_method('euler_maruyama', 'torch', is_stochastic=True)\n\n# Classify methods\nis_sde_method('euler_maruyama')  # → True\nis_sde_method('rk4')              # → False\nis_fixed_step('rk4')              # → True\nis_fixed_step('RK45')             # → False (adaptive)\n\n# Discover available methods\nmethods = get_available_methods('torch', method_type='stochastic')\n\n\nMethod Classification\nMethods are classified along two dimensions:\n\nSystem type: Deterministic (ODE) vs Stochastic (SDE)\nTime stepping: Fixed-step vs Adaptive\n\n\n\n\n\n\n\n\n\nCategory\nExamples\nUse Case\n\n\n\n\nDETERMINISTIC_FIXED_STEP\neuler, heun, midpoint, rk4\nManual implementations\n\n\nDETERMINISTIC_ADAPTIVE\nRK45, LSODA, dopri5, tsit5\nProduction ODE solvers\n\n\nSDE_FIXED_STEP\nEM, euler, milstein, SRIW1\nMost SDE methods\n\n\nSDE_ADAPTIVE\nLambaEM, AutoEM, adaptive_heun\nRare adaptive SDE\n\n\n\n\n\nNormalization Map\nThe registry maintains a comprehensive map for cross-backend method translation:\nNORMALIZATION_MAP = {\n    # SDE Methods\n    'euler_maruyama': {'numpy': 'EM', 'torch': 'euler', 'jax': 'Euler'},\n    'milstein': {'numpy': 'RKMil', 'torch': 'milstein', 'jax': 'ItoMilstein'},\n    'sra1': {'numpy': 'SRA1', 'torch': 'srk', 'jax': 'SRA1'},\n\n    # ODE Methods\n    'rk45': {'numpy': 'RK45', 'torch': 'dopri5', 'jax': 'tsit5'},\n    'dopri5': {'numpy': 'RK45', 'torch': 'dopri5', 'jax': 'dopri5'},\n    'tsit5': {'numpy': 'Tsit5', 'torch': 'dopri5', 'jax': 'tsit5'},\n    # ... more mappings\n}\n\n\nUsage in Factories\nBoth IntegratorFactory and SDEIntegratorFactory use the registry for method handling:\n# IntegratorFactory.create() internally:\nmethod = normalize_method_name(method, backend)\nis_valid, error = validate_method(method, backend, is_stochastic=False)\nif is_fixed_step(method) and dt is None:\n    raise ValueError(\"Fixed-step method requires dt\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-track-1",
    "href": "architecture/Integration_Framework_Architecture.html#sec-track-1",
    "title": "Integration Framework Architecture",
    "section": "Track 1: Deterministic ODE Integration",
    "text": "Track 1: Deterministic ODE Integration\n\nIntegratorBase: Abstract Interface\nFile: integrator_base.py\nThe IntegratorBase class defines the unified interface that all numerical integrators must implement. This abstraction enables backend-agnostic integration while maintaining consistent behavior across implementations.\nCore responsibilities:\n\nDefine integration contract through abstract methods\nTrack performance statistics (function evaluations, steps, timing)\nManage integration parameters (time step, tolerances, backend)\nProvide consistent result format via IntegrationResult TypedDict\n\nKey attributes:\nsystem: ContinuousSystemBase     # Dynamical system to integrate\ndt: float                        # Time step (or initial guess for adaptive)\nstep_mode: StepMode              # FIXED or ADAPTIVE\nbackend: Backend                 # 'numpy', 'torch', or 'jax'\nrtol: float                      # Relative error tolerance (adaptive methods)\natol: float                      # Absolute error tolerance (adaptive methods)\n_stats: dict                     # Performance tracking\nAbstract methods required by all implementations:\ndef step(self, x: Array, u: Array, dt: float) -&gt; Array:\n    \"\"\"Single integration step: x(t) -&gt; x(t + dt)\"\"\"\n    \ndef integrate(\n    self, \n    x0: Array, \n    u_func: Callable, \n    t_span: tuple[float, float]\n) -&gt; IntegrationResult:\n    \"\"\"Multi-step integration over time interval\"\"\"\n    \n@property\ndef name(self) -&gt; str:\n    \"\"\"Unique identifier for this integrator\"\"\"\nStepMode enumeration:\n\nFIXED: Constant time step (euler, rk4, midpoint)\nADAPTIVE: Variable time step with error control (RK45, dopri5, tsit5)\n\n\n\nIntegratorFactory: Smart Creation\nFile: integrator_factory.py\nThe IntegratorFactory provides intelligent integrator creation with automatic backend and method selection. It encapsulates the complexity of choosing appropriate integration methods based on system properties and use case requirements.\nIntegration with Method Registry:\nThe factory delegates method normalization and validation to the centralized method_registry:\n# Internally, IntegratorFactory.create() does:\nmethod = normalize_method_name(method, backend)  # Registry function\nis_valid, error = validate_method(method, backend, is_stochastic=False)\nif is_fixed_step(method) and dt is None:\n    raise ValueError(\"Fixed-step method requires dt\")\nJulia Preference for NumPy Backend:\nWhen using the NumPy backend, IntegratorFactory automatically prefers Julia implementations for basic methods when DiffEqPy is available:\n\neuler → Julia’s Euler (better performance)\nheun → Julia’s Heun\nmidpoint → Julia’s Midpoint\n\nTo explicitly use manual Python implementations:\nintegrator = IntegratorFactory.create(\n    system, backend='numpy', method='euler', prefer_manual=True\n)\nFactory methods:\n# Automatic selection based on system and backend\nIntegratorFactory.auto(system, backend=None)\n\n# Production use with auto-stiffness detection\nIntegratorFactory.for_production(system, **options)\n\n# High-performance Julia integration\nIntegratorFactory.for_julia(system, algorithm='Tsit5', **options)\n\n# Neural ODE training with adjoint gradients\nIntegratorFactory.for_neural_ode(system, **options)\n\n# JAX optimization workflows\nIntegratorFactory.for_optimization(system, **options)\n\n# Direct method specification\nIntegratorFactory.create(system, backend, method, **options)\nMethod registry:\nThe factory uses the centralized method registry for mapping method names to backends and capabilities:\n\n\n\n\n\n\n\n\n\n\nMethod\nBackend\nType\nOrder\nBest For\n\n\n\n\nLSODA\nNumPy (scipy)\nAdaptive\nVariable\nAutomatic stiffness detection\n\n\nRK45\nNumPy (scipy)\nAdaptive\n5(4)\nGeneral non-stiff ODEs\n\n\nDOP853\nNumPy (scipy)\nAdaptive\n8(5,3)\nHigh-accuracy requirements\n\n\nRadau\nNumPy (scipy)\nAdaptive\n5\nStiff systems (implicit)\n\n\nBDF\nNumPy (scipy)\nAdaptive\nVariable\nVery stiff systems\n\n\nTsit5\nNumPy (Julia)\nAdaptive\n5(4)\nHigh performance\n\n\nVern9\nNumPy (Julia)\nAdaptive\n9(8)\nMaximum accuracy\n\n\nRodas5\nNumPy (Julia)\nAdaptive\n5(4)\nStiff (Rosenbrock method)\n\n\ndopri5\nPyTorch/JAX\nAdaptive\n5(4)\nNeural ODEs, GPU acceleration\n\n\ndopri8\nPyTorch/JAX\nAdaptive\n8\nHigh-accuracy neural ODEs\n\n\ntsit5\nJAX (diffrax)\nAdaptive\n5(4)\nOptimization, XLA compilation\n\n\neuler\nAny\nFixed\n1\nSimple systems, education\n\n\nheun\nAny\nFixed\n2\nImproved Euler, predictor-corrector\n\n\nmidpoint\nAny\nFixed\n2\nSecond-order, midpoint evaluation\n\n\nrk4\nAny\nFixed\n4\nModerate accuracy, fixed step\n\n\n\n\n\nScipyIntegrator: Adaptive NumPy Integration\nFile: scipy_integrator.py\nWraps scipy.integrate.solve_ivp to provide professional-grade adaptive integration with comprehensive error control. This is the recommended starting point for most NumPy-based applications.\nSupported methods:\n\nRK45 (default): Dormand-Prince 5(4) — general purpose, good balance\nRK23: Bogacki-Shampine 3(2) — fast, lower accuracy\nDOP853: Dormand-Prince 8(5,3) — very high accuracy\nRadau: Implicit Runge-Kutta — stiff systems\nBDF: Backward differentiation formulas — very stiff systems\nLSODA: Automatic stiffness detection — adapts to problem\n\nKey features:\n\nProfessional adaptive time stepping with embedded error estimation\nConfigurable error tolerances (rtol, atol)\nDense output via continuous extension (interpolation between steps)\nEvent detection for state-dependent conditions\nSupport for both controlled and autonomous systems\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.scipy_integrator import ScipyIntegrator\n\n# Create system\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Create adaptive integrator with tight tolerances\nintegrator = ScipyIntegrator(\n    system,\n    method='RK45',\n    rtol=1e-6,\n    atol=1e-8\n)\n\n# Integrate over time span\nx0 = np.array([1.0, 0.0])  # [angle, angular_velocity]\nu_func = lambda t, x: np.zeros(1)  # No control input\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Success: {result['success']}\")\nprint(f\"Function evaluations: {result['nfev']}\")\nprint(f\"Steps taken: {result['nsteps']}\")\n\n\nWhen to use:\n\nGeneral-purpose NumPy applications\nWhen you need reliable adaptive stepping\nSystems with unknown stiffness (use LSODA)\nWhen dense output is required\n\n\n\nTorchDiffEqIntegrator: GPU-Accelerated PyTorch\nFile: `torchdiffeq_integrator.py**\nProvides PyTorch integration with GPU acceleration and automatic differentiation support. Essential for neural ODE applications and gradient-based optimization.\nSupported methods:\n\ndopri5: Dormand-Prince 5(4) — recommended default\ndopri8: Dormand-Prince 8 — high accuracy\nadaptive_heun: Heun’s method — good for moderately stiff\nbosh3: Bogacki-Shampine 3 — fast, lower accuracy\nfehlberg2: Fehlberg 2(1) — very fast, low accuracy\nexplicit_adams, implicit_adams: Multi-step methods\n\nKey features:\n\nGPU acceleration: Automatic CUDA support for large-scale problems\nAutomatic differentiation: Seamless gradient computation through dynamics\nAdjoint method: Memory-efficient backpropagation for neural ODEs\nBatch processing: Vectorized integration of multiple trajectories\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.torchdiffeq_integrator import TorchDiffEqIntegrator\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Create GPU-accelerated integrator\nintegrator = TorchDiffEqIntegrator(\n    system,\n    method='dopri5',\n    backend='torch',\n    device='cpu',  # Use 'cuda:0' for GPU\n    rtol=1e-6,\n    atol=1e-8\n)\n\nx0 = torch.tensor([1.0, 0.0], requires_grad=True)\nu_func = lambda t, x: torch.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Solver: {result['solver']}\")\nprint(f\"Integration time: {result['integration_time']:.4f}s\")\n\n\nWhen to use:\n\nNeural ODE training\nGPU-accelerated simulations\nGradient-based optimization\nLarge-scale batch processing\n\n\n\nDiffraxIntegrator: JAX with XLA Compilation\nFile: diffrax_integrator.py\nLeverages JAX’s diffrax library for high-performance integration with XLA compilation. Ideal for optimization workflows requiring extensive JIT compilation and functional transformations.\nSupported methods:\n\ntsit5: Tsitouras 5(4) — recommended, efficient\ndopri5: Dormand-Prince 5(4) — standard reference\ndopri8: Dormand-Prince 8 — high accuracy\nheun: Heun’s method — simple, robust\nralston: Ralston’s method — improved stability\nreversible_heun: Time-reversible integration\n\nKey features:\n\nXLA compilation: Near-C++ performance via just-in-time compilation\nJAX transformations: jit, vmap, grad, pmap all work seamlessly\nFunctional style: Pure functions enable advanced optimizations\nEfficient for optimization: Fast repeated evaluations with parameter sweeps\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.diffrax_integrator import DiffraxIntegrator\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Create JAX integrator\nintegrator = DiffraxIntegrator(\n    system,\n    method='tsit5',\n    backend='jax',\n    rtol=1e-6,\n    atol=1e-8\n)\n\nx0 = jnp.array([1.0, 0.0])\nu_func = lambda t, x: jnp.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Success: {result['success']}\")\n\n\nWhen to use:\n\nParameter optimization requiring many integrations\nWhen you need vmap for batch parameter sweeps\nGradient-based control optimization\nMaximum computational efficiency\n\n\n\nDiffEqPyIntegrator: Julia’s Solver Ecosystem\nFile: diffeqpy_integrator.py\nAccesses Julia’s extensive DifferentialEquations.jl ecosystem through Python bindings. Provides the most comprehensive method library with production-grade performance.\nSupported method families:\nExplicit Runge-Kutta: - Tsit5, Vern6, Vern7, Vern8, Vern9 — variable order adaptive - DP5, DP8 — Dormand-Prince variants\nRosenbrock (implicit for stiff): - Rosenbrock23, Rosenbrock32, Rodas4, Rodas5\nBDF methods: - TRBDF2, KenCarp3, KenCarp4, KenCarp5\nSpecialized: - RadauIIA5 — implicit Runge-Kutta - ROCK2, ROCK4 — stabilized methods - VelocityVerlet, SymplecticEuler — symplectic integrators\nAuto-switching (composite): - AutoTsit5(Rosenbrock23()) — switches based on stiffness - AutoVern7(Rodas5()) — high accuracy with stiffness handling\nKey features:\n\nHighest performance: Often 2-10× faster than SciPy\nAutomatic stiffness detection: Seamlessly switches solvers\nExtensive method library: 100+ algorithms available\nProduction reliability: Battle-tested in scientific computing\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.diffeqpy_integrator import DiffEqPyIntegrator\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Ultra-high accuracy Julia integration\nintegrator = DiffEqPyIntegrator(\n    system,\n    algorithm='Vern9',  # 9th order method\n    backend='numpy',\n    reltol=1e-12,\n    abstol=1e-14\n)\n\nx0 = np.array([1.0, 0.0])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 100))\n\nprint(f\"Function evaluations: {result['nfev']}\")\nprint(f\"Achieved accuracy: reltol={1e-12}, abstol={1e-14}\")\n\n\nWhen to use:\n\nMaximum performance requirements\nVery stiff systems needing automatic detection\nHigh-accuracy applications (&gt;8 digits)\nProduction environments with reliability requirements\n\n\n\nFixedStepIntegrators: Educational and Simple Systems\nFile: fixed_step_integrators.py\nManual implementations of classic fixed-step methods. These provide transparent, backend-agnostic integration suitable for education and simple systems where adaptive stepping is unnecessary.\nAvailable methods:\n\nExplicitEulerIntegrator: Forward Euler (order 1) — simplest method\nHeunIntegrator: Heun’s method / Improved Euler (order 2) — predictor-corrector approach\nMidpointIntegrator: Midpoint method (order 2) — midpoint evaluation\nRK4Integrator: Classic Runge-Kutta 4 (order 4) — excellent balance\n\nHeunIntegrator:\nHeun’s method uses a predictor-corrector approach with trapezoidal averaging:\nk1 = f(x_k, u_k)                    # Predictor (Euler step)\nx_pred = x_k + dt * k1\nk2 = f(x_pred, u_k)                 # Corrector\nx_{k+1} = x_k + (dt/2) * (k1 + k2)  # Trapezoidal rule\nAlso known as Improved Euler or Explicit Trapezoid method. Uses 2 function evaluations per step for second-order accuracy.\nKey features:\n\nBackend agnostic: Work with NumPy, PyTorch, and JAX arrays\nTransparent implementation: Clear, readable code for learning\nConstant time step: Predictable computational cost\nNo external dependencies: Pure Python implementations\nTypedDict results: All integrators return IntegrationResult TypedDict\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.fixed_step_integrators import (\n    RK4Integrator,\n    HeunIntegrator,\n)\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nx0 = np.array([1.0, 0.0])\nu_func = lambda t, x: np.zeros(1)\n\n# RK4 with fixed time step (4 function evals/step)\nrk4_integrator = RK4Integrator(system, dt=0.01, backend='numpy')\nresult_rk4 = rk4_integrator.integrate(x0, u_func, t_span=(0, 10))\n\n# Heun's method (2 function evals/step, predictor-corrector)\nheun_integrator = HeunIntegrator(system, dt=0.01, backend='numpy')\nresult_heun = heun_integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"RK4 - Steps: {result_rk4['nsteps']}, Solver: {result_rk4['solver']}\")\nprint(f\"Heun - Steps: {result_heun['nsteps']}, Solver: {result_heun['solver']}\")\n\n\nWhen to use:\n\nEducational purposes and learning\nSimple systems with smooth dynamics\nReal-time applications requiring predictable timing\nDebugging with deterministic stepping",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-track-2",
    "href": "architecture/Integration_Framework_Architecture.html#sec-track-2",
    "title": "Integration Framework Architecture",
    "section": "Track 2: Stochastic SDE Integration",
    "text": "Track 2: Stochastic SDE Integration\n\nSDEIntegratorBase: Stochastic Abstract Interface\nFile: sde_integrator_base.py\nExtends IntegratorBase to handle stochastic differential equations of the form:\n\\[dx = f(x, u, t)dt + g(x, u, t)dW\\]\nwhere:\n\n\\(f(x, u, t)\\): Drift term (deterministic dynamics)\n\\(g(x, u, t)\\): Diffusion term (stochastic intensity)\n\\(dW\\): Brownian motion increments (Wiener process)\n\nKey differences from deterministic integration:\n\nRandom noise generation: Requires proper Brownian motion sampling\nConvergence types:\n\nStrong convergence: Pathwise accuracy (Monte Carlo, control)\nWeak convergence: Distribution accuracy (statistics)\n\nNoise structure exploitation: Additive, diagonal, scalar, or general\nMultiple realizations: Monte Carlo simulation support\nInterpretation: Itô vs Stratonovich calculus\n\nAdditional abstract methods:\ndef step(\n    self, \n    x: Array, \n    u: Array, \n    dt: float, \n    dW: Array\n) -&gt; Array:\n    \"\"\"Single SDE step with provided noise\"\"\"\n    \ndef integrate_monte_carlo(\n    self,\n    x0: Array,\n    u_func: Callable,\n    t_span: tuple[float, float],\n    n_paths: int\n) -&gt; SDEIntegrationResult:\n    \"\"\"Multiple trajectory simulation for statistics\"\"\"\n\n\nSDEIntegratorFactory: SDE-Specific Creation\nFile: sde_integrator_factory.py\nProvides intelligent SDE integrator creation with automatic noise structure detection and method selection.\nIntegration with Method Registry:\nLike IntegratorFactory, the SDE factory delegates to the centralized method_registry for method normalization and validation:\n# Internally, SDEIntegratorFactory.create() does:\nmethod = normalize_method_name(method, backend)  # Registry function\nis_valid, error = validate_method(method, backend, is_stochastic=True)\nif is_fixed_step(method) and dt is None:\n    raise ValueError(\"Fixed-step SDE method requires dt\")\nFactory methods:\n# Automatic selection based on noise structure\nSDEIntegratorFactory.auto(sde_system, backend=None)\n\n# Direct method specification\nSDEIntegratorFactory.create(\n    sde_system, backend, method, dt, **options\n)\n\n# Optimized for Monte Carlo simulations\nSDEIntegratorFactory.for_monte_carlo(\n    sde_system, noise_type='general', **options\n)\n\n# Neural SDE training with adjoint\nSDEIntegratorFactory.for_neural_sde(sde_system, adjoint=True, **options)\n\n# Julia DiffEqPy SDE solvers\nSDEIntegratorFactory.for_julia(sde_system, algorithm='SRIW1', **options)\n\n# Gradient-based optimization\nSDEIntegratorFactory.for_optimization(sde_system, backend=None, **options)\nAvailable SDE methods:\n\n\n\nMethod\nBackend\nConvergence\nNoise Type\nOrder\n\n\n\n\neuler-maruyama\nAll\nStrong 0.5\nGeneral\n0.5\n\n\nmilstein\nPyTorch/NumPy\nStrong 1.0\nDiagonal\n1.0\n\n\nreversible_heun\nPyTorch/JAX\nStrong 1.0\nAdditive\n1.0\n\n\nadaptive_heun\nPyTorch\nStrong 1.0\nAdditive\n1.0 (adaptive)\n\n\nsrk\nPyTorch\nStrong\nGeneral\nVariable\n\n\nmidpoint\nPyTorch\nStrong\nGeneral\nVariable\n\n\n\nNoise structure types:\n\nAdditive: \\(g(x, u, t) = g(t)\\) — diffusion independent of state\nDiagonal: \\(g\\) is diagonal matrix — independent noise channels\nScalar: \\(g\\) is scalar — single noise source\nGeneral: Full matrix \\(g\\) — correlated noise\n\n\n\nTorchSDEIntegrator: PyTorch SDE Integration\nFile: torchsde_integrator.py\nGPU-accelerated SDE integration using the torchsde library. Supports automatic differentiation through stochastic dynamics.\nSupported methods:\n\neuler: Euler-Maruyama (strong order 0.5) — Itô and Stratonovich\nmilstein: Milstein method (strong order 1.0 for diagonal noise) — Itô only\nsrk: Stochastic Runge-Kutta (general noise) — Itô and Stratonovich\nmidpoint: Midpoint method — Stratonovich only\nreversible_heun: Reversible Heun (strong order 1.0 for additive noise) — Stratonovich only\nadaptive_heun: Adaptive Heun with error control — Itô and Stratonovich\n\nKey features:\n\nGPU acceleration for large-scale stochastic simulations\nAdaptive stepping with stochastic error control\nNoise structure exploitation for efficiency\nAdjoint method for memory-efficient gradients through SDEs\nSDE type compatibility: Most methods support either Itô or Stratonovich (see method list)\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.torchsde_integrator import TorchSDEIntegrator\n\n# Create Ornstein-Uhlenbeck process: dx = -α*x*dt + σ*dW\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\nintegrator = TorchSDEIntegrator(\n    sde_system,\n    method='euler',  # Euler-Maruyama for Itô SDEs\n    dt=0.01,\n    backend='torch'\n)\n\nx0 = torch.tensor([0.5])\nu_func = lambda t, x: torch.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Convergence type: {result['convergence_type']}\")\nprint(f\"SDE type: {result['sde_type']}\")\n\n\n\n\nDiffraxSDEIntegrator: JAX SDE Integration\nFile: diffrax_sde_integrator.py\nJAX-based SDE integration with XLA compilation and functional transformations. Excellent for optimization involving stochastic dynamics.\nSupported methods:\n\neuler: Euler-Maruyama\nheun: Heun’s method (if supported by diffrax)\nreversible_heun: Time-reversible stochastic integration\n\nKey features:\n\nXLA compilation for near-C++ performance\nJAX transformations (jit, vmap, grad) work seamlessly\nCustom noise support for deterministic testing\nEfficient for stochastic optimization\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.diffrax_sde_integrator import DiffraxSDEIntegrator\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\nintegrator = DiffraxSDEIntegrator(\n    sde_system,\n    method='euler',\n    dt=0.01,\n    backend='jax',\n    seed=SEED\n)\n\nx0 = jnp.array([0.5])\nu_func = lambda t, x: jnp.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\n\n\n\n\nDiffEqPySDEIntegrator: Julia SDE Integration\nFile: diffeqpy_sde_integrator.py\nAccess to Julia’s comprehensive SDE solver ecosystem through Python bindings.\nSupported methods:\n\nEuler-Maruyama variants\nMilstein method\nStochastic Rosenbrock methods\nAdvanced Julia SDE algorithms\n\nKey features:\n\nProduction-grade SDE solvers\nAutomatic noise structure detection\nHigh-performance algorithms\nExtensive method library\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.diffeqpy_sde_integrator import DiffEqPySDEIntegrator\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\nintegrator = DiffEqPySDEIntegrator(\n    sde_system,\n    method='EM',  # Euler-Maruyama\n    dt=0.01,\n    backend='numpy',\n    seed=SEED\n)\n\nx0 = np.array([0.5])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Diffusion evaluations: {result['diffusion_evals']}\")\n\n\n\n\nCustomBrownianPath: Deterministic Noise for Testing\nFile: custom_brownian.py\nProvides custom Brownian motion paths for deterministic testing and reproducibility. Implements diffrax’s AbstractPath interface.\nKey features:\n\nUser-provided noise increments\nDeterministic testing support\nCustom noise patterns (e.g., zero noise, specific realizations)\nCompatible with diffrax integrators\n\nUsage example:\n\n\nCode\nfrom jax import random\nfrom cdesym.systems.base.numerical_integration.stochastic.custom_brownian import (\n    CustomBrownianPath, create_custom_or_random_brownian\n)\nfrom cdesym.systems.base.numerical_integration.stochastic.diffrax_sde_integrator import DiffraxSDEIntegrator\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nnw = sde_system.nw\n\n# Zero noise for deterministic testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(t0=0.0, t1=10.0, dW=dW)\n\n# Or generate random noise\nkey = random.key(SEED)\nbrownian_random = create_custom_or_random_brownian(\n    key, t0=0.0, t1=10.0, shape=(nw,), dW=None\n)\n\n# Use in integration\nintegrator = DiffraxSDEIntegrator(sde_system, method='euler', dt=0.01, backend='jax')\nx0 = jnp.array([0.5])\nu_func = lambda t, x: jnp.zeros(1)\n\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10), brownian_path=brownian\n)\n\nprint(\"Deterministic SDE integration (zero noise)\")\n\n\nImportant notes:\n\nTime span matching: CustomBrownianPath(t0, t1, dW) must match t_span\nSingle dW for entire integration: Unlike step(), provide one dW for the full interval\nAutomatic interpolation: Diffrax handles internal time queries",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-result-types",
    "href": "architecture/Integration_Framework_Architecture.html#sec-result-types",
    "title": "Integration Framework Architecture",
    "section": "Integration Result Types",
    "text": "Integration Result Types\n\nIntegrationResult (Deterministic ODEs)\nAll ODE integrators return a TypedDict with consistent fields:\n{\n    't': array,              # Time points (T,)\n    'x': array,              # States (T, nx) - time-major format\n    'success': bool,         # Integration succeeded\n    'message': str,          # Status message\n    'nfev': int,             # Function evaluations\n    'nsteps': int,           # Steps taken\n    'integration_time': float,  # Wall clock time (seconds)\n    'solver': str,           # Integrator name\n    \n    # Optional (adaptive methods only):\n    'njev': int,             # Jacobian evaluations\n    'nlu': int,              # LU decompositions\n    'status': int,           # Solver-specific status code\n    'sol': object,           # Dense output object (if requested)\n    'dense_output': bool,    # Dense output available\n}\n\n\nSDEIntegrationResult (Stochastic SDEs)\nSDE integrators extend IntegrationResult with stochastic-specific fields:\n{\n    # All IntegrationResult fields, plus:\n    'diffusion_evals': int,     # Diffusion function calls\n    'noise_samples': array,     # Brownian increments used\n    'n_paths': int,             # Number of trajectories\n    'convergence_type': str,    # 'strong' or 'weak'\n    'sde_type': str,            # 'ito' or 'stratonovich'\n    'noise_type': str,          # 'additive', 'diagonal', 'scalar', 'general'\n    \n    # For Monte Carlo (n_paths &gt; 1):\n    'x': array,                 # (n_paths, T, nx)\n    'statistics': dict,         # {'mean', 'std', 'q25', 'q50', 'q75'}\n}",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-usage-examples",
    "href": "architecture/Integration_Framework_Architecture.html#sec-usage-examples",
    "title": "Integration Framework Architecture",
    "section": "Practical Usage Examples",
    "text": "Practical Usage Examples\n\n\n\n\n\n\nNoteRecommended Usage Pattern\n\n\n\nThe examples below show direct integrator instantiation for documentation purposes. In practice, most users should use the system’s integrate() method which delegates to the appropriate integrator automatically:\n# Recommended approach\nresult = system.integrate(x0=x0, method='RK45', t_span=(0, 10))\n\n# Advanced approach (shown in examples below)\nintegrator = IntegratorFactory.auto(system)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\nExample 1: Recommended High-Level Interface\n\n\nCode\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Most users should use this approach - system handles delegation\nx0 = np.array([0.1, 0.0])\nresult = system.integrate(\n    x0=x0,\n    method='RK45',  # Optional: auto-selected if not specified\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\nprint(f\"Success: {result['success']}\")\n\n\n\n\nExample 2: Advanced - Direct Integrator Access\n\n\nCode\n# Advanced: Direct integrator instantiation for reuse or fine control\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nintegrator = IntegratorFactory.auto(system)\n\n# Can reuse integrator for multiple integrations\nx0 = np.array([0.1, 0.0])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0.0, 10.0))\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\n\n\n\n\nExample 3: High-Accuracy Julia Integration\n\n\nCode\n# Recommended: System-level interface\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nx0 = np.array([1.0, 0.0])\n\nresult = system.integrate(\n    x0=x0,\n    method='Vern9',  # Julia's 9th order method\n    rtol=1e-12,\n    atol=1e-14,\n    t_span=(0, 100)\n)\n\nprint(f\"Function evaluations: {result['nfev']}\")\nprint(f\"Integration time: {result['integration_time']:.4f}s\")\n\n\n\n\nExample 4: GPU-Accelerated Neural ODE\n\n\nCode\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Switch to PyTorch backend for gradients\nwith system.use_backend('torch'):\n    x0 = torch.tensor([1.0, 0.0], requires_grad=True)\n    \n    result = system.integrate(\n        x0=x0,\n        method='dopri5',\n        device='cpu',  # Use 'cuda:0' for GPU\n        t_span=(0, 10)\n    )\n    \n    # Gradient computation works seamlessly\n    final_state = result['x'][-1]\n    loss = final_state.sum()\n    loss.backward()\n    \n    print(f\"Gradient w.r.t. x0: {x0.grad}\")\n\n\n\n\nExample 5: Stochastic Simulation with Monte Carlo\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic import get_trajectory_statistics\n\n# Create stochastic system\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\n# Use integrator for Monte Carlo (don't specify backend, it's handled internally)\nintegrator = SDEIntegratorFactory.for_monte_carlo(\n    sde_system, n_paths=1000\n)\n\nx0 = np.array([1.0])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate_monte_carlo(\n    x0, u_func, t_span=(0, 10), n_paths=1000\n)\n\n# Extract statistics\nstats = get_trajectory_statistics(result)\n\n# Extract scalar values from arrays\nmean_final = float(stats['mean'][-1].flat[0])\nstd_final = float(stats['std'][-1].flat[0])\n\nprint(f\"Mean at t=10: {mean_final:.4f}\")\nprint(f\"Std at t=10: {std_final:.4f}\")\n\n\n\n\nExample 6: Deterministic Testing with Custom Noise\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.custom_brownian import CustomBrownianPath\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nnw = sde_system.nw\n\n# Zero noise for deterministic testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(t0=0.0, t1=10.0, dW=dW)\n\n# Create JAX integrator\nintegrator = SDEIntegratorFactory.create(\n    sde_system,\n    backend='jax',\n    method='Euler',\n    dt=0.01,\n    seed=SEED\n)\n\n# Integrate with custom noise\nx0 = jnp.array([0.5])\nu_func = lambda t, x: jnp.zeros(1)\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10), brownian_path=brownian\n)\n\nprint(f\"Deterministic integration complete\")\nprint(f\"Final state: {result['x'][-1]}\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-selection-guide",
    "href": "architecture/Integration_Framework_Architecture.html#sec-selection-guide",
    "title": "Integration Framework Architecture",
    "section": "Integrator Selection Guide",
    "text": "Integrator Selection Guide\n\nBy Use Case\n\n\n\n\n\n\n\n\nUse Case\nRecommended Approach\nRationale\n\n\n\n\nGeneral ODE\nIntegratorFactory.for_production(system)\nLSODA auto-stiffness detection\n\n\nNeural ODE\nIntegratorFactory.for_neural_ode(system)\nAdjoint method for memory efficiency\n\n\nOptimization\nIntegratorFactory.for_optimization(system)\nJAX with XLA compilation\n\n\nHigh Accuracy\nIntegratorFactory.for_julia(system, 'Vern9')\nJulia 9th order methods\n\n\nStiff ODE\nScipyIntegrator(system, method='BDF')\nBackward differentiation\n\n\nSimple ODE\nRK4Integrator(system, dt=0.01)\nClassic fixed-step\n\n\nGeneral SDE\nSDEIntegratorFactory.auto(sde_system)\nAutomatic noise detection\n\n\nMonte Carlo\nSDEIntegratorFactory.for_monte_carlo(...)\nParallelized trajectories\n\n\n\n\n\nBy Backend Capabilities\n\n\n\n\n\n\n\n\n\nBackend\nODE Integrator\nSDE Integrator\nBest For\n\n\n\n\nNumPy\nScipyIntegrator, DiffEqPyIntegrator\nDiffEqPySDEIntegrator\nGeneral purpose, highest compatibility\n\n\nPyTorch\nTorchDiffEqIntegrator\nTorchSDEIntegrator\nGPU acceleration, neural networks\n\n\nJAX\nDiffraxIntegrator\nDiffraxSDEIntegrator\nOptimization, functional programming\n\n\n\n\n\nBy System Properties\n\n\n\n\n\n\n\n\n\nSystem Type\nBest Method\nConvergence Order\nNotes\n\n\n\n\nNon-stiff\nRK45, Tsit5, dopri5\n5(4)\nGeneral purpose\n\n\nStiff\nBDF, Radau, Rodas5\nVariable\nImplicit methods required\n\n\nVery stiff\nBDF, LSODA\nVariable\nAutomatic stiffness detection\n\n\nHigh accuracy\nVern9, DOP853\n9(8) or 8(5,3)\nFor precision-critical applications\n\n\nReal-time\nRK4, euler\n4 or 1\nFixed step, predictable timing\n\n\nAdditive noise SDE\nreversible_heun, adaptive_heun\n1.0 (strong)\nExploits simplified noise structure\n\n\nGeneral SDE\nEuler-Maruyama\n0.5 (strong)\nRobust for any noise type\n\n\nDiagonal noise SDE\nMilstein\n1.0 (strong)\nHigher order for independent channels",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-design-principles",
    "href": "architecture/Integration_Framework_Architecture.html#sec-design-principles",
    "title": "Integration Framework Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\nBackend Abstraction\nAll integrators provide consistent interfaces across computational backends. Switch between NumPy, PyTorch, and JAX without changing integration code:\n# Same interface, different backends\nintegrator_numpy = IntegratorFactory.auto(system, backend='numpy')\nintegrator_torch = IntegratorFactory.auto(system, backend='torch')\nintegrator_jax = IntegratorFactory.auto(system, backend='jax')\n\n\nFactory Pattern for Complexity Management\nFactories encapsulate the complexity of choosing appropriate integrators:\n# User specifies intent, factory handles details\nIntegratorFactory.for_production(system)  # → LSODA\nIntegratorFactory.for_neural_ode(system)  # → dopri5 with adjoint\nIntegratorFactory.for_optimization(system)  # → tsit5 with JAX\n\n\nUnified Result Types\nTypedDict results provide consistent structure with IDE support:\nresult: IntegrationResult = integrator.integrate(...)\n# IDE knows 'success', 'nfev', 'x', 't' are available\n\n\nComposition Over Inheritance\nIntegrators compose with systems rather than inheriting deeply:\nclass Integrator:\n    def __init__(self, system: ContinuousSystemBase):\n        self.system = system  # Composition\n\n\nBuilt-in Performance Tracking\nAll integrators track statistics automatically:\nprint(f\"Function evaluations: {integrator._stats['total_fev']}\")\nprint(f\"Integration steps: {integrator._stats['total_steps']}\")\nprint(f\"Computation time: {integrator._stats['total_time']:.4f}s\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-strengths",
    "href": "architecture/Integration_Framework_Architecture.html#sec-strengths",
    "title": "Integration Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\nMulti-backend support: Seamless NumPy/PyTorch/JAX switching\nExtensive method library: 40+ integration methods across ODE and SDE\nCentralized method registry: Unified method normalization, validation, and discovery\nCanonical name support: Use portable names (euler_maruyama, rk45) across backends\nIntelligent factories: Automatic method selection based on system properties\nType safety: TypedDict results with full IDE support\nGPU acceleration: First-class support via PyTorch and JAX\nXLA compilation: Near-native performance with JAX\nJulia integration: Access to world-class DifferentialEquations.jl ecosystem\nSDE support: Comprehensive stochastic integration framework\nNoise exploitation: Automatic detection and optimization for noise structure\nMonte Carlo: Built-in multi-trajectory simulation\nCustom noise: Deterministic testing with user-provided Brownian paths\nProduction ready: Professional error control and performance tracking",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#summary",
    "href": "architecture/Integration_Framework_Architecture.html#summary",
    "title": "Integration Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe ControlDESymulation integration framework provides a comprehensive, production-ready solution for numerical integration across deterministic and stochastic systems. With support for multiple backends, extensive method libraries, and intelligent automation through factory patterns, it enables efficient development of control theory and machine learning applications requiring state-of-the-art numerical integration.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html",
    "href": "architecture/Control_Framework_Architecture.html",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "The Control Framework provides classical control theory algorithms for analysis and synthesis of dynamical systems. It consists of 3 core modules organized into a clean 2-layer architecture: pure stateless functions and thin composition wrappers.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nPure Function Layer: classical_control_functions.py - Stateless control algorithms\nComposition Layer: control_synthesis.py, system_analysis.py - System integration\nType Layer: control_classical.py - TypedDict result definitions\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nUsers interact with the control framework through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\n\n# Control design\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\n\n# System analysis\nstability = system.analysis.stability(A, system_type='continuous')\ncontrollability = system.analysis.controllability(A, B)\n\n# ✗ INCORRECT: Direct function imports (not recommended)\nfrom cdesym.control.classical_control_functions import design_lqr\nlqr = design_lqr(A, B, Q, R, system_type='continuous')\nThe system properties (system.control, system.analysis) automatically handle backend management and provide a consistent interface. Direct function calls are possible but bypass the system’s backend configuration.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-overview",
    "href": "architecture/Control_Framework_Architecture.html#sec-overview",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "The Control Framework provides classical control theory algorithms for analysis and synthesis of dynamical systems. It consists of 3 core modules organized into a clean 2-layer architecture: pure stateless functions and thin composition wrappers.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nPure Function Layer: classical_control_functions.py - Stateless control algorithms\nComposition Layer: control_synthesis.py, system_analysis.py - System integration\nType Layer: control_classical.py - TypedDict result definitions\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nUsers interact with the control framework through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\n\n# Control design\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\n\n# System analysis\nstability = system.analysis.stability(A, system_type='continuous')\ncontrollability = system.analysis.controllability(A, B)\n\n# ✗ INCORRECT: Direct function imports (not recommended)\nfrom cdesym.control.classical_control_functions import design_lqr\nlqr = design_lqr(A, B, Q, R, system_type='continuous')\nThe system properties (system.control, system.analysis) automatically handle backend management and provide a consistent interface. Direct function calls are possible but bypass the system’s backend configuration.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Control_Framework_Architecture.html#sec-architecture-philosophy",
    "title": "Control Framework Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nFunctional Design with Composition - The control framework achieves:\n\nPure Functions - Stateless algorithms like scipy (design_lqr, analyze_stability)\nThin Wrappers - Minimal composition layer for system integration\nType Safety - TypedDict results for all algorithms\nBackend Consistency - Automatic backend handling from parent system\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Implements classical control theory correctly\nClean Integration - Natural system.control and system.analysis APIs\n\nDesign principle: Control algorithms are pure functions that work like scipy—take matrices in, return structured results. Thin wrapper classes provide system integration without adding business logic.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-framework-layers",
    "href": "architecture/Control_Framework_Architecture.html#sec-framework-layers",
    "title": "Control Framework Architecture",
    "section": "Framework Layers",
    "text": "Framework Layers\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│              (ContinuousSystemBase, DiscreteSystemBase)    │\n│                                                            │\n│  system.control   ─────► ControlSynthesis                 │\n│  system.analysis  ─────► SystemAnalysis                   │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ delegates to\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│              PURE FUNCTION LAYER                           │\n│          classical_control_functions.py                    │\n│                                                            │\n│  Control Design:          System Analysis:                 │\n│  • design_lqr()          • analyze_stability()             │\n│  • design_kalman()       • analyze_controllability()       │\n│  • design_lqg()          • analyze_observability()         │\n│                                                            │\n│  All functions are stateless, pure, backend-agnostic       │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ returns\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   TYPE LAYER                               │\n│             control_classical.py                           │\n│                                                            │\n│  • LQRResult           • StabilityInfo                     │\n│  • KalmanFilterResult  • ControllabilityInfo               │\n│  • LQGResult           • ObservabilityInfo                 │\n└────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-pure-function-layer",
    "href": "architecture/Control_Framework_Architecture.html#sec-pure-function-layer",
    "title": "Control Framework Architecture",
    "section": "Pure Function Layer",
    "text": "Pure Function Layer\n\nclassical_control_functions.py: Stateless Algorithms\nFile: classical_control_functions.py\nThe pure function layer provides stateless control algorithms that work like scipy—take matrices in, return structured TypedDict results.\nDesign philosophy:\n\nPure functions - No side effects, no state\nBackend agnostic - Internal conversion to/from NumPy for scipy\nMathematical correctness - Rigorous implementation of control theory\nComprehensive validation - Dimension checks, positive-definiteness\nClear error handling - Actionable exceptions for infeasible problems\n\nKey categories:\n\n\nControl Design Functions\n\nLQR Controller Design\nMathematical background:\nContinuous-time LQR:\n\\[J = \\int_0^\\infty (x'Qx + u'Ru + 2x'Nu) dt\\]\nAlgebraic Riccati Equation (ARE):\n\\[A'P + PA - PBR^{-1}B'P + Q - N'R^{-1}N = 0\\]\nOptimal gain:\n\\[K = R^{-1}(B'P + N')\\]\nDiscrete-time LQR:\n\\[J = \\sum_{k=0}^\\infty (x[k]'Qx[k] + u[k]'Ru[k] + 2x[k]'Nu[k])\\]\nDiscrete ARE:\n\\[P = A'PA - (A'PB + N)(R + B'PB)^{-1}(B'PA + N') + Q\\]\nOptimal gain:\n\\[K = (R + B'PB)^{-1}(B'PA + N')\\]\nFunction signature:\ndef design_lqr(\n    A: StateMatrix,\n    B: InputMatrix,\n    Q: StateMatrix,\n    R: InputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQRResult:\n    \"\"\"\n    Design Linear Quadratic Regulator (LQR) controller.\n    \n    Unified interface for continuous and discrete LQR.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    Q : StateMatrix\n        State cost matrix (nx, nx), Q ≥ 0, (Q,A) detectable\n    R : InputMatrix\n        Control cost matrix (nu, nu), R &gt; 0\n    N : InputMatrix, optional\n        Cross-coupling matrix (nx, nu)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    LQRResult\n        gain : Optimal feedback gain K (nu, nx)\n        cost_to_go : Riccati solution P (nx, nx)\n        closed_loop_eigenvalues : eig(A - BK)\n        stability_margin : Stability robustness measure\n    \n    Raises\n    ------\n    ValueError\n        If Q, R dimensions incompatible or conditions violated\n    LinAlgError\n        If Riccati equation has no stabilizing solution\n    \"\"\"\nUsage example:\n\n\nCode\nsystem = Pendulum()\n\n# Linearize at upright equilibrium\nx_eq = np.array([np.pi, 0.0])\nu_eq = np.array([0.0])\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])   # Penalize angle more than velocity\nR = np.array([[0.1]])   # Small control cost\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Extract results\nK = lqr['gain']\nP = lqr['cost_to_go']\neigs = lqr['controller_eigenvalues']\n\nprint(f\"LQR gain shape: {K.shape}\")\nprint(f\"Closed-loop stable: {np.all(np.real(eigs) &lt; 0)}\")\n\n\n\n\nKalman Filter Design\nMathematical background:\nSystem model:\n\\[x[k+1] = Ax[k] + Bu[k] + w[k], \\quad w \\sim \\mathcal{N}(0, Q)\\]\n\\[y[k] = Cx[k] + v[k], \\quad v \\sim \\mathcal{N}(0, R)\\]\nEstimator dynamics:\n\\[\\hat{x}[k+1] = A\\hat{x}[k] + Bu[k] + L(y[k] - C\\hat{x}[k])\\]\nOptimal gain:\n\\[L = APC'(CPC' + R)^{-1}\\]\nError covariance Riccati equation:\n\\[P = A(P - PC'(CPC' + R)^{-1}CP)A' + Q\\]\nFunction signature:\ndef design_kalman_filter(\n    A: StateMatrix,\n    C: OutputMatrix,\n    Q: StateMatrix,\n    R: OutputMatrix,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; KalmanFilterResult:\n    \"\"\"\n    Design Kalman filter for optimal state estimation.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    Q : StateMatrix\n        Process noise covariance (nx, nx), Q ≥ 0\n    R : OutputMatrix\n        Measurement noise covariance (ny, ny), R &gt; 0\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    KalmanFilterResult\n        gain : Kalman gain L (nx, ny)\n        error_covariance : Steady-state P (nx, nx)\n        innovation_covariance : S = CPC' + R (ny, ny)\n        observer_eigenvalues : eig(A - LC)\n    \"\"\"\nUsage example:\n\n\nCode\n# Define measurement model (measure angle only)\nC = np.array([[1, 0]])\n\n# Define noise covariances\nQ_process = 0.01 * np.eye(2)      # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# Extract results\nL = kalman['gain']\nP = kalman['estimation_error_covariance']\nestimator_eigs = kalman['estimator_eigenvalues']\n\nprint(f\"Kalman gain shape: {L.shape}\")\nprint(f\"Observer stable: {np.all(np.real(estimator_eigs) &lt; 0)}\")\n\n\n\n\nLQG Controller Design\nMathematical background:\nSeparation principle:\n\nDesign LQR assuming full state feedback: \\(u = -Kx\\)\nDesign Kalman filter for state estimation\nCombine via certainty equivalence: \\(u = -K\\hat{x}\\)\n\nClosed-loop system:\n\\[\\begin{bmatrix} x[k+1] \\\\ e[k+1] \\end{bmatrix} = \\begin{bmatrix} A - BK & BK \\\\ 0 & A - LC \\end{bmatrix} \\begin{bmatrix} x[k] \\\\ e[k] \\end{bmatrix} + \\begin{bmatrix} w[k] \\\\ w[k] - Lv[k] \\end{bmatrix}\\]\nEigenvalues:\n\nController poles: \\(\\text{eig}(A - BK)\\)\nObserver poles: \\(\\text{eig}(A - LC)\\)\nCombined: \\(\\text{eig}(A - BK) \\cup \\text{eig}(A - LC)\\)\n\nFunction signature:\ndef design_lqg(\n    A: StateMatrix,\n    B: InputMatrix,\n    C: OutputMatrix,\n    Q_state: StateMatrix,\n    R_control: InputMatrix,\n    Q_process: StateMatrix,\n    R_measurement: OutputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQGResult:\n    \"\"\"\n    Design Linear Quadratic Gaussian (LQG) controller.\n    \n    Combines LQR (optimal control) with Kalman filter (optimal estimation)\n    via the separation principle.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    Q_state : StateMatrix\n        LQR state cost (nx, nx)\n    R_control : InputMatrix\n        LQR control cost (nu, nu)\n    Q_process : StateMatrix\n        Process noise covariance (nx, nx)\n    R_measurement : OutputMatrix\n        Measurement noise covariance (ny, ny)\n    N : InputMatrix, optional\n        Cross-coupling (nx, nu)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    LQGResult\n        control_gain : LQR gain K (nu, nx)\n        estimator_gain : Kalman gain L (nx, ny)\n        control_cost_to_go : Controller Riccati P_c\n        estimation_error_covariance : Estimator Riccati P_e\n        separation_verified : bool\n        closed_loop_stable : bool\n        controller_eigenvalues : eig(A - BK)\n        estimator_eigenvalues : eig(A - LC)\n    \"\"\"\nUsage example:\n\n\nCode\n# Design LQG controller\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state=np.diag([10, 1]),\n    R_control=np.array([[0.1]]),\n    Q_process=0.01*np.eye(2),\n    R_measurement=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Extract both gains\nK_control = lqg['control_gain']\nL_estimator = lqg['estimator_gain']\n\nprint(f\"LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"Separation verified: {lqg['separation_verified']}\")\nprint(f\"Controller poles: {lqg['controller_eigenvalues']}\")\nprint(f\"Observer poles: {lqg['estimator_eigenvalues']}\")\n\n\n\n\n\nSystem Analysis Functions\n\nStability Analysis\nMathematical background:\nContinuous-time stability criteria: - Asymptotically stable: All \\(\\text{Re}(\\lambda) &lt; 0\\) (left half-plane) - Marginally stable: \\(\\max \\text{Re}(\\lambda) \\approx 0\\) - Unstable: Any \\(\\text{Re}(\\lambda) &gt; 0\\)\nDiscrete-time stability criteria: - Asymptotically stable: All \\(|\\lambda| &lt; 1\\) (inside unit circle) - Marginally stable: \\(\\max |\\lambda| \\approx 1\\) - Unstable: Any \\(|\\lambda| &gt; 1\\)\nFunction signature:\ndef analyze_stability(\n    A: StateMatrix,\n    system_type: str = \"continuous\",\n    backend: Backend = \"numpy\"\n) -&gt; StabilityInfo:\n    \"\"\"\n    Analyze system stability via eigenvalue placement.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    StabilityInfo\n        eigenvalues : Complex eigenvalues of A\n        magnitudes : |λ| for each eigenvalue\n        max_magnitude : max |λ| (spectral radius)\n        spectral_radius : Same as max_magnitude\n        is_stable : Asymptotic stability\n        is_marginally_stable : On boundary\n        is_unstable : At least one unstable mode\n    \"\"\"\nUsage example:\n\n\nCode\n# Analyze open-loop stability\nstability_ol = system.analysis.stability(A, system_type='continuous')\n\nprint(f\"Open-loop stable: {stability_ol['is_stable']}\")\nprint(f\"Spectral radius: {stability_ol['spectral_radius']:.3f}\")\nprint(f\"Eigenvalues: {stability_ol['eigenvalues']}\")\n\n# Analyze closed-loop stability (with LQR)\nA_cl = A - B @ K\nstability_cl = system.analysis.stability(A_cl, system_type='continuous')\n\nprint(f\"\\nClosed-loop stable: {stability_cl['is_stable']}\")\nprint(f\"Spectral radius: {stability_cl['spectral_radius']:.3f}\")\n\n\n\n\nControllability Analysis\nMathematical background:\nControllability test:\n\\[\\text{rank}(\\mathcal{C}) = n_x \\quad \\text{where} \\quad \\mathcal{C} = [B, AB, A^2B, \\ldots, A^{n_x-1}B]\\]\nInterpretation: - Controllable: All states can be driven to any value in finite time - Uncontrollable: Some states cannot be influenced by control\nFunction signature:\ndef analyze_controllability(\n    A: StateMatrix,\n    B: InputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ControllabilityInfo:\n    \"\"\"\n    Test system controllability via rank condition.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    ControllabilityInfo\n        controllability_matrix : C = [B AB ... A^(n-1)B] (nx, nx*nu)\n        rank : Rank of controllability matrix\n        is_controllable : rank == nx\n        uncontrollable_modes : Eigenvalues of uncontrollable subsystem\n    \"\"\"\nUsage example:\n\n\nCode\n# Check controllability\nctrl = system.analysis.controllability(A, B)\n\nprint(f\"Controllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif ctrl['is_controllable']:\n    print(\"✓ Can design LQR controller\")\nelse:\n    print(\"✗ Cannot design LQR - system not controllable\")\n    if ctrl.get('uncontrollable_modes') is not None:\n        print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n\n\n\nObservability Analysis\nMathematical background:\nObservability test:\n\\[\\text{rank}(\\mathcal{O}) = n_x \\quad \\text{where} \\quad \\mathcal{O} = \\begin{bmatrix} C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n_x-1} \\end{bmatrix}\\]\nInterpretation: - Observable: Initial state can be determined from output measurements - Unobservable: Some states hidden from measurements\nFunction signature:\ndef analyze_observability(\n    A: StateMatrix,\n    C: OutputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ObservabilityInfo:\n    \"\"\"\n    Test system observability via rank condition.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    ObservabilityInfo\n        observability_matrix : O = [C; CA; ...] (nx*ny, nx)\n        rank : Rank of observability matrix\n        is_observable : rank == nx\n        unobservable_modes : Eigenvalues of unobservable subsystem\n    \"\"\"\nUsage example:\n\n\nCode\n# Check observability\nobs = system.analysis.observability(A, C)\n\nprint(f\"Observable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n    if obs.get('unobservable_modes') is not None:\n        print(f\"Unobservable modes: {obs['unobservable_modes']}\")\n\n# Check minimal realization\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"\\n✓ System is minimal (controllable and observable)\")\n    print(\"✓ Can design LQG controller\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-composition-wrapper-layer",
    "href": "architecture/Control_Framework_Architecture.html#sec-composition-wrapper-layer",
    "title": "Control Framework Architecture",
    "section": "Composition Wrapper Layer",
    "text": "Composition Wrapper Layer\n\nControlSynthesis: Control Design Wrapper\nFile: control_synthesis.py\nThe ControlSynthesis class provides a thin wrapper for control design algorithms, integrating them with the system’s backend configuration.\nDesign philosophy:\n\nComposition not inheritance - Utility composed by system, not inherited\nNo state - Only stores backend setting from parent system\nNo caching - Delegates immediately to pure functions\nClean API - Methods match control theory terminology\n\nArchitecture:\nclass ControlSynthesis:\n    \"\"\"\n    Control synthesis wrapper for system composition.\n    \n    Thin wrapper that routes to pure control design functions while\n    maintaining backend consistency with parent system.\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def design_lqr(self, A, B, Q, R, N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqr()\"\"\"\n        from cdesym.control.classical_control_functions import design_lqr\n        return design_lqr(A, B, Q, R, N, system_type, self.backend)\n    \n    def design_kalman(self, A, C, Q, R, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_kalman_filter()\"\"\"\n        from cdesym.control.classical_control_functions import design_kalman_filter\n        return design_kalman_filter(A, C, Q, R, system_type, self.backend)\n    \n    def design_lqg(self, A, B, C, Q_state, R_control, Q_process, R_measurement, \n                   N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqg()\"\"\"\n        from cdesym.control.classical_control_functions import design_lqg\n        return design_lqg(A, B, C, Q_state, R_control, Q_process, R_measurement, \n                         N, system_type, self.backend)\nSystem integration:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef control(self) -&gt; ControlSynthesis:\n    \"\"\"Access control synthesis utilities.\"\"\"\n    if not hasattr(self, '_control_synthesis'):\n        from cdesym.control.control_synthesis import ControlSynthesis\n        self._control_synthesis = ControlSynthesis(backend=self.backend.default_backend)\n    return self._control_synthesis\n\n\nSystemAnalysis: System Analysis Wrapper\nFile: system_analysis.py\nThe SystemAnalysis class provides a thin wrapper for system analysis algorithms, identical in design to ControlSynthesis.\nArchitecture:\nclass SystemAnalysis:\n    \"\"\"\n    System analysis wrapper for composition.\n    \n    Thin wrapper that routes to pure system analysis functions while\n    maintaining backend consistency with parent system.\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def stability(self, A, system_type='continuous'):\n        \"\"\"Route to classical_control_functions.analyze_stability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_stability\n        return analyze_stability(A, system_type, self.backend)\n    \n    def controllability(self, A, B):\n        \"\"\"Route to classical_control_functions.analyze_controllability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_controllability\n        return analyze_controllability(A, B, self.backend)\n    \n    def observability(self, A, C):\n        \"\"\"Route to classical_control_functions.analyze_observability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_observability\n        return analyze_observability(A, C, self.backend)\nSystem integration:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef analysis(self) -&gt; SystemAnalysis:\n    \"\"\"Access system analysis utilities.\"\"\"\n    if not hasattr(self, '_system_analysis'):\n        from cdesym.control.system_analysis import SystemAnalysis\n        self._system_analysis = SystemAnalysis(backend=self.backend.default_backend)\n    return self._system_analysis",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-design-patterns",
    "href": "architecture/Control_Framework_Architecture.html#sec-design-patterns",
    "title": "Control Framework Architecture",
    "section": "Design Patterns",
    "text": "Design Patterns\n\nPattern 1: Pure Functions + Thin Wrappers\nPrinciple: Separate stateless algorithms from system integration.\n\n\nCode\n# ✗ ANTI-PATTERN: Methods on system class (violates SRP)\nclass ContinuousSystemBase:\n    def design_lqr(self, Q, R):\n        # LQR implementation mixed with system concerns\n        pass\n\n# ✓ GOOD PATTERN: Pure function + composition\n\n# Pure function (classical_control_functions.py)\ndef design_lqr(A, B, Q, R, system_type, backend):\n    \"\"\"Stateless, testable, reusable.\"\"\"\n    # Focus solely on LQR algorithm\n    return LQRResult(...)\n\n# Thin wrapper (control_synthesis.py)\nclass ControlSynthesis:\n    def design_lqr(self, A, B, Q, R, system_type):\n        return design_lqr(A, B, Q, R, system_type, self.backend)\n\n# System integration (continuous_system_base.py)\n@property\ndef control(self) -&gt; ControlSynthesis:\n    return ControlSynthesis(backend=self.backend.default_backend)\n\n\nBenefits:\n\n✓ Single responsibility per component\n✓ Easy unit testing of pure functions\n✓ Reusable algorithms outside system context\n✓ Maintainability through isolation\n\n\n\nPattern 2: Backend Agnosticism\nPrinciple: Convert to NumPy for scipy, then back to original backend.\ndef design_lqr(..., backend: Backend):\n    \"\"\"Works with NumPy, PyTorch, JAX transparently.\"\"\"\n    \n    # Convert to NumPy for scipy\n    A_np = _to_numpy(A, backend)\n    B_np = _to_numpy(B, backend)\n    Q_np = _to_numpy(Q, backend)\n    R_np = _to_numpy(R, backend)\n    \n    # Solve in NumPy (scipy.linalg)\n    P = solve_continuous_are(A_np, B_np, Q_np, R_np)\n    K = np.linalg.solve(R_np, B_np.T @ P)\n    \n    # Convert back to original backend\n    K_result = _from_numpy(K, backend)\n    P_result = _from_numpy(P, backend)\n    \n    return LQRResult(gain=K_result, cost_to_go=P_result, ...)\n\n\nPattern 3: TypedDict Results\nPrinciple: Structured results with type safety and IDE support.\n\n\nCode\n# All functions return structured TypedDict\nresult: LQRResult = design_lqr(A, B, Q, R, system_type='continuous')\n\n# IDE autocomplete knows all fields\nK = result['gain']                    # ✓ Valid\nP = result['cost_to_go']              # ✓ Valid\neigs = result['controller_eigenvalues']  # ✓ Valid\nbad = result['nonexistent_key']       # ✗ Type error!\n\n# Type checking prevents errors\ndef apply_control(result: LQRResult) -&gt; np.ndarray:\n    return result['gain']  # ✓ Type checker verifies\n\n\n\n\nPattern 4: Unified Continuous/Discrete Interface\nPrinciple: Single function handles both continuous and discrete cases.\ndef design_lqr(A, B, Q, R, N=None, system_type='discrete', backend='numpy'):\n    \"\"\"Unified interface - system_type selects algorithm.\"\"\"\n    \n    if system_type == 'continuous':\n        # Continuous-time algebraic Riccati equation\n        P = solve_continuous_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R, B.T @ P)\n    elif system_type == 'discrete':\n        # Discrete-time algebraic Riccati equation\n        P = solve_discrete_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R + B.T @ P @ B, B.T @ P @ A)\n    else:\n        raise ValueError(f\"Invalid system_type: {system_type}\")\n    \n    # Rest of implementation identical\n    closed_loop_eigs = np.linalg.eigvals(A - B @ K)\n    \n    return LQRResult(gain=K, cost_to_go=P, ...)\nBenefits:\n\n✓ Single function for both cases\n✓ Less code duplication\n✓ Consistent API across system types\n✓ Easier maintenance",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-usage-workflows",
    "href": "architecture/Control_Framework_Architecture.html#sec-usage-workflows",
    "title": "Control Framework Architecture",
    "section": "Usage Workflows",
    "text": "Usage Workflows\n\nWorkflow 1: LQR Controller Design\nComplete workflow from linearization to closed-loop simulation:\n\n\nCode\n# 1. Create system\nsystem = Pendulum(m_val=1.0, l_val=0.5, g_val=9.81, beta_val=0.1)\n\n# 2. Define equilibrium (upright position)\nx_eq = np.array([np.pi, 0])  # [theta, omega]\nu_eq = np.zeros(1)\n\n# 3. Linearize at equilibrium\nA, B = system.linearize(x_eq, u_eq)\n\n# 4. Design LQR controller\nQ = np.diag([10, 1])   # Penalize angle more than velocity\nR = np.array([[0.1]])   # Small control cost\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# 5. Extract and verify\nK = lqr['gain']\neigs = lqr['controller_eigenvalues']\n\nprint(f\"✓ LQR gain: {K}\")\nprint(f\"✓ Closed-loop stable: {np.all(np.real(eigs) &lt; 0)}\")\n\n# 6. Implement controller\ndef lqr_controller(t, x):\n    return -K @ (x - x_eq)\n\n# 7. Simulate (closed-loop)\nresult = system.simulate(\n    x0=np.array([np.pi + 0.2, 0]),  # Start near upright\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\nprint(f\"✓ Simulation complete: {len(result['time'])} time points\")\n\n\n\n\nWorkflow 2: Kalman Filter Design\nObserver design for partial state measurements:\n\n\nCode\n# 1. Same system and linearization\nA, B = system.linearize(x_eq, u_eq)\n\n# 2. Define measurement model (measure angle only)\nC = np.array([[1, 0]])  # Observe theta, not omega\n\n# 3. Define noise covariances\nQ_process = 0.01 * np.eye(2)      # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# 4. Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 5. Extract gain\nL = kalman['gain']\nobserver_eigs = kalman['estimator_eigenvalues']\n\nprint(f\"✓ Kalman gain: {L}\")\nprint(f\"✓ Observer stable: {np.all(np.real(observer_eigs) &lt; 0)}\")\n\n# 6. Implement estimator\nx_hat = np.zeros(2)\ndt = 0.01\nN = 1000\n\nfor k in range(N):\n    # Prediction\n    x_hat_pred = A @ x_hat * dt + x_hat + B @ u[k] * dt\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + np.random.randn() * np.sqrt(0.1)\n    innovation = y_meas - C @ x_hat_pred\n    x_hat = x_hat_pred + L @ innovation * dt\n\n\n\n\nWorkflow 3: LQG Controller Design\nCombined optimal control and estimation:\n\n\nCode\n# 1. Define all matrices\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Partial state measurement\n\n# 2. Design weights\nQ_state = np.diag([10, 1])        # LQR state cost\nR_control = np.array([[0.1]])      # LQR control cost\nQ_process = 0.01 * np.eye(2)      # Kalman process noise\nR_measurement = np.array([[0.1]])  # Kalman measurement noise\n\n# 3. Design LQG\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state, R_control,\n    Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 4. Extract both gains\nK = lqg['controller_gain']\nL = lqg['estimator_gain']\n\nprint(f\"✓ LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"✓ Separation verified: {lqg['separation_verified']}\")\n\n# 5. Implement LQG controller\nx_hat = np.zeros(2)\ndt = 0.01\n\nfor k in range(N):\n    # Control (certainty equivalence)\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Prediction\n    x_hat = A @ x_hat * dt + x_hat + B @ u[k] * dt\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + measurement_noise[k]\n    innovation = y_meas - C @ x_hat\n    x_hat = x_hat + L @ innovation * dt\n\n\n\n\nWorkflow 4: System Analysis\nComplete system analysis before controller design:\n\n\nCode\n# 1. Linearize system\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])\n\n# 2. Check stability\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Open-loop stable: {stability['is_stable']}\")\nprint(f\"Eigenvalues: {stability['eigenvalues']}\")\nprint(f\"Spectral radius: {stability['spectral_radius']:.3f}\")\n\n# 3. Check controllability\nctrl = system.analysis.controllability(A, B)\nprint(f\"\\nControllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif not ctrl['is_controllable']:\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 4. Check observability\nobs = system.analysis.observability(A, C)\nprint(f\"\\nObservable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\n# 5. Verify conditions for control design\nif ctrl['is_controllable']:\n    print(\"\\n✓ Can design LQR controller\")\nelse:\n    print(\"\\n✗ Cannot design LQR - system not controllable\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"✓ System is minimal - can design LQG controller\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-key-strengths",
    "href": "architecture/Control_Framework_Architecture.html#sec-key-strengths",
    "title": "Control Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipControl Framework Advantages\n\n\n\n\nPure Functional Core - Stateless algorithms, easy to test and reuse\nThin Wrappers - Minimal composition layer with no business logic\nType Safety - TypedDict results throughout with IDE support\nBackend Agnostic - NumPy/PyTorch/JAX transparency\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Correct implementation of classical control theory\nClean Integration - Natural system.control and system.analysis APIs\nUnified Interface - Single function for continuous/discrete cases\nComprehensive - LQR, Kalman, LQG, stability, controllability, observability\nScipy-like - Familiar API for control engineers",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#summary",
    "href": "architecture/Control_Framework_Architecture.html#summary",
    "title": "Control Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe Control Framework provides production-quality classical control theory algorithms through a clean two-layer architecture:\n\nPure Function Layer provides stateless, testable algorithms\nComposition Layer integrates algorithms with system backend management\nType Layer ensures type safety with structured TypedDict results\n\nUsers interact through intuitive system properties (system.control, system.analysis) that automatically handle backend management and provide consistent interfaces across continuous and discrete systems.\nThe framework implements classical control theory correctly while maintaining clean software architecture and comprehensive type safety.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/index.html",
    "href": "architecture/index.html",
    "title": "Architecture",
    "section": "",
    "text": "ControlDESymulation is built on a type-driven, composition-based architecture that achieves mathematical rigor, software engineering excellence, and multi-backend performance simultaneously. This section provides comprehensive documentation of the framework’s internal design for developers and advanced users.\n\n\n\n\n\n\nImportantWho Should Read This?\n\n\n\nMost users do NOT need to read architecture documentation. If you’re:\n\nUsing built-in systems from cdesym.systems.builtin.*\nDefining custom systems by subclassing ContinuousSymbolicSystem or DiscreteSymbolicSystem\nFollowing tutorials and examples\n\nThen you can skip this section entirely. The architecture documentation is intended for:\n\nFramework contributors and maintainers\nAdvanced users implementing custom integrators or utilities\nResearchers studying the framework’s design\nDevelopers extending the framework with new capabilities",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#introduction",
    "href": "architecture/index.html#introduction",
    "title": "Architecture",
    "section": "",
    "text": "ControlDESymulation is built on a type-driven, composition-based architecture that achieves mathematical rigor, software engineering excellence, and multi-backend performance simultaneously. This section provides comprehensive documentation of the framework’s internal design for developers and advanced users.\n\n\n\n\n\n\nImportantWho Should Read This?\n\n\n\nMost users do NOT need to read architecture documentation. If you’re:\n\nUsing built-in systems from cdesym.systems.builtin.*\nDefining custom systems by subclassing ContinuousSymbolicSystem or DiscreteSymbolicSystem\nFollowing tutorials and examples\n\nThen you can skip this section entirely. The architecture documentation is intended for:\n\nFramework contributors and maintainers\nAdvanced users implementing custom integrators or utilities\nResearchers studying the framework’s design\nDevelopers extending the framework with new capabilities",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#architecture-documents",
    "href": "architecture/index.html#architecture-documents",
    "title": "Architecture",
    "section": "Architecture Documents",
    "text": "Architecture Documents\nThe framework consists of 7 architectural layers, each documented separately:\n\n1. Design Philosophy\nStart here to understand the core principles that guide the framework’s design.\nTopics covered:\n\nType-driven design philosophy\nComposition over inheritance\nBackend agnosticism\nZero code duplication\nProgressive disclosure of complexity\nDesign patterns and trade-offs\n\nRead this if: You want to understand why the framework is built the way it is, or you’re contributing new features.\n\n\n2. Type System Architecture\nThe foundational Layer 0 that provides semantic types, structured results, and type-safe interfaces.\nTopics covered:\n\nMulti-backend array types (NumPy, PyTorch, JAX)\nSemantic vector/matrix types (StateVector, GainMatrix, etc.)\nTypedDict structured results (IntegrationResult, LQRResult, etc.)\nProtocol-based interfaces for duck typing with type safety\n200+ type definitions across 8 modules\n\nRead this if: You’re implementing custom components, need to understand type conventions, or want to leverage IDE support.\n\n\n3. UI Framework Architecture\nThe user-facing Layer 3 for defining and working with dynamical systems.\nComponents documented:\n\nLayer 0: SymbolicSystemBase - Time-domain agnostic foundation\nLayer 1: ContinuousSystemBase, DiscreteSystemBase - Time-domain interfaces\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem - Concrete implementations\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem - Stochastic extensions\n\nRead this if: You’re defining custom systems, extending the framework, or need to understand the class hierarchy.\n\n\n4. Delegation Layer\nThe internal service layer that provides specialized utilities through composition.\nComponents documented:\n\nCore Utilities: BackendManager, CodeGenerator, EquilibriumHandler, SymbolicValidator\nDeterministic Evaluation: DynamicsEvaluator, LinearizationEngine, ObservationEngine\nStochastic Support: DiffusionHandler, NoiseCharacterizer, SDEValidator\nLow-Level Utilities: codegen_utils\n\nRead this if: You’re implementing custom system types or need to understand how symbolic-to-numerical compilation works.\n\n\n5. Integration Framework\nMulti-backend numerical integration for ODEs and SDEs.\nTopics covered:\n\nIntegrator architecture and factories\nDeterministic integrators (Scipy, TorchDiffEq, Diffrax, DiffEqPy, Fixed-step)\nStochastic integrators (TorchSDE, Diffrax SDE, DiffEqPy SDE)\n40+ integration methods across 4 backends\nIntegration result types and performance tracking\n\nRead this if: You’re implementing custom integrators, need to understand method selection, or want to optimize integration performance.\n\n\n6. Control Framework Architecture\nClassical control theory algorithms for analysis and synthesis.\nTopics covered:\n\nControl Design: LQR, Kalman filter, LQG controller design\nSystem Analysis: Stability, controllability, observability analysis\nPure functional architecture with thin composition wrappers\nUnified continuous/discrete interface\nTypedDict results (LQRResult, KalmanFilterResult, StabilityInfo, etc.)\n\nRead this if: You’re using control design methods, need to understand the control API, or want to extend control capabilities.\n\n\n7. Visualization Framework\nInteractive, publication-ready plotting for dynamical systems analysis.\nComponents documented:\n\nTheming layer (colors, styles, themes)\nTrajectoryPlotter - Time-domain visualization\nPhasePortraitPlotter - State-space visualization\nControlPlotter - Control analysis plots\n\nRead this if: You’re extending visualization capabilities or need to understand the plotting system architecture.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#quick-navigation",
    "href": "architecture/index.html#quick-navigation",
    "title": "Architecture",
    "section": "Quick Navigation",
    "text": "Quick Navigation\n\nBy User Level\nBeginners: - Skip architecture docs - use Getting Started instead\nIntermediate Users: - Read Design Philosophy for conceptual understanding - Skim UI Framework for custom system definition - Skim Visualization Framework for plotting capabilities\nAdvanced Users: - Study all architecture documents - Focus on Type System for understanding type conventions - Focus on Integration Framework for custom numerical methods - Reference Delegation Layer for system extension - Reference Control Framework for control design algorithms\n\n\nBy Use Case\nI want to understand the framework’s design principles: → Design Philosophy\nI want to understand the type system and conventions: → Type System Architecture\nI want to define a custom dynamical system: → UI Framework Architecture\nI want to implement a custom integrator: → Integration Framework\nI want to extend the system base classes: → Delegation Layer\nI want to use or extend control design (LQR, Kalman, LQG): → Control Framework Architecture\nI want to customize or extend plotting: → Visualization Framework\nI want to understand symbolic-to-numerical compilation: → Delegation Layer → CodeGenerator\nI want to add a new backend (e.g., TensorFlow): → Design Philosophy → Extension Points → Delegation Layer → BackendManager",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#architecture-statistics",
    "href": "architecture/index.html#architecture-statistics",
    "title": "Architecture",
    "section": "Architecture Statistics",
    "text": "Architecture Statistics\nThe framework consists of:\n\n50+ core files organized into 7 architectural layers\n200+ types for semantic clarity and IDE support\n55+ integration methods across NumPy, PyTorch, JAX, and Julia backends\n11 delegation layer utilities providing specialized services\nClassical control algorithms (LQR, Kalman, LQG, stability, controllability, observability)\n8 core UI framework classes for system definition\n16+ plot types for comprehensive visualization\nZero code duplication through strategic abstraction",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#design-principles-summary",
    "href": "architecture/index.html#design-principles-summary",
    "title": "Architecture",
    "section": "Design Principles Summary",
    "text": "Design Principles Summary\n\n\n\n\n\n\nTipCore Principles\n\n\n\n\nType-Driven Design - Types are not just annotations—they are the architecture\nComposition Over Inheritance - Build systems from specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX\nZero Code Duplication - Every line exists in exactly one place\nStructured Results - TypedDict for all outputs with IDE support\nProtocol-Based Interfaces - Duck typing with type safety\nFactory Pattern - Hide complexity behind simple creation methods\nSemantic Naming - Names convey mathematical meaning\nProgressive Disclosure - Simple things simple, complex things possible",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#common-architectural-questions",
    "href": "architecture/index.html#common-architectural-questions",
    "title": "Architecture",
    "section": "Common Architectural Questions",
    "text": "Common Architectural Questions\n\nWhy composition instead of inheritance?\nShort answer: Single responsibility, testability, and flexibility.\nLong answer: See Design Philosophy\n\n\nWhy support multiple backends?\nShort answer: Different backends excel at different tasks—NumPy for CPU, PyTorch for GPUs/neural networks, JAX for optimization.\nLong answer: See Design Philosophy\n\n\nWhere does symbolic-to-numerical compilation happen?\nShort answer: In the CodeGenerator utility, with per-backend caching.\nLong answer: See Delegation Layer\n\n\nHow are integrators selected automatically?\nShort answer: Through the IntegratorFactory which chooses based on system properties and backend.\nLong answer: See Integration Framework\n\n\nHow does the framework avoid code duplication?\nShort answer: Through SymbolicSystemBase providing shared functionality to both continuous and discrete systems.\nLong answer: See UI Framework Architecture and Design Philosophy\n\n\nWhat types should I use for my custom components?\nShort answer: Use semantic types like StateVector, ControlVector, and TypedDict results like IntegrationResult.\nLong answer: See Type System Architecture\n\n\nHow do I design an LQR controller?\nShort answer: Use system.control.design_lqr(A, B, Q, R) after linearizing your system.\nLong answer: See Control Framework Architecture\n\n\nHow do I define a custom dynamical system?\nShort answer: Subclass ContinuousSymbolicSystem or DiscreteSymbolicSystem and implement define_system().\nLong answer: See UI Framework Architecture",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#contributing-to-the-framework",
    "href": "architecture/index.html#contributing-to-the-framework",
    "title": "Architecture",
    "section": "Contributing to the Framework",
    "text": "Contributing to the Framework\nIf you’re interested in contributing:\n\nStart with Design Philosophy to understand core principles\nReview Type System Architecture to understand type conventions\nStudy the relevant layer docs for your contribution area:\n\nSystem definition → UI Framework Architecture\nInternal utilities → Delegation Layer\nNumerical integration → Integration Framework\nControl algorithms → Control Framework\nVisualization → Visualization Framework\n\nFollow the established patterns (composition, type-driven design, etc.)\nWrite comprehensive tests for each component in isolation\nDocument your additions with clear examples and type annotations\n\nSee Contributing Guidelines for more details.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#getting-help",
    "href": "architecture/index.html#getting-help",
    "title": "Architecture",
    "section": "Getting Help",
    "text": "Getting Help\n\nQuestions about architecture? Open a discussion on GitHub\nFound a design issue? File an issue with the “architecture” label\nWant to propose an enhancement? Start with a discussion to align with design principles\n\n\nRemember: Most users don’t need to read architecture documentation. The framework is designed so you can be productive without understanding its internals. These documents are here when you need them.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ControlDESymulation",
    "section": "",
    "text": "ControlDESymulation is a comprehensive Python framework for symbolic modeling, simulation, and control of dynamical systems.\n\n\n\nWrite Once, Run Anywhere: Define systems symbolically, execute on any backend (NumPy/PyTorch/JAX)\nNo Backend Lock-in: Switch between CPU, GPU, or TPU without changing your code\nGradient-Aware: Automatic differentiation support for learned controllers and neural ODEs\nType-Safe: Comprehensive type hints for better IDE support and fewer bugs\nResearch to Production: Prototype in NumPy, scale with JAX, integrate with PyTorch models\n\n\n\n\n\nSymbolic Specification: Define systems using SymPy with automatic code generation\nMulti-Backend Support: Seamlessly switch between NumPy, PyTorch, JAX, and Julia\nDual Time Domains: Full support for both continuous-time (ODEs/SDEs) and discrete-time systems\nStochastic Systems: First-class support for stochastic differential equations (SDEs)\n40+ Integration Methods: Adaptive and fixed-step solvers from scipy, torchdiffeq, diffrax, and DiffEqPy\nType Safety: Comprehensive TypedDict definitions with IDE autocomplete support\nGPU Acceleration: Native PyTorch and JAX support for GPU-based simulations\nZero Code Duplication: Clean 4-layer architecture with composition over inheritance\nProduction Ready: Extensive test coverage, comprehensive documentation, CI/CD workflows\n\n\n\n\n\nComposition Over Inheritance - Delegate to specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX/Julia\nType-Driven Design - Comprehensive TypedDict definitions\nZero Code Duplication - Shared functionality in base classes\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance First - Multi-backend support enables GPU and XLA acceleration\n\n\n\n\n\nArchitecture Guides: Deep dives into framework design with working examples\nTutorials: Practical how-to guides with executable code\nExamples Gallery: Complete interactive demonstrations\n\n\n\n\n\nInstallation Guide: Current installation guide"
  },
  {
    "objectID": "index.html#sec-overview",
    "href": "index.html#sec-overview",
    "title": "ControlDESymulation",
    "section": "",
    "text": "ControlDESymulation is a comprehensive Python framework for symbolic modeling, simulation, and control of dynamical systems.\n\n\n\nWrite Once, Run Anywhere: Define systems symbolically, execute on any backend (NumPy/PyTorch/JAX)\nNo Backend Lock-in: Switch between CPU, GPU, or TPU without changing your code\nGradient-Aware: Automatic differentiation support for learned controllers and neural ODEs\nType-Safe: Comprehensive type hints for better IDE support and fewer bugs\nResearch to Production: Prototype in NumPy, scale with JAX, integrate with PyTorch models\n\n\n\n\n\nSymbolic Specification: Define systems using SymPy with automatic code generation\nMulti-Backend Support: Seamlessly switch between NumPy, PyTorch, JAX, and Julia\nDual Time Domains: Full support for both continuous-time (ODEs/SDEs) and discrete-time systems\nStochastic Systems: First-class support for stochastic differential equations (SDEs)\n40+ Integration Methods: Adaptive and fixed-step solvers from scipy, torchdiffeq, diffrax, and DiffEqPy\nType Safety: Comprehensive TypedDict definitions with IDE autocomplete support\nGPU Acceleration: Native PyTorch and JAX support for GPU-based simulations\nZero Code Duplication: Clean 4-layer architecture with composition over inheritance\nProduction Ready: Extensive test coverage, comprehensive documentation, CI/CD workflows\n\n\n\n\n\nComposition Over Inheritance - Delegate to specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX/Julia\nType-Driven Design - Comprehensive TypedDict definitions\nZero Code Duplication - Shared functionality in base classes\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance First - Multi-backend support enables GPU and XLA acceleration\n\n\n\n\n\nArchitecture Guides: Deep dives into framework design with working examples\nTutorials: Practical how-to guides with executable code\nExamples Gallery: Complete interactive demonstrations\n\n\n\n\n\nInstallation Guide: Current installation guide"
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "TODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-mechanical-systems",
    "href": "examples/index.html#sec-mechanical-systems",
    "title": "Examples",
    "section": "",
    "text": "TODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-aerospace-systems",
    "href": "examples/index.html#sec-aerospace-systems",
    "title": "Examples",
    "section": "Aerospace Systems",
    "text": "Aerospace Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-chemical-systems",
    "href": "examples/index.html#sec-chemical-systems",
    "title": "Examples",
    "section": "Chemical Systems",
    "text": "Chemical Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-chaotic-systems",
    "href": "examples/index.html#sec-chaotic-systems",
    "title": "Examples",
    "section": "Chaotic Systems",
    "text": "Chaotic Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-stochastic-systems",
    "href": "examples/index.html#sec-stochastic-systems",
    "title": "Examples",
    "section": "Stochastic Systems",
    "text": "Stochastic Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-discrete-systems",
    "href": "examples/index.html#sec-discrete-systems",
    "title": "Examples",
    "section": "Discrete Systems",
    "text": "Discrete Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html",
    "href": "architecture/Delegation_Layer_Architecture.html",
    "title": "Delegation Layer Architecture",
    "section": "",
    "text": "The Delegation Layer (also called the Support Framework) provides specialized internal services to the UI framework through composition rather than inheritance. This layer consists of 11 focused utility classes that handle backend management, code generation, dynamics evaluation, and stochastic analysis.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework components. Users should NOT directly instantiate or interact with these classes. The delegation layer is an internal implementation detail accessed through the high-level system interface:\n# ❌ INCORRECT: Direct delegation layer access\ncode_gen = CodeGenerator(system)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n\n# ✓ CORRECT: Use system interface (delegation happens automatically)\nsystem = Pendulum()\ndx = system(x, u)  # DynamicsEvaluator called internally\nA, B = system.linearize(x_eq, u_eq)  # LinearizationEngine called internally\nThe system classes (e.g., ContinuousSymbolicSystem) automatically compose these utilities and expose their functionality through clean, user-facing APIs. This documentation is provided for framework developers and advanced users who need to understand the internal architecture.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-overview",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-overview",
    "title": "Delegation Layer Architecture",
    "section": "",
    "text": "The Delegation Layer (also called the Support Framework) provides specialized internal services to the UI framework through composition rather than inheritance. This layer consists of 11 focused utility classes that handle backend management, code generation, dynamics evaluation, and stochastic analysis.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework components. Users should NOT directly instantiate or interact with these classes. The delegation layer is an internal implementation detail accessed through the high-level system interface:\n# ❌ INCORRECT: Direct delegation layer access\ncode_gen = CodeGenerator(system)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n\n# ✓ CORRECT: Use system interface (delegation happens automatically)\nsystem = Pendulum()\ndx = system(x, u)  # DynamicsEvaluator called internally\nA, B = system.linearize(x_eq, u_eq)  # LinearizationEngine called internally\nThe system classes (e.g., ContinuousSymbolicSystem) automatically compose these utilities and expose their functionality through clean, user-facing APIs. This documentation is provided for framework developers and advanced users who need to understand the internal architecture.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-architecture-philosophy",
    "title": "Delegation Layer Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\n\nComposition Over Inheritance\nInstead of creating deep inheritance hierarchies, the UI framework composes these specialized utilities as private attributes. This internal composition is transparent to users:\n\n\nCode\n# Internal framework structure (users never access these directly)\nbackend_manager = continuous_pendulum.backend  # BackendManager\ncode_generator = continuous_pendulum._code_gen  # CodeGenerator\ndynamics_evaluator = continuous_pendulum._dynamics  # DynamicsEvaluator\nlinearization_engine = continuous_pendulum._linearization  # LinearizationEngine\nobservation_engine = continuous_pendulum._observation  # ObservationEngine\nequilibrium_handler = continuous_pendulum.equilibria  # EquilibriumHandler\n\n# Stochastic systems add additional handlers\ndiffusion_handler = langevin.diffusion_handler  # DiffusionHandler\n\nprint(\"✓ Framework internally composed - users interact with system methods only\")\n\n\n\n\nDesign Benefits\nThis architecture provides:\n\nSingle Responsibility - Each class does one thing well\nReusability - Utilities can be composed by different system types\nTestability - Each component tested in isolation\nFlexibility - Easy to swap implementations internally\nClarity - Clear separation of concerns\nEncapsulation - Internal complexity hidden from users",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-architecture-layers",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-architecture-layers",
    "title": "Delegation Layer Architecture",
    "section": "Architecture Layers",
    "text": "Architecture Layers\n┌─────────────────────────────────────────────────────────────┐\n│                     UI FRAMEWORK                            │\n│  (SymbolicSystemBase, ContinuousSymbolicSystem, etc.)       │\n│                                                             │\n│  User-facing methods that delegate to utilities:            │\n│  • system(x, u) → delegates to DynamicsEvaluator            │\n│  • system.linearize() → delegates to LinearizationEngine    │\n│  • system.set_default_backend() → delegates to BackendMgr   │\n└────────────────────┬────────────────────────────────────────┘\n                     │ uses (composition)\n                     ↓\n┌─────────────────────────────────────────────────────────────┐\n│                  DELEGATION LAYER (Internal)                │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  CORE UTILITIES (Universal)                           │  │\n│  │  • BackendManager      - Multi-backend support        │  │\n│  │  • CodeGenerator       - Symbolic → numerical         │  │\n│  │  • EquilibriumHandler  - Equilibrium management       │  │\n│  │  • SymbolicValidator   - System validation            │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  DETERMINISTIC EVALUATION (ODE Systems)               │  │\n│  │  • DynamicsEvaluator    - Forward dynamics            │  │\n│  │  • LinearizationEngine  - Jacobian computation        │  │\n│  │  • ObservationEngine    - Output evaluation           │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  STOCHASTIC SUPPORT (SDE Systems)                     │  │\n│  │  • DiffusionHandler    - Diffusion generation         │  │\n│  │  • NoiseCharacterizer  - Noise analysis               │  │\n│  │  • SDEValidator        - SDE validation               │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  LOW-LEVEL UTILITIES                                  │  │\n│  │  • codegen_utils       - SymPy code generation        │  │\n│  └───────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-core-utilities",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-core-utilities",
    "title": "Delegation Layer Architecture",
    "section": "Core Utilities (Universal)",
    "text": "Core Utilities (Universal)\n\nBackendManager: Multi-Backend Array Handling\nFile: backend_manager.py\nThe BackendManager handles all backend-specific array operations and device management. Users interact with this functionality through system-level methods, never directly.\nInternal responsibilities:\n\nBackend detection from array types\nArray conversion between backends (NumPy ↔︎ PyTorch ↔︎ JAX)\nBackend availability checking\nDevice management (CPU, CUDA, TPU)\nDefault backend configuration\nTemporary backend switching (context manager)\n\nUser-facing interface (system-level):\n\n\nCode\n# ✓ User interacts with system methods\nsystem = Pendulum()\n\n# Check current backend\nprint(f\"Default backend: {system.backend.default_backend}\")\n\n# Set backend for system\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\n# Temporary backend switching\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx = system(x_torch, u_torch)\n    print(f\"Result type: {type(dx)}\")\n\nprint(\"✓ Backend management through system interface\")\n\n\nSupported backends:\n\n\n\n\n\n\n\n\nBackend\nExecution\nBest For\n\n\n\n\nNumPy\nCPU\nGeneral purpose, maximum compatibility\n\n\nPyTorch\nCPU/GPU\nNeural networks, GPU acceleration, autograd\n\n\nJAX\nCPU/GPU/TPU\nOptimization, XLA compilation, functional programming\n\n\n\nInternal capabilities (framework use only):\n# Framework code (users never write this)\nbackend = backend_manager.detect(array)\nx_torch = backend_manager.convert(array, target_backend='torch')\nx_cuda = backend_manager.convert(array, target_backend='torch', device='cuda:0')\n\n\nCodeGenerator: Symbolic to Numerical Compilation\nFile: code_generator.py\nThe CodeGenerator orchestrates the symbolic-to-numerical code generation pipeline with intelligent caching. This is completely internal—users simply call system methods that trigger code generation when needed.\nInternal responsibilities:\n\nGenerate dynamics functions: f(x, u) → dx/dt\nGenerate output functions: h(x) → y\nGenerate Jacobian functions: A, B, C\nPer-backend function caching\nCompilation and warmup\nCache invalidation on parameter changes\n\nHow users benefit (transparent):\n\n\nCode\nsystem = Pendulum()\n\n# First call: Code generated and cached automatically\nx = np.array([1.0, 0.0])\nu = np.array([0.0])\ndx1 = system(x, u)  # CodeGenerator works internally\n\n# Subsequent calls: Use cached compiled function (fast)\ndx2 = system(x, u)  # Instant - cached function reused\n\n# When you change parameters, cache automatically invalidates\n# (parameters are accessed via system.parameters dict)\nm_sym = [k for k in system.parameters.keys() if str(k) == 'm'][0]\nl_sym = [k for k in system.parameters.keys() if str(k) == 'l'][0]\nsystem.parameters[m_sym] = 2.0\nsystem.parameters[l_sym] = 1.0\nsystem.reset_caches()  # Explicitly clear cache after parameter change\ndx3 = system(x, u)  # Uses new parameter values\n\nprint(\"✓ Code generation happens transparently\")\n\n\nCaching strategy (internal):\n\nFunctions cached per backend\nSymbolic Jacobians computed once, then compiled per backend\nAutomatic cache invalidation on parameter changes\nLazy generation (only when first needed)\n\nBackend-specific optimizations (internal):\n\nNumPy: Common subexpression elimination (CSE)\nPyTorch: Expression simplification for autograd\nJAX: JIT compilation via jax.jit\n\n\n\nEquilibriumHandler: Named Equilibrium Management\nFile: equilibrium_handler.py\nThe EquilibriumHandler manages multiple named equilibrium points with automatic backend conversion. Users interact through system methods.\nInternal responsibilities:\n\nStore equilibria as NumPy arrays (backend-neutral)\nConvert to any backend on demand\nNamed equilibrium management\nEquilibrium verification\nMetadata storage (stability, description, etc.)\n\nUser-facing interface:\n\n\nCode\nsystem = Pendulum()\n\n# Add equilibrium (system delegates to EquilibriumHandler)\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    verify=True,\n    metadata={'stability': 'unstable', 'description': 'Inverted pendulum'}\n)\n\n# Get equilibrium (backend conversion automatic)\nx_eq, u_eq = system.get_equilibrium('upright')\n\n# List all equilibria\nequilibria = system.list_equilibria()\nprint(f\"Available equilibria: {equilibria}\")\n\n# Get metadata\nmeta = system.get_equilibrium_metadata('upright')\nif meta:\n    print(f\"Stability: {meta.get('stability', 'unknown')}\")\nelse:\n    print(\"No metadata available\")\n\n\nAutomatic features:\n\nOrigin equilibrium always present\nDimension validation on add\nFinite value checking (no NaN/Inf)\nOptional verification with tolerance\nBackend-agnostic storage with on-demand conversion\n\n\n\nSymbolicValidator: System Definition Validation\nFile: symbolic_validator.py\nThe SymbolicValidator performs comprehensive validation of symbolic system definitions during initialization. Users benefit from clear error messages without directly interacting with the validator.\nValidation checks (automatic during system creation):\nRequired validations:\n\n✓ state_vars is list of sp.Symbol\n✓ control_vars is list of sp.Symbol\n✓ _f_sym is sp.Matrix with correct dimensions\n✓ parameters keys are sp.Symbol (not strings)\n✓ order divides nx evenly (nx % order == 0)\n\nOutput function validations (if defined):\n\n✓ _h_sym is sp.Matrix\n✓ _h_sym only depends on state_vars (not control)\n✓ output_vars matches _h_sym dimensions\n\nExample validation (automatic):\n# This validation happens automatically during system creation\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self):\n        x = sp.Symbol('x')\n        \n        # ❌ This will fail validation with clear error message\n        self.parameters = {'m': 1.0}  # String key instead of Symbol\n        \n        # ✓ Correct - validator passes\n        m = sp.Symbol('m')\n        self.parameters = {m: 1.0}  # Symbol key\nError messages are clear and actionable, helping users fix issues quickly.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-deterministic-evaluation",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-deterministic-evaluation",
    "title": "Delegation Layer Architecture",
    "section": "Deterministic Evaluation Components",
    "text": "Deterministic Evaluation Components\n\nDynamicsEvaluator: Forward Dynamics Computation\nFile: dynamics_evaluator.py\nThe DynamicsEvaluator handles forward dynamics evaluation (dx/dt = f(x, u)) across all backends. Users call system(x, u) which internally delegates to this evaluator.\nInternal responsibilities:\n\nEvaluate dx/dt = f(x, u) for controlled systems\nEvaluate dx/dt = f(x) for autonomous systems\nHandle batched vs single evaluation\nBackend-specific dispatch\nInput shape validation\nPerformance tracking\n\nUser-facing interface:\n\n\nCode\nsystem = Pendulum()\n\n# Single evaluation (DynamicsEvaluator called internally)\nx = np.array([1.0, 0.0])\nu = np.array([0.0])\ndx = system(x, u)\nprint(f\"State derivative shape: {dx.shape}\")\n\n# Batched evaluation (automatically detected)\nx_batch = np.random.randn(100, 2)\nu_batch = np.zeros((100, 1))\ndx_batch = system(x_batch, u_batch)\nprint(f\"Batch derivatives shape: {dx_batch.shape}\")\n\n# Works seamlessly with different backends\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx_torch = system(x_torch, u_torch)\n    print(f\"PyTorch result type: {type(dx_torch)}\")\n\n\nAutomatic features:\n\nBackend detection from input arrays\nShape validation and broadcasting\nBatched evaluation detection\nPerformance statistics tracking\n\n\n\nLinearizationEngine: Jacobian Computation\nFile: linearization_engine.py\nThe LinearizationEngine computes system linearizations (Jacobians) at equilibrium points. Users access this through system.linearize().\nMathematical forms:\nContinuous systems:\n\\[\\delta\\dot{x} = A\\delta x + B\\delta u\\]\nwhere:\n\\[A = \\frac{\\partial f}{\\partial x}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_x}\\]\n\\[B = \\frac{\\partial f}{\\partial u}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_u}\\]\nDiscrete systems:\n\\[\\delta x[k+1] = A_d\\delta x[k] + B_d\\delta u[k]\\]\nUser-facing interface:\n\n\nCode\nsystem = Pendulum()\n\n# Get equilibrium point\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Compute linearization (LinearizationEngine called internally)\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix shape: {A.shape}\")\nprint(f\"B matrix shape: {B.shape}\")\n\n# Works with any backend\nwith system.use_backend('torch'):\n    x_eq_torch = torch.tensor([0.0, 0.0])\n    u_eq_torch = torch.tensor([0.0])\n    A_torch, B_torch = system.linearize(x_eq_torch, u_eq_torch)\n    print(f\"PyTorch A type: {type(A_torch)}\")\n\n\nHigher-order system handling:\nFor order=n systems where the state is [q, q̇, ..., q^(n-1)] and only q^(n) is defined:\n\nAutomatically constructs full state-space representation\nComputes Jacobian of complete state derivative\nReturns proper \\((n_x \\times n_x)\\) and \\((n_x \\times n_u)\\) matrices\n\n\n\nObservationEngine: Output Function Evaluation\nFile: observation_engine.py\nThe ObservationEngine handles output function evaluation (y = h(x)) and output Jacobian computation. Users access through system.output() and system.output_jacobian().\nMathematical form:\n\\[y = h(x)\\]\nOutput linearization:\n\\[\\delta y = C\\delta x\\]\nwhere\n\\[C = \\frac{\\partial h}{\\partial x}\\bigg|_{x_{eq}} \\in \\mathbb{R}^{n_y \\times n_x}\\]\nUser-facing interface:\n\n\nCode\n# Create system with output function\nclass ObservableSystem(ContinuousSymbolicSystem):\n    def define_system(self):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -x + u])\n        \n        # Output: only position is measured\n        self._h_sym = sp.Matrix([x])\n        self.output_vars = [sp.Symbol('y')]\n        self.order = 1\n\nsystem = ObservableSystem()\n\n# Evaluate output\nx = np.array([1.5, 0.2])\ny = system.h(x)  # h() method evaluates output\nprint(f\"Output: {y}\")\n\n# Compute output Jacobian\nC = system.linearized_observation(x)\nprint(f\"C matrix shape: {C.shape}\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-stochastic-support",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-stochastic-support",
    "title": "Delegation Layer Architecture",
    "section": "Stochastic Support Components",
    "text": "Stochastic Support Components\n\nDiffusionHandler: SDE Diffusion Management\nFile: diffusion_handler.py\nThe DiffusionHandler generates and caches diffusion functions for stochastic systems. Users interact through system.diffusion() method.\nMathematical form:\n\\[dx = f(x, u)dt + g(x, u)dW\\]\nDiffusion matrix \\(g(x, u) \\in \\mathbb{R}^{n_x \\times n_w}\\)\nwhere:\n\n\\(n_x\\): state dimension\n\\(n_w\\): number of independent Wiener processes\n\nNoise structure types (auto-detected):\n\n\n\n\n\n\n\n\nType\nStructure\nOptimization\n\n\n\n\nAdditive\n\\(g(x, u) = \\text{constant}\\)\nReturn constant matrix (no recomputation)\n\n\nMultiplicative Diagonal\n\\(g\\) is diagonal\nIndependent noise channels\n\n\nMultiplicative Scalar\n\\(n_w = 1\\)\nSingle Wiener process\n\n\nGeneral\nFull matrix coupling\nComplete computation\n\n\n\nUser-facing interface:\n\n\nCode\n# Stochastic system automatically sets up DiffusionHandler\nsystem = LangevinDynamics()\n\n# Evaluate diffusion (DiffusionHandler called internally)\n# LangevinDynamics has nx=2 (position and velocity)\nx = np.array([1.0, 0.5])\nu = np.array([0.0])\ng = system.diffusion(x, u)\nprint(f\"Diffusion matrix shape: {g.shape}\")\n\n# Check noise properties\nprint(f\"Is additive noise: {system.is_additive_noise()}\")\nprint(f\"Noise dimensions: {system.nw}\")\n\n# Get solver recommendations based on noise structure\nsolvers = system.recommend_solvers('torch')\nprint(f\"Recommended solvers: {solvers[:3] if len(solvers) &gt; 3 else solvers}\")\n\n\nAutomatic optimizations (internal):\n\nAdditive noise: Returns constant matrix, no function calls needed\nDiagonal noise: Specialized handling for independent channels\nScalar noise: Simplified operations for single Wiener process\n\n\n\nSDEValidator: SDE-Specific Validation\nFile: sde_validator.py\nThe SDEValidator performs SDE-specific validation during system creation. Validation happens automatically with clear error messages.\nValidation checks (automatic):\n\n✓ diffusion_expr is sp.Matrix\n✓ Dimensions: \\((n_x, n_w)\\) where \\(n_w \\geq 1\\)\n✓ diffusion_expr only uses state_vars and control_vars\n✓ sde_type is ‘ito’ or ‘stratonovich’\n✓ Compatibility between drift and diffusion\n✓ No division by zero in diffusion terms\n\nExample validation (automatic):\nclass MyStochasticSystem(ContinuousStochasticSystem):\n    def define_system(self):\n        x = sp.Symbol('x')\n        sigma = sp.Symbol('sigma', positive=True)\n        \n        # ❌ Wrong dimensions - validator catches this\n        self.diffusion_expr = sp.Matrix([[sigma]])  # nx=2 but only 1 row\n        \n        # ✓ Correct dimensions\n        self.diffusion_expr = sp.Matrix([[sigma], [0]])  # (2, 1) ✓",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-low-level-utilities",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-low-level-utilities",
    "title": "Delegation Layer Architecture",
    "section": "Low-Level Utilities",
    "text": "Low-Level Utilities\n\ncodegen_utils: SymPy Code Generation\nFile: codegen_utils.py\nLow-level utilities for converting SymPy expressions to executable functions. This is completely internal to the framework.\nOptimization strategies (internal):\nNumPy: - Common subexpression elimination (CSE) - Fast numerical modules (‘numpy’, ‘scipy’) - Matrix operation optimization\nPyTorch: - Symbolic simplification before generation - Automatic differentiation compatibility - GPU tensor operation support\nJAX: - JIT compilation via jax.jit - Pure functional style for XLA - Automatic vectorization",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-composition-patterns",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-composition-patterns",
    "title": "Delegation Layer Architecture",
    "section": "Internal Composition Patterns",
    "text": "Internal Composition Patterns\n\n\n\n\n\n\nNoteFramework Implementation Details\n\n\n\nThese patterns show how the framework internally composes delegation layer components. Users never write this code—it’s handled automatically by system classes.\n\n\n\nPattern 1: Core System Utilities\nUsed by all symbolic systems:\n# Internal framework code (in SymbolicSystemBase.__init__)\nself.backend = BackendManager(default_backend, default_device)\nself._code_gen = CodeGenerator(self, self.backend)\nself._validator = SymbolicValidator()\nself.equilibria = EquilibriumHandler(nx, nu)\n\n\nPattern 2: Deterministic Extensions\nAdded by continuous and discrete systems:\n# Internal framework code (in ContinuousSymbolicSystem.__init__)\nsuper().__init__(*args, **kwargs)  # Core utilities\n\n# Add deterministic evaluators\nself._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\nself._linearization = LinearizationEngine(self, self._code_gen, self.backend)\nself._observation = ObservationEngine(self, self._code_gen, self.backend)\n\n\nPattern 3: Stochastic Extensions\nAdded by stochastic systems:\n# Internal framework code (in ContinuousStochasticSystem.__init__)\nsuper().__init__(*args, **kwargs)  # Deterministic utilities\n\n# Add stochastic support\nself.diffusion_handler = DiffusionHandler(self, self._code_gen, self.backend)\nself.noise_characteristics = NoiseCharacterizer().analyze(self.diffusion_expr)\nself._sde_validator = SDEValidator()",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-design-principles",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-design-principles",
    "title": "Delegation Layer Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\nSingle Responsibility Principle\nEach class has one clear, focused purpose:\n\nBackendManager → Backend management only\nCodeGenerator → Code generation only\nDynamicsEvaluator → Dynamics evaluation only\nLinearizationEngine → Linearization only\n\n\n\nComposition Over Inheritance\nSystems compose utilities as private attributes rather than inheriting functionality:\n# ❌ NOT: Deep inheritance\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator):\n    pass\n\n# ✓ YES: Composition\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()\n        self._code_gen = CodeGenerator()\n        self._dynamics = DynamicsEvaluator()\n\n\nDependency Injection\nUtilities receive dependencies explicitly through constructors:\n# Clear dependency chain (internal framework code)\nbackend_mgr = BackendManager()\ncode_gen = CodeGenerator(system, backend_mgr)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n\n\nInterface Segregation\nEach utility exposes a minimal, focused interface:\n\nBackendManager: detect, convert, to_backend\nCodeGenerator: generate_dynamics, generate_jacobians\nDynamicsEvaluator: evaluate\n\n\n\nLazy Initialization\nFunctions generated and cached only when first needed:\n# First call: generates and caches\nf = code_gen.generate_dynamics('numpy')\n\n# Subsequent calls: returns cached\nf_again = code_gen.generate_dynamics('numpy')\nassert f is f_again  # Same function object\n\n\nBackend Agnosticism\nAll utilities work transparently across backends:\n# Same interface, different backends (internal)\ndx_numpy = evaluator.evaluate(x_np, u_np, backend='numpy')\ndx_torch = evaluator.evaluate(x_torch, u_torch, backend='torch')\ndx_jax = evaluator.evaluate(x_jax, u_jax, backend='jax')",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-practical-examples",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-practical-examples",
    "title": "Delegation Layer Architecture",
    "section": "Practical Examples",
    "text": "Practical Examples\n\n\n\n\n\n\nNoteUser-Facing Examples\n\n\n\nThese examples show how users benefit from the delegation layer through the system interface. Users never directly instantiate delegation layer components.\n\n\n\nExample 1: Creating a System (Delegation Automatic)\n\n\nCode\nclass SpringMassDamper(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0, c=0.5):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            v,\n            (-k_sym*x - c_sym*v + u)/m_sym\n        ])\n        self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n        self.order = 1\n\n# Delegation layer automatically composed internally\nsystem = SpringMassDamper()\n\n# User interacts with clean system interface\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\ndx = system(x, u)  # DynamicsEvaluator called internally\n\nA, B = system.linearize(np.zeros(2), np.zeros(1))  # LinearizationEngine\nprint(f\"System created with automatic delegation\")\n\n\n\n\nExample 2: Multi-Backend Usage (Transparent)\n\n\nCode\nsystem = Pendulum()\n\n# NumPy computation\nx_np = np.array([1.0, 0.0])\nu_np = np.array([0.0])\ndx_np = system(x_np, u_np)\n\n# PyTorch computation (backend conversion automatic)\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx_torch = system(x_torch, u_torch)\n    print(f\"PyTorch result: {type(dx_torch)}\")\n\n# JAX computation\nwith system.use_backend('jax'):\n    x_jax = jnp.array([1.0, 0.0])\n    u_jax = jnp.array([0.0])\n    dx_jax = system(x_jax, u_jax)\n    print(f\"JAX result: {type(dx_jax)}\")\n\nprint(\"✓ Backend management completely transparent\")\n\n\n\n\nExample 3: Stochastic System (Full Delegation)\n\n\nCode\nclass BrownianMotion(ContinuousStochasticSystem):\n    def define_system(self, mu=0.0, sigma=1.0):\n        x = sp.Symbol('x', real=True)\n        u = sp.Symbol('u', real=True)\n        mu_sym, sigma_sym = sp.symbols('mu sigma', real=True)\n        \n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([mu_sym + u])\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.parameters = {mu_sym: mu, sigma_sym: sigma}\n        self.sde_type = 'ito'\n        self.order = 1\n\n# Stochastic delegation automatic\nsde_system = BrownianMotion()\n\n# User interacts through clean interface\nx = np.array([0.0])\nu = np.array([0.0])\n\n# Drift and diffusion evaluated automatically\nf = sde_system.drift(x, u)  # DynamicsEvaluator\ng = sde_system.diffusion(x, u)  # DiffusionHandler\n\nprint(f\"Noise type: {sde_system.is_additive_noise()}\")\nprint(f\"Recommended methods: {sde_system.recommend_solvers('numpy')[:3]}\")\n\n\n\n\nExample 4: Equilibrium Management (Delegated)\n\n\nCode\nsystem = Pendulum()\n\n# Add multiple equilibria (delegates to EquilibriumHandler)\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0.0]),\n    u_eq=np.zeros(1),\n    verify=True,\n    metadata={'stability': 'unstable'}\n)\n\nsystem.add_equilibrium(\n    'downright',\n    x_eq=np.array([-np.pi, 0.0]),\n    u_eq=np.zeros(1),\n    metadata={'stability': 'unstable'}\n)\n\n# List and access equilibria\nequilibria = system.list_equilibria()\nprint(f\"Available: {equilibria}\")\n\n# Get equilibrium in any backend\nx_eq_np, u_eq_np = system.get_equilibrium('upright')\n\nwith system.use_backend('torch'):\n    x_eq_torch, u_eq_torch = system.get_equilibrium('upright')\n    print(f\"Backend conversion automatic: {type(x_eq_torch)}\")\n\n\n\n\nExample 5: Linearization Workflow (Seamless)\n\n\nCode\nsystem = SpringMassDamper()\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Linearize (LinearizationEngine called internally)\nA, B = system.linearize(x_eq, u_eq)\n\n# Analyze stability\neigenvalues = np.linalg.eigvals(A)\nprint(f\"Eigenvalues: {eigenvalues}\")\nprint(f\"Stable: {np.all(eigenvalues.real &lt; 0)}\")\n\n# Linearization works with any backend\nwith system.use_backend('torch'):\n    A_torch, B_torch = system.linearize(\n        torch.zeros(2),\n        torch.zeros(1)\n    )\n    print(f\"PyTorch linearization: {type(A_torch)}\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-key-strengths",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-key-strengths",
    "title": "Delegation Layer Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\nClean Separation - Each utility has one clear responsibility\nEncapsulation - Internal complexity hidden from users\nReusability - Components can be composed by different system types\nTestability - Easy to test each component in isolation\nFlexibility - Internal implementation can change without affecting users\nPerformance - Intelligent caching and lazy initialization\nMulti-Backend - Seamless backend switching without user intervention\nType Safety - TypedDict and semantic types throughout\nDocumentation - Clear purpose and interface for each component\nMaintainability - Easy to understand, modify, and extend\nUser-Friendly - Complex functionality exposed through simple interfaces",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#summary",
    "href": "architecture/Delegation_Layer_Architecture.html#summary",
    "title": "Delegation Layer Architecture",
    "section": "Summary",
    "text": "Summary\nThe delegation layer provides robust internal services that power the ControlDESymulation framework. Through careful composition and encapsulation, these utilities enable powerful functionality while maintaining a clean, user-friendly system interface.\nUsers benefit from this architecture without needing to understand its internal workings—they simply interact with intuitive system methods that delegate to the appropriate internal components automatically.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html",
    "href": "architecture/Visualization_Framework_Architecture.html",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "The Visualization Framework provides interactive, publication-ready plotting for dynamical systems analysis. It consists of 4 core modules organized into a 2-layer architecture: centralized theming + specialized plotters.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\n\nTheming Layer: Centralized colors, styles, and themes\nPlotter Layer: Specialized visualization classes\n\nTrajectoryPlotter - Time-domain plots\nPhasePortraitPlotter - State-space plots\nControlPlotter - Control analysis plots\n\n\n\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nUsers should NOT directly instantiate plotter classes. Instead, access plotters through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)  # TrajectoryPlotter\nfig = system.phase_plotter.plot_2d(x)       # PhasePortraitPlotter\nfig = system.control_plotter.plot_eigenvalue_map(eigs)  # ControlPlotter\n\n# ❌ INCORRECT: Direct instantiation (not recommended)\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nplotter = TrajectoryPlotter()  # Don't do this!\nfig = plotter.plot_trajectory(t, x)\nThe system properties automatically configure plotters with the correct backend and provide a consistent interface. Direct instantiation is only needed for framework development or advanced customization.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-overview",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-overview",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "The Visualization Framework provides interactive, publication-ready plotting for dynamical systems analysis. It consists of 4 core modules organized into a 2-layer architecture: centralized theming + specialized plotters.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\n\nTheming Layer: Centralized colors, styles, and themes\nPlotter Layer: Specialized visualization classes\n\nTrajectoryPlotter - Time-domain plots\nPhasePortraitPlotter - State-space plots\nControlPlotter - Control analysis plots\n\n\n\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nUsers should NOT directly instantiate plotter classes. Instead, access plotters through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)  # TrajectoryPlotter\nfig = system.phase_plotter.plot_2d(x)       # PhasePortraitPlotter\nfig = system.control_plotter.plot_eigenvalue_map(eigs)  # ControlPlotter\n\n# ❌ INCORRECT: Direct instantiation (not recommended)\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nplotter = TrajectoryPlotter()  # Don't do this!\nfig = plotter.plot_trajectory(t, x)\nThe system properties automatically configure plotters with the correct backend and provide a consistent interface. Direct instantiation is only needed for framework development or advanced customization.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-architecture-philosophy",
    "title": "Visualization Framework Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nThemeable Interactive Visualization - The visualization framework enables:\n\nInteractive Plots - Plotly-based with zoom, pan, hover tooltips\nCentralized Theming - Consistent colors and styles across all plots\nBackend Agnostic - Works with NumPy, PyTorch, JAX seamlessly\nSpecialized Plotters - Dedicated classes for different visualization types\nPublication Ready - High-quality output for papers and presentations\nSystem Integration - Clean system.plotter and system.control_plotter APIs\nAccessible Design - Colorblind-safe palettes available",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-framework-layers",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-framework-layers",
    "title": "Visualization Framework Architecture",
    "section": "Framework Layers",
    "text": "Framework Layers\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│         (ContinuousSystemBase, DiscreteSystemBase)         │\n│                                                            │\n│  system.plotter          ──────► TrajectoryPlotter         │\n│  system.phase_plotter    ──────► PhasePortraitPlotter      │\n│  system.control_plotter  ──────► ControlPlotter            │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ use theming from\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   THEMING LAYER                            │\n│                   themes.py                                │\n│                                                            │\n│  ColorSchemes:            PlotThemes:                      │\n│  • PLOTLY                • DEFAULT                         │\n│  • D3                    • PUBLICATION                     │\n│  • COLORBLIND_SAFE       • DARK                            │\n│  • TABLEAU                                                 │\n│  • SEQUENTIAL_BLUE                                         │\n│  • DIVERGING_RED_BLUE                                      │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ used by\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   PLOTTER LAYER                            │\n│                                                            │\n│  TrajectoryPlotter, PhasePortraitPlotter, ControlPlotter   │\n└────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-theming-layer",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-theming-layer",
    "title": "Visualization Framework Architecture",
    "section": "Theming Layer",
    "text": "Theming Layer\n\nColor Schemes\nThe framework provides several built-in color schemes optimized for different purposes:\n\n\nCode\n# Demonstrate different color schemes\nschemes = {\n    'Plotly (Default)': ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A'],\n    'Colorblind Safe': ['#0173B2', '#DE8F05', '#029E73', '#CC78BC', '#CA9161'],\n    'Tableau': ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F'],\n}\n\nfig = make_subplots(\n    rows=len(schemes), cols=1,\n    subplot_titles=list(schemes.keys()),\n    vertical_spacing=0.20\n)\n\nfor i, (name, colors) in enumerate(schemes.items(), 1):\n    for j, color in enumerate(colors):\n        fig.add_trace(\n            go.Bar(x=[j], y=[1], marker_color=color, showlegend=False),\n            row=i, col=1\n        )\n    fig.update_xaxes(showticklabels=False, row=i, col=1)  # Hide x ticks\n    fig.update_yaxes(showticklabels=False, row=i, col=1)\n\n# Add single x-axis label at bottom\nfig.add_annotation(\n    text=\"Color Index\",\n    xref=\"paper\", yref=\"paper\",\n    x=0.5, y=-0.05,\n    showarrow=False,\n    font=dict(size=12)\n)\n\nfig.update_layout(\n    height=450,\n    title_text=\"Color Scheme Comparison\",\n    showlegend=False,\n    margin=dict(b=60)\n)\nfig\n\n\n                            \n                                            \nBuilt-in color schemes with accessibility options\n\n\n\n\nPlot Themes\nThree built-in themes provide different visual styles:\n\n\n\n\n\n\n\n\nTheme\nUse Case\nFeatures\n\n\n\n\ndefault\nInteractive exploration\nPlotly default, colorful\n\n\npublication\nPapers, presentations\nClean, high-contrast, serif fonts\n\n\ndark\nPresentations, demos\nDark background, reduced eye strain",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-trajectory-plotter",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-trajectory-plotter",
    "title": "Visualization Framework Architecture",
    "section": "TrajectoryPlotter: Time-Domain Visualization",
    "text": "TrajectoryPlotter: Time-Domain Visualization\n\n\n\n\n\n\nTipIntegration Methods for Visualization\n\n\n\nFor visualization purposes, use simulate() instead of integrate():\n\nsimulate() returns regular time grids (uniform spacing) - ideal for plotting\nintegrate() returns adaptive time points (variable spacing) - can create uneven plots\n\n# ✓ RECOMMENDED for plotting: Regular time grid\nresult = system.simulate(x0, controller, t_span=(0, 10), dt=0.01)\nfig = system.plotter.plot_trajectory(result['time'], result['states'])\n\n# ⚠️ Works but may have uneven time spacing: Adaptive grid\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='RK45')\n# Or use t_eval for regular grid:\nresult = system.integrate(x0, u=None, t_span=(0, 10), t_eval=np.linspace(0, 10, 1001))\nfig = system.plotter.plot_trajectory(result['t'], result['x'])\nWhy this matters: - Adaptive methods choose time points based on error control (dense where dynamics change, sparse where smooth) - This can create visually uneven plots with more points in some regions - Regular grids ensure uniform visual appearance - For comparison plots, all trajectories must have same time grid\n\n\n\nBasic Trajectory Plot\nThe most common visualization: state variables vs time.\n\n\nCode\n# Simulate pendulum with regular time grid (recommended for plotting)\nx0 = np.array([0.5, 0.0])\nresult = system.simulate(x0, controller=None, t_span=(0, 10), dt=0.01)\n\n# Plot using system's built-in plotter\nfig = system.plotter.plot_trajectory(\n    result['time'],\n    result['states'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title='Pendulum Dynamics'\n)\nfig\n\n\n                            \n                                            \nSimple pendulum trajectory showing angle and angular velocity over time\n\n\n\n\n\n\n\n\nNoteWhy simulate() for Plotting\n\n\n\nThis example uses simulate() rather than integrate() because:\n\nRegular time grid (uniform dt=0.01) makes for smooth, evenly-spaced plots\nTime-major output result['states'] is (T, nx) - natural for plotting\nReconstructed controls available if controller provided\n\nFor comparison, integrate() returns adaptive time points that may create visually uneven plots.\n\n\n\n\nBatched Trajectories (Monte Carlo)\nAutomatically handles multiple trajectories. This example uses the stochastic pendulum to show genuine stochastic dynamics:\n\n\nCode\n# Use torch backend (now fixed!)\nstochastic_system.set_default_backend('torch')\n\n# Run Monte Carlo simulation\nn_trials = 20\nx0 = np.array([0.5, 0.0])\n\n# Define output times\nt_eval = np.linspace(0, 10, 1001)\n\n# Collect trajectories\nresults = []\nfor i in range(n_trials):\n    result = stochastic_system.integrate(\n        x0, \n        u=None, \n        t_span=(0, 10),\n        method='euler',\n        dt=0.01,\n        t_eval=t_eval,\n        seed=i\n    )\n    # Convert torch tensor to numpy\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    results.append(x_np)\n\n# Stack: (n_trials, T, nx)\nx_batch = np.stack(results)\nt_np = result['t'].cpu().numpy() if hasattr(result['t'], 'cpu') else result['t']\n\nprint(f\"Batch shape: {x_batch.shape} (n_trials={n_trials}, T={len(t_np)}, nx=2)\")\n\n# Plot individual trajectories\nfig = stochastic_system.plotter.plot_trajectory(\n    t_np,\n    x_batch,\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title=f'Stochastic Pendulum Monte Carlo (n={n_trials}, σ=0.3)',\n    color_scheme='colorblind_safe'\n)\nfig\n\n\nBatch shape: (20, 1001, 2) (n_trials=20, T=1001, nx=2)\n\n\n                            \n                                            \nMonte Carlo simulation of stochastic pendulum showing 20 independent noise realizations\n\n\n\n\n\n\n\n\nNoteStochastic Monte Carlo Visualization\n\n\n\nThis demonstrates true stochastic dynamics from Wiener process noise, described by the SDE:\n\\[dx = f(x, u)dt + g(x, u)dW\\]\nWhat you see:\n\nIndividual trajectories: Each colored line shows one noise realization\nStochastic spread: Trajectories diverge over time from accumulated Brownian forcing\nNonlinear effects: Pendulum damping limits growth but uncertainty remains\n\nKey distinction: The trajectory variability comes from random Brownian forcing \\(dW(t)\\), not just different initial conditions. Starting from identical states (θ=0.5, ω=0), the 20 trajectories spread due to different noise realizations, visualizing inherent stochastic uncertainty.\nFor comparison, deterministic Monte Carlo shows variability only from initial condition uncertainty, not from dynamic randomness.\n\n\n\n\n\n\n\n\nTipSDE Integration\n\n\n\nIf you still want to use integrate directly despite the recommendation for simulate, specify output times with t_eval:\n# Define output times\nt_eval = np.linspace(0, 10, 1001)  # 1001 uniformly spaced points\n\nresult = system.integrate(\n    x0,\n    u=None,\n    t_span=(0, 10),\n    method='euler',       # PyTorch torchsde method\n    dt=0.01,              # Integration time step\n    t_eval=t_eval,        # Output time points\n    seed=42\n)\nIntegration Parameters:\n\ndt=0.01: Internal time step (controls accuracy)\nt_eval: Which points to return in output (controls density)\n\n\n\n\n\n\n\n\n\nTipBackend Conversion for Plotting\n\n\n\nThe plotter requires NumPy arrays, but integration returns arrays of default backend type:\n# Convert torch tensor to numpy\nx_np = result['x'].cpu().numpy()  # Move to CPU, then numpy\nt_np = result['t'].cpu().numpy()  # Same for time\nWhy this is needed:\n\nPyTorch solvers work with torch tensors (for autodiff/GPU)\nJAX solvers work with jax.numpy.array arrays (for TPU/JIT performance)\nPlotly requires NumPy arrays for visualization\n\n\n\n\n\nState and Control Together\nVisualize both states and control inputs:\n\n\nCode\n# Simple proportional controller\ndef controller(x, t):\n    K = np.array([[-0.5, -0.15]])\n    return -K @ x\n\n# Simulate with controller\nfrom cdesym.systems.base.core.continuous_system_base import ContinuousSystemBase\nresult = system.simulate(x0, controller=controller, t_span=(0, 10), dt=0.01)\n\n# Plot states and controls\nfig = system.plotter.plot_state_and_control(\n    result['time'],\n    result['states'],\n    result['controls'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    control_names=['Torque (N⋅m)']\n)\nfig\n\n\n                            \n                                            \nCombined state and control visualization\n\n\n\n\nComparing Multiple Designs\nCompare different control strategies:\n\n\nCode\n# Simulate with different controllers\n# Note: All must use same time grid for comparison\ncontrollers = {\n    'P (K=1)': lambda x, t: np.array([-1.0 * x[0] - 0.5 * x[1]]),\n    'P (K=5)': lambda x, t: np.array([-5.0 * x[0] - 2.0 * x[1]]),\n    'No Control': None\n}\n\n# Use common dt for all simulations\ndt = 0.01\ntrajectories = {}\nt_common = np.arange(0, 10 + dt, dt)\n\nfor name, ctrl in controllers.items():\n    # Use simulate() to ensure regular time grid\n    result = system.simulate(x0, controller=ctrl, t_span=(0, 10), dt=dt)\n    trajectories[name] = result['states']\n\n# Compare trajectories (all have same time grid)\nfig = system.plotter.plot_comparison(\n    t_common,\n    trajectories,\n    state_names=['θ (rad)', 'ω (rad/s)']\n)\nfig\n\n\n                            \n                                            \nComparison of different control strategies\n\n\n\n\n\n\n\n\nImportantRegular Time Grids Required for Comparison\n\n\n\nWhen comparing multiple trajectories, all must use the same time grid. Use simulate() with the same dt for all runs, or use integrate() with the same t_eval array.\n# ✓ CORRECT: Same time grid\nfor name, ctrl in controllers.items():\n    result = system.simulate(x0, controller=ctrl, t_span=(0, 10), dt=0.01)\n    \n# ❌ WRONG: Different adaptive grids\nfor name, ctrl in controllers.items():\n    result = system.integrate(x0, u=ctrl, t_span=(0, 10))\n    # Different number of time points! Cannot compare directly.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-phase-portrait",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-phase-portrait",
    "title": "Visualization Framework Architecture",
    "section": "PhasePortraitPlotter: State-Space Visualization",
    "text": "PhasePortraitPlotter: State-Space Visualization\n\n2D Phase Portrait\nVisualize dynamics in state space:\n\n\nCode\n# Simulate from multiple initial conditions (use simulate for regular grids)\ninitial_conditions = [\n    np.array([0.3, 0.0]),\n    np.array([1.0, 0.0]),\n    np.array([1.5, 0.5]),\n]\n\ntrajectories = []\nfor x0_i in initial_conditions:\n    result = system.simulate(x0_i, controller=None, t_span=(0, 15), dt=0.01)\n    trajectories.append(result['states'])\n\nx_all = np.stack(trajectories)  # (n_traj, T, nx)\n\n# Plot phase portrait\nfig = system.phase_plotter.plot_2d(\n    x_all,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    equilibria=[np.array([0, 0])],\n    show_direction=True\n)\nfig\n\n\n                            \n                                            \n2D phase portrait showing state-space trajectory\n\n\n\n\nWith Vector Field\nAdd vector field to show dynamics everywhere:\n\n\nCode\n# Define vector field function\ndef pendulum_field(theta, omega):\n    \"\"\"Compute derivatives at any point in phase space.\"\"\"\n    x = np.array([theta, omega])\n    dx = system(x, u=np.zeros(1))\n    return dx[0], dx[1]\n\n# Plot with vector field\nfig = system.phase_plotter.plot_2d(\n    x_all,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    vector_field=pendulum_field,\n    equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n    show_direction=True\n)\nfig\n\n\n                            \n                                            \nPhase portrait with vector field overlay",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter",
    "title": "Visualization Framework Architecture",
    "section": "ControlPlotter: Control Analysis",
    "text": "ControlPlotter: Control Analysis\n\nEigenvalue Map\nVisualize closed-loop stability with comparison:\n\n\nCode\n# Get linearization at origin\nx_eq, u_eq = system.get_equilibrium('origin')\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\nlqr_result = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Plot eigenvalues using dictionary format (recommended for comparison)\neigenvalues_ol = np.linalg.eigvals(A)\neigenvalues_cl = lqr_result['controller_eigenvalues']\n\neigenvalue_sets = {\n    'Open-loop': eigenvalues_ol,\n    'Closed-loop (LQR)': eigenvalues_cl,\n}\n\nfig = system.control_plotter.plot_eigenvalue_map(\n    eigenvalue_sets,\n    system_type='continuous',\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\nfig\n\n\n                            \n                                            \nEigenvalue map comparing open-loop and closed-loop poles\n\n\n\n\n\n\n\n\nTipComparing Eigenvalue Sets\n\n\n\nThe plot_eigenvalue_map() method supports multiple input formats:\nDictionary format (recommended for comparison):\neigenvalue_sets = {\n    'Open-loop': eigs_ol,\n    'Closed-loop (LQR)': eigs_cl,\n}\nfig = system.control_plotter.plot_eigenvalue_map(eigenvalue_sets)\nConcatenated with per-eigenvalue labels:\neigs_all = np.concatenate([eigs_ol, eigs_cl])\nlabels = ['Open-loop'] * len(eigs_ol) + ['Closed-loop'] * len(eigs_cl)\nfig = system.control_plotter.plot_eigenvalue_map(eigs_all, labels=labels)\nSingle set:\nfig = system.control_plotter.plot_eigenvalue_map(eigs_cl, labels='LQR')\nEach set gets a unique color and marker symbol for easy distinction!",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-stochastic-viz",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-stochastic-viz",
    "title": "Visualization Framework Architecture",
    "section": "Stochastic System Visualization",
    "text": "Stochastic System Visualization\n\nComparing Noise Levels\nVisualize impact of different noise intensities:\n\n\nCode\n# Create systems with different noise levels\nnoise_levels = [0.1, 0.3, 0.5]\ntrajectories_noise = {}\n\n# Use common time grid for comparison\ndt = 0.01\nt_common = np.arange(0, 15 + dt, dt)\n\nfor sigma in noise_levels:\n    sys_i = ContinuousStochasticPendulum(g=9.81, L=1.0, b=0.5, sigma=sigma)\n    sys_i.set_default_backend('torch')\n    x0 = np.array([0.3, 0.0])\n    \n    result = sys_i.integrate(\n        x0, u=None, t_span=(0, 15), \n        method='euler', dt=dt, seed=42\n    )\n    \n    # Convert to numpy for plotting\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    trajectories_noise[f'σ={sigma}'] = x_np\n\n# Compare trajectories (pass t and trajectories separately)\nfig = stochastic_system.plotter.plot_comparison(\n    t_common,\n    trajectories_noise,\n    state_names=['θ (rad)', 'ω (rad/s)']\n)\nfig.update_layout(title='Effect of Noise Intensity on Stochastic Pendulum')\nfig\n\n\n                            \n                                            \nEffect of noise intensity on pendulum dynamics\n\n\n\n\n\n\n\n\nTipNoise Impact\n\n\n\nNotice how increasing noise intensity (\\(\\sigma\\)):\n\nCreates larger amplitude fluctuations\nCan induce transitions over energy barriers\nAffects regularity of oscillations\nChanges effective damping behavior\n\nAt moderate noise levels, the system exhibits stochastic resonance - an optimal noise level that actually enhances response to periodic forcing.\n\n\n\n\nStochastic Phase Portrait\nPhase portraits reveal noise-induced behavior:\n\n\nCode\n# Switch to torch for SDE integration\nstochastic_system.set_default_backend('torch')\n\n# Multiple stochastic trajectories from same initial condition\nn_trajectories = 3\nstochastic_trajectories = []\n\nfor i in range(n_trajectories):\n    result = stochastic_system.integrate(\n        np.array([np.pi/2, 0.0]),\n        u=None,\n        t_span=(0, 20),\n        method='euler',\n        dt=0.01,\n        seed=i\n    )\n    # Convert to numpy\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    stochastic_trajectories.append(x_np)\n\nx_stochastic = np.stack(stochastic_trajectories)\n\n# Reset backend\nstochastic_system.set_default_backend('numpy')\n\n# Plot stochastic phase portrait\nfig = stochastic_system.phase_plotter.plot_2d(\n    x_stochastic,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    equilibria=[np.array([0, 0])],\n    show_direction=True\n)\nfig.update_layout(title='Stochastic Pendulum Phase Portrait (Same IC, Different Noise)')\nfig\n\n\n                            \n                                            \nPhase portrait of stochastic pendulum showing noise-induced wandering\n\n\n\n\n\n\n\n\nNoteStochastic vs Deterministic Phase Portraits\n\n\n\nUnlike deterministic systems where each initial condition produces one unique trajectory, stochastic systems produce a cloud of possible trajectories from the same initial condition. This visualization shows:\n\nTrajectory spreading due to random forcing\nNoise-induced wandering in phase space\nProbabilistic barrier crossing (not deterministic separatrix)\nEffective diffusion in state space\n\nThe phase portrait becomes a probability distribution rather than a single curve!",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter-continued",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter-continued",
    "title": "Visualization Framework Architecture",
    "section": "ControlPlotter: Control Analysis",
    "text": "ControlPlotter: Control Analysis\n\nGain Comparison\nCompare feedback gains for different designs:\n\n\nCode\n# Design LQR with different Q weights\nQ_values = [1, 10, 100]\ngains = {}\nfor q in Q_values:\n    Q_i = q * np.diag([10, 1])\n    result = system.control.design_lqr(A, B, Q_i, R, system_type='continuous')\n    gains[f'Q={q}'] = result['gain']\n\n# Plot gain comparison\nfig = system.control_plotter.plot_gain_comparison(\n    gains,\n    labels=['θ', 'ω']\n)\nfig\n\n\n                            \n                                            \nHeatmap comparing LQR gains for different Q weights\n\n\n\n\nStep Response\nAnalyze closed-loop performance:\n\n\nCode\n# Create closed-loop system\nfrom scipy import signal\n\n# Output: measure angle only\nC = np.array([[1, 0]])\nD = np.zeros((1, 1))\n\n# Closed-loop dynamics\nprint(f\"A matrix:\\n{A}\")\nprint(f\"B matrix:\\n{B}\")\nprint(f\"LQR Gain:\\n{lqr_result['gain']}\")\nA_cl = A - B @ lqr_result['gain']\nsys_cl = signal.StateSpace(A_cl, B, C, D)\n\n# Step response\nt_step = np.linspace(0, 5, 500)\nt_out, y_out = signal.step(sys_cl, T=t_step)\n\n# Plot with metrics\nfig = system.control_plotter.plot_step_response(\n    t_out,\n    y_out.squeeze(),\n    reference=1.0,\n    show_metrics=True\n)\nfig\n\n\nA matrix:\n[[ 0.    1.  ]\n [ 9.81 -1.  ]]\nB matrix:\n[[0.]\n [1.]]\nLQR Gain:\n[[23.81842961  6.65747081]]\n\n\n                            \n                                            \nStep response showing rise time, overshoot, and settling time",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-publication-ready",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-publication-ready",
    "title": "Visualization Framework Architecture",
    "section": "Publication-Ready Output",
    "text": "Publication-Ready Output\n\nPublication Theme\nSwitch to publication theme for papers:\n\n\nCode\n# Get a fresh result for this example\nx0_pub = np.array([0.5, 0.0])\nresult_pub = system.simulate(x0_pub, controller=None, t_span=(0, 10), dt=0.01)\n\n# Same trajectory, publication theme\nfig = system.plotter.plot_trajectory(\n    result_pub['time'],\n    result_pub['states'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title='Pendulum Dynamics',\n    theme='publication',\n    color_scheme='colorblind_safe'\n)\nfig\n\n\n                            \n                                            \nSame plot with publication theme (serif fonts, clean styling)\n\n\n\n\nExporting Figures\nPlotly figures can be exported in multiple formats:\n# Export as HTML (interactive)\nfig.write_html('pendulum_trajectory.html')\n\n# Export as static image (requires kaleido)\nfig.write_image('pendulum_trajectory.pdf', width=800, height=600)\nfig.write_image('pendulum_trajectory.png', width=800, height=600, scale=2)\n\n# Export as SVG (vector graphics)\nfig.write_image('pendulum_trajectory.svg')",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-design-patterns",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-design-patterns",
    "title": "Visualization Framework Architecture",
    "section": "Design Patterns",
    "text": "Design Patterns\n\nPattern 1: Centralized Theming\nAll plotters use centralized themes:\n# ❌ BAD: Hardcoded colors\nclass BadPlotter:\n    def plot(self):\n        fig.add_trace(go.Scatter(line=dict(color='#1f77b4')))\n\n# ✓ GOOD: Centralized theming\nclass GoodPlotter:\n    def plot(self, color_scheme='plotly', theme='default'):\n        colors = ColorSchemes.get_colors(color_scheme)\n        fig.add_trace(go.Scatter(line=dict(color=colors[0])))\n        fig = PlotThemes.apply_theme(fig, theme)\n\n\nPattern 2: Backend Agnostic\nAutomatically converts PyTorch/JAX to NumPy:\ndef plot_trajectory(self, t, x):\n    # Convert to NumPy for Plotly\n    t_np = self._to_numpy(t)\n    x_np = self._to_numpy(x)\n    \n    # Plot with Plotly (requires NumPy)\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=t_np, y=x_np[:, 0]))\n    return fig\n\ndef _to_numpy(self, arr):\n    if hasattr(arr, 'cpu'):  # PyTorch\n        return arr.cpu().numpy()\n    elif hasattr(arr, '__array__'):  # JAX\n        return np.array(arr)\n    return arr\n\n\nPattern 3: Adaptive Layouts\nOptimal subplot arrangements:\ndef _determine_subplot_layout(self, n_plots: int) -&gt; Tuple[int, int]:\n    \"\"\"\n    Determine optimal subplot grid.\n    \n    1-2 plots: (n, 1) vertical\n    3-4 plots: (2, 2) square\n    5-6 plots: (2, 3)\n    7-9 plots: (3, 3)\n    \"\"\"\n    if n_plots &lt;= 2:\n        return n_plots, 1\n    elif n_plots &lt;= 4:\n        return 2, 2\n    else:\n        cols = int(np.ceil(np.sqrt(n_plots)))\n        rows = int(np.ceil(n_plots / cols))\n        return rows, cols\n\n\nPattern 4: Batch Detection\nAutomatically detect and process batched data:\ndef _process_batch(self, x: np.ndarray):\n    if x.ndim == 3:  # (n_batch, T, nx)\n        return np.mean(x, axis=0), np.std(x, axis=0), True\n    elif x.ndim == 2:  # (T, nx)\n        return x, None, False\n    else:\n        raise ValueError(f\"Invalid shape: {x.shape}\")",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-integration",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-integration",
    "title": "Visualization Framework Architecture",
    "section": "Integration with Systems",
    "text": "Integration with Systems\n\nProperty-Based Access (Recommended)\nAll systems provide plotter properties for convenient access:\n# ✓ Access via system properties (recommended)\nsystem.plotter           # TrajectoryPlotter instance\nsystem.phase_plotter     # PhasePortraitPlotter instance\nsystem.control_plotter   # ControlPlotter instance\n\n# Convenience method\nsystem.plot(result)      # Quick trajectory plot\n\n\n\n\n\n\nWarningDo Not Instantiate Plotters Directly\n\n\n\nPlotters are internal framework components that should be accessed through system properties, not instantiated directly:\n# ❌ WRONG: Direct instantiation\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nfrom cdesym.visualization.phase_portrait import PhasePortraitPlotter\nfrom cdesym.visualization.control_plots import ControlPlotter\n\nplotter = TrajectoryPlotter(backend='numpy')  # Don't do this!\nphase = PhasePortraitPlotter(backend='numpy')  # Don't do this!\ncontrol = ControlPlotter(backend='numpy')      # Don't do this!\n\n# ✓ CORRECT: Access via system\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)\nfig = system.phase_plotter.plot_2d(x)\nfig = system.control_plotter.plot_eigenvalue_map(eigs)\nThe system automatically creates and configures plotters with the correct backend. Direct instantiation is only needed for: - Framework development - Testing plotter components in isolation - Advanced customization outside the system context\n\n\n\n\nTypical Workflow\n# 1. Create system\nsystem = Pendulum()\n\n# 2. Simulate\nresult = system.simulate(x0, controller, t_span=(0, 10))\n\n# 3. Visualize (plotters accessed through system)\nfig = system.plotter.plot_trajectory(\n    result['time'],\n    result['states'],\n    theme='publication'\n)\nfig",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-plot-types",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-plot-types",
    "title": "Visualization Framework Architecture",
    "section": "Available Plot Types",
    "text": "Available Plot Types\n\nSummary Table\n\n\n\nPlotter\nMethod\nPurpose\n\n\n\n\nTrajectoryPlotter\n\n\n\n\n\nplot_trajectory()\nStates vs time\n\n\n\nplot_state_and_control()\nStates + controls\n\n\n\nplot_comparison()\nCompare multiple runs\n\n\nPhasePortraitPlotter\n\n\n\n\n\nplot_2d()\n2D phase portrait\n\n\n\nplot_3d()\n3D phase portrait\n\n\n\nplot_limit_cycle()\nPeriodic orbits\n\n\nControlPlotter\n\n\n\n\n\nplot_eigenvalue_map()\nStability analysis\n\n\n\nplot_gain_comparison()\nCompare gains\n\n\n\nplot_step_response()\nStep response metrics\n\n\n\nplot_impulse_response()\nImpulse response\n\n\n\nplot_frequency_response()\nBode plots\n\n\n\nplot_nyquist()\nNyquist diagram\n\n\n\nplot_root_locus()\nRoot locus\n\n\n\nplot_controllability_gramian()\nGramian heatmap\n\n\n\nplot_observability_gramian()\nGramian heatmap\n\n\n\nplot_riccati_convergence()\nSolver convergence",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-key-strengths",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-key-strengths",
    "title": "Visualization Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipFramework Advantages\n\n\n\n\nCentralized Theming - Single source of truth for colors/styles\nBackend Agnostic - NumPy/PyTorch/JAX transparent\nInteractive - Plotly-based with zoom, pan, hover\nPublication Ready - Professional defaults and themes\nAccessible - Colorblind-safe palettes\nSpecialized Plotters - Right tool for each visualization type\nSystem Integration - Clean system.plotter APIs\nAdaptive Layouts - Optimal subplot arrangements\nBatch Support - Monte Carlo visualization automatic\nComprehensive - 16+ plot types covering all needs",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#summary",
    "href": "architecture/Visualization_Framework_Architecture.html#summary",
    "title": "Visualization Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe visualization framework provides publication-quality interactive plotting seamlessly integrated with ControlDESymulation’s dynamical systems. All plots are:\n\n✅ Interactive with Plotly\n✅ Themeable for different contexts\n✅ Backend-agnostic\n✅ Automatically adaptive\n✅ Publication-ready\n\n\n\n\n\n\n\nImportantUsage Reminder\n\n\n\nAccess visualization through system properties:\nsystem.plotter           # Time-domain plots\nsystem.phase_plotter     # Phase space plots\nsystem.control_plotter   # Control analysis plots\nDo not directly instantiate TrajectoryPlotter, PhasePortraitPlotter, or ControlPlotter classes—the system handles this automatically with proper configuration.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html",
    "href": "architecture/Type_System_Architecture.html",
    "title": "Type System Architecture",
    "section": "",
    "text": "The Type System is the foundational layer (Layer 0) that provides semantic types, structured results, and type-safe interfaces for the entire framework. It consists of 8 focused modules defining over 200 type aliases and structured dictionaries.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework types. Users should NOT directly reference or manipulate these types except through system methods. The type system is an internal implementation detail that provides:\n\nType safety through static checking\nIDE autocomplete support\nClear documentation of expected types\nBackend-agnostic interfaces\n\n# ✓ CORRECT: Types work transparently through system methods\nsystem = Pendulum()\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n# result is IntegrationResult (TypedDict) - IDE knows fields available\n\nA, B = system.linearize(x_eq, u_eq)\n# A is StateMatrix, B is InputMatrix - types guide usage\n\n# ✗ INCORRECT: No need to import or reference types directly\nfrom cdesym.types.core import StateVector, ControlVector\nx: StateVector = np.array([1.0, 0.0])  # Unnecessary annotation\nThe type system enables type checking and IDE support while remaining invisible during normal use. This documentation is provided for framework developers and advanced users implementing custom components.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-overview",
    "href": "architecture/Type_System_Architecture.html#sec-overview",
    "title": "Type System Architecture",
    "section": "",
    "text": "The Type System is the foundational layer (Layer 0) that provides semantic types, structured results, and type-safe interfaces for the entire framework. It consists of 8 focused modules defining over 200 type aliases and structured dictionaries.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework types. Users should NOT directly reference or manipulate these types except through system methods. The type system is an internal implementation detail that provides:\n\nType safety through static checking\nIDE autocomplete support\nClear documentation of expected types\nBackend-agnostic interfaces\n\n# ✓ CORRECT: Types work transparently through system methods\nsystem = Pendulum()\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n# result is IntegrationResult (TypedDict) - IDE knows fields available\n\nA, B = system.linearize(x_eq, u_eq)\n# A is StateMatrix, B is InputMatrix - types guide usage\n\n# ✗ INCORRECT: No need to import or reference types directly\nfrom cdesym.types.core import StateVector, ControlVector\nx: StateVector = np.array([1.0, 0.0])  # Unnecessary annotation\nThe type system enables type checking and IDE support while remaining invisible during normal use. This documentation is provided for framework developers and advanced users implementing custom components.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Type_System_Architecture.html#sec-architecture-philosophy",
    "title": "Type System Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nType-Driven Design - Types are not just annotations—they are architecture.\nThe type system enables:\n\nSemantic Clarity - Names convey mathematical meaning (StateVector, not ArrayLike)\nType Safety - Static checking via mypy/pyright catches errors before runtime\nIDE Support - Autocomplete knows result['t'] exists and is TimePoints\nBackend Agnosticism - Same types work with NumPy/PyTorch/JAX\nStructured Results - TypedDict for dictionaries (not plain dict)\nSelf-Documentation - Type signatures encode mathematical constraints\n\nExample comparison:\n\n\nCode\n# ✗ Bad: Unclear types and semantics\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# ✓ Good: Clear semantics and constraints\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-framework-layers",
    "href": "architecture/Type_System_Architecture.html#sec-framework-layers",
    "title": "Type System Architecture",
    "section": "Framework Layers",
    "text": "Framework Layers\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│  (UI Framework, Delegation Layer, Integration Framework)   │\n└─────────────────────┬──────────────────────────────────────┘\n                      │ uses types from\n                      ↓\n┌────────────────────────────────────────────────────────────┐\n│                    TYPE SYSTEM (Layer 0)                   │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  FOUNDATIONAL TYPES                                  │  │\n│  │  • core.py           - Vectors, matrices             │  │\n│  │  • backends.py       - Backend enums, configs        │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  DOMAIN TYPES                                        │  │\n│  │  • trajectories.py   - Time series results           │  │\n│  │  • linearization.py  - Jacobian tuples               │  │\n│  │  • symbolic.py       - SymPy types                   │  │\n│  │  • control_classical.py - Control design results     │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  STRUCTURAL TYPES                                    │  │\n│  │  • protocols.py      - Abstract interfaces           │  │\n│  │  • utilities.py      - Helper types, guards          │  │\n│  └──────────────────────────────────────────────────────┘  │\n└────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-foundational-types",
    "href": "architecture/Type_System_Architecture.html#sec-foundational-types",
    "title": "Type System Architecture",
    "section": "Foundational Types",
    "text": "Foundational Types\n\ncore.py: Fundamental Building Blocks\nFile: core.py\nThe core module provides fundamental building blocks for all other types in the framework. These types establish semantic clarity and backend agnosticism throughout the library.\nKey categories:\n\nMulti-Backend Arrays (20+ types)\nBackend-agnostic array types that work transparently with NumPy, PyTorch, and JAX:\nArrayLike = Union[np.ndarray, torch.Tensor, jnp.ndarray]\nNumpyArray = np.ndarray\nTorchTensor = torch.Tensor\nJaxArray = jnp.ndarray\nScalarLike = Union[float, int, np.number, torch.Tensor, jnp.ndarray]\nIntegerLike = Union[int, np.integer]\nUsage in framework:\n\n\nCode\nsystem = Pendulum()\n\n# Same function works with all backends\nx_np = np.array([1.0, 0.0])      # NumPy\nx_torch = torch.tensor([1.0, 0.0])  # PyTorch\nx_jax = jnp.array([1.0, 0.0])    # JAX\n\n# Backend detected automatically - no type errors\ndx_np = system(x_np, np.zeros(1))\ndx_torch = system(x_torch, torch.zeros(1))\ndx_jax = system(x_jax, jnp.zeros(1))\n\nprint(\"✓ Backend-agnostic type system\")\n\n\n\n\nSemantic Vector Types (15+ types)\nVector types that convey mathematical meaning:\nStateVector         # x ∈ ℝⁿˣ - System state\nControlVector       # u ∈ ℝⁿᵘ - Control input\nOutputVector        # y ∈ ℝⁿʸ - Measured output\nNoiseVector         # w ∈ ℝⁿʷ - Stochastic noise\nEquilibriumState    # x_eq - Equilibrium state\nEquilibriumControl  # u_eq - Equilibrium control\nTimeDerivative      # dx/dt - State derivative\nStateIncrement      # δx - State deviation\nControlIncrement    # δu - Control deviation\nWhy semantic types matter:\n\n\nCode\n# ✗ Unclear what arrays represent\ndef compute(arr1, arr2, arr3):\n    return arr1 @ arr2 + arr3\n\n# ✓ Clear mathematical meaning\ndef compute_control(x: StateVector, K: GainMatrix, u_ff: ControlVector) -&gt; ControlVector:\n    \"\"\"State feedback with feedforward: u = -K*x + u_ff\"\"\"\n    return -K @ x + u_ff\n\n\n\n\nMatrix Types (30+ types)\nMatrix types organized by mathematical purpose:\nDynamics matrices:\nStateMatrix         # A ∈ ℝⁿˣˣⁿˣ - ∂f/∂x\nInputMatrix         # B ∈ ℝⁿˣˣⁿᵘ - ∂f/∂u  \nDiffusionMatrix     # G ∈ ℝⁿˣˣⁿʷ - Noise intensity\nObservation matrices:\nOutputMatrix        # C ∈ ℝⁿʸˣⁿˣ - ∂h/∂x\nFeedthroughMatrix   # D ∈ ℝⁿʸˣⁿᵘ - Direct feedthrough\nControl matrices:\nGainMatrix          # K ∈ ℝⁿᵘˣⁿˣ - Feedback gain\nCostMatrix          # Q ∈ ℝⁿˣˣⁿˣ - State cost\nControlCostMatrix   # R ∈ ℝⁿᵘˣⁿᵘ - Control cost\nStochastic matrices:\nCovarianceMatrix    # P ∈ ℝⁿˣˣⁿˣ - Covariance\nProcessNoiseMatrix  # Q ∈ ℝⁿˣˣⁿˣ - Process noise cov\nMeasurementNoiseMatrix  # R ∈ ℝⁿʸˣⁿʸ - Measurement noise cov\nSpecial matrices:\nIdentityMatrix      # I ∈ ℝⁿˣⁿ\nZeroMatrix         # 0 ∈ ℝᵐˣⁿ\nGramianMatrix      # Controllability/observability gramian\nControllabilityMatrix  # [B AB A²B ... Aⁿ⁻¹B]\nObservabilityMatrix    # [C; CA; CA²; ...; CAⁿ⁻¹]\n\n\nFunction Signatures (10+ types)\nCallable types that define function interfaces:\nDynamicsFunction    # (x, u) → dx/dt\nOutputFunction      # (x) → y\nControlPolicy       # (t, x) → u\nCostFunction        # (x, u) → scalar\nObserverFunction    # (y, u) → x_hat\nUsage example:\n\n\nCode\nfrom cdesym.types import StateVector, ControlVector\n# Function signature guides implementation\ndef simulate_with_controller(\n    system: Callable[[StateVector, ControlVector], StateVector],  # DynamicsFunction\n    controller: Callable[[float, StateVector], ControlVector],    # ControlPolicy\n    x0: StateVector,\n    t_span: Tuple[float, float]\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Type signatures document the contract.\"\"\"\n    # Implementation here\n    pass\n\nprint(\"✓ Function types document interfaces\")\n\n\n\n\nSystem Properties (15+ types)\nTypes for system dimensions and properties:\nStateDimension      # nx - Number of states\nControlDimension    # nu - Number of controls\nOutputDimension     # ny - Number of outputs\nNoiseDimension      # nw - Number of Wiener processes\nSystemOrder         # order - Differential order\n\nEquilibriumPoint    # (x_eq, u_eq) - Tuple\nEquilibriumName     # str - Named equilibrium\n\n\n\nbackends.py: Backend Configuration\nFile: backends.py\nThe backends module defines backend selection, device management, and method specification types.\nKey categories:\n\nBackend Types\nBackend = Literal[\"numpy\", \"torch\", \"jax\"]\nDevice = str  # 'cpu', 'cuda:0', 'mps', 'tpu'\n\nclass BackendConfig(TypedDict, total=False):\n    backend: Backend\n    device: Optional[Device]\n    dtype: Optional[str]  # 'float32', 'float64'\nUsage in framework:\n\n\nCode\nsystem = Pendulum()\n\n# Backend configuration handled internally\nprint(f\"Default backend: {system.backend.default_backend}\")\nprint(f\"Default device: {system.backend.preferred_device}\")\n\n# Users interact through simple methods\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\nwith system.use_backend('torch'):\n    print(f\"Temporary backend: {system.backend.default_backend}\")\n\n\n\n\nIntegration Methods\nIntegrationMethod = str  # 'RK45', 'dopri5', 'tsit5', etc.\n\n# Specific categories\nOdeMethod = str          # Deterministic methods\nSdeMethod = str          # Stochastic methods\nFixedStepMethod = str    # Fixed-step methods\nAdaptiveMethod = str     # Adaptive methods\n\n\nDiscretization Methods\nDiscretizationMethod = Literal[\n    \"exact\",      # Matrix exponential\n    \"euler\",      # Forward Euler\n    \"tustin\",     # Bilinear transform\n    \"backward\",   # Backward Euler\n    \"matched\",    # Zero-order hold\n]\n\n\nSDE Types\nSDEType = Literal[\"ito\", \"stratonovich\"]\n\nclass NoiseType(Enum):\n    ADDITIVE = \"additive\"\n    MULTIPLICATIVE = \"multiplicative\"\n    MULTIPLICATIVE_DIAGONAL = \"multiplicative_diagonal\"\n    MULTIPLICATIVE_SCALAR = \"multiplicative_scalar\"\n    MULTIPLICATIVE_GENERAL = \"multiplicative_general\"\n    UNKNOWN = \"unknown\"\n\nclass ConvergenceType(Enum):\n    STRONG = \"strong\"  # Pathwise convergence\n    WEAK = \"weak\"      # Distribution convergence\n\n\nSystem Configuration\nclass SystemConfig(TypedDict, total=False):\n    \"\"\"Complete system configuration.\"\"\"\n    nx: int              # State dimension\n    nu: int              # Control dimension\n    ny: int              # Output dimension\n    nw: int              # Noise dimension\n    order: int           # System order\n    dt: Optional[float]  # Time step (discrete)\n    backend: Backend\n    device: Device",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-domain-types",
    "href": "architecture/Type_System_Architecture.html#sec-domain-types",
    "title": "Type System Architecture",
    "section": "Domain Types",
    "text": "Domain Types\n\ntrajectories.py: Time Series Results\nFile: trajectories.py\nThe trajectories module defines types for time series data and simulation results.\nKey categories:\n\nTrajectory Types\nStateTrajectory = ArrayLike      # (T, nx) or (T, batch, nx)\nControlSequence = ArrayLike      # (T, nu) or (T, batch, nu)\nOutputSequence = ArrayLike       # (T, ny)\nNoiseSequence = ArrayLike        # (T, nw)\nConvention: Time-major ordering - All trajectories use (T, ...) format where T is the first dimension.\n\n\nTime Types\nTimePoints = ArrayLike           # (T,) - Time grid\nTimeSpan = Tuple[float, float]   # (t0, tf) - Interval\nTimeStep = float                 # dt - Step size\n\n\nIntegration Results (TypedDict)\nDeterministic ODE Integration:\nclass IntegrationResult(TypedDict, total=False):\n    \"\"\"ODE integration result.\"\"\"\n    t: TimePoints              # Time points\n    x: StateTrajectory         # State trajectory (T, nx)\n    success: bool              # Integration succeeded\n    message: str               # Status message\n    nfev: int                  # Function evaluations\n    nsteps: int                # Integration steps\n    integration_time: float    # Wall time (seconds)\n    solver: str                # Integrator name\n    \n    # Optional fields (adaptive methods)\n    njev: int                  # Jacobian evaluations\n    nlu: int                   # LU decompositions\n    status: int                # Solver status code\n    sol: Any                   # Dense output object\n    dense_output: bool         # Dense output available\nStochastic SDE Integration:\nclass SDEIntegrationResult(TypedDict, total=False):\n    \"\"\"SDE integration result (extends IntegrationResult).\"\"\"\n    # All IntegrationResult fields, plus:\n    diffusion_evals: int       # Diffusion function calls\n    noise_samples: NoiseVector # Brownian increments used\n    n_paths: int               # Number of trajectories\n    convergence_type: str      # 'strong' or 'weak'\n    sde_type: str              # 'ito' or 'stratonovich'\n    noise_type: str            # Noise structure\nBatch Simulation:\nclass BatchSimulationResult(TypedDict):\n    \"\"\"Batched simulation result.\"\"\"\n    t: TimePoints                    # (T,)\n    x: StateTrajectory               # (T, batch, nx)\n    u: ControlSequence               # (T, batch, nu)\n    batch_size: int\n    statistics: Dict[str, ArrayLike] # Mean, std, etc.\nWhy TypedDict:\n\n\nCode\nsystem = Pendulum()\nx0 = np.array([1.0, 0.0])\n\n# TypedDict result provides IDE support\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n\n# IDE knows these fields exist and their types\nt = result['t']              # TimePoints\nx = result['x']              # StateTrajectory\nsuccess = result['success']  # bool\nsolver = result['solver']    # str\n\nprint(f\"Integration {'succeeded' if success else 'failed'}\")\nprint(f\"Solver: {solver}\")\n\n\n\n\n\nlinearization.py: Jacobian Types\nFile: linearization.py\nThe linearization module defines return types for linearization operations.\nMathematical forms:\nContinuous systems:\n\\[\\delta\\dot{x} = A\\delta x + B\\delta u\\]\nwhere:\n\\[A = \\frac{\\partial f}{\\partial x}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_x}\\]\n\\[B = \\frac{\\partial f}{\\partial u}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_u}\\]\nDiscrete systems:\n\\[\\delta x[k+1] = A_d\\delta x[k] + B_d\\delta u[k]\\]\nType definitions:\n\nBasic Linearization\nDeterministicLinearization = Tuple[StateMatrix, InputMatrix]\n# Returns: (A, B) where\n#   A = ∂f/∂x - State Jacobian\n#   B = ∂f/∂u - Control Jacobian\n\nStochasticLinearization = Tuple[StateMatrix, InputMatrix, DiffusionMatrix]\n# Returns: (A, B, G) where\n#   A = ∂f/∂x\n#   B = ∂f/∂u  \n#   G = ∂g/∂x or g(x_eq) - Diffusion\n\nLinearizationResult = Union[DeterministicLinearization, StochasticLinearization]\n# Polymorphic: works with both\n\n\nOutput Linearization\nObservationLinearization = Tuple[OutputMatrix, FeedthroughMatrix]\n# Returns: (C, D) where\n#   C = ∂h/∂x - Output Jacobian\n#   D = ∂h/∂u - Feedthrough (usually 0)\n\n\nFull State-Space\nFullLinearization = Tuple[StateMatrix, InputMatrix, OutputMatrix, FeedthroughMatrix]\n# Returns: (A, B, C, D)\n\nFullStochasticLinearization = Tuple[\n    StateMatrix, InputMatrix, DiffusionMatrix, OutputMatrix, FeedthroughMatrix\n]\n# Returns: (A, B, G, C, D)\nUsage example:\n\n\nCode\nsystem = Pendulum()\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Type annotation guides usage\nA, B = system.linearize(x_eq, u_eq)  # DeterministicLinearization\n\n# Natural tuple unpacking\nprint(f\"A shape: {A.shape}\")  # (nx, nx)\nprint(f\"B shape: {B.shape}\")  # (nx, nu)\n\n\n\n\n\nsymbolic.py: SymPy Integration\nFile: symbolic.py\nThe symbolic module provides types for SymPy symbolic expressions.\nKey categories:\n\nSymbolic Variables\nSymbolicVariable = sp.Symbol        # Single variable\nSymbolicVector = sp.Matrix          # Vector of symbols\nSymbolicMatrix = sp.Matrix          # Matrix expression\nSymbolicExpression = sp.Expr        # General expression\n\n\nSystem Components\nDynamicsExpression = sp.Matrix      # f(x, u) symbolic\nOutputExpression = sp.Matrix        # h(x) symbolic\nDiffusionExpression = sp.Matrix     # g(x, u) symbolic\nParameterDict = Dict[sp.Symbol, float]  # Parameter values\n\n\nJacobian Expressions\nJacobianExpression = sp.Matrix      # ∂f/∂x symbolic\nHessianExpression = sp.Matrix       # ∂²f/∂x² symbolic\nGradientExpression = sp.Matrix      # ∇f symbolic\nUsage in framework:\n\n\nCode\n# Define custom system using symbolic types\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        # SymbolicVariable\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        # SymbolicVector\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        \n        # DynamicsExpression (SymbolicMatrix)\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\n        \n        # ParameterDict\n        m_sym, k_sym = sp.symbols('m k', positive=True)\n        self.parameters = {m_sym: m, k_sym: k}\n        \n        self.order = 1\n\nsystem = MySystem()\nprint(\"✓ Symbolic types guide system definition\")\n\n\n\n\n\ncontrol_classical.py: Control Design Results\nFile: control_classical.py\nThe control_classical module provides TypedDict results for classical control theory operations.\nKey categories:\n\nSystem Analysis Results\nStability Analysis:\nclass StabilityInfo(TypedDict):\n    \"\"\"Stability analysis result.\n    \n    Stability Criteria:\n    - Continuous: All Re(λ) &lt; 0 (left half-plane)\n    - Discrete: All |λ| &lt; 1 (inside unit circle)\n    \"\"\"\n    eigenvalues: np.ndarray          # Complex eigenvalues\n    magnitudes: np.ndarray           # |λ| values\n    max_magnitude: float             # Spectral radius\n    spectral_radius: float           # Same as max_magnitude\n    is_stable: bool                  # Asymptotically stable\n    is_marginally_stable: bool       # On stability boundary\n    is_unstable: bool                # Unstable\nControllability:\nclass ControllabilityInfo(TypedDict, total=False):\n    \"\"\"Controllability analysis result.\n    \n    Test: rank(C) = nx where C = [B AB A²B ... Aⁿ⁻¹B]\n    \"\"\"\n    controllability_matrix: ControllabilityMatrix  # (nx, nx*nu)\n    rank: int                        # Rank of C\n    is_controllable: bool            # rank == nx\n    uncontrollable_modes: Optional[np.ndarray]  # Eigenvalues\nObservability:\nclass ObservabilityInfo(TypedDict, total=False):\n    \"\"\"Observability analysis result.\n    \n    Test: rank(O) = nx where O = [C; CA; CA²; ...; CAⁿ⁻¹]\n    \"\"\"\n    observability_matrix: ObservabilityMatrix  # (nx*ny, nx)\n    rank: int                        # Rank of O\n    is_observable: bool              # rank == nx\n    unobservable_modes: Optional[np.ndarray]  # Eigenvalues\n\n\nControl Design Results\nLQR Controller:\nclass LQRResult(TypedDict):\n    \"\"\"Linear Quadratic Regulator result.\n    \n    Minimizes: J = ∫(x'Qx + u'Ru)dt  (continuous)\n               J = Σ(x'Qx + u'Ru)     (discrete)\n    \n    Control law: u = -Kx\n    \"\"\"\n    gain: GainMatrix                 # Feedback gain K (nu, nx)\n    cost_to_go: CovarianceMatrix     # Riccati solution P (nx, nx)\n    closed_loop_eigenvalues: np.ndarray  # eig(A - BK)\n    stability_margin: float          # Phase/gain margin\nKalman Filter:\nclass KalmanFilterResult(TypedDict):\n    \"\"\"Kalman Filter (optimal estimator) result.\n    \n    System:\n        x[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0,Q)\n        y[k] = Cx[k] + v[k],            v ~ N(0,R)\n    \n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    gain: GainMatrix                 # Kalman gain L (nx, ny)\n    error_covariance: CovarianceMatrix  # Error cov P (nx, nx)\n    innovation_covariance: CovarianceMatrix  # Innovation S (ny, ny)\n    observer_eigenvalues: np.ndarray  # eig(A - LC)\nLQG Controller:\nclass LQGResult(TypedDict):\n    \"\"\"Linear Quadratic Gaussian controller result.\n    \n    Combines LQR (optimal control) + Kalman (optimal estimation)\n    via separation principle.\n    \n    Controller: u = -Kx̂\n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    control_gain: GainMatrix         # LQR gain K (nu, nx)\n    estimator_gain: GainMatrix       # Kalman gain L (nx, ny)\n    control_cost_to_go: CovarianceMatrix  # Controller Riccati P\n    estimation_error_covariance: CovarianceMatrix  # Estimator Riccati P\n    separation_verified: bool        # Separation principle holds\n    closed_loop_stable: bool         # Overall stability\n    controller_eigenvalues: np.ndarray  # eig(A - BK)\n    estimator_eigenvalues: np.ndarray   # eig(A - LC)\nPole Placement:\nclass PolePlacementResult(TypedDict):\n    \"\"\"Pole placement (eigenvalue assignment) result.\n    \n    Design K such that eig(A - BK) = desired poles\n    \"\"\"\n    gain: GainMatrix                 # State feedback gain K\n    desired_poles: np.ndarray        # Desired eigenvalues\n    achieved_poles: np.ndarray       # Actual eig(A - BK)\n    is_controllable: bool            # Arbitrary placement possible\nLuenberger Observer:\nclass LuenbergerObserverResult(TypedDict):\n    \"\"\"Luenberger observer (deterministic estimator) result.\n    \n    Observer: x̂̇ = Ax̂ + Bu + L(y - Cx̂)\n    Error dynamics: ė = (A - LC)e\n    \"\"\"\n    gain: GainMatrix                 # Observer gain L (nx, ny)\n    desired_poles: np.ndarray        # Desired observer poles\n    achieved_poles: np.ndarray       # Actual eig(A - LC)\n    is_observable: bool              # Arbitrary placement possible\nUsage example:\n\n\nCode\n# Stability analysis (TypedDict provides structure)\nstability: StabilityInfo = system.control.analyze_stability(A, system_type='continuous')\nif stability['is_stable']:\n    print(f\"Stable with spectral radius {stability['spectral_radius']:.3f}\")\n\n# LQR design (clear result structure)\nlqr: LQRResult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\nclosed_loop_eigs = lqr['controller_eigenvalues']\n\n# Kalman filter (all fields documented)\nkalman: KalmanFilterResult = system.control.design_kalman(\n    A, C, Q_process, R_measurement, system_type='discrete'\n)\nL = kalman['gain']\n\n# LQG controller (separation principle results)\nlqg: LQGResult = system.control.design_lqg(\n    A, B, C, Q, R, Q_process, R_measurement, system_type='discrete'\n)\nK = lqg['controller_gain']\nL = lqg['estimator_gain']",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-structural-types",
    "href": "architecture/Type_System_Architecture.html#sec-structural-types",
    "title": "Type System Architecture",
    "section": "Structural Types",
    "text": "Structural Types\n\nprotocols.py: Abstract Interfaces\nFile: protocols.py\nThe protocols module defines abstract interfaces via Protocol (structural typing).\nKey categories:\n\nSystem Protocols\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Abstract interface for dynamical systems.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    @property\n    def nu(self) -&gt; int: ...\n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\nclass ContinuousSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Continuous-time system interface.\"\"\"\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable,\n        t_span: TimeSpan\n    ) -&gt; IntegrationResult: ...\n\nclass DiscreteSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Discrete-time system interface.\"\"\"\n    @property\n    def dt(self) -&gt; float: ...\n    def step(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\nclass StochasticSystemProtocol(Protocol):\n    \"\"\"Stochastic system interface.\"\"\"\n    @property\n    def nw(self) -&gt; int: ...\n    def drift(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n    def diffusion(self, x: StateVector, u: ControlVector) -&gt; DiffusionMatrix: ...\n\n\nController Protocols\nclass ControllerProtocol(Protocol):\n    \"\"\"Controller interface.\"\"\"\n    def compute_control(self, x: StateVector) -&gt; ControlVector: ...\n\nclass FeedbackControllerProtocol(ControllerProtocol, Protocol):\n    \"\"\"Linear feedback controller.\"\"\"\n    @property\n    def K(self) -&gt; GainMatrix: ...\n\n\nObserver Protocols\nclass ObserverProtocol(Protocol):\n    \"\"\"State observer interface.\"\"\"\n    def observe(self, x: StateVector) -&gt; OutputVector: ...\n    def estimate(self, y: OutputVector, u: ControlVector) -&gt; StateVector: ...\nWhy Protocol:\n\n\nCode\n# No inheritance needed - structural typing\nclass MyCustomSystem:\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property  \n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally (duck typing with type safety)\nsystem: DynamicalSystemProtocol = MyCustomSystem()  # ✓ Type checker approves!\n\n\n\n\n\nutilities.py: Helper Types\nFile: utilities.py\nThe utilities module provides helper types, type guards, and performance tracking.\nKey categories:\n\nType Guards\ndef is_numpy(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is NumPy.\"\"\"\n    return isinstance(arr, np.ndarray)\n\ndef is_torch(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is PyTorch.\"\"\"\n    return hasattr(arr, '__module__') and 'torch' in arr.__module__\n\ndef is_jax(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is JAX.\"\"\"\n    return hasattr(arr, '__module__') and 'jax' in arr.__module__\n\n\nShape Utilities\ndef is_batched(arr: ArrayLike, expected_dims: int = 1) -&gt; bool:\n    \"\"\"Check if array is batched.\"\"\"\n    return arr.ndim &gt; expected_dims\n\ndef get_batch_size(arr: ArrayLike) -&gt; Optional[int]:\n    \"\"\"Get batch size if batched.\"\"\"\n    return arr.shape[0] if is_batched(arr) else None\n\ndef get_state_dim(x: StateVector) -&gt; int:\n    \"\"\"Get state dimension.\"\"\"\n    return x.shape[-1] if x.ndim &gt; 0 else 1\n\n\nPerformance Types\nclass ExecutionStats(TypedDict):\n    \"\"\"Performance statistics.\"\"\"\n    count: int              # Number of calls\n    total_time: float       # Total time (seconds)\n    avg_time: float         # Average time\n    min_time: float         # Fastest call\n    max_time: float         # Slowest call\n\n\nValidation Types\nclass ValidationResult(TypedDict):\n    \"\"\"Validation result.\"\"\"\n    valid: bool\n    errors: List[str]\n    warnings: List[str]\n    info: Dict[str, Any]",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-design-principles",
    "href": "architecture/Type_System_Architecture.html#sec-design-principles",
    "title": "Type System Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\n1. Semantic Over Structural\nPrinciple: Names convey mathematical meaning, not implementation details.\n\n\nCode\n# ✗ Structural (what it is)\ndef compute(arr1: np.ndarray, arr2: np.ndarray) -&gt; np.ndarray:\n    return arr1 @ arr2\n\n# ✓ Semantic (what it means)\ndef compute_control(x: StateVector, K: GainMatrix) -&gt; ControlVector:\n    \"\"\"u = -Kx\"\"\"\n    return -K @ x\n\n\n\n\n2. Backend Agnosticism\nPrinciple: Same types work with NumPy/PyTorch/JAX.\n\n\nCode\n# Same function signature works for all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # Works with NumPy, PyTorch, JAX\n    return x + u  # Backend detected from input\n\n# Works with all backends\ndx_np = dynamics(np.array([1.0, 0.0]), np.array([0.0]))\ndx_torch = dynamics(torch.tensor([1.0, 0.0]), torch.tensor([0.0]))\ndx_jax = dynamics(jnp.array([1.0, 0.0]), jnp.array([0.0]))\n\nprint(\"✓ Backend-agnostic types\")\n\n\n\n\n3. TypedDict for Structured Results\nPrinciple: Never return plain dictionaries—use TypedDict for structure and safety.\n\n\nCode\n# ✗ Plain dict (no IDE support, no type checking)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# ✓ TypedDict (type-safe, self-documenting)\ndef integrate() -&gt; IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\n\n\n\n\n4. Optional Fields with total=False\nPrinciple: Use total=False for optional fields in TypedDict.\nclass IntegrationResult(TypedDict, total=False):\n    # Required fields (always present)\n    t: TimePoints\n    x: StateTrajectory\n    success: bool\n    \n    # Optional fields (may not be present)\n    njev: int  # Only adaptive methods\n    sol: Any   # Dense output (optional)\n\n\n5. Polymorphic Types via Union\nPrinciple: Use Union for polymorphic return types.\nLinearizationResult = Union[\n    Tuple[StateMatrix, InputMatrix],           # Deterministic\n    Tuple[StateMatrix, InputMatrix, DiffusionMatrix]  # Stochastic\n]\n\n# Single function handles both\ndef analyze(result: LinearizationResult):\n    A, B = result[0], result[1]\n    if len(result) == 3:\n        G = result[2]  # Stochastic\n\n\n6. Protocol for Interfaces\nPrinciple: Define interfaces via Protocol (structural typing) not inheritance.\n\n\nCode\n# No inheritance needed - structural typing\nclass MySystem:\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies DynamicalSystemProtocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # ✓ Type checker approves!",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-usage-throughout-framework",
    "href": "architecture/Type_System_Architecture.html#sec-usage-throughout-framework",
    "title": "Type System Architecture",
    "section": "Usage Throughout Framework",
    "text": "Usage Throughout Framework\n\nIn UI Framework\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __call__(\n        self, \n        x: StateVector, \n        u: Optional[ControlVector] = None\n    ) -&gt; StateVector:\n        \"\"\"Evaluate dynamics (types guide implementation).\"\"\"\n        return self._dynamics.evaluate(x, u, backend=self.backend.default_backend)\n    \n    def linearize(\n        self,\n        x_eq: EquilibriumState,\n        u_eq: EquilibriumControl,\n        backend: Backend = \"numpy\"\n    ) -&gt; DeterministicLinearization:\n        \"\"\"Compute linearization (return type documents structure).\"\"\"\n        return self._linearization.linearize_continuous(x_eq, u_eq, backend)\n\n\nIn Delegation Layer\nclass DynamicsEvaluator:\n    def evaluate(\n        self,\n        x: StateVector,\n        u: Optional[ControlVector],\n        backend: Backend\n    ) -&gt; StateVector:\n        \"\"\"Evaluate forward dynamics (types ensure correctness).\"\"\"\n        f_func: DynamicsFunction = self.code_gen.generate_dynamics(backend)\n        return f_func(x, u)\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        \"\"\"Get performance statistics (TypedDict result).\"\"\"\n        return {\n            'count': self._call_count,\n            'total_time': self._total_time,\n            'avg_time': self._total_time / self._call_count,\n            'min_time': self._min_time,\n            'max_time': self._max_time\n        }\n\n\nIn Integration Framework\nclass ScipyIntegrator(IntegratorBase):\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable[[ScalarLike, StateVector], Optional[ControlVector]],\n        t_span: TimeSpan,\n        t_eval: Optional[TimePoints] = None\n    ) -&gt; IntegrationResult:\n        \"\"\"Integrate using scipy (TypedDict ensures complete result).\"\"\"\n        # ... implementation ...\n        \n        result: IntegrationResult = {\n            't': sol.t,\n            'x': sol.y.T,\n            'success': sol.success,\n            'message': sol.message,\n            'nfev': sol.nfev,\n            'nsteps': sol.nfev,\n            'integration_time': elapsed,\n            'solver': self.name\n        }\n        \n        # Optional fields (type system allows this)\n        if hasattr(sol, 'njev'):\n            result['njev'] = sol.njev\n        \n        return result",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-type-statistics",
    "href": "architecture/Type_System_Architecture.html#sec-type-statistics",
    "title": "Type System Architecture",
    "section": "Type Statistics",
    "text": "Type Statistics\n\nType Distribution\n\n\n\n\n\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nVector Types\n15+\nStateVector, ControlVector, OutputVector\n\n\nMatrix Types\n30+\nStateMatrix, GainMatrix, CovarianceMatrix\n\n\nFunction Types\n10+\nDynamicsFunction, ControlPolicy\n\n\nBackend Types\n20+\nBackend, Device, NoiseType\n\n\nTrajectory Types\n15+\nStateTrajectory, IntegrationResult\n\n\nLinearization Types\n15+\nDeterministicLinearization\n\n\nSymbolic Types\n10+\nSymbolicExpression, DynamicsExpression\n\n\nProtocol Types\n20+\nDynamicalSystemProtocol\n\n\nUtility Types\n20+\nExecutionStats, ValidationResult\n\n\nTypedDict Results\n15+\nIntegrationResult, LQRResult, StabilityInfo\n\n\nTOTAL\n200+\nComplete type system",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-key-strengths",
    "href": "architecture/Type_System_Architecture.html#sec-key-strengths",
    "title": "Type System Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipType System Benefits\n\n\n\n\nSemantic Clarity - Names convey mathematical meaning\nType Safety - Static checking prevents errors\nIDE Support - Autocomplete and inline documentation\nBackend Agnostic - Works with NumPy/PyTorch/JAX transparently\nStructured Results - TypedDict not plain dict\nSelf-Documenting - Types encode constraints and invariants\nComposition - Types compose naturally\nExtensible - Easy to add new types\nConsistent - Same conventions throughout framework\nTestable - Type-driven testing patterns",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#summary",
    "href": "architecture/Type_System_Architecture.html#summary",
    "title": "Type System Architecture",
    "section": "Summary",
    "text": "Summary\nThe type system is the foundational layer that enables clean, type-safe architecture throughout ControlDESymulation. By providing semantic types, structured results, and protocol-based interfaces, it supports:\n\nType-driven development - Types guide implementation\nStatic verification - Catch errors before runtime\nMulti-backend support - Transparent backend switching\nClear contracts - Function signatures document expectations\nMaintainability - Types make code self-documenting\n\nThe type system is infrastructure—users benefit from it without needing to understand it. This documentation is provided for framework developers and advanced users who need to understand the internal type architecture.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html",
    "href": "architecture/cdesym_Design_Philosophy.html",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic specification and multi-backend simulation of nonlinear dynamical systems. It embodies a type-driven, composition-based architecture that achieves three seemingly contradictory goals simultaneously:\n\nMathematical Rigor - Proper control theory, stochastic processes, and linearization\nSoftware Engineering Excellence - Clean architecture, zero duplication, extensive testing\nMulti-Backend Performance - Seamless NumPy/PyTorch/JAX with GPU/XLA support\n\n\n\n\n\n\n\nNoteLibrary Overview\n\n\n\nThe library consists of 39 core files organized into 4 architectural layers, serving researchers in control theory, robotics, and machine learning.\n\n\n\n\n\n\n\n\nImportantUser Interface Levels\n\n\n\nMost users should interact with the framework at two levels:\n\nBuilt-in Systems (cdesym.systems.builtin.*)\nfrom cdesym import Pendulum, CartPole, LorenzSystem\n\nsystem = Pendulum()\nresult = system.simulate(x0, u=None, t_span=(0, 10))\nUI Framework (Define your own systems)\nfrom cdesym import ContinuousSymbolicSystem\nimport sympy as sp\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        # Define symbolic system\n        pass\n\nLower layers (Type System, Delegation Layer, Integration Framework) are internal implementation details. Users should NOT directly instantiate:\n\nBackendManager, CodeGenerator, DynamicsEvaluator (Delegation Layer)\nIntegratorFactory, ScipyIntegrator, etc. (Integration Framework)\nTypedDict classes from Type System\n\nThe UI framework automatically composes these internal components and exposes their functionality through clean, user-facing methods. This document explains the internal architecture for framework developers and advanced users who need to understand how the framework works.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-executive-summary",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-executive-summary",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic specification and multi-backend simulation of nonlinear dynamical systems. It embodies a type-driven, composition-based architecture that achieves three seemingly contradictory goals simultaneously:\n\nMathematical Rigor - Proper control theory, stochastic processes, and linearization\nSoftware Engineering Excellence - Clean architecture, zero duplication, extensive testing\nMulti-Backend Performance - Seamless NumPy/PyTorch/JAX with GPU/XLA support\n\n\n\n\n\n\n\nNoteLibrary Overview\n\n\n\nThe library consists of 39 core files organized into 4 architectural layers, serving researchers in control theory, robotics, and machine learning.\n\n\n\n\n\n\n\n\nImportantUser Interface Levels\n\n\n\nMost users should interact with the framework at two levels:\n\nBuilt-in Systems (cdesym.systems.builtin.*)\nfrom cdesym import Pendulum, CartPole, LorenzSystem\n\nsystem = Pendulum()\nresult = system.simulate(x0, u=None, t_span=(0, 10))\nUI Framework (Define your own systems)\nfrom cdesym import ContinuousSymbolicSystem\nimport sympy as sp\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        # Define symbolic system\n        pass\n\nLower layers (Type System, Delegation Layer, Integration Framework) are internal implementation details. Users should NOT directly instantiate:\n\nBackendManager, CodeGenerator, DynamicsEvaluator (Delegation Layer)\nIntegratorFactory, ScipyIntegrator, etc. (Integration Framework)\nTypedDict classes from Type System\n\nThe UI framework automatically composes these internal components and exposes their functionality through clean, user-facing methods. This document explains the internal architecture for framework developers and advanced users who need to understand how the framework works.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-user-interaction",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-user-interaction",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "User Interaction Model",
    "text": "User Interaction Model\n\nThe Right Way to Use the Framework\nThe framework is designed with clear user-facing and internal boundaries:\n✓ User-Facing APIs (Use These):\n# Level 1: Use built-in systems\nfrom cdesym import Pendulum, VanDerPol, LangevinDynamics\n\nsystem = Pendulum()\nresult = system.simulate(x0, controller, t_span=(0, 10))\nA, B = system.linearize(x_eq, u_eq)\n\n# Level 2: Define custom systems\nfrom cdesym import ContinuousSymbolicSystem\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, **params):\n        # Your symbolic definition\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n\nsystem = MySystem()  # Framework handles all internal composition\n✗ Internal APIs (Don’t Use These Directly):\n# ❌ WRONG: Direct delegation layer access\nfrom cdesym.systems.base.utils.backend_manager import BackendManager\nfrom cdesym.systems.base.utils.code_generator import CodeGenerator\nfrom cdesym.systems.base.utils.dynamics_evaluator import DynamicsEvaluator\n\nbackend = BackendManager()  # Don't do this!\ncode_gen = CodeGenerator(system)  # Framework creates these automatically\ndynamics = DynamicsEvaluator(system, code_gen, backend)  # Internal!\n\n# ❌ WRONG: Direct integrator instantiation\nfrom cdesym.systems.base.numerical_integration.scipy_integrator import ScipyIntegrator\n\nintegrator = ScipyIntegrator(system, method='RK45')  # Don't do this!\n\n# ✓ CORRECT: Use system interface\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='RK45')\n# Framework creates appropriate integrator internally\n\n\nWhy This Separation Matters\nUser-Facing Benefits:\n\nSimple, consistent interface across all systems\nNo need to understand internal architecture\nFramework handles complexity automatically\nChanges to internals don’t break user code\n\nFramework Developer Benefits:\n\nCan refactor internal components freely\nClear separation of concerns\nEasier to maintain and test\nWell-defined extension points\n\n\n\nWhen You Might Need Internal APIs\nThe only time to directly use internal components:\n\nFramework Extension - Adding new system types, integrators, or utilities\nAdvanced Debugging - Diagnosing framework issues\nPerformance Optimization - Custom integration workflows\nResearch Purposes - Experimenting with new numerical methods\n\nFor these advanced use cases, refer to the architecture documentation for each layer.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-core-design-philosophy",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-core-design-philosophy",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Core Design Philosophy",
    "text": "Core Design Philosophy\n\n1. Type-Driven Design\nPrinciple: Types are not just annotations—they are the architecture.\nThe entire framework is built on a foundational type system (200+ types) that provides:\n\nSemantic Clarity: StateVector, GainMatrix instead of np.ndarray\nType Safety: Static checking via mypy/pyright catches errors before runtime\nIDE Support: Autocomplete knows result['t'] exists and is TimePoints\nSelf-Documentation: Type signatures encode mathematical constraints\n\nExample comparison:\n# ❌ Bad: Unclear types and semantics\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# ✓ Good: Clear semantics and constraints\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u\nImpact: Every function signature is a mini-specification. New developers understand code by reading types.\n\n\n2. Composition Over Inheritance\nPrinciple: Systems compose specialized utilities rather than inheriting monolithic bases.\nTraditional OOP would create deep inheritance hierarchies. We rejected this in favor of composition via delegation:\n# ❌ NOT this (deep inheritance):\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator, ...):\n    pass  # 50 methods, unclear responsibilities\n\n# ✓ YES this (composition):\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()       # Multi-backend support\n        self._code_gen = CodeGenerator()      # Symbolic → numerical\n        self._dynamics = DynamicsEvaluator()  # Forward evaluation\n        self._linearization = LinearizationEngine()  # Jacobians\n        self.equilibria = EquilibriumHandler()  # Named equilibria\nBenefits:\n\n\n\nBenefit\nDescription\n\n\n\n\nSingle Responsibility\nEach utility does one thing well\n\n\nTestability\nTest utilities in isolation\n\n\nReusability\nUse BackendManager anywhere\n\n\nClarity\nExplicit dependencies\n\n\nFlexibility\nEasy to swap implementations\n\n\n\n\n\n\n\n\n\nImportantStrategic Use of Inheritance\n\n\n\nWe DO use cooperative multiple inheritance in the UI framework—but only at the top level where it provides genuine value (avoiding duplication while maintaining clean interfaces).\n\n\n\n\n3. Backend Agnosticism\nPrinciple: Write once, run on NumPy/PyTorch/JAX without code changes.\nSupporting multiple backends is not a feature—it’s a design constraint that forces better architecture:\n# Same code works with all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # x can be np.ndarray, torch.Tensor, or jax.Array\n    return -K @ x  # Works with all!\n\n# Backend switching is trivial\nsystem.set_default_backend('torch')\nsystem.to_device('cuda:0')\nArchitectural implications:\n\nArrayLike Union Type: All array types accept Union[np.ndarray, torch.Tensor, jnp.ndarray]\nBackendManager Utility: Centralized backend detection and conversion\nPer-Backend Caching: Code generated once per backend, then cached\nDevice Management: Automatic GPU placement when available\n\nResult: Users can start with NumPy for prototyping, switch to PyTorch for neural ODEs, or JAX for optimization—with zero code changes.\n\n\n4. Zero Code Duplication\nPrinciple: Every line of code should exist in exactly one place.\nWe eliminated ~1,800 lines of duplication between continuous and discrete systems through strategic abstraction:\nBefore refactoring: Continuous and discrete systems each had:\n\nParameter handling\nBackend management\nCode generation\nSymbolic validation\nConfiguration persistence\n\nAfter refactoring: SymbolicSystemBase provides shared functionality:\n\nAll parameter logic: ONE implementation\nAll backend logic: ONE BackendManager\nAll code generation: ONE CodeGenerator\nAll validation: ONE SymbolicValidator\n\nImplementation via cooperative multiple inheritance:\nLayer 0: SymbolicSystemBase (shared foundation)\n         |\n    +----+----+\n    |         |\nLayer 1: ContinuousSystemBase, DiscreteSystemBase (time-domain specific)\n         |                      |\n         +----------+-----------+\n                    |\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem\nThis isn’t inheritance for convenience—it’s strategic abstraction to eliminate duplication while maintaining clarity.\n\n\n5. Structured Results via TypedDict\nPrinciple: Never return plain dictionaries—use TypedDict for structure and safety.\n# ❌ BAD: Plain dict (no IDE support, no type checking)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# ✓ GOOD: TypedDict (type-safe, self-documenting)\ndef integrate() -&gt; IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\nBenefits:\n\n✓ Type checker ensures all required fields present\n✓ IDE autocompletes field names\n✓ Documentation embedded in type definition\n✓ Optional fields clearly marked (total=False)\n✓ Refactoring safe (rename propagates)\n\nUsed throughout:\n\n\n\nResult Type\nPurpose\n\n\n\n\nIntegrationResult\nODE integration output\n\n\nSDEIntegrationResult\nSDE integration output\n\n\nExecutionStats\nPerformance metrics\n\n\nValidationResult\nSystem validation status\n\n\nBackendConfig\nConfiguration data\n\n\n\n\n\n6. Protocol-Based Interfaces\nPrinciple: Define interfaces via Protocol (structural typing) not inheritance.\nProtocols enable duck typing with type safety:\nfrom typing import Protocol\n\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Any class satisfying this structure is a dynamical system.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    \n    @property\n    def nu(self) -&gt; int: ...\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\n# No inheritance needed!\nclass MySystem:  # Doesn't inherit from anything\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property  \n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # ✓ Type checker approves!\nAdvantages:\n\nNo inheritance coupling\nStructural subtyping (like Go interfaces)\nEasy to implement interfaces\nCompose protocols naturally\nThird-party types work automatically\n\n\n\n7. Factory Pattern for Complex Creation\nPrinciple: Hide complexity behind simple factory methods.\nCreating integrators involves choosing backends, methods, and configurations. Factories simplify this:\n# ❌ Instead of this complexity:\nif backend == 'numpy':\n    if method == 'RK45':\n        return ScipyIntegrator(system, method='RK45', rtol=1e-6)\n    elif method == 'Tsit5':\n        return DiffEqPyIntegrator(system, algorithm='Tsit5')\nelif backend == 'torch':\n    return TorchDiffEqIntegrator(system, method='dopri5')\n# ... 50 more cases\n\n# ✓ We provide this simplicity:\nintegrator = IntegratorFactory.auto(system)\n# or\nintegrator = IntegratorFactory.for_production(system)\n# or  \nintegrator = IntegratorFactory.for_neural_ode(system)\nAvailable factory methods:\n\n\n\nMethod\nPurpose\n\n\n\n\nauto()\nBest integrator for system/backend\n\n\nfor_production()\nLSODA/AutoTsit5 for reliability\n\n\nfor_optimization()\nJAX tsit5 for speed\n\n\nfor_neural_ode()\nPyTorch dopri5 with adjoint\n\n\nfor_julia()\nHighest performance\n\n\ncreate()\nFull control when needed\n\n\n\nResult: Simple interface for common cases, full control when needed.\n\n\n8. Semantic Naming\nPrinciple: Names should convey mathematical meaning, not implementation details.\nGood semantic names:\n\n✓ StateVector not ArrayLike - conveys it’s a state\n✓ GainMatrix not Matrix - conveys it’s for feedback control\n✓ DynamicsEvaluator not FunctionCaller - conveys purpose\n✓ LinearizationEngine not JacobianComputer - conveys operation\n\nBad implementation names:\n\n✗ data - what data?\n✗ arr1, arr2 - meaningless\n✗ compute() - compute what?\n✗ process_stuff() - what stuff?\n\nImpact: Code reads like mathematical papers. Control theorists immediately understand.\n\n\n9. Progressive Disclosure of Complexity\nPrinciple: Simple things should be simple, complex things should be possible.\nThe framework provides three levels of interaction, each building on the previous:\nLevel 1 - Beginner (Use Built-in Systems):\nfrom cdesym import Pendulum, CartPole, LorenzSystem\n\n# Use pre-defined systems from cdesym.systems.builtin\nsystem = Pendulum()\nresult = system.simulate(x0, u=np.zeros(1), t_span=(0, 10))\n\n# All internal complexity handled automatically\nLevel 2 - Intermediate (Define Custom Systems):\nfrom cdesym import ContinuousSymbolicSystem\nimport sympy as sp\n\n# Define your own system using UI framework\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\n\nsystem = MySystem(m=2.0)  # Framework composes internals\nresult = system.integrate(x0, u=None, t_span=(0, 10))\nLevel 3 - Expert (Framework Extension):\n# ⚠️ Advanced: Only for framework developers\n# Directly use internal APIs for custom integrators, utilities, etc.\n\n# Custom integrator implementation\nfrom cdesym.systems.base.numerical_integration import IntegratorBase\n\nclass MyCustomIntegrator(IntegratorBase):\n    def step(self, x, u, dt):\n        # Custom integration logic\n        pass\n\n# Custom utility for system composition\nfrom cdesym.systems.base.utils import BackendManager\n\nclass MyUtility:\n    def __init__(self, system, backend_mgr: BackendManager):\n        # Custom utility using internal components\n        pass\n\n\n\n\n\n\nTipRecommended Entry Points\n\n\n\n\nBeginners: Use built-in systems from cdesym.systems.builtin.*\nIntermediate: Subclass ContinuousSymbolicSystem or DiscreteSymbolicSystem\nAdvanced: Only access Layers 0-2 when extending the framework itself\n\n\n\nPrinciple applied:\n\nDefault arguments for common cases\nProgressive power through optional parameters\n\nExpert features available but hidden from typical users\nInternal complexity encapsulated at each level",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-architectural-layers",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-architectural-layers",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Architectural Layers",
    "text": "Architectural Layers\n\n\n\n\n\n\nWarningFor Framework Developers\n\n\n\nThe following sections describe the internal architecture of the framework. Typical users do not need to understand these layers and should not directly instantiate components from Layers 0-2.\nUsers should work with: - Built-in systems from cdesym.systems.builtin.* - UI framework by subclassing ContinuousSymbolicSystem or DiscreteSymbolicSystem\nThe internal layers are documented here for: - Framework contributors and maintainers - Advanced users implementing custom integrators or utilities - Researchers studying the framework architecture\n\n\nThe library consists of 4 distinct architectural layers, each with clear responsibilities:\n\nLayer 0: Type System (Foundation)\nPurpose: Foundational types and structured results\nFiles: 7 modules, 200+ types\nKey components:\n\n\n\nModule\nPurpose\n\n\n\n\ncore.py\nVectors, matrices, functions\n\n\nbackends.py\nBackend enums, configs\n\n\ntrajectories.py\nTime series results\n\n\nlinearization.py\nJacobian types\n\n\nsymbolic.py\nSymPy integration\n\n\nprotocols.py\nAbstract interfaces\n\n\nutilities.py\nType guards, helpers\n\n\n\nDesign principles:\n\nSemantic over structural naming\nBackend-agnostic unions\nTypedDict for all results\nProtocol-based interfaces\n\nImpact: Every layer above uses these types. Changes here propagate everywhere—so we keep them stable and well-designed.\n\n\nLayer 1: Delegation Layer (Services)\nPurpose: Specialized utilities via composition\nFiles: 11 modules\nCore utilities:\n\nBackendManager - Multi-backend support\nCodeGenerator - Symbolic → numerical\nEquilibriumHandler - Named equilibria\nSymbolicValidator - System validation\n\nDeterministic services:\n\nDynamicsEvaluator - Forward dynamics\nLinearizationEngine - Jacobians\nObservationEngine - Output evaluation\n\nStochastic services:\n\nDiffusionHandler - SDE diffusion\nNoiseCharacterizer - Noise analysis\nSDEValidator - SDE validation\n\nLow-level:\n\ncodegen_utils - SymPy code generation\n\nDesign principles:\n\nSingle responsibility per utility\nComposition not inheritance\nDependency injection\nLazy initialization with caching\n\nImpact: UI framework composes these utilities. Each utility is independently testable and reusable.\n\n\nLayer 2: Integration Framework (Numerical Methods)\nPurpose: Multi-backend numerical integration\nFiles: 13 modules\nDeterministic (ODE) integrators:\n\n\n\nIntegrator\nBackend\nPurpose\n\n\n\n\nScipyIntegrator\nNumPy\nscipy.integrate.solve_ivp\n\n\nTorchDiffEqIntegrator\nPyTorch\nGPU acceleration + autograd\n\n\nDiffraxIntegrator\nJAX\nXLA compilation\n\n\nDiffEqPyIntegrator\nJulia\nHighest performance\n\n\nFixedStepIntegrators\nAny\nEuler, RK4, Midpoint\n\n\n\nStochastic (SDE) integrators:\n\n\n\nIntegrator\nBackend\nPurpose\n\n\n\n\nTorchSDEIntegrator\nPyTorch\nGPU SDE integration\n\n\nDiffraxSDEIntegrator\nJAX\nXLA-compiled SDEs\n\n\nDiffEqPySDEIntegrator\nJulia\nProduction-grade SDEs\n\n\nCustomBrownianPath\nJAX\nCustom noise for testing\n\n\n\nDesign principles:\n\nFactory pattern for creation\nUnified result types (TypedDict)\nBackend abstraction\nPerformance tracking\n\nSupported methods: 40+ integration methods across 4 backends\n\n\nLayer 3: UI Framework (User-Facing Systems)\nPurpose: Symbolic system definition and high-level interface\nFiles: 8 modules\nArchitecture hierarchy:\nLayer 0: SymbolicSystemBase\n         └─ Time-agnostic foundation\n         \nLayer 1: Time-domain bases\n         ├─ ContinuousSystemBase\n         └─ DiscreteSystemBase\n         \nLayer 2: Concrete implementations\n         ├─ ContinuousSymbolicSystem\n         └─ DiscreteSymbolicSystem\n         \nLayer 3: Stochastic extensions\n         ├─ ContinuousStochasticSystem\n         └─ DiscreteStochasticSystem\nKey responsibilities:\n\n\n\n\n\n\n\nComponent\nResponsibility\n\n\n\n\nSymbolicSystemBase\nSymbolic variables, parameters, code generation, backend management, equilibria, config\n\n\nContinuousSystemBase\nContinuous-time interface (dx/dt = f)\n\n\nDiscreteSystemBase\nDiscrete-time interface (x[k+1] = f)\n\n\nContinuousSymbolicSystem\nCombine symbolic + continuous\n\n\nDiscreteSymbolicSystem\nCombine symbolic + discrete\n\n\nStochastic Systems\nAdd diffusion handling\n\n\nDiscretizedSystem\nContinuous → discrete conversion\n\n\n\nDesign principles:\n\nCooperative multiple inheritance (strategic use only)\nZero code duplication\nTemplate method pattern\nComposition for utilities",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-design-patterns",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-design-patterns",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Design Patterns Used",
    "text": "Design Patterns Used\n\n1. Template Method Pattern\nWhere: All system base classes\nHow: Base class defines workflow, subclasses fill in details\nclass SymbolicSystemBase(ABC):\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\nBenefit: Consistent initialization workflow. Users only implement define_system().\n\n\n2. Factory Method Pattern\nWhere: IntegratorFactory, SDEIntegratorFactory\nHow: Factory methods create appropriate concrete classes\nclass IntegratorFactory:\n    @classmethod\n    def create(cls, system, backend, method, **opts):\n        \"\"\"Create appropriate integrator based on inputs.\"\"\"\n        if backend == 'numpy':\n            if method in SCIPY_METHODS:\n                return ScipyIntegrator(system, method, **opts)\n            elif method in JULIA_METHODS:\n                return DiffEqPyIntegrator(system, method, **opts)\n        elif backend == 'torch':\n            return TorchDiffEqIntegrator(system, method, **opts)\n        # ...\n    \n    @classmethod\n    def auto(cls, system):\n        \"\"\"Best integrator for system.\"\"\"\n        backend = system.backend.default_backend\n        method = cls._BACKEND_DEFAULTS[backend]\n        return cls.create(system, backend, method)\nBenefit: Users get right integrator without knowing details.\n\n\n3. Strategy Pattern\nWhere: Integration methods\nHow: Different algorithms (strategies) with same interface\n# All integrators implement same interface\nclass IntegratorBase(ABC):\n    @abstractmethod\n    def integrate(self, x0, u_func, t_span) -&gt; IntegrationResult:\n        pass\n\n# Different strategies\nintegrator = ScipyIntegrator(system, method='RK45')  # Strategy 1\nintegrator = DiffraxIntegrator(system, method='tsit5')  # Strategy 2\n\n# Same interface\nresult = integrator.integrate(x0, u_func, t_span)\nBenefit: Swap integration methods without code changes.\n\n\n4. Dependency Injection\nWhere: All delegation layer utilities\nHow: Dependencies injected via constructor\nclass DynamicsEvaluator:\n    def __init__(\n        self,\n        system: SymbolicSystemBase,\n        code_gen: CodeGenerator,\n        backend_mgr: BackendManager\n    ):\n        # Dependencies injected, not created internally\n        self.system = system\n        self.code_gen = code_gen\n        self.backend_mgr = backend_mgr\nBenefit: Easy to test (mock dependencies), clear dependencies.\n\n\n5. Lazy Initialization\nWhere: Code generation, function compilation\nHow: Generate/compile on first use, cache result\nclass CodeGenerator:\n    def generate_dynamics(self, backend):\n        # Check cache first\n        if self._f_funcs[backend] is not None:\n            return self._f_funcs[backend]  # Instant\n        \n        # Generate only if needed\n        func = self._compile_dynamics(backend)\n        \n        # Cache for next time\n        self._f_funcs[backend] = func\n        return func\nBenefit: Fast startup, compile only what’s needed.\n\n\n6. Observer Pattern\nWhere: Performance statistics, validation\nHow: Utilities track events and report statistics\nclass DynamicsEvaluator:\n    def evaluate(self, x, u):\n        start = time.time()\n        result = self._f_func(x, u)\n        elapsed = time.time() - start\n        \n        # Update statistics\n        self._stats['calls'] += 1\n        self._stats['total_time'] += elapsed\n        \n        return result\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        return self._stats\nBenefit: Built-in performance monitoring.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-mathematical-rigor",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-mathematical-rigor",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Mathematical Rigor",
    "text": "Mathematical Rigor\n\nControl Theory Foundations\nThe library implements proper control theory:\n1. State-Space Representation\n\\[\n\\begin{aligned}\n\\text{Continuous:} \\quad & \\dot{x} = f(x, u, t) \\\\\n                          & y = h(x, t) \\\\\n\\\\\n\\text{Discrete:} \\quad   & x[k+1] = f(x[k], u[k]) \\\\\n                          & y[k] = h(x[k])\n\\end{aligned}\n\\]\n2. Linearization\n\\[\n\\begin{aligned}\n\\delta\\dot{x} &= A\\cdot\\delta x + B\\cdot\\delta u  && \\text{(continuous)} \\\\\n\\delta x[k+1] &= A_d\\cdot\\delta x[k] + B_d\\cdot\\delta u[k] && \\text{(discrete)}\n\\end{aligned}\n\\]\nwhere: - \\(A = \\frac{\\partial f}{\\partial x}\\) (state Jacobian) - \\(B = \\frac{\\partial f}{\\partial u}\\) (control Jacobian)\n3. Higher-Order Systems\nFor order \\(n\\) system \\(q^{(n)} = f(q, \\dot{q}, \\ldots, q^{(n-1)}, u)\\):\n\\[\n\\text{State: } x = [q, \\dot{q}, \\ldots, q^{(n-1)}]^T \\\\\n\\text{Dynamics: } \\dot{x} = [\\dot{q}, \\ddot{q}, \\ldots, q^{(n)}]^T\n\\]\n4. Stochastic Processes\n\\[\n\\begin{aligned}\n\\text{Itô:} \\quad & dx = f(x,u)dt + g(x,u)dW \\\\\n\\text{Stratonovich:} \\quad & dx = f(x,u)dt + g(x,u)\\circ dW\n\\end{aligned}\n\\]\nNoise types:\n\nAdditive: \\(g(x,u) = G\\) (constant)\nMultiplicative: \\(g\\) depends on \\(x\\) or \\(u\\)\nDiagonal: Independent noise channels\nScalar: Single Wiener process\n\n\n\nNumerical Methods\nODE Solvers (40+ methods):\n\n\n\nCategory\nMethods\n\n\n\n\nExplicit RK\nRK45, Tsit5, Vern9, dopri5\n\n\nImplicit\nRadau, BDF, Rodas5\n\n\nAuto-stiffness\nLSODA, AutoTsit5\n\n\nFixed-step\nEuler, RK4, Midpoint\n\n\n\nSDE Solvers:\n\n\n\nMethod\nConvergence\nNoise Type\n\n\n\n\nEuler-Maruyama\nStrong 0.5\nGeneral\n\n\nMilstein\nStrong 1.0\nDiagonal\n\n\nHeun\nStrong 1.0\nAdditive\n\n\nStochastic RK\nVariable\nGeneral",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-performance",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-performance",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Performance Considerations",
    "text": "Performance Considerations\n\n1. Caching Strategy\nThree-level cache:\n\nSymbolic Cache: Jacobians computed once symbolically\nPer-Backend Cache: Compiled functions per backend\nEquilibrium Cache: Linearizations at equilibria\n\n# First call: symbolic computation + compilation\nA, B = system.linearize(x_eq, u_eq)\n\n# Second call: cached (instant)\nA, B = system.linearize(x_eq, u_eq)\n\n\n2. Backend Optimization\nNumPy:\n\nCommon subexpression elimination (CSE)\nFast numerical modules\nVectorized operations\n\nPyTorch:\n\nSymbolic simplification before codegen\nGPU tensor operations\nAutomatic differentiation\nAdjoint method for memory efficiency\n\nJAX:\n\nJIT compilation via jax.jit\nXLA optimization\nPure functional style\nAutomatic vectorization (vmap)\n\n\n\n3. Batching Support\nAll evaluators support batched operations:\n# Single evaluation\ndx = system(x, u)  # x: (nx,), u: (nu,) → dx: (nx,)\n\n# Batched evaluation (possible 100x speedup over loop)\ndx_batch = system(x_batch, u_batch)  \n# x: (100, nx), u: (100, nu) → dx: (100, nx)\n\n\n4. GPU Acceleration\nPyTorch:\nsystem.set_default_backend('torch')\nsystem.to_device('cuda:0')\n\nx = torch.tensor([[1.0, 0.0]], device='cuda:0')\ndx = system(x, u)  # Computed on GPU\nJAX:\nsystem.set_default_backend('jax')\nsystem.to_device('cuda:0')\n\nx = jnp.array([1.0, 0.0])\ndx = jax.jit(system)(x, u)  # XLA compiled, GPU enabled",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-testing",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-testing",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Testing Philosophy",
    "text": "Testing Philosophy\n\n1. Type-Driven Testing\nTypes guide what to test:\ndef test_dynamics_signature():\n    \"\"\"Type annotations specify contract.\"\"\"\n    x: StateVector = np.array([1.0, 0.0])\n    u: ControlVector = np.array([0.5])\n    \n    dx: StateVector = system(x, u)\n    \n    assert isinstance(dx, np.ndarray)\n    assert dx.shape == (system.nx,)\n\n\n2. Property-Based Testing\nTest mathematical properties:\ndef test_linearization_is_linear():\n    \"\"\"Linearization should be linear in δx and δu.\"\"\"\n    A, B = system.linearize(x_eq, u_eq)\n    \n    δx1, δx2 = np.random.randn(2, nx)\n    \n    # Linearity: f(αx₁ + βx₂) = αf(x₁) + βf(x₂)\n    α, β = 0.3, 0.7\n    \n    lhs = A @ (α*δx1 + β*δx2)\n    rhs = α*(A @ δx1) + β*(A @ δx2)\n    \n    np.testing.assert_allclose(lhs, rhs)\n\n\n3. Multi-Backend Consistency\nSame results across backends:\ndef test_backend_consistency():\n    \"\"\"NumPy, PyTorch, JAX should agree.\"\"\"\n    x_np = np.array([1.0, 0.0])\n    \n    dx_np = system(x_np, backend='numpy')\n    dx_torch = system(torch.tensor(x_np), backend='torch')\n    dx_jax = system(jnp.array(x_np), backend='jax')\n    \n    np.testing.assert_allclose(dx_np, dx_torch.numpy())\n    np.testing.assert_allclose(dx_np, np.array(dx_jax))\n\n\n4. Regression Testing\nCritical numerical values frozen:\ndef test_pendulum_energy_conservation():\n    \"\"\"Known system should have expected behavior.\"\"\"\n    system = Pendulum(m=1.0, l=1.0, g=9.81)\n    \n    # Energy should be conserved (no damping)\n    E0 = compute_energy(x0)\n    x_final = system.simulate(x0, u=None, t_span=(0, 10))[-1]\n    E_final = compute_energy(x_final)\n    \n    np.testing.assert_allclose(E0, E_final, rtol=1e-6)",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-documentation",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-documentation",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Documentation Philosophy",
    "text": "Documentation Philosophy\n\n1. Self-Documenting Code\nCode should be readable without comments:\n# ❌ Bad\ndef f(x, u, m):  # What is this?\n    return x[1], -m*x[0] + u\n\n# ✓ Good  \ndef compute_dynamics(\n    state: StateVector,\n    control: ControlVector,\n    stiffness: float\n) -&gt; StateVector:\n    \"\"\"\n    Compute dynamics for mass-spring system.\n    \n    Parameters\n    ----------\n    state : StateVector\n        [position, velocity]\n    control : ControlVector\n        Applied force\n    stiffness : float\n        Spring constant k\n    \n    Returns\n    -------\n    StateVector\n        [velocity, acceleration]\n    \"\"\"\n    position, velocity = state\n    force = control\n    acceleration = -stiffness * position + force\n    return np.array([velocity, acceleration])\n\n\n2. Examples in Docstrings\nEvery public function has usage examples:\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; DeterministicLinearization:\n    \"\"\"\n    Compute linearization at equilibrium.\n    \n    Returns state and control Jacobians (A, B).\n    \n    Examples\n    --------\n    &gt;&gt;&gt; # Linearize at origin\n    &gt;&gt;&gt; A, B = system.linearize(\n    ...     x_eq=np.zeros(2),\n    ...     u_eq=np.zeros(1)\n    ... )\n    &gt;&gt;&gt; print(A.shape)  # (2, 2)\n    &gt;&gt;&gt; print(B.shape)  # (2, 1)\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; # Check stability\n    &gt;&gt;&gt; eigenvalues = np.linalg.eigvals(A)\n    &gt;&gt;&gt; stable = np.all(np.real(eigenvalues) &lt; 0)\n    \"\"\"\n\n\n3. Mathematical Documentation\nExplain theory behind code:\n\"\"\"\nLinearization Engine for Dynamical Systems\n\nMathematical Background\n-----------------------\nFor a nonlinear system:\n    dx/dt = f(x, u)\n\nThe linearization at (x_eq, u_eq) is:\n    δẋ = A·δx + B·δu\n\nwhere:\n    A = ∂f/∂x|(x_eq, u_eq) ∈ ℝ^(nx×nx)  (State Jacobian)\n    B = ∂f/∂u|(x_eq, u_eq) ∈ ℝ^(nx×nu)  (Control Jacobian)\n\nThis enables:\n- Stability analysis via eigenvalues of A\n- LQR controller design\n- Observer design (Kalman filter)\n- Small-signal analysis\n\"\"\"\n\n\n4. Architecture Documents\nHigh-level guides (like this one!) explain design philosophy and patterns.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-error-handling",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-error-handling",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Error Handling Philosophy",
    "text": "Error Handling Philosophy\n\n1. Fail Fast, Fail Clearly\nDetect errors as early as possible with clear messages:\n# ❌ Bad\ndef compute(x):\n    return x[5]  # IndexError: vague\n\n# ✓ Good\ndef compute(state: StateVector) -&gt; float:\n    if len(state) &lt; 6:\n        raise ValueError(\n            f\"State must have at least 6 elements for this computation. \"\n            f\"Got {len(state)} elements: {state}\"\n        )\n    return state[5]\n\n\n2. Validation at Construction\nCatch errors during __init__, not during use:\nclass System(SymbolicSystemBase):\n    def define_system(self):\n        # Bad parameter type\n        self.parameters = {'m': 1.0}  # String key!\n        \n# Validation catches this immediately:\n# ValueError: Parameter keys must be Symbol, not str.\n# Found string key: 'm'\n# Use: m_sym = sp.symbols('m'); parameters = {m_sym: 1.0}\n\n\n3. Type Checking Before Runtime\nUse type annotations + mypy to catch errors before running:\n$ mypy src/\nerror: Argument 1 to \"compute\" has incompatible type \"List[float]\"; \nexpected \"ndarray[Any, dtype[Any]]\"\n\n\n4. Helpful Error Messages\nInclude context and solutions:\nif x.shape[0] != self.nx:\n    raise ValueError(\n        f\"State dimension mismatch.\\n\"\n        f\"Expected: {self.nx} (from system definition)\\n\"\n        f\"Got: {x.shape[0]} (from input)\\n\"\n        f\"State: {x}\\n\"\n        f\"Hint: Check that state vector has correct dimension.\"\n    )",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-extension-points",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-extension-points",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Extension Points",
    "text": "Extension Points\nThe architecture provides clear extension points:\n\n1. Add New System Type\nclass MyCustomSystem(SymbolicSystemBase):\n    \"\"\"Just implement define_system().\"\"\"\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n        self.parameters = {...}\n\n    def setup_equilibria(self):\n        \"\"\"Optional: Auto-set equilibria upon instantiation.\"\"\"\n        # Define custom equilibrium setup\n        pass\n\n\n2. Add New Integrator\nclass MyIntegrator(IntegratorBase):\n    \"\"\"Implement abstract methods.\"\"\"\n    def step(self, x, u, dt):\n        # Single step logic\n        pass\n    \n    def integrate(self, x0, u_func, t_span):\n        # Multi-step logic\n        return IntegrationResult(...)\n\n\n3. Add New Utility\nclass MyUtility:\n    \"\"\"Independent utility via composition.\"\"\"\n    def __init__(self, system):\n        self.system = system\n    \n    def my_operation(self):\n        # Custom operation\n        pass\n\n# Use via composition\nsystem._my_utility = MyUtility(system)\n\n\n4. Add New Backend\n# 1. Add to Backend type\nBackend = Literal[\"numpy\", \"torch\", \"jax\", \"my_backend\"]\n\n# 2. Extend BackendManager\nclass BackendManager:\n    def _convert_to_backend(self, arr, backend):\n        if backend == \"my_backend\":\n            return my_backend.array(arr)\n        # ...\n\n# 3. Add to codegen_utils\ndef generate_function(expr, vars, backend):\n    if backend == \"my_backend\":\n        return my_backend.lambdify(...)\n    # ...",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-trade-offs",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-trade-offs",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Trade-offs and Decisions",
    "text": "Trade-offs and Decisions\n\n1. Cooperative Multiple Inheritance\nDecision: Use cooperative multiple inheritance ONLY in UI framework Layer 2\n\n\n\n\n\n\nTipRationale\n\n\n\nPros:\n\nEliminates ~1,800 lines of duplication\nClean interfaces (ContinuousSymbolicSystem has both capabilities)\nPython’s MRO handles it correctly with super()\n\nCons:\n\nCan be confusing if overused\nRequires careful design\n\nWhy limited use: We restrict it to where it provides genuine value—the top-level system classes that need both symbolic machinery and time-domain interfaces.\n\n\n\n\n2. TypedDict vs Dataclass\nDecision: Use TypedDict for results, not dataclass\n\n\n\n\n\n\nTipRationale\n\n\n\nPros:\n\nCompatible with plain dictionaries (gradual typing)\nNo runtime overhead\nWorks with JSON serialization\n\nCons:\n\nNot as pythonic as dataclass\nNo default values (use total=False instead)\n\nWhy TypedDict: Integration results come from external libraries (scipy, etc.) as dictionaries. TypedDict lets us type them without conversion.\n\n\n\n\n3. Backend Support\nDecision: Support NumPy, PyTorch, JAX (not TensorFlow)\n\n\n\nBackend\nRationale\n\n\n\n\nNumPy\nUniversal, stable, CPU\n\n\nPyTorch\nNeural networks, GPU, mature ecosystem\n\n\nJAX\nFunctional, JIT, XLA, research-friendly\n\n\nTensorFlow\n✗ Skipped due to complexity, declining use in research\n\n\n\nWhy these three: Cover 95% of use cases with minimal complexity.\n\n\n4. Symbolic Engine\nDecision: Use SymPy (not custom symbolic engine)\nRationale:\n\n✓ Mature, well-tested symbolic math\n✓ Excellent documentation\n✓ Large community\n✗ Can be slow for very large systems\n✗ Limited control over simplification\n\nWhy SymPy: Reinventing symbolic math is not our value proposition. SymPy is battle-tested.\n\n\n5. Testing Framework\nDecision: pytest (not unittest)\nRationale:\n\n✓ Less boilerplate\n✓ Better fixtures\n✓ Parametrized tests\n✓ Better assertions\n\nWhy pytest: Industry standard, developer-friendly.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-future",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-future",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Future Directions",
    "text": "Future Directions\n\nActive Development\nFeatures being implemented prior to release:\n\nClassical Control Theory\n\nStability, controllability, and observability metrics\nKalman Filter, Luenberger Observer design\nLinear Quadratic (Gaussian) Regulator control design\nCallable controllers\n\nVisualization\n\nPlotly-based interactive plotting\nTrajectory visualization across all variables\nPhase portrait visualization in 2D and 3D\n\n\n\n\nPlanned Features\n\nRL Environment Synthesis\n\nGymnasium library interface compatibility\nExport of Gymnasium environments from symbolic dynamics\n\nSynthetic Data Generation\n\nClasses and methods for generating synthetic physical data\nExport in standard formats\n\nParameter and Uncertainty Estimation\n\nSystem identification\nBayesian inference\nAdaptive control\nConformal methods\nSobol indices\nMorris screening\n\nNeural Controller Design\n\nProtocol interface for backend-agnostic functionality\nNeural controller training\nNeural certificate function construction and verification\n\nLyapunov, barrier, contraction metric\n\nForward and backward reachability analysis\n\nModel Predictive Control (MPC)\n\nReceding horizon optimization\nConstraint handling\nReal-time capable\nIntegration with do-mpc, CasADi, acados\n\nAdvanced Stochastic\n\nParticle filters\nStochastic MPC\nNoisy measurement models\nOther robust and/or stochastic control\n\nSystem Composition\n\nConnector protocol interfaces to couple multiple subsystems\n\n\n\n\nPotential Future Extensions\nLong-term possibilities:\n\nHybrid Systems\n\nSwitched dynamics\nHybrid automata\nJump/flow dynamics\n\nDistributed Systems\n\nMulti-agent dynamics\nNetwork topology\nConsensus protocols\n\nDelay Systems\n\nTime-delayed feedback\nDDE integration\nDelayed stability analysis\n\nPDE Systems\n\nSpatiotemporal dynamics\nFinite/discrete element methods\nSpectral methods",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-conclusion",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-conclusion",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Conclusion",
    "text": "Conclusion\nControlDESymulation demonstrates that mathematical rigor, software engineering excellence, and multi-backend performance are not competing goals—they are mutually reinforcing when built on a foundation of:\n\n\n\n\n\n\nImportantCore Design Principles\n\n\n\n\nType-Driven Design - Types are architecture\nComposition Over Inheritance - Build with utilities\nBackend Agnosticism - Write once, run anywhere\nZero Duplication - Strategic abstraction\nStructured Results - TypedDict everywhere\nProtocol Interfaces - Duck typing with safety\nFactory Patterns - Hide complexity\nSemantic Naming - Code reads like math\nProgressive Disclosure - Simple to complex\n\n\n\nThe result is a library where:\n\nControl theorists find familiar mathematics\nSoftware engineers find clean architecture\nML researchers find GPU acceleration\nStudents find gentle learning curves\nExperts find power and flexibility\n\nCode organized into 4 architectural layers, implementing 200+ types and 40+ integration methods—all serving a single vision: symbolic dynamical systems done right.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-appendix",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-appendix",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Appendix: Statistics Summary",
    "text": "Appendix: Statistics Summary\n\nType Distribution\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nVector Types\n15+\nStateVector, ControlVector\n\n\nMatrix Types\n30+\nStateMatrix, GainMatrix\n\n\nFunction Types\n10+\nDynamicsFunction, ControlPolicy\n\n\nBackend Types\n20+\nBackend, Device, NoiseType\n\n\nTrajectory Types\n15+\nStateTrajectory, IntegrationResult\n\n\nLinearization Types\n15+\nDeterministicLinearization\n\n\nSymbolic Types\n10+\nSymbolicExpression\n\n\nProtocol Types\n20+\nDynamicalSystemProtocol\n\n\nUtility Types\n20+\nExecutionStats, TypeGuards\n\n\nTypedDict Results\n15+\nIntegrationResult\n\n\nTOTAL\n200+\nComplete type system\n\n\n\n\n\nIntegration Methods\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nNumPy (scipy)\n6\nRK45, LSODA, BDF, Radau\n\n\nNumPy (Julia)\n20+\nTsit5, Vern9, Rodas5, AutoTsit5\n\n\nPyTorch\n8\ndopri5, dopri8, adaptive_heun\n\n\nJAX\n8\ntsit5, dopri5, heun, ralston\n\n\nFixed-step\n3\neuler, midpoint, rk4\n\n\nSDE Methods\n10+\neuler-maruyama, milstein, heun\n\n\nTOTAL\n55+\nComprehensive coverage\n\n\n\n\n\nDesign Patterns\n\n\n\nPattern\nCount\nWhere Used\n\n\n\n\nTemplate Method\n8\nAll system base classes\n\n\nFactory Method\n2\nIntegrator/SDE factories\n\n\nStrategy\n55+\nAll integration methods\n\n\nDependency Injection\n11\nAll delegation utilities\n\n\nLazy Initialization\n7\nCode generation, caching\n\n\nObserver\n5\nPerformance statistics\n\n\nProtocol\n20+\nAll structural interfaces\n\n\n\n\nThe numbers tell the story: a comprehensive, well-architected library built on solid design principles.",
    "crumbs": [
      "Installation Guide",
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-actual-problem",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-actual-problem",
    "title": "",
    "section": "The Actual Problem",
    "text": "The Actual Problem\nThe root cause was NOT in TorchSDEIntegrator - it was in dynamics_evaluator.py!\n\nError Message\nAttributeError: 'numpy.ndarray' object has no attribute 'unsqueeze'\nFile: dynamics_evaluator.py, line 364\n\n\nRoot Cause\nWhen using PyTorch or JAX backends with SDE integration:\n\nThe SDE wrapper’s f() method calls u_func(t, x) which returns:\n\nNone for autonomous systems\nnp.ndarray for controlled systems (from user’s control function)\n\nThis gets passed to sde_system.drift(x, u, backend='torch')\nWhich eventually calls _evaluate_torch(x, u)\nBut _evaluate_torch() expected u to already be a torch.Tensor!\nWhen it tried u.unsqueeze(0) on a numpy array → CRASH"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-fix",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-fix",
    "title": "",
    "section": "The Fix",
    "text": "The Fix\nAdded automatic type conversion at the start of _evaluate_torch() and _evaluate_jax():\n\nFor PyTorch (_evaluate_torch)\n# CRITICAL FIX: Convert inputs to torch tensors if needed\nimport torch\nimport numpy as np\n\n# Convert x if it's a numpy array\nif isinstance(x, np.ndarray):\n    x = torch.from_numpy(x).float()\n\n# Convert u if it's a numpy array, or create empty tensor if None\nif u is None:\n    # Autonomous system: create empty tensor\n    u = torch.tensor([], dtype=x.dtype, device=x.device)\nelif isinstance(u, np.ndarray):\n    # Convert numpy array to torch tensor with same dtype and device as x\n    u = torch.from_numpy(u).to(dtype=x.dtype, device=x.device)\n\n\nFor JAX (_evaluate_jax)\n# CRITICAL FIX: Convert inputs to jax arrays if needed\nimport jax.numpy as jnp\nimport numpy as np\n\nif isinstance(x, np.ndarray):\n    x = jnp.array(x)\n\n# Convert u if it's a numpy array, or create empty array if None\nif u is None:\n    # Autonomous system: create empty array\n    u = jnp.array([])\nelif isinstance(u, np.ndarray):\n    # Convert numpy array to jax array\n    u = jnp.array(u)"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#impact",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#impact",
    "title": "",
    "section": "Impact",
    "text": "Impact\nThis fix makes ALL of the following work correctly: - ✅ PyTorch SDE integration - ✅ JAX SDE integration - ✅ PyTorch ODE integration with numpy control functions - ✅ JAX ODE integration with numpy control functions - ✅ Autonomous systems (u=None) - ✅ Controlled systems with numpy arrays - ✅ Mixed backend workflows"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#why-this-happened",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#why-this-happened",
    "title": "",
    "section": "Why This Happened",
    "text": "Why This Happened\nThe code assumed that if backend='torch' was specified, then ALL inputs would already be torch tensors. But in practice:\n\nControl functions often return numpy arrays (natural for users)\nAutonomous systems pass None for control\nThe conversion from None → empty tensor was happening in evaluate() but not reaching _evaluate_torch() in all code paths"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#files-changed",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#files-changed",
    "title": "",
    "section": "Files Changed",
    "text": "Files Changed\ndynamics_evaluator.py: - Line ~315: Added type conversion for _evaluate_torch() - Line ~436: Added type conversion for _evaluate_jax() - Docstring: Added note about automatic type conversion"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#what-was-not-broken",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#what-was-not-broken",
    "title": "",
    "section": "What Was NOT Broken",
    "text": "What Was NOT Broken\n\nTorchSDEIntegrator: Actually works fine once inputs are correct types\nTime grid generation: Was creating 1001 points correctly\ntorchsde library: Works as expected"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#testing-recommendations",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#testing-recommendations",
    "title": "",
    "section": "Testing Recommendations",
    "text": "Testing Recommendations\nAfter applying this fix, test:\n# Test 1: Autonomous SDE with PyTorch\nsystem.set_default_backend('torch')\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='euler', dt=0.01)\nassert result['x'].shape[0] &gt; 100  # Should get full trajectory\n\n# Test 2: Controlled SDE with numpy control function\ndef controller(t, x):\n    return np.array([0.5])  # Returns numpy!\n\nresult = system.integrate(x0, u=controller, t_span=(0, 10), method='euler', dt=0.01)\nassert result['x'].shape[0] &gt; 100\n\n# Test 3: Same tests with JAX backend\nsystem.set_default_backend('jax')\n# ... repeat tests"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#summary",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Summary\nOne type conversion bug in dynamics_evaluator.py was breaking: - All PyTorch SDE integrations - All JAX SDE integrations\n- Any torch/jax usage with numpy control functions\nThe fix: 10 lines of type conversion code in 2 methods.\nResult: Entire PyTorch and JAX backends now work correctly for SDEs!"
  },
  {
    "objectID": "tutorials/basic_usage.html",
    "href": "tutorials/basic_usage.html",
    "title": "Basic Usage",
    "section": "",
    "text": "This tutorial covers the basics of defining and simulating dynamical systems.",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  },
  {
    "objectID": "tutorials/basic_usage.html#sec-introduction",
    "href": "tutorials/basic_usage.html#sec-introduction",
    "title": "Basic Usage",
    "section": "",
    "text": "This tutorial covers the basics of defining and simulating dynamical systems.",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  },
  {
    "objectID": "tutorials/basic_usage.html#sec-setting-up",
    "href": "tutorials/basic_usage.html#sec-setting-up",
    "title": "Basic Usage",
    "section": "Setting Up",
    "text": "Setting Up\nFirst, import the necessary modules:\n\nimport numpy as np\nimport sympy as sp\nfrom cdesym import ContinuousSymbolicSystem\n\n# Set random seed for reproducibility\nnp.random.seed(42)",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  },
  {
    "objectID": "tutorials/basic_usage.html#sec-defining-a-simple-system",
    "href": "tutorials/basic_usage.html#sec-defining-a-simple-system",
    "title": "Basic Usage",
    "section": "Defining a Simple System",
    "text": "Defining a Simple System\nLet’s create a simple pendulum:\n\nclass SymbolicPendulum(ContinuousSymbolicSystem):\n    def define_system(\n        self,\n        m_val: float = 1.0,\n        l_val: float = 1.0,\n        beta_val: float = 1.0,\n        g_val: float = 9.81,\n    ):\n        \"\"\"First order model of a pendulum\"\"\"\n        # define the symbolic variables\n        theta, theta_dot = sp.symbols(\"theta theta_dot\", real=True)\n        u = sp.symbols(\"u\", real=True)\n        m, l, beta, g = sp.symbols(\"m l beta g\", real=True, positive=True)\n\n        # add the variables to the system fields properly\n        self.parameters = {m: m_val, l: l_val, beta: beta_val, g: g_val}\n        self.state_vars = [theta, theta_dot]\n        self.control_vars = [u]\n        self.order = 1\n\n        # define the dynamics of the system\n        ml2 = m * l * l\n        self._f_sym = sp.Matrix(\n            [theta_dot, (-beta / ml2) * theta_dot + (g / l) * sp.sin(theta) + u / ml2],\n        )\n        self._h_sym = sp.Matrix([theta])\n\n    def setup_equilibria(self):\n        # method to add equilibria to the system automatically after initialization\n\n        # add the stable equilibrium where the pendulum is hanging down\n        self.add_equilibrium(\n            'downward',\n            x_eq=np.array([0.0, 0.0]),\n            u_eq=np.array([0.0]),\n            verify=True\n            )\n\n        # add the unstable equilibrium where the pendulum is inverted\n        self.add_equilibrium(\n            'inverted',\n            x_eq=np.array([np.pi, 0.0]),\n            u_eq=np.array([0.0]),\n            stability='unstable',\n            notes='Requires active control'\n            )\n\n# Instantiate the system\npendulum = SymbolicPendulum()\n\n# Initial conditions\nx0 = np.array([1.0, 0.0])",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  },
  {
    "objectID": "tutorials/basic_usage.html#sec-simulation",
    "href": "tutorials/basic_usage.html#sec-simulation",
    "title": "Basic Usage",
    "section": "Simulation",
    "text": "Simulation\nNow simulate the system:\n\n# Integrate a trajectory with auto-selection of\n# relevant arguments\npendulum_integration_result = pendulum.integrate(\n        x0=x0,\n        t_span = (0.0, 20.0)\n    )\nfor k, v in pendulum_integration_result.items():\n    if k != \"x\" and k != \"t\":\n        print(k, \" : \", v)\n\nsuccess  :  True\nmessage  :  The solver successfully reached the end of the integration interval.\nnfev  :  1442\nnsteps  :  1442\nintegration_time  :  0.020517826080322266\nsolver  :  scipy.RK45\nnjev  :  0\nnlu  :  0\nstatus  :  0",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  },
  {
    "objectID": "tutorials/basic_usage.html#sec-visualization",
    "href": "tutorials/basic_usage.html#sec-visualization",
    "title": "Basic Usage",
    "section": "Visualization",
    "text": "Visualization\nPlot the trajectory in 2D:\n\nSTATE_NAMES = ['angle', 'angular velocity']\ntrajectory_plot = pendulum.plot(\n    result=pendulum_integration_result,\n    state_names = STATE_NAMES\n)\ntrajectory_plot.show()",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  },
  {
    "objectID": "tutorials/basic_usage.html#sec-phase-portrait",
    "href": "tutorials/basic_usage.html#sec-phase-portrait",
    "title": "Basic Usage",
    "section": "Phase Portrait",
    "text": "Phase Portrait\nPlot the 2D phase portrait\n\nupright_state, _ = pendulum.get_equilibrium('inverted')\ndownward_state, _ = pendulum.get_equilibrium('downward')\nphase_portrait = pendulum.phase_plotter.plot_2d(\n    x=pendulum_integration_result['x'],\n    state_names = STATE_NAMES,\n    show_direction = True,\n    equilibria=[upright_state, \n                downward_state]\n)\nphase_portrait.show()",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  },
  {
    "objectID": "tutorials/basic_usage.html#sec-next-steps",
    "href": "tutorials/basic_usage.html#sec-next-steps",
    "title": "Basic Usage",
    "section": "Next Steps",
    "text": "Next Steps\n\nLearn about stochastic systems not implemented\nExplore different backends not implemented\nSee advanced examples not implemented",
    "crumbs": [
      "Small Demonstrations of Basic Functionality",
      "Basic Usage"
    ]
  }
]