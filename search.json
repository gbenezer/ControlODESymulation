[
  {
    "objectID": "tutorials/getting_started/installation.html",
    "href": "tutorials/getting_started/installation.html",
    "title": "Installation Guide",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic dynamical systems with multi-backend support. This guide covers installation methods, backend configuration, and verification steps."
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-overview",
    "href": "tutorials/getting_started/installation.html#sec-overview",
    "title": "Installation Guide",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic dynamical systems with multi-backend support. This guide covers installation methods, backend configuration, and verification steps."
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-requirements",
    "href": "tutorials/getting_started/installation.html#sec-requirements",
    "title": "Installation Guide",
    "section": "Requirements",
    "text": "Requirements\n\nSystem Requirements\n\nPython 3.9 or higher\npip package manager\n(Optional) GPU with CUDA support for PyTorch/JAX acceleration\n\n\n\nCore Dependencies\nThe library requires:\n\nnumpy - Core numerical operations\nscipy - Scientific computing and integration\nsympy - Symbolic mathematics\nmatplotlib - Visualization\n\n\n\nOptional Backend Dependencies\n\nPyTorch: torch - For automatic differentiation and GPU acceleration\nJAX: jax, jaxlib - For high-performance numerical computing and JIT compilation"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-installation-methods",
    "href": "tutorials/getting_started/installation.html#sec-installation-methods",
    "title": "Installation Guide",
    "section": "Installation Methods",
    "text": "Installation Methods\n\nStandard Installation (NumPy Only)\nFor basic functionality with NumPy backend:\npip install cdesym\nThis installs the core library with NumPy support, suitable for most educational and prototyping applications.\n\n\nInstallation with PyTorch Backend\nFor neural network integration and GPU acceleration:\npip install \"cdesym[torch]\"\nFor specific CUDA versions, install PyTorch first:\n# Example: CUDA 11.8\npip install torch --index-url https://download.pytorch.org/whl/cu118\npip install \"cdesym[torch]\"\n\n\nInstallation with JAX Backend\nFor high-performance computing and JIT compilation:\npip install \"cdesym[jax]\"\nFor GPU support with JAX:\n# CUDA 12\npip install \"cdesym[jax]\" \"jax[cuda12]\"\n\n# CUDA 11\npip install \"cdesym[jax]\" \"jax[cuda11]\"\n\n\nInstallation with Julia DifferentialEquations.jl and DiffEqPy\nFor support for Julia DifferentialEquations.jl support, first install Julia and add it to the environment path so that it can be discovered. Then, install and pre-compile DifferentialEquations.jl.\nOnce that is done, then execute the following:\npip install \"cdesym[julia]\"\n\n\nDevelopment Installation\nTo install from source for development or to access the latest features:\ngit clone https://github.com/yourusername/ControlDESymulation.git\ncd ControlDESymulation\npip install -e .\nThe -e flag installs in editable mode, allowing you to modify the source code without reinstalling.\n\n\nInstalling All Backends\nFor full functionality with all backends (including Julia support):\nFirst install Julia and DifferentialEquations.jl, then\npip install \"cdesym[torch,jax,julia]\"\n\n\nOther options\nThese flags will install core library dependencies PLUS\npip install \"cdesym[viz]\"\nPlotly, matplotlib, and seaborn\npip install \"cdesym[control]\"\nPython control library\npip install \"cdesym[optimization]\"\nCVXPY, Clarabel, OSPQ, SCS, CasADi (for future functionality)\npip install \"cdesym[dev]\"\nPytest and many associated Pytest extensions, Coverage.py, Mutmut, Black, isort, ruff, mypy and extensions, flake8, pylint, bandit, safety, pre-commit, radon, pydeps types-requests, types-setuptools, build, twine, setuptools, and wheel\npip install \"cdesym[docs]\"\nSphinx and associated extensions, myst-parser\npip install \"cdesym[notebooks]\"\nJupyter, JupyterLab, IPyKernel, IPyWidgets, Notebook, and IPython"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-backend-configuration",
    "href": "tutorials/getting_started/installation.html#sec-backend-configuration",
    "title": "Installation Guide",
    "section": "Backend Configuration",
    "text": "Backend Configuration\n\nSetting the Default Backend\nControlDESymulation automatically detects available backends. You can explicitly set the backend:\nfrom cdesym import DynamicalSystem\n\n# Using NumPy (default)\nsystem = DynamicalSystem(..., backend='numpy')\n\n# Using PyTorch\nsystem = DynamicalSystem(..., backend='torch')\n\n# Using JAX\nsystem = DynamicalSystem(..., backend='jax')\n\n\nBackend Priority\nWhen no backend is specified, the library searches in order:\n\nJAX (if available)\nPyTorch (if available)\nNumPy (always available)\n\n\n\nChecking Available Backends\nfrom cdesym.backends import get_available_backends\n\nprint(get_available_backends())\n# Output: ['numpy', 'torch', 'jax']"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-verification",
    "href": "tutorials/getting_started/installation.html#sec-verification",
    "title": "Installation Guide",
    "section": "Verification",
    "text": "Verification\n\nBasic Installation Check\nVerify the installation:\nimport cdesym\nprint(cdesym.__version__)\n\n\nTesting Backend Functionality\nTest each backend with a simple system:\nimport sympy as sp\nfrom cdesym import DynamicalSystem\n\n# Define symbolic variables\nx, y = sp.symbols('x y')\n\n# Define a simple system: dx/dt = -x, dy/dt = -y\ndynamics = sp.Matrix([-x, -y])\nstate_vars = sp.Matrix([x, y])\n\n# Test NumPy backend\nsystem_np = DynamicalSystem(\n    dynamics=dynamics,\n    state_vars=state_vars,\n    backend='numpy'\n)\n\n# Test simulation\nt_span = (0, 5)\ninitial_state = [1.0, 1.0]\nresult = system_np.simulate(t_span, initial_state)\nprint(f\"NumPy backend: {len(result.t)} time points\")\n\n# Test PyTorch backend (if available)\ntry:\n    system_torch = DynamicalSystem(\n        dynamics=dynamics,\n        state_vars=state_vars,\n        backend='torch'\n    )\n    print(\"PyTorch backend: Available\")\nexcept ImportError:\n    print(\"PyTorch backend: Not available\")\n\n# Test JAX backend (if available)\ntry:\n    system_jax = DynamicalSystem(\n        dynamics=dynamics,\n        state_vars=state_vars,\n        backend='jax'\n    )\n    print(\"JAX backend: Available\")\nexcept ImportError:\n    print(\"JAX backend: Not available\")\n\n\nRunning Test Suite\nIf you have the development installation, run the test suite:\npytest tests/\nFor specific backend tests:\npytest tests/test_numpy_backend.py\npytest tests/test_torch_backend.py\npytest tests/test_jax_backend.py"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-troubleshooting",
    "href": "tutorials/getting_started/installation.html#sec-troubleshooting",
    "title": "Installation Guide",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nImport Errors\nProblem: ModuleNotFoundError: No module named 'cdesym'\nSolution: Ensure installation completed successfully:\npip list | grep cdesym\n\n\nBackend Not Available\nProblem: “Backend ‘torch’ not available”\nSolution: Install the required backend:\npip install torch\n\n\nCUDA/GPU Issues\nProblem: PyTorch or JAX not utilizing GPU\nSolution: Verify GPU availability:\n# For PyTorch\nimport torch\nprint(torch.cuda.is_available())\n\n# For JAX\nimport jax\nprint(jax.devices())\nInstall appropriate CUDA-enabled versions if needed.\n\n\nSymPy Compatibility\nProblem: Symbolic computation errors\nSolution: Ensure SymPy is up to date:\npip install --upgrade sympy\n\n\nNumerical Integration Warnings\nProblem: Integration warnings during simulation\nSolution: These are typically harmless but can be addressed by: - Adjusting tolerance parameters (atol, rtol) - Using different integration methods - Checking system stability"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-gpu-acceleration-setup",
    "href": "tutorials/getting_started/installation.html#sec-gpu-acceleration-setup",
    "title": "Installation Guide",
    "section": "GPU Acceleration Setup",
    "text": "GPU Acceleration Setup\n\nPyTorch GPU Configuration\nimport torch\n\n# Check CUDA availability\nif torch.cuda.is_available():\n    device = torch.device('cuda')\n    print(f\"Using GPU: {torch.cuda.get_device_name(0)}\")\nelse:\n    device = torch.device('cpu')\n    print(\"Using CPU\")\n\n# Create system with PyTorch backend\nsystem = DynamicalSystem(..., backend='torch')\n\n# Move tensors to GPU when needed\ninitial_state_gpu = torch.tensor(initial_state).to(device)\n\n\nJAX GPU Configuration\nimport jax\n\n# JAX automatically uses GPU if available\nprint(f\"JAX backend: {jax.default_backend()}\")\nprint(f\"JAX devices: {jax.devices()}\")\n\n# Verify GPU usage\nimport jax.numpy as jnp\nx = jnp.ones(1000)\nprint(x.device())  # Should show GPU device"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-virtual-environment-setup",
    "href": "tutorials/getting_started/installation.html#sec-virtual-environment-setup",
    "title": "Installation Guide",
    "section": "Virtual Environment Setup",
    "text": "Virtual Environment Setup\n\nUsing venv\n# Create virtual environment\npython -m venv cds_env\n\n# Activate (Linux/Mac)\nsource cds_env/bin/activate\n\n# Activate (Windows)\ncds_env\\Scripts\\activate\n\n# Install ControlDESymulation\npip install cdesym\n\n\nUsing conda\n# Create conda environment\nconda create -n cds_env python=3.12\n\n# Activate environment\nconda activate cds_env\n\n# Install ControlDESymulation\npip install cdesym"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-next-steps",
    "href": "tutorials/getting_started/installation.html#sec-next-steps",
    "title": "Installation Guide",
    "section": "Next Steps",
    "text": "Next Steps\nAfter successful installation:\n\nReview the Quick Start Guide for basic usage examples\nExplore Tutorials for detailed walkthroughs\nCheck API Reference for comprehensive documentation\nSee Examples Gallery for application demonstrations"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-getting-help",
    "href": "tutorials/getting_started/installation.html#sec-getting-help",
    "title": "Installation Guide",
    "section": "Getting Help",
    "text": "Getting Help\nIf you encounter issues not covered here:\n\nCheck the GitHub Issues\nReview the FAQ\nJoin the Discussions"
  },
  {
    "objectID": "tutorials/getting_started/installation.html#sec-version-information",
    "href": "tutorials/getting_started/installation.html#sec-version-information",
    "title": "Installation Guide",
    "section": "Version Information",
    "text": "Version Information\nCheck your installed version:\nimport cdesym\nprint(f\"ControlDESymulation version: {cdesym.__version__}\")\nUpdate to the latest version:\npip install --upgrade cdesym"
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Installation\nBasic Usage"
  },
  {
    "objectID": "tutorials/index.html#sec-getting-started",
    "href": "tutorials/index.html#sec-getting-started",
    "title": "Tutorials",
    "section": "",
    "text": "Installation\nBasic Usage"
  },
  {
    "objectID": "tutorials/index.html#sec-core-concepts-chemical",
    "href": "tutorials/index.html#sec-core-concepts-chemical",
    "title": "Tutorials",
    "section": "Core Concepts of Continuous Systems: A Tutorial Series Using Chemical Reactors",
    "text": "Core Concepts of Continuous Systems: A Tutorial Series Using Chemical Reactors\n\nAnatomy of a Symbolic System: Stochastic Batch Reactors\nComparing Systems: Deterministic and Stochastic Reactors\nSystem Discretization\nControlling a Batch Reactor"
  },
  {
    "objectID": "tutorials/index.html#sec-advanced-topics",
    "href": "tutorials/index.html#sec-advanced-topics",
    "title": "Tutorials",
    "section": "Advanced Topics",
    "text": "Advanced Topics\n\nTODO: Plan and make these"
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html",
    "href": "architecture/UI_Framework_Architecture.html",
    "title": "UI Framework Architecture",
    "section": "",
    "text": "The UI (User Interface) Framework is Layer 3 of the architecture, consisting of 8 core files organized into a 4-layer hierarchy that provides the user-facing API for defining and working with dynamical systems. This layer eliminates approximately 1,800 lines of code duplication while maintaining clean separation of concerns.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nLayer 0: SymbolicSystemBase - Time-domain agnostic foundation\nLayer 1: ContinuousSystemBase, DiscreteSystemBase - Time-domain interfaces\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem - Concrete implementations\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem - Stochastic extensions\nSpecial: DiscretizedSystem - Continuous → discrete conversion\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nMost users interact with the UI framework at two levels:\n# Level 1: Use built-in systems (simplest)\nfrom cdesym import Pendulum, CartPole, VanDerPol\n\nsystem = Pendulum()\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\n\n# Level 2: Define custom systems (subclass framework)\nfrom cdesym import ContinuousSymbolicSystem\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\nUsers should NOT: - Directly instantiate internal utilities (BackendManager, CodeGenerator, etc.) - Access private attributes (those starting with _) - Override methods other than define_system() and print_equations()\nThe framework automatically composes internal components and exposes functionality through clean public methods. This documentation describes the internal architecture for framework developers.",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-overview",
    "href": "architecture/UI_Framework_Architecture.html#sec-overview",
    "title": "UI Framework Architecture",
    "section": "",
    "text": "The UI (User Interface) Framework is Layer 3 of the architecture, consisting of 8 core files organized into a 4-layer hierarchy that provides the user-facing API for defining and working with dynamical systems. This layer eliminates approximately 1,800 lines of code duplication while maintaining clean separation of concerns.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nLayer 0: SymbolicSystemBase - Time-domain agnostic foundation\nLayer 1: ContinuousSystemBase, DiscreteSystemBase - Time-domain interfaces\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem - Concrete implementations\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem - Stochastic extensions\nSpecial: DiscretizedSystem - Continuous → discrete conversion\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nMost users interact with the UI framework at two levels:\n# Level 1: Use built-in systems (simplest)\nfrom cdesym import Pendulum, CartPole, VanDerPol\n\nsystem = Pendulum()\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\n\n# Level 2: Define custom systems (subclass framework)\nfrom cdesym import ContinuousSymbolicSystem\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\nUsers should NOT: - Directly instantiate internal utilities (BackendManager, CodeGenerator, etc.) - Access private attributes (those starting with _) - Override methods other than define_system() and print_equations()\nThe framework automatically composes internal components and exposes functionality through clean public methods. This documentation describes the internal architecture for framework developers.",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/UI_Framework_Architecture.html#sec-architecture-philosophy",
    "title": "UI Framework Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nLayered Composition with Strategic Inheritance - The UI framework achieves:\n\nZero Code Duplication - Shared functionality lives in exactly one place\nClean Separation - Each layer has a single, focused responsibility\nProgressive Complexity - Simple systems inherit from basic layers\nType Safety - Comprehensive type annotations throughout\nExtensibility - Clear extension points via define_system()\nBackend Agnosticism - Multi-backend support transparent to users\n\nThe architecture uses cooperative multiple inheritance strategically at Layer 2 to combine symbolic machinery with time-domain interfaces, avoiding the duplication that would occur with composition alone.",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-architecture-layers",
    "href": "architecture/UI_Framework_Architecture.html#sec-architecture-layers",
    "title": "UI Framework Architecture",
    "section": "Architecture Layers",
    "text": "Architecture Layers\n┌─────────────────────────────────────────────────────────────┐\n│  Layer 0: SymbolicSystemBase (time-domain agnostic)         │\n│  • Symbolic variables and parameters                        │\n│  • Code generation and backend management                   │\n│  • Equilibrium handling and configuration                   │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n          ┌──────────┴──────────┐\n          │                     │\n┌─────────▼────────┐  ┌─────────▼─────────┐\n│  Layer 1:        │  │  Layer 1:         │\n│  Continuous      │  │  Discrete         │\n│  SystemBase      │  │  SystemBase       │\n│  • dx/dt = f     │  │  • x[k+1] = f     │\n│  • integrate()   │  │  • step()         │\n│  • linearize()   │  │  • simulate()     │\n└─────────┬────────┘  └─────────┬─────────┘\n          │                     │\n    ┌─────┴─────┐         ┌─────┴─────┐\n    │           │         │           │\n┌───▼────┐  ┌───▼────┐ ┌─▼──────┐ ┌──▼──────┐\n│Layer 2:│  │Layer 3:│ │Layer 2:│ │Layer 3: │\n│Cont.   │  │Cont.   │ │Disc.   │ │Disc.    │\n│Symbolic│  │Stoch.  │ │Symbolic│ │Stoch.   │\n│System  │  │System  │ │System  │ │System   │\n└────────┘  └────────┘ └────────┘ └─────────┘",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-0",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-0",
    "title": "UI Framework Architecture",
    "section": "Layer 0: Foundation",
    "text": "Layer 0: Foundation\n\nSymbolicSystemBase: Time-Agnostic Foundation\nFile: symbolic_system_base.py\nThe SymbolicSystemBase provides all symbolic manipulation and backend management functionality, making no assumptions about continuous vs discrete time.\nCore responsibilities:\n\nSymbolic variable management - State, control, and output variables\nParameter handling - Symbolic parameters with numeric values\nCode generation - Symbolic → numerical via CodeGenerator\nBackend management - NumPy/PyTorch/JAX switching via BackendManager\nEquilibrium management - Named equilibria via EquilibriumHandler\nConfiguration persistence - Save/load system definitions\nValidation - Symbolic system validation via SymbolicValidator\n\nKey design patterns:\n\nComposition - Delegates to specialized utilities\nTemplate Method - __init__ orchestrates: define → validate → initialize\nAbstract Methods - Forces subclasses to implement define_system()\n\nWhat Layer 0 does NOT provide:\n\nForward dynamics evaluation (__call__, step)\nTime integration (integrate, simulate)\nLinearization computation\nThese are time-domain specific and live in Layer 1\n\nInternal composition (users never access these directly):\n\n\nCode\nsystem = Pendulum()\n\n# Internal utilities (composed automatically)\nbackend_mgr = system.backend           # BackendManager\ncode_gen = system._code_gen            # CodeGenerator\nequilibria = system.equilibria         # EquilibriumHandler\nvalidator = system._validator          # SymbolicValidator\n\nprint(\"✓ Layer 0 composes internal utilities transparently\")\n\n\nUser-facing Layer 0 methods:\n\n\nCode\n# Backend management\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\n# Equilibrium management\nsystem.add_equilibrium('origin', x_eq=np.zeros(2), u_eq=np.zeros(1))\nx_eq, u_eq = system.get_equilibrium('origin')\nequilibria_list = system.list_equilibria()\n\n# Configuration\n# config = system.save_config('pendulum_config.json')\n# system_loaded = Pendulum.load_config('pendulum_config.json')\n\nprint(f\"System order: {system.order}\")\nprint(f\"State dimension: {system.nx}\")\nprint(f\"Control dimension: {system.nu}\")\n\n\nAbstract methods subclasses must implement:\n@abstractmethod\ndef define_system(self, **params):\n    \"\"\"Define symbolic system components.\n    \n    Must set:\n    - self.state_vars: List[sp.Symbol]\n    - self.control_vars: List[sp.Symbol]\n    - self._f_sym: sp.Matrix (dynamics)\n    - self.parameters: Dict[sp.Symbol, float]\n    - self.order: int\n    \"\"\"\n    pass\n\n@abstractmethod\ndef print_equations(self, simplify: bool = True):\n    \"\"\"Print system equations in readable form.\"\"\"\n    pass",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-1",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-1",
    "title": "UI Framework Architecture",
    "section": "Layer 1: Time-Domain Interfaces",
    "text": "Layer 1: Time-Domain Interfaces\n\nContinuousSystemBase: Continuous-Time Interface\nFile: continuous_system_base.py\nThe ContinuousSystemBase defines the abstract interface for continuous-time systems described by ODEs.\nMathematical form:\n\\[\\frac{dx}{dt} = f(x, u, t)\\]\nCore responsibilities:\n\nDynamics evaluation - Abstract __call__(x, u) for forward dynamics\nNumerical integration - Abstract integrate() with multi-method support\nLinearization - Abstract linearize() for Jacobian computation\nHigh-level simulation - Concrete simulate() with controller support\n\nAbstract methods (Layer 2 implements):\n@abstractmethod\ndef __call__(\n    self, \n    x: StateVector, \n    u: Optional[ControlVector] = None\n) -&gt; StateVector:\n    \"\"\"Evaluate dx/dt = f(x, u).\"\"\"\n    pass\n\n@abstractmethod\ndef integrate(\n    self,\n    x0: StateVector,\n    u: Optional[Union[ControlVector, Callable]] = None,\n    t_span: TimeSpan = (0, 10),\n    **kwargs\n) -&gt; IntegrationResult:\n    \"\"\"Integrate system over time span.\"\"\"\n    pass\n\n@abstractmethod\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute A = ∂f/∂x, B = ∂f/∂u.\"\"\"\n    pass\nConcrete method (provided by Layer 1):\ndef simulate(\n    self,\n    x0: StateVector,\n    controller: Optional[Callable[[float, StateVector], ControlVector]] = None,\n    t_span: TimeSpan = (0, 10),\n    dt: float = 0.01,\n    **kwargs\n) -&gt; Dict[str, np.ndarray]:\n    \"\"\"High-level simulation with regular time grid.\n    \n    Returns\n    -------\n    dict with keys:\n        'time': Regular time points (T,)\n        'states': State trajectory (T, nx)\n        'controls': Control sequence (T, nu)\n    \"\"\"\nUsage example:\n\n\nCode\nsystem = Pendulum()\n\n# Evaluate dynamics (Layer 1 interface)\nx = np.array([0.5, 0.0])\nu = np.array([0.0])\ndx = system(x, u)\nprint(f\"State derivative: {dx}\")\n\n# Integrate (adaptive time grid)\nresult = system.integrate(x, u=None, t_span=(0, 5), method='RK45')\nprint(f\"Integration steps: {result['nsteps']}\")\n\n# Simulate (regular time grid - better for plotting)\nsim_result = system.simulate(x, controller=None, t_span=(0, 5), dt=0.01)\nprint(f\"Simulation time points: {len(sim_result['time'])}\")\n\n# Linearize\nx_eq, u_eq = system.get_equilibrium('origin')\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix: {A.shape}\")\n\n\nKey features:\n\nFlexible control input (None, arrays, or callable controllers)\nMulti-backend integration support (scipy, Julia, PyTorch, JAX)\nDense output and adaptive stepping available\nComprehensive solver diagnostics\n\n\n\nDiscreteSystemBase: Discrete-Time Interface\nFile: discrete_system_base.py\nThe DiscreteSystemBase defines the abstract interface for discrete-time systems.\nMathematical form:\n\\[x[k+1] = f(x[k], u[k], k)\\]\nCore responsibilities:\n\nSingle step - Abstract step(x, u) for one time step\nMulti-step simulation - Abstract simulate() for trajectories\nLinearization - Abstract linearize() for discrete Jacobians\nSampling properties - Concrete dt property and sampling_frequency\n\nAbstract property (must implement):\n@property\n@abstractmethod\ndef dt(self) -&gt; float:\n    \"\"\"Sampling period [seconds].\"\"\"\n    pass\nAbstract methods (Layer 2 implements):\n@abstractmethod\ndef step(\n    self,\n    x: StateVector,\n    u: Optional[ControlVector] = None,\n    k: int = 0\n) -&gt; StateVector:\n    \"\"\"Single time step: x[k] → x[k+1].\"\"\"\n    pass\n\n@abstractmethod\ndef simulate(\n    self,\n    x0: StateVector,\n    u_sequence: Optional[ControlSequence] = None,\n    n_steps: int = 100,\n    **kwargs\n) -&gt; Dict[str, np.ndarray]:\n    \"\"\"Multi-step simulation.\"\"\"\n    pass\n\n@abstractmethod\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute Ad = ∂f/∂x, Bd = ∂f/∂u (discrete Jacobians).\"\"\"\n    pass\nConcrete properties (provided by Layer 1):\n@property\ndef sampling_frequency(self) -&gt; float:\n    \"\"\"Sampling frequency [Hz].\"\"\"\n    return 1.0 / self.dt\nKey conventions:\n\nTime-major ordering - Arrays are (n_steps, nx), not (nx, n_steps)\nControl sequences - Pre-computed controls or None for autonomous systems\nState feedback - rollout() method for policy-based simulation",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-2",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-2",
    "title": "UI Framework Architecture",
    "section": "Layer 2: Concrete Symbolic Implementations",
    "text": "Layer 2: Concrete Symbolic Implementations\n\nContinuousSymbolicSystem: Symbolic + Continuous\nFile: continuous_symbolic_system.py\nInheritance: SymbolicSystemBase + ContinuousSystemBase (cooperative multiple inheritance)\nThe ContinuousSymbolicSystem combines symbolic machinery (Layer 0) with continuous-time execution (Layer 1).\nKey internal components (automatically composed):\n\nDynamicsEvaluator - Evaluates dx/dt = f(x, u)\nLinearizationEngine - Computes A = ∂f/∂x, B = ∂f/∂u\nObservationEngine - Evaluates y = h(x), C = ∂h/∂x\nIntegratorFactory - Creates appropriate ODE solvers\n\nImplemented methods (Layer 1 abstractions):\ndef __call__(\n    self, \n    x: StateVector, \n    u: Optional[ControlVector] = None\n) -&gt; StateVector:\n    \"\"\"Evaluate dx/dt = f(x, u) using DynamicsEvaluator.\"\"\"\n    return self._dynamics.evaluate(x, u, backend=self.backend.default_backend)\n\ndef integrate(\n    self,\n    x0: StateVector,\n    u: Optional[Union[ControlVector, Callable]] = None,\n    t_span: TimeSpan = (0, 10),\n    method: Optional[str] = None,\n    **kwargs\n) -&gt; IntegrationResult:\n    \"\"\"Integrate using IntegratorFactory.\"\"\"\n    # Creates appropriate integrator and delegates\n\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; Tuple[StateMatrix, InputMatrix]:\n    \"\"\"Compute Jacobians using LinearizationEngine.\"\"\"\n    return self._linearization.linearize_continuous(x_eq, u_eq)\nUser subclass pattern:\n\n\nCode\nclass SpringMassDamper(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0, c=0.5):\n        \"\"\"Define mass-spring-damper system.\"\"\"\n        # Symbolic variables\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n        \n        # System definition\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            v,\n            (-k_sym*x - c_sym*v + u)/m_sym\n        ])\n        self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Mass-Spring-Damper Equations:\")\n        print(\"  dx/dt = v\")\n        print(\"  dv/dt = (-k*x - c*v + u)/m\")\n\n# Use the system\nsystem = SpringMassDamper(m=2.0, k=5.0)\nx0 = np.array([1.0, 0.0])\nresult = system.simulate(x0, controller=None, t_span=(0, 10))\nprint(f\"✓ Custom continuous symbolic system\")\n\n\n\n\nDiscreteSymbolicSystem: Symbolic + Discrete\nFile: discrete_symbolic_system.py\nInheritance: SymbolicSystemBase + DiscreteSystemBase (cooperative multiple inheritance)\nThe DiscreteSymbolicSystem combines symbolic machinery with discrete-time execution.\nKey internal components:\n\nDynamicsEvaluator - Evaluates x[k+1] = f(x[k], u[k])\nLinearizationEngine - Computes Ad = ∂f/∂x, Bd = ∂f/∂u\nObservationEngine - Evaluates y[k] = h(x[k])\n\nCritical requirement:\n\n\n\n\n\n\nImportantRequired: Set self._dt\n\n\n\nDiscrete systems must set self._dt in define_system(). This is the sampling period that defines the discrete-time grid.\n\n\nUser subclass pattern:\n\n\nCode\nclass DiscreteLinearSystem(DiscreteSymbolicSystem):\n    def define_system(self, a=0.9, b=0.1, dt=0.01):\n        \"\"\"Define discrete linear system.\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        a_sym, b_sym = sp.symbols('a b', real=True)\n        \n        # System definition\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([a_sym*x + b_sym*u])\n        self.parameters = {a_sym: a, b_sym: b}\n        self._dt = dt  # REQUIRED for discrete systems!\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Discrete Linear System:\")\n        print(f\"  x[k+1] = a*x[k] + b*u[k]\")\n        print(f\"  dt = {self._dt}s\")\n\n# Use the system\nsystem = DiscreteLinearSystem(a=0.95, dt=0.1)\nx0 = np.array([1.0])\nresult = system.simulate(x0, u_sequence=None, n_steps=50)\nprint(f\"✓ Custom discrete symbolic system\")",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-layer-3",
    "href": "architecture/UI_Framework_Architecture.html#sec-layer-3",
    "title": "UI Framework Architecture",
    "section": "Layer 3: Stochastic Extensions",
    "text": "Layer 3: Stochastic Extensions\n\nContinuousStochasticSystem: SDE Support\nFile: continuous_stochastic_system.py\nInheritance: ContinuousSymbolicSystem (single inheritance - extends deterministic)\nThe ContinuousStochasticSystem adds stochastic differential equation (SDE) support to continuous systems.\nMathematical form:\n\\[dx = f(x, u, t)dt + g(x, u, t)dW\\]\nwhere: - \\(f(x, u, t)\\) - Drift (inherited from parent) - \\(g(x, u, t)\\) - Diffusion matrix (added here) - \\(dW\\) - Brownian motion increments\nAdditional internal components:\n\nDiffusionHandler - Generates and caches diffusion functions\nNoiseCharacterizer - Automatic noise structure analysis\nSDEValidator - SDE-specific validation\nSDEIntegratorFactory - Stochastic integration methods\n\nNoise structure types (auto-detected):\n\n\n\n\n\n\n\n\nType\nStructure\nMeaning\n\n\n\n\nADDITIVE\n\\(g(x,u,t) = \\text{constant}\\)\nNoise intensity independent of state\n\n\nMULTIPLICATIVE\n\\(g\\) depends on state\nState-dependent noise\n\n\nDIAGONAL\n\\(g\\) is diagonal matrix\nIndependent noise channels\n\n\nSCALAR\nSingle Wiener process\n\\(n_w = 1\\)\n\n\nGENERAL\nFull matrix coupling\nCorrelated noise\n\n\n\nAdditional user-facing methods:\ndef drift(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Evaluate drift term f(x, u).\"\"\"\n    \ndef diffusion(self, x: StateVector, u: ControlVector) -&gt; DiffusionMatrix:\n    \"\"\"Evaluate diffusion term g(x, u).\"\"\"\n\ndef is_additive_noise(self) -&gt; bool:\n    \"\"\"Check if noise is additive (state-independent).\"\"\"\n\ndef recommend_solvers(self, backend: Backend) -&gt; List[str]:\n    \"\"\"Recommend integration methods based on noise structure.\"\"\"\nUser subclass pattern:\n\n\nCode\nclass OrnsteinUhlenbeck(ContinuousStochasticSystem):\n    def define_system(self, alpha=1.0, sigma=0.5):\n        \"\"\"Define Ornstein-Uhlenbeck process: dx = -α*x*dt + σ*dW\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        alpha_sym, sigma_sym = sp.symbols('alpha sigma', positive=True)\n        \n        # Drift (deterministic part)\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n        self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion (stochastic part)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'  # or 'stratonovich'\n    \n    def print_equations(self, simplify=True):\n        print(\"Ornstein-Uhlenbeck Process:\")\n        print(\"  dx = -α*x*dt + σ*dW\")\n\n# Use the stochastic system\nsystem = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nprint(f\"Additive noise: {system.is_additive_noise()}\")\nprint(f\"Noise dimension: {system.nw}\")\n\n# Integrate SDE\nx0 = np.array([1.0])\nresult = system.integrate(\n    x0, u=None, t_span=(0, 10), \n    method='EM',  # Euler-Maruyama for SDEs\n    dt=0.01\n)\nprint(f\"✓ Stochastic system integration\")\n\n\n\n\nDiscreteStochasticSystem: Discrete SDE Support\nFile: discrete_stochastic_system.py\nInheritance: DiscreteSymbolicSystem (single inheritance)\nThe DiscreteStochasticSystem adds stochastic difference equation support.\nMathematical form:\n\\[x[k+1] = f(x[k], u[k]) + g(x[k], u[k]) \\cdot w[k]\\]\nwhere: - \\(f(x[k], u[k])\\) - Deterministic dynamics - \\(g(x[k], u[k])\\) - Diffusion matrix - \\(w[k]\\) - Discrete-time noise\nSimilar structure to continuous stochastic but for discrete-time systems.",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-special-system",
    "href": "architecture/UI_Framework_Architecture.html#sec-special-system",
    "title": "UI Framework Architecture",
    "section": "Special System: DiscretizedSystem",
    "text": "Special System: DiscretizedSystem\n\nDiscretizedSystem: Continuous → Discrete Conversion\nFile: discretized_system.py\nThe DiscretizedSystem creates discrete-time approximations from continuous systems.\nDiscretization methods:\n\n\n\nMethod\nOrder\nDescription\n\n\n\n\nexact\nN/A\nMatrix exponential (linear systems only)\n\n\neuler\n1\nForward Euler approximation\n\n\nrk4\n4\nFourth-order Runge-Kutta\n\n\ntustin\n2\nBilinear (Tustin) transform\n\n\nbackward\n1\nBackward Euler (implicit)\n\n\nmatched\nN/A\nZero-order hold\n\n\n\nUsage example:\n\n\nCode\n# Start with continuous system\ncontinuous_system = Pendulum()\n\n# Create discrete approximation\nfrom cdesym.systems.base.core.discretized_system import DiscretizedSystem\n\ndiscrete_system = DiscretizedSystem(\n    continuous_system,\n    dt=0.01,\n    method='rk4'\n)\n\n# Use as discrete system\nx_next = discrete_system.step(x, u)\nresult = discrete_system.simulate(x0, u_sequence=None, n_steps=100)\n\n\nKey features:\n\nMultiple discretization methods available\nPreserves symbolic structure when possible\nHandles deterministic and stochastic systems\nAutomatic validation of discretization accuracy",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-design-principles",
    "href": "architecture/UI_Framework_Architecture.html#sec-design-principles",
    "title": "UI Framework Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\n1. Cooperative Multiple Inheritance\nWhere used: Layer 2 (ContinuousSymbolicSystem, DiscreteSymbolicSystem)\nWhy: Combines symbolic machinery (Layer 0) with time-domain interface (Layer 1) without code duplication.\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __init__(self, *args, **kwargs):\n        # Python's MRO ensures correct initialization order\n        super().__init__(*args, **kwargs)\nBenefit: Users get both symbolic capabilities and continuous-time interface in one class.\n\n\n2. Composition Over Inheritance\nInternal utilities composed, not inherited:\nclass SymbolicSystemBase:\n    def __init__(self):\n        # Compose specialized utilities\n        self.backend = BackendManager()\n        self._code_gen = CodeGenerator(self, self.backend)\n        self.equilibria = EquilibriumHandler(self.nx, self.nu)\n        self._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\n        # etc.\nBenefit: Single responsibility, testability, flexibility.\n\n\n3. Template Method Pattern\nBase class orchestrates, subclass fills details:\nclass SymbolicSystemBase:\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\nBenefit: Consistent initialization, clear extension point.\n\n\n4. Separation of Concerns\nEach layer has a single, focused responsibility:\n\nLayer 0: Symbolic manipulation (time-agnostic)\nLayer 1: Time-domain semantics (abstract interfaces)\nLayer 2: Concrete execution (symbolic + time-domain)\nLayer 3: Specialized extensions (stochastic)\n\n\n\n5. Zero Code Duplication\nBefore refactoring: ~1,800 lines duplicated between continuous and discrete systems\nAfter refactoring: All shared functionality in SymbolicSystemBase\nEliminated duplication: - Parameter handling - Backend management - Code generation - Symbolic validation - Equilibrium management - Configuration persistence",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-system-properties",
    "href": "architecture/UI_Framework_Architecture.html#sec-system-properties",
    "title": "UI Framework Architecture",
    "section": "System Properties",
    "text": "System Properties\n\nAutomatic Properties (All Systems)\nAll systems automatically provide these properties:\n\n\nCode\nsystem = Pendulum()\n\n# Dimensions\nprint(f\"State dimension (nx): {system.nx}\")\nprint(f\"Control dimension (nu): {system.nu}\")\nprint(f\"Output dimension (ny): {system.ny}\")\nprint(f\"Physical dimension (nq): {system.nq}\")\nprint(f\"System order: {system.order}\")\n\n# Backend\nprint(f\"Default backend: {system.backend.default_backend}\")\nprint(f\"Device: {system.backend.preferred_device}\")\n\n\n\n\nDiscrete-Only Properties\n# Discrete systems only\ndt: float                    # Sampling period [s]\nsampling_frequency: float    # 1/dt [Hz]\n\n\nStochastic-Only Properties\n# Stochastic systems only\nnw: int                      # Number of Wiener processes\nis_additive_noise() -&gt; bool  # Noise structure check\nis_multiplicative_noise() -&gt; bool",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-backend-support",
    "href": "architecture/UI_Framework_Architecture.html#sec-backend-support",
    "title": "UI Framework Architecture",
    "section": "Backend Support",
    "text": "Backend Support\nAll systems support multi-backend execution transparently:\n\n\n\n\n\n\n\n\nBackend\nExecution\nBest For\n\n\n\n\nNumPy\nCPU\nGeneral purpose, maximum compatibility\n\n\nPyTorch\nCPU/GPU\nNeural networks, GPU acceleration, automatic differentiation\n\n\nJAX\nCPU/GPU/TPU\nOptimization, XLA compilation, functional programming\n\n\nJulia (via DiffEqPy)\nCPU\nHigh-performance ODE/SDE solvers\n\n\n\nSwitching backends:\n\n\nCode\nsystem = Pendulum()\n\n# NumPy (default)\nx_np = np.array([1.0, 0.0])\ndx_np = system(x_np, np.zeros(1))\n\n# Temporary PyTorch\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    dx_torch = system(x_torch, torch.zeros(1))\n    print(f\"PyTorch result type: {type(dx_torch)}\")\n\n# Permanent switch\nsystem.set_default_backend('jax')\nx_jax = jnp.array([1.0, 0.0])\ndx_jax = system(x_jax, jnp.zeros(1))\n\nprint(\"✓ Backend switching is transparent\")",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-integration-methods",
    "href": "architecture/UI_Framework_Architecture.html#sec-integration-methods",
    "title": "UI Framework Architecture",
    "section": "Integration Methods",
    "text": "Integration Methods\n\nContinuous Systems (ODE Solvers)\n\n\n\n\n\n\n\n\nBackend\nMethods\nExamples\n\n\n\n\nscipy\nAdaptive\nRK45, RK23, DOP853, Radau, BDF, LSODA\n\n\nJulia (DiffEqPy)\nAdaptive\nTsit5, Vern7, Vern9, Rodas5, AutoTsit5\n\n\nJAX (diffrax)\nAdaptive\ndopri5, tsit5, heun\n\n\nPyTorch (torchdiffeq)\nAdaptive\ndopri5, adaptive_heun\n\n\nFixed-step\nAll backends\neuler, rk4, midpoint\n\n\n\n\n\nStochastic Systems (SDE Solvers)\n\n\n\nBackend\nMethods\nConvergence\n\n\n\n\ntorchsde\neuler, milstein, srk\nStrong 0.5-1.0\n\n\ndiffrax\neuler, heun\nStrong 0.5-1.0\n\n\nJulia (DiffEqPy)\nEM, milstein, etc.\nStrong/Weak",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-usage-examples",
    "href": "architecture/UI_Framework_Architecture.html#sec-usage-examples",
    "title": "UI Framework Architecture",
    "section": "Usage Examples",
    "text": "Usage Examples\n\nExample 1: Pendulum (Continuous)\n\n\nCode\nclass SimplePendulum(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, l=0.5, g=9.81, b=0.1):\n        \"\"\"Simple pendulum with damping.\"\"\"\n        # Symbolic variables\n        theta, omega = sp.symbols('theta omega', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, l_sym, g_sym, b_sym = sp.symbols('m l g b', positive=True)\n        \n        # System definition\n        self.state_vars = [theta, omega]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            omega,\n            -(g_sym/l_sym)*sp.sin(theta) - (b_sym/(m_sym*l_sym**2))*omega + u/(m_sym*l_sym**2)\n        ])\n        self.parameters = {m_sym: m, l_sym: l, g_sym: g, b_sym: b}\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Simple Pendulum Equations:\")\n        print(\"  dθ/dt = ω\")\n        print(\"  dω/dt = -(g/l)sin(θ) - (b/ml²)ω + u/(ml²)\")\n\n# Create and use\npendulum = SimplePendulum(m=0.5, l=0.3)\nx0 = np.array([0.1, 0.0])\n\n# Evaluate dynamics\ndx = pendulum(x0, np.zeros(1))\nprint(f\"State derivative: {dx}\")\n\n# Integrate\nresult = pendulum.integrate(x0, u=None, t_span=(0, 5), method='RK45')\nprint(f\"Integration successful: {result['success']}\")\n\n# Linearize\nA, B = pendulum.linearize(np.zeros(2), np.zeros(1))\nprint(f\"Linearization: A shape {A.shape}, B shape {B.shape}\")\n\n\n\n\nExample 2: Linear System (Discrete)\n\n\nCode\nclass DiscreteDoubleIntegrator(DiscreteSymbolicSystem):\n    def define_system(self, dt=0.01):\n        \"\"\"Discrete double integrator.\"\"\"\n        # Symbolic variables\n        p, v = sp.symbols('p v', real=True)\n        u = sp.symbols('u', real=True)\n        dt_sym = sp.symbols('dt', positive=True)\n        \n        # Discrete dynamics (Euler approximation)\n        self.state_vars = [p, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            p + dt_sym * v,\n            v + dt_sym * u\n        ])\n        self.parameters = {dt_sym: dt}\n        self._dt = dt  # REQUIRED!\n        self.order = 1\n    \n    def print_equations(self, simplify=True):\n        print(\"Discrete Double Integrator:\")\n        print(\"  p[k+1] = p[k] + dt*v[k]\")\n        print(\"  v[k+1] = v[k] + dt*u[k]\")\n\n# Create and use\nsystem = DiscreteDoubleIntegrator(dt=0.1)\nx0 = np.array([0.0, 0.0])\n\n# Single step\nx_next = system.step(x0, np.array([1.0]))\nprint(f\"Next state: {x_next}\")\n\n# Simulate\nresult = system.simulate(x0, u_sequence=None, n_steps=50)\nprint(f\"Simulation shape: {result['states'].shape}\")\n\n# Linearize\nAd, Bd = system.linearize(np.zeros(2), np.zeros(1))\nprint(f\"Discrete linearization: Ad shape {Ad.shape}\")\n\n\n\n\nExample 3: Stochastic Process\n\n\nCode\nclass BrownianMotion(ContinuousStochasticSystem):\n    def define_system(self, mu=0.0, sigma=1.0):\n        \"\"\"Standard Brownian motion with drift.\"\"\"\n        # Symbolic variables\n        x = sp.symbols('x', real=True)\n        u = sp.symbols('u', real=True)\n        mu_sym, sigma_sym = sp.symbols('mu sigma', real=True)\n        \n        # Drift term\n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([[mu_sym + u]])\n        self.parameters = {mu_sym: mu, sigma_sym: sigma}\n        self.order = 1\n        \n        # Diffusion term (additive noise)\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.sde_type = 'ito'\n    \n    def print_equations(self, simplify=True):\n        print(\"Brownian Motion with Drift:\")\n        print(\"  dx = μ*dt + σ*dW\")\n\n# Create and use\nbrownian = BrownianMotion(mu=0.1, sigma=0.5)\n\n# Check noise properties\nprint(f\"Additive noise: {brownian.is_additive_noise()}\")\nprint(f\"Noise dimension: {brownian.nw}\")\n\n# Drift and diffusion evaluation\nx = np.array([0.5])\nf = brownian.drift(x, np.zeros(1))\ng = brownian.diffusion(x, np.zeros(1))\nprint(f\"Drift: {f}, Diffusion: {g}\")\n\n# Integrate SDE\nx0 = np.array([0.0])\nresult = brownian.integrate(\n    x0, u=None, t_span=(0, 10),\n    method='EM', dt=0.01\n)\nprint(f\"SDE integration complete: {result['success']}\")",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#sec-key-strengths",
    "href": "architecture/UI_Framework_Architecture.html#sec-key-strengths",
    "title": "UI Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipUI Framework Advantages\n\n\n\n\nClean Separation - Each layer has single responsibility\nZero Duplication - Symbolic machinery shared across all systems\nType Safety - Comprehensive TypedDict definitions throughout\nBackend Flexibility - Seamless NumPy/PyTorch/JAX/Julia switching\nExtensibility - Easy to add new system types via define_system()\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance - Multi-backend support enables GPU acceleration\nUser-Friendly - Simple subclass pattern for custom systems\nDocumentation - Extensive docstrings with mathematical notation\nProduction-Quality - Professional software engineering practices",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/UI_Framework_Architecture.html#summary",
    "href": "architecture/UI_Framework_Architecture.html#summary",
    "title": "UI Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe UI Framework provides a clean, layered architecture for defining and working with dynamical systems:\n\nLayer 0 provides time-agnostic symbolic foundations\nLayer 1 defines abstract time-domain interfaces\nLayer 2 combines symbolic + time-domain into concrete systems\nLayer 3 extends with stochastic capabilities\n\nUsers interact primarily at Layers 2 and 3 by subclassing ContinuousSymbolicSystem, DiscreteSymbolicSystem, or their stochastic variants. The framework handles all internal complexity transparently, providing a simple define_system() extension point while delivering production-grade functionality.\nThe architecture eliminates ~1,800 lines of code duplication while maintaining clean separation of concerns and type safety throughout.",
    "crumbs": [
      "Framework Design",
      "UI Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html",
    "href": "architecture/Integration_Framework_Architecture.html",
    "title": "Integration Framework Architecture",
    "section": "",
    "text": "The ControlDESymulation numerical integration framework provides multi-backend, multi-method support for integrating both deterministic ordinary differential equations (ODEs) and stochastic differential equations (SDEs). The framework consists of 14 core files organized into a clean two-track architecture with a shared method registry.\nKey capabilities:\n\nBackend agnostic: Seamless switching between NumPy, PyTorch, and JAX\n40+ integration methods: From simple Euler to high-order adaptive schemes\nStochastic support: Full SDE integration with noise structure exploitation\nFactory pattern: Automatic method selection based on system properties\nProduction ready: Professional-grade error control and performance tracking\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nMost users should NOT directly instantiate integrators or factories. Instead, use the high-level system interface:\n# Recommended: Use system.integrate() - delegates to appropriate integrator\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nresult = system.integrate(\n    x0=np.array([1.0, 0.0]),\n    method='RK45',  # Optional: framework selects automatically\n    t_span=(0, 10)\n)\n\n# Advanced: Direct integrator access (only when needed for fine control)\nintegrator = IntegratorFactory.auto(system)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\nThe system’s integrate() method automatically handles backend selection, method routing, and integrator lifecycle. Direct integrator instantiation is only needed for advanced use cases requiring explicit integrator reuse or fine-grained control.",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-overview",
    "href": "architecture/Integration_Framework_Architecture.html#sec-overview",
    "title": "Integration Framework Architecture",
    "section": "",
    "text": "The ControlDESymulation numerical integration framework provides multi-backend, multi-method support for integrating both deterministic ordinary differential equations (ODEs) and stochastic differential equations (SDEs). The framework consists of 14 core files organized into a clean two-track architecture with a shared method registry.\nKey capabilities:\n\nBackend agnostic: Seamless switching between NumPy, PyTorch, and JAX\n40+ integration methods: From simple Euler to high-order adaptive schemes\nStochastic support: Full SDE integration with noise structure exploitation\nFactory pattern: Automatic method selection based on system properties\nProduction ready: Professional-grade error control and performance tracking\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nMost users should NOT directly instantiate integrators or factories. Instead, use the high-level system interface:\n# Recommended: Use system.integrate() - delegates to appropriate integrator\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nresult = system.integrate(\n    x0=np.array([1.0, 0.0]),\n    method='RK45',  # Optional: framework selects automatically\n    t_span=(0, 10)\n)\n\n# Advanced: Direct integrator access (only when needed for fine control)\nintegrator = IntegratorFactory.auto(system)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\nThe system’s integrate() method automatically handles backend selection, method routing, and integrator lifecycle. Direct integrator instantiation is only needed for advanced use cases requiring explicit integrator reuse or fine-grained control.",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-architecture",
    "href": "architecture/Integration_Framework_Architecture.html#sec-architecture",
    "title": "Integration Framework Architecture",
    "section": "Architecture Overview",
    "text": "Architecture Overview\nThe framework follows a dual-track design separating deterministic and stochastic integration, with a shared method registry providing centralized method management:\nShared Infrastructure\n├── MethodRegistry (centralized method normalization and validation)\n│   ├── normalize_method_name() - cross-backend name mapping\n│   ├── validate_method() - backend/system compatibility\n│   ├── is_sde_method() / is_fixed_step() - classification\n│   └── get_available_methods() - method discovery\n│\nTrack 1: Deterministic ODE Integration\n├── IntegratorBase (abstract interface)\n├── IntegratorFactory (method selection via registry)\n├── Backend-Specific Implementations:\n│   ├── ScipyIntegrator (NumPy/SciPy)\n│   ├── TorchDiffEqIntegrator (PyTorch with GPU)\n│   ├── DiffraxIntegrator (JAX with XLA)\n│   └── DiffEqPyIntegrator (Julia via Python)\n└── FixedStepIntegrators (Euler, Heun, Midpoint, RK4)\n\nTrack 2: Stochastic SDE Integration\n├── SDEIntegratorBase (extends IntegratorBase)\n├── SDEIntegratorFactory (SDE-specific creation via registry)\n├── Backend-Specific Implementations:\n│   ├── TorchSDEIntegrator (PyTorch SDEs)\n│   ├── DiffraxSDEIntegrator (JAX SDEs)\n│   └── DiffEqPySDEIntegrator (Julia SDEs)\n└── CustomBrownianPath (deterministic noise for testing)",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-method-registry",
    "href": "architecture/Integration_Framework_Architecture.html#sec-method-registry",
    "title": "Integration Framework Architecture",
    "section": "Method Registry: Centralized Method Management",
    "text": "Method Registry: Centralized Method Management\nFile: method_registry.py\nThe method_registry module serves as the single source of truth for all integration methods across backends. It provides centralized method normalization, validation, and classification for both ODE and SDE integrators.\n\nDesign Philosophy\nBackend Naming Conventions:\n\n\n\n\n\n\n\n\nBackend\nConvention\nExamples\n\n\n\n\nNumPy/Julia (DiffEqPy)\nCapitalized\nEM, Tsit5, SRIW1\n\n\nPyTorch (TorchSDE/TorchDiffEq)\nlowercase\neuler, dopri5, milstein\n\n\nJAX (Diffrax)\nPascalCase\nEuler, ItoMilstein, Tsit5\n\n\n\nCanonical Names:\nUser-friendly aliases that work across all backends (e.g., euler_maruyama, milstein, rk45). These are automatically normalized to backend-specific names.\n\n\nCore Functions\nfrom cdesym.systems.base.numerical_integration.method_registry import (\n    normalize_method_name,\n    validate_method,\n    is_sde_method,\n    is_fixed_step,\n    get_available_methods,\n    get_method_info,\n)\n\n# Normalize canonical names to backend-specific\nnormalize_method_name('euler_maruyama', 'numpy')  # → 'EM'\nnormalize_method_name('euler_maruyama', 'torch')  # → 'euler'\nnormalize_method_name('euler_maruyama', 'jax')    # → 'Euler'\n\n# Validate method/backend/system compatibility\nis_valid, error = validate_method('euler_maruyama', 'torch', is_stochastic=True)\n\n# Classify methods\nis_sde_method('euler_maruyama')  # → True\nis_sde_method('rk4')              # → False\nis_fixed_step('rk4')              # → True\nis_fixed_step('RK45')             # → False (adaptive)\n\n# Discover available methods\nmethods = get_available_methods('torch', method_type='stochastic')\n\n\nMethod Classification\nMethods are classified along two dimensions:\n\nSystem type: Deterministic (ODE) vs Stochastic (SDE)\nTime stepping: Fixed-step vs Adaptive\n\n\n\n\n\n\n\n\n\nCategory\nExamples\nUse Case\n\n\n\n\nDETERMINISTIC_FIXED_STEP\neuler, heun, midpoint, rk4\nManual implementations\n\n\nDETERMINISTIC_ADAPTIVE\nRK45, LSODA, dopri5, tsit5\nProduction ODE solvers\n\n\nSDE_FIXED_STEP\nEM, euler, milstein, SRIW1\nMost SDE methods\n\n\nSDE_ADAPTIVE\nLambaEM, AutoEM, adaptive_heun\nRare adaptive SDE\n\n\n\n\n\nNormalization Map\nThe registry maintains a comprehensive map for cross-backend method translation:\nNORMALIZATION_MAP = {\n    # SDE Methods\n    'euler_maruyama': {'numpy': 'EM', 'torch': 'euler', 'jax': 'Euler'},\n    'milstein': {'numpy': 'RKMil', 'torch': 'milstein', 'jax': 'ItoMilstein'},\n    'sra1': {'numpy': 'SRA1', 'torch': 'srk', 'jax': 'SRA1'},\n\n    # ODE Methods\n    'rk45': {'numpy': 'RK45', 'torch': 'dopri5', 'jax': 'tsit5'},\n    'dopri5': {'numpy': 'RK45', 'torch': 'dopri5', 'jax': 'dopri5'},\n    'tsit5': {'numpy': 'Tsit5', 'torch': 'dopri5', 'jax': 'tsit5'},\n    # ... more mappings\n}\n\n\nUsage in Factories\nBoth IntegratorFactory and SDEIntegratorFactory use the registry for method handling:\n# IntegratorFactory.create() internally:\nmethod = normalize_method_name(method, backend)\nis_valid, error = validate_method(method, backend, is_stochastic=False)\nif is_fixed_step(method) and dt is None:\n    raise ValueError(\"Fixed-step method requires dt\")",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-track-1",
    "href": "architecture/Integration_Framework_Architecture.html#sec-track-1",
    "title": "Integration Framework Architecture",
    "section": "Track 1: Deterministic ODE Integration",
    "text": "Track 1: Deterministic ODE Integration\n\nIntegratorBase: Abstract Interface\nFile: integrator_base.py\nThe IntegratorBase class defines the unified interface that all numerical integrators must implement. This abstraction enables backend-agnostic integration while maintaining consistent behavior across implementations.\nCore responsibilities:\n\nDefine integration contract through abstract methods\nTrack performance statistics (function evaluations, steps, timing)\nManage integration parameters (time step, tolerances, backend)\nProvide consistent result format via IntegrationResult TypedDict\n\nKey attributes:\nsystem: ContinuousSystemBase     # Dynamical system to integrate\ndt: float                        # Time step (or initial guess for adaptive)\nstep_mode: StepMode              # FIXED or ADAPTIVE\nbackend: Backend                 # 'numpy', 'torch', or 'jax'\nrtol: float                      # Relative error tolerance (adaptive methods)\natol: float                      # Absolute error tolerance (adaptive methods)\n_stats: dict                     # Performance tracking\nAbstract methods required by all implementations:\ndef step(self, x: Array, u: Array, dt: float) -&gt; Array:\n    \"\"\"Single integration step: x(t) -&gt; x(t + dt)\"\"\"\n    \ndef integrate(\n    self, \n    x0: Array, \n    u_func: Callable, \n    t_span: tuple[float, float]\n) -&gt; IntegrationResult:\n    \"\"\"Multi-step integration over time interval\"\"\"\n    \n@property\ndef name(self) -&gt; str:\n    \"\"\"Unique identifier for this integrator\"\"\"\nStepMode enumeration:\n\nFIXED: Constant time step (euler, rk4, midpoint)\nADAPTIVE: Variable time step with error control (RK45, dopri5, tsit5)\n\n\n\nIntegratorFactory: Smart Creation\nFile: integrator_factory.py\nThe IntegratorFactory provides intelligent integrator creation with automatic backend and method selection. It encapsulates the complexity of choosing appropriate integration methods based on system properties and use case requirements.\nIntegration with Method Registry:\nThe factory delegates method normalization and validation to the centralized method_registry:\n# Internally, IntegratorFactory.create() does:\nmethod = normalize_method_name(method, backend)  # Registry function\nis_valid, error = validate_method(method, backend, is_stochastic=False)\nif is_fixed_step(method) and dt is None:\n    raise ValueError(\"Fixed-step method requires dt\")\nJulia Preference for NumPy Backend:\nWhen using the NumPy backend, IntegratorFactory automatically prefers Julia implementations for basic methods when DiffEqPy is available:\n\neuler → Julia’s Euler (better performance)\nheun → Julia’s Heun\nmidpoint → Julia’s Midpoint\n\nTo explicitly use manual Python implementations:\nintegrator = IntegratorFactory.create(\n    system, backend='numpy', method='euler', prefer_manual=True\n)\nFactory methods:\n# Automatic selection based on system and backend\nIntegratorFactory.auto(system, backend=None)\n\n# Production use with auto-stiffness detection\nIntegratorFactory.for_production(system, **options)\n\n# High-performance Julia integration\nIntegratorFactory.for_julia(system, algorithm='Tsit5', **options)\n\n# Neural ODE training with adjoint gradients\nIntegratorFactory.for_neural_ode(system, **options)\n\n# JAX optimization workflows\nIntegratorFactory.for_optimization(system, **options)\n\n# Direct method specification\nIntegratorFactory.create(system, backend, method, **options)\nMethod registry:\nThe factory uses the centralized method registry for mapping method names to backends and capabilities:\n\n\n\n\n\n\n\n\n\n\nMethod\nBackend\nType\nOrder\nBest For\n\n\n\n\nLSODA\nNumPy (scipy)\nAdaptive\nVariable\nAutomatic stiffness detection\n\n\nRK45\nNumPy (scipy)\nAdaptive\n5(4)\nGeneral non-stiff ODEs\n\n\nDOP853\nNumPy (scipy)\nAdaptive\n8(5,3)\nHigh-accuracy requirements\n\n\nRadau\nNumPy (scipy)\nAdaptive\n5\nStiff systems (implicit)\n\n\nBDF\nNumPy (scipy)\nAdaptive\nVariable\nVery stiff systems\n\n\nTsit5\nNumPy (Julia)\nAdaptive\n5(4)\nHigh performance\n\n\nVern9\nNumPy (Julia)\nAdaptive\n9(8)\nMaximum accuracy\n\n\nRodas5\nNumPy (Julia)\nAdaptive\n5(4)\nStiff (Rosenbrock method)\n\n\ndopri5\nPyTorch/JAX\nAdaptive\n5(4)\nNeural ODEs, GPU acceleration\n\n\ndopri8\nPyTorch/JAX\nAdaptive\n8\nHigh-accuracy neural ODEs\n\n\ntsit5\nJAX (diffrax)\nAdaptive\n5(4)\nOptimization, XLA compilation\n\n\neuler\nAny\nFixed\n1\nSimple systems, education\n\n\nheun\nAny\nFixed\n2\nImproved Euler, predictor-corrector\n\n\nmidpoint\nAny\nFixed\n2\nSecond-order, midpoint evaluation\n\n\nrk4\nAny\nFixed\n4\nModerate accuracy, fixed step\n\n\n\n\n\nScipyIntegrator: Adaptive NumPy Integration\nFile: scipy_integrator.py\nWraps scipy.integrate.solve_ivp to provide professional-grade adaptive integration with comprehensive error control. This is the recommended starting point for most NumPy-based applications.\nSupported methods:\n\nRK45 (default): Dormand-Prince 5(4) — general purpose, good balance\nRK23: Bogacki-Shampine 3(2) — fast, lower accuracy\nDOP853: Dormand-Prince 8(5,3) — very high accuracy\nRadau: Implicit Runge-Kutta — stiff systems\nBDF: Backward differentiation formulas — very stiff systems\nLSODA: Automatic stiffness detection — adapts to problem\n\nKey features:\n\nProfessional adaptive time stepping with embedded error estimation\nConfigurable error tolerances (rtol, atol)\nDense output via continuous extension (interpolation between steps)\nEvent detection for state-dependent conditions\nSupport for both controlled and autonomous systems\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.scipy_integrator import ScipyIntegrator\n\n# Create system\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Create adaptive integrator with tight tolerances\nintegrator = ScipyIntegrator(\n    system,\n    method='RK45',\n    rtol=1e-6,\n    atol=1e-8\n)\n\n# Integrate over time span\nx0 = np.array([1.0, 0.0])  # [angle, angular_velocity]\nu_func = lambda t, x: np.zeros(1)  # No control input\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Success: {result['success']}\")\nprint(f\"Function evaluations: {result['nfev']}\")\nprint(f\"Steps taken: {result['nsteps']}\")\n\n\nWhen to use:\n\nGeneral-purpose NumPy applications\nWhen you need reliable adaptive stepping\nSystems with unknown stiffness (use LSODA)\nWhen dense output is required\n\n\n\nTorchDiffEqIntegrator: GPU-Accelerated PyTorch\nFile: `torchdiffeq_integrator.py**\nProvides PyTorch integration with GPU acceleration and automatic differentiation support. Essential for neural ODE applications and gradient-based optimization.\nSupported methods:\n\ndopri5: Dormand-Prince 5(4) — recommended default\ndopri8: Dormand-Prince 8 — high accuracy\nadaptive_heun: Heun’s method — good for moderately stiff\nbosh3: Bogacki-Shampine 3 — fast, lower accuracy\nfehlberg2: Fehlberg 2(1) — very fast, low accuracy\nexplicit_adams, implicit_adams: Multi-step methods\n\nKey features:\n\nGPU acceleration: Automatic CUDA support for large-scale problems\nAutomatic differentiation: Seamless gradient computation through dynamics\nAdjoint method: Memory-efficient backpropagation for neural ODEs\nBatch processing: Vectorized integration of multiple trajectories\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.torchdiffeq_integrator import TorchDiffEqIntegrator\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Create GPU-accelerated integrator\nintegrator = TorchDiffEqIntegrator(\n    system,\n    method='dopri5',\n    backend='torch',\n    device='cpu',  # Use 'cuda:0' for GPU\n    rtol=1e-6,\n    atol=1e-8\n)\n\nx0 = torch.tensor([1.0, 0.0], requires_grad=True)\nu_func = lambda t, x: torch.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Solver: {result['solver']}\")\nprint(f\"Integration time: {result['integration_time']:.4f}s\")\n\n\nWhen to use:\n\nNeural ODE training\nGPU-accelerated simulations\nGradient-based optimization\nLarge-scale batch processing\n\n\n\nDiffraxIntegrator: JAX with XLA Compilation\nFile: diffrax_integrator.py\nLeverages JAX’s diffrax library for high-performance integration with XLA compilation. Ideal for optimization workflows requiring extensive JIT compilation and functional transformations.\nSupported methods:\n\ntsit5: Tsitouras 5(4) — recommended, efficient\ndopri5: Dormand-Prince 5(4) — standard reference\ndopri8: Dormand-Prince 8 — high accuracy\nheun: Heun’s method — simple, robust\nralston: Ralston’s method — improved stability\nreversible_heun: Time-reversible integration\n\nKey features:\n\nXLA compilation: Near-C++ performance via just-in-time compilation\nJAX transformations: jit, vmap, grad, pmap all work seamlessly\nFunctional style: Pure functions enable advanced optimizations\nEfficient for optimization: Fast repeated evaluations with parameter sweeps\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.diffrax_integrator import DiffraxIntegrator\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Create JAX integrator\nintegrator = DiffraxIntegrator(\n    system,\n    method='tsit5',\n    backend='jax',\n    rtol=1e-6,\n    atol=1e-8\n)\n\nx0 = jnp.array([1.0, 0.0])\nu_func = lambda t, x: jnp.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Success: {result['success']}\")\n\n\nWhen to use:\n\nParameter optimization requiring many integrations\nWhen you need vmap for batch parameter sweeps\nGradient-based control optimization\nMaximum computational efficiency\n\n\n\nDiffEqPyIntegrator: Julia’s Solver Ecosystem\nFile: diffeqpy_integrator.py\nAccesses Julia’s extensive DifferentialEquations.jl ecosystem through Python bindings. Provides the most comprehensive method library with production-grade performance.\nSupported method families:\nExplicit Runge-Kutta: - Tsit5, Vern6, Vern7, Vern8, Vern9 — variable order adaptive - DP5, DP8 — Dormand-Prince variants\nRosenbrock (implicit for stiff): - Rosenbrock23, Rosenbrock32, Rodas4, Rodas5\nBDF methods: - TRBDF2, KenCarp3, KenCarp4, KenCarp5\nSpecialized: - RadauIIA5 — implicit Runge-Kutta - ROCK2, ROCK4 — stabilized methods - VelocityVerlet, SymplecticEuler — symplectic integrators\nAuto-switching (composite): - AutoTsit5(Rosenbrock23()) — switches based on stiffness - AutoVern7(Rodas5()) — high accuracy with stiffness handling\nKey features:\n\nHighest performance: Often 2-10× faster than SciPy\nAutomatic stiffness detection: Seamlessly switches solvers\nExtensive method library: 100+ algorithms available\nProduction reliability: Battle-tested in scientific computing\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.diffeqpy_integrator import DiffEqPyIntegrator\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Ultra-high accuracy Julia integration\nintegrator = DiffEqPyIntegrator(\n    system,\n    algorithm='Vern9',  # 9th order method\n    backend='numpy',\n    reltol=1e-12,\n    abstol=1e-14\n)\n\nx0 = np.array([1.0, 0.0])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 100))\n\nprint(f\"Function evaluations: {result['nfev']}\")\nprint(f\"Achieved accuracy: reltol={1e-12}, abstol={1e-14}\")\n\n\nWhen to use:\n\nMaximum performance requirements\nVery stiff systems needing automatic detection\nHigh-accuracy applications (&gt;8 digits)\nProduction environments with reliability requirements\n\n\n\nFixedStepIntegrators: Educational and Simple Systems\nFile: fixed_step_integrators.py\nManual implementations of classic fixed-step methods. These provide transparent, backend-agnostic integration suitable for education and simple systems where adaptive stepping is unnecessary.\nAvailable methods:\n\nExplicitEulerIntegrator: Forward Euler (order 1) — simplest method\nHeunIntegrator: Heun’s method / Improved Euler (order 2) — predictor-corrector approach\nMidpointIntegrator: Midpoint method (order 2) — midpoint evaluation\nRK4Integrator: Classic Runge-Kutta 4 (order 4) — excellent balance\n\nHeunIntegrator:\nHeun’s method uses a predictor-corrector approach with trapezoidal averaging:\nk1 = f(x_k, u_k)                    # Predictor (Euler step)\nx_pred = x_k + dt * k1\nk2 = f(x_pred, u_k)                 # Corrector\nx_{k+1} = x_k + (dt/2) * (k1 + k2)  # Trapezoidal rule\nAlso known as Improved Euler or Explicit Trapezoid method. Uses 2 function evaluations per step for second-order accuracy.\nKey features:\n\nBackend agnostic: Work with NumPy, PyTorch, and JAX arrays\nTransparent implementation: Clear, readable code for learning\nConstant time step: Predictable computational cost\nNo external dependencies: Pure Python implementations\nTypedDict results: All integrators return IntegrationResult TypedDict\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.fixed_step_integrators import (\n    RK4Integrator,\n    HeunIntegrator,\n)\n\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nx0 = np.array([1.0, 0.0])\nu_func = lambda t, x: np.zeros(1)\n\n# RK4 with fixed time step (4 function evals/step)\nrk4_integrator = RK4Integrator(system, dt=0.01, backend='numpy')\nresult_rk4 = rk4_integrator.integrate(x0, u_func, t_span=(0, 10))\n\n# Heun's method (2 function evals/step, predictor-corrector)\nheun_integrator = HeunIntegrator(system, dt=0.01, backend='numpy')\nresult_heun = heun_integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"RK4 - Steps: {result_rk4['nsteps']}, Solver: {result_rk4['solver']}\")\nprint(f\"Heun - Steps: {result_heun['nsteps']}, Solver: {result_heun['solver']}\")\n\n\nWhen to use:\n\nEducational purposes and learning\nSimple systems with smooth dynamics\nReal-time applications requiring predictable timing\nDebugging with deterministic stepping",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-track-2",
    "href": "architecture/Integration_Framework_Architecture.html#sec-track-2",
    "title": "Integration Framework Architecture",
    "section": "Track 2: Stochastic SDE Integration",
    "text": "Track 2: Stochastic SDE Integration\n\nSDEIntegratorBase: Stochastic Abstract Interface\nFile: sde_integrator_base.py\nExtends IntegratorBase to handle stochastic differential equations of the form:\n\\[dx = f(x, u, t)dt + g(x, u, t)dW\\]\nwhere:\n\n\\(f(x, u, t)\\): Drift term (deterministic dynamics)\n\\(g(x, u, t)\\): Diffusion term (stochastic intensity)\n\\(dW\\): Brownian motion increments (Wiener process)\n\nKey differences from deterministic integration:\n\nRandom noise generation: Requires proper Brownian motion sampling\nConvergence types:\n\nStrong convergence: Pathwise accuracy (Monte Carlo, control)\nWeak convergence: Distribution accuracy (statistics)\n\nNoise structure exploitation: Additive, diagonal, scalar, or general\nMultiple realizations: Monte Carlo simulation support\nInterpretation: Itô vs Stratonovich calculus\n\nAdditional abstract methods:\ndef step(\n    self, \n    x: Array, \n    u: Array, \n    dt: float, \n    dW: Array\n) -&gt; Array:\n    \"\"\"Single SDE step with provided noise\"\"\"\n    \ndef integrate_monte_carlo(\n    self,\n    x0: Array,\n    u_func: Callable,\n    t_span: tuple[float, float],\n    n_paths: int\n) -&gt; SDEIntegrationResult:\n    \"\"\"Multiple trajectory simulation for statistics\"\"\"\n\n\nSDEIntegratorFactory: SDE-Specific Creation\nFile: sde_integrator_factory.py\nProvides intelligent SDE integrator creation with automatic noise structure detection and method selection.\nIntegration with Method Registry:\nLike IntegratorFactory, the SDE factory delegates to the centralized method_registry for method normalization and validation:\n# Internally, SDEIntegratorFactory.create() does:\nmethod = normalize_method_name(method, backend)  # Registry function\nis_valid, error = validate_method(method, backend, is_stochastic=True)\nif is_fixed_step(method) and dt is None:\n    raise ValueError(\"Fixed-step SDE method requires dt\")\nFactory methods:\n# Automatic selection based on noise structure\nSDEIntegratorFactory.auto(sde_system, backend=None)\n\n# Direct method specification\nSDEIntegratorFactory.create(\n    sde_system, backend, method, dt, **options\n)\n\n# Optimized for Monte Carlo simulations\nSDEIntegratorFactory.for_monte_carlo(\n    sde_system, noise_type='general', **options\n)\n\n# Neural SDE training with adjoint\nSDEIntegratorFactory.for_neural_sde(sde_system, adjoint=True, **options)\n\n# Julia DiffEqPy SDE solvers\nSDEIntegratorFactory.for_julia(sde_system, algorithm='SRIW1', **options)\n\n# Gradient-based optimization\nSDEIntegratorFactory.for_optimization(sde_system, backend=None, **options)\nAvailable SDE methods:\n\n\n\nMethod\nBackend\nConvergence\nNoise Type\nOrder\n\n\n\n\neuler-maruyama\nAll\nStrong 0.5\nGeneral\n0.5\n\n\nmilstein\nPyTorch/NumPy\nStrong 1.0\nDiagonal\n1.0\n\n\nreversible_heun\nPyTorch/JAX\nStrong 1.0\nAdditive\n1.0\n\n\nadaptive_heun\nPyTorch\nStrong 1.0\nAdditive\n1.0 (adaptive)\n\n\nsrk\nPyTorch\nStrong\nGeneral\nVariable\n\n\nmidpoint\nPyTorch\nStrong\nGeneral\nVariable\n\n\n\nNoise structure types:\n\nAdditive: \\(g(x, u, t) = g(t)\\) — diffusion independent of state\nDiagonal: \\(g\\) is diagonal matrix — independent noise channels\nScalar: \\(g\\) is scalar — single noise source\nGeneral: Full matrix \\(g\\) — correlated noise\n\n\n\nTorchSDEIntegrator: PyTorch SDE Integration\nFile: torchsde_integrator.py\nGPU-accelerated SDE integration using the torchsde library. Supports automatic differentiation through stochastic dynamics.\nSupported methods:\n\neuler: Euler-Maruyama (strong order 0.5) — Itô and Stratonovich\nmilstein: Milstein method (strong order 1.0 for diagonal noise) — Itô only\nsrk: Stochastic Runge-Kutta (general noise) — Itô and Stratonovich\nmidpoint: Midpoint method — Stratonovich only\nreversible_heun: Reversible Heun (strong order 1.0 for additive noise) — Stratonovich only\nadaptive_heun: Adaptive Heun with error control — Itô and Stratonovich\n\nKey features:\n\nGPU acceleration for large-scale stochastic simulations\nAdaptive stepping with stochastic error control\nNoise structure exploitation for efficiency\nAdjoint method for memory-efficient gradients through SDEs\nSDE type compatibility: Most methods support either Itô or Stratonovich (see method list)\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.torchsde_integrator import TorchSDEIntegrator\n\n# Create Ornstein-Uhlenbeck process: dx = -α*x*dt + σ*dW\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\nintegrator = TorchSDEIntegrator(\n    sde_system,\n    method='euler',  # Euler-Maruyama for Itô SDEs\n    dt=0.01,\n    backend='torch'\n)\n\nx0 = torch.tensor([0.5])\nu_func = lambda t, x: torch.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Convergence type: {result['convergence_type']}\")\nprint(f\"SDE type: {result['sde_type']}\")\n\n\n\n\nDiffraxSDEIntegrator: JAX SDE Integration\nFile: diffrax_sde_integrator.py\nJAX-based SDE integration with XLA compilation and functional transformations. Excellent for optimization involving stochastic dynamics.\nSupported methods:\n\neuler: Euler-Maruyama\nheun: Heun’s method (if supported by diffrax)\nreversible_heun: Time-reversible stochastic integration\n\nKey features:\n\nXLA compilation for near-C++ performance\nJAX transformations (jit, vmap, grad) work seamlessly\nCustom noise support for deterministic testing\nEfficient for stochastic optimization\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.diffrax_sde_integrator import DiffraxSDEIntegrator\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\nintegrator = DiffraxSDEIntegrator(\n    sde_system,\n    method='euler',\n    dt=0.01,\n    backend='jax',\n    seed=SEED\n)\n\nx0 = jnp.array([0.5])\nu_func = lambda t, x: jnp.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\n\n\n\n\nDiffEqPySDEIntegrator: Julia SDE Integration\nFile: diffeqpy_sde_integrator.py\nAccess to Julia’s comprehensive SDE solver ecosystem through Python bindings.\nSupported methods:\n\nEuler-Maruyama variants\nMilstein method\nStochastic Rosenbrock methods\nAdvanced Julia SDE algorithms\n\nKey features:\n\nProduction-grade SDE solvers\nAutomatic noise structure detection\nHigh-performance algorithms\nExtensive method library\n\nUsage example:\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.diffeqpy_sde_integrator import DiffEqPySDEIntegrator\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\nintegrator = DiffEqPySDEIntegrator(\n    sde_system,\n    method='EM',  # Euler-Maruyama\n    dt=0.01,\n    backend='numpy',\n    seed=SEED\n)\n\nx0 = np.array([0.5])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\nprint(f\"Diffusion evaluations: {result['diffusion_evals']}\")\n\n\n\n\nCustomBrownianPath: Deterministic Noise for Testing\nFile: custom_brownian.py\nProvides custom Brownian motion paths for deterministic testing and reproducibility. Implements diffrax’s AbstractPath interface.\nKey features:\n\nUser-provided noise increments\nDeterministic testing support\nCustom noise patterns (e.g., zero noise, specific realizations)\nCompatible with diffrax integrators\n\nUsage example:\n\n\nCode\nfrom jax import random\nfrom cdesym.systems.base.numerical_integration.stochastic.custom_brownian import (\n    CustomBrownianPath, create_custom_or_random_brownian\n)\nfrom cdesym.systems.base.numerical_integration.stochastic.diffrax_sde_integrator import DiffraxSDEIntegrator\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nnw = sde_system.nw\n\n# Zero noise for deterministic testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(t0=0.0, t1=10.0, dW=dW)\n\n# Or generate random noise\nkey = random.key(SEED)\nbrownian_random = create_custom_or_random_brownian(\n    key, t0=0.0, t1=10.0, shape=(nw,), dW=None\n)\n\n# Use in integration\nintegrator = DiffraxSDEIntegrator(sde_system, method='euler', dt=0.01, backend='jax')\nx0 = jnp.array([0.5])\nu_func = lambda t, x: jnp.zeros(1)\n\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10), brownian_path=brownian\n)\n\nprint(\"Deterministic SDE integration (zero noise)\")\n\n\nImportant notes:\n\nTime span matching: CustomBrownianPath(t0, t1, dW) must match t_span\nSingle dW for entire integration: Unlike step(), provide one dW for the full interval\nAutomatic interpolation: Diffrax handles internal time queries",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-result-types",
    "href": "architecture/Integration_Framework_Architecture.html#sec-result-types",
    "title": "Integration Framework Architecture",
    "section": "Integration Result Types",
    "text": "Integration Result Types\n\nIntegrationResult (Deterministic ODEs)\nAll ODE integrators return a TypedDict with consistent fields:\n{\n    't': array,              # Time points (T,)\n    'x': array,              # States (T, nx) - time-major format\n    'success': bool,         # Integration succeeded\n    'message': str,          # Status message\n    'nfev': int,             # Function evaluations\n    'nsteps': int,           # Steps taken\n    'integration_time': float,  # Wall clock time (seconds)\n    'solver': str,           # Integrator name\n    \n    # Optional (adaptive methods only):\n    'njev': int,             # Jacobian evaluations\n    'nlu': int,              # LU decompositions\n    'status': int,           # Solver-specific status code\n    'sol': object,           # Dense output object (if requested)\n    'dense_output': bool,    # Dense output available\n}\n\n\nSDEIntegrationResult (Stochastic SDEs)\nSDE integrators extend IntegrationResult with stochastic-specific fields:\n{\n    # All IntegrationResult fields, plus:\n    'diffusion_evals': int,     # Diffusion function calls\n    'noise_samples': array,     # Brownian increments used\n    'n_paths': int,             # Number of trajectories\n    'convergence_type': str,    # 'strong' or 'weak'\n    'sde_type': str,            # 'ito' or 'stratonovich'\n    'noise_type': str,          # 'additive', 'diagonal', 'scalar', 'general'\n    \n    # For Monte Carlo (n_paths &gt; 1):\n    'x': array,                 # (n_paths, T, nx)\n    'statistics': dict,         # {'mean', 'std', 'q25', 'q50', 'q75'}\n}",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-usage-examples",
    "href": "architecture/Integration_Framework_Architecture.html#sec-usage-examples",
    "title": "Integration Framework Architecture",
    "section": "Practical Usage Examples",
    "text": "Practical Usage Examples\n\n\n\n\n\n\nNoteRecommended Usage Pattern\n\n\n\nThe examples below show direct integrator instantiation for documentation purposes. In practice, most users should use the system’s integrate() method which delegates to the appropriate integrator automatically:\n# Recommended approach\nresult = system.integrate(x0=x0, method='RK45', t_span=(0, 10))\n\n# Advanced approach (shown in examples below)\nintegrator = IntegratorFactory.auto(system)\nresult = integrator.integrate(x0, u_func, t_span=(0, 10))\n\n\n\nExample 1: Recommended High-Level Interface\n\n\nCode\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Most users should use this approach - system handles delegation\nx0 = np.array([0.1, 0.0])\nresult = system.integrate(\n    x0=x0,\n    method='RK45',  # Optional: auto-selected if not specified\n    t_span=(0.0, 10.0)\n)\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\nprint(f\"Success: {result['success']}\")\n\n\n\n\nExample 2: Advanced - Direct Integrator Access\n\n\nCode\n# Advanced: Direct integrator instantiation for reuse or fine control\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nintegrator = IntegratorFactory.auto(system)\n\n# Can reuse integrator for multiple integrations\nx0 = np.array([0.1, 0.0])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate(x0, u_func, t_span=(0.0, 10.0))\n\nprint(f\"Method: {result['solver']}\")\nprint(f\"Steps: {result['nsteps']}\")\n\n\n\n\nExample 3: High-Accuracy Julia Integration\n\n\nCode\n# Recommended: System-level interface\nsystem = Pendulum(m_val=1.0, l_val=0.5)\nx0 = np.array([1.0, 0.0])\n\nresult = system.integrate(\n    x0=x0,\n    method='Vern9',  # Julia's 9th order method\n    rtol=1e-12,\n    atol=1e-14,\n    t_span=(0, 100)\n)\n\nprint(f\"Function evaluations: {result['nfev']}\")\nprint(f\"Integration time: {result['integration_time']:.4f}s\")\n\n\n\n\nExample 4: GPU-Accelerated Neural ODE\n\n\nCode\nsystem = Pendulum(m_val=1.0, l_val=0.5)\n\n# Switch to PyTorch backend for gradients\nwith system.use_backend('torch'):\n    x0 = torch.tensor([1.0, 0.0], requires_grad=True)\n    \n    result = system.integrate(\n        x0=x0,\n        method='dopri5',\n        device='cpu',  # Use 'cuda:0' for GPU\n        t_span=(0, 10)\n    )\n    \n    # Gradient computation works seamlessly\n    final_state = result['x'][-1]\n    loss = final_state.sum()\n    loss.backward()\n    \n    print(f\"Gradient w.r.t. x0: {x0.grad}\")\n\n\n\n\nExample 5: Stochastic Simulation with Monte Carlo\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic import get_trajectory_statistics\n\n# Create stochastic system\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n\n# Use integrator for Monte Carlo (don't specify backend, it's handled internally)\nintegrator = SDEIntegratorFactory.for_monte_carlo(\n    sde_system, n_paths=1000\n)\n\nx0 = np.array([1.0])\nu_func = lambda t, x: np.zeros(1)\nresult = integrator.integrate_monte_carlo(\n    x0, u_func, t_span=(0, 10), n_paths=1000\n)\n\n# Extract statistics\nstats = get_trajectory_statistics(result)\n\n# Extract scalar values from arrays\nmean_final = float(stats['mean'][-1].flat[0])\nstd_final = float(stats['std'][-1].flat[0])\n\nprint(f\"Mean at t=10: {mean_final:.4f}\")\nprint(f\"Std at t=10: {std_final:.4f}\")\n\n\n\n\nExample 6: Deterministic Testing with Custom Noise\n\n\nCode\nfrom cdesym.systems.base.numerical_integration.stochastic.custom_brownian import CustomBrownianPath\n\nsde_system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\nnw = sde_system.nw\n\n# Zero noise for deterministic testing\ndW = jnp.zeros((nw,))\nbrownian = CustomBrownianPath(t0=0.0, t1=10.0, dW=dW)\n\n# Create JAX integrator\nintegrator = SDEIntegratorFactory.create(\n    sde_system,\n    backend='jax',\n    method='Euler',\n    dt=0.01,\n    seed=SEED\n)\n\n# Integrate with custom noise\nx0 = jnp.array([0.5])\nu_func = lambda t, x: jnp.zeros(1)\nresult = integrator.integrate(\n    x0, u_func, t_span=(0, 10), brownian_path=brownian\n)\n\nprint(f\"Deterministic integration complete\")\nprint(f\"Final state: {result['x'][-1]}\")",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-selection-guide",
    "href": "architecture/Integration_Framework_Architecture.html#sec-selection-guide",
    "title": "Integration Framework Architecture",
    "section": "Integrator Selection Guide",
    "text": "Integrator Selection Guide\n\nBy Use Case\n\n\n\n\n\n\n\n\nUse Case\nRecommended Approach\nRationale\n\n\n\n\nGeneral ODE\nIntegratorFactory.for_production(system)\nLSODA auto-stiffness detection\n\n\nNeural ODE\nIntegratorFactory.for_neural_ode(system)\nAdjoint method for memory efficiency\n\n\nOptimization\nIntegratorFactory.for_optimization(system)\nJAX with XLA compilation\n\n\nHigh Accuracy\nIntegratorFactory.for_julia(system, 'Vern9')\nJulia 9th order methods\n\n\nStiff ODE\nScipyIntegrator(system, method='BDF')\nBackward differentiation\n\n\nSimple ODE\nRK4Integrator(system, dt=0.01)\nClassic fixed-step\n\n\nGeneral SDE\nSDEIntegratorFactory.auto(sde_system)\nAutomatic noise detection\n\n\nMonte Carlo\nSDEIntegratorFactory.for_monte_carlo(...)\nParallelized trajectories\n\n\n\n\n\nBy Backend Capabilities\n\n\n\n\n\n\n\n\n\nBackend\nODE Integrator\nSDE Integrator\nBest For\n\n\n\n\nNumPy\nScipyIntegrator, DiffEqPyIntegrator\nDiffEqPySDEIntegrator\nGeneral purpose, highest compatibility\n\n\nPyTorch\nTorchDiffEqIntegrator\nTorchSDEIntegrator\nGPU acceleration, neural networks\n\n\nJAX\nDiffraxIntegrator\nDiffraxSDEIntegrator\nOptimization, functional programming\n\n\n\n\n\nBy System Properties\n\n\n\n\n\n\n\n\n\nSystem Type\nBest Method\nConvergence Order\nNotes\n\n\n\n\nNon-stiff\nRK45, Tsit5, dopri5\n5(4)\nGeneral purpose\n\n\nStiff\nBDF, Radau, Rodas5\nVariable\nImplicit methods required\n\n\nVery stiff\nBDF, LSODA\nVariable\nAutomatic stiffness detection\n\n\nHigh accuracy\nVern9, DOP853\n9(8) or 8(5,3)\nFor precision-critical applications\n\n\nReal-time\nRK4, euler\n4 or 1\nFixed step, predictable timing\n\n\nAdditive noise SDE\nreversible_heun, adaptive_heun\n1.0 (strong)\nExploits simplified noise structure\n\n\nGeneral SDE\nEuler-Maruyama\n0.5 (strong)\nRobust for any noise type\n\n\nDiagonal noise SDE\nMilstein\n1.0 (strong)\nHigher order for independent channels",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-design-principles",
    "href": "architecture/Integration_Framework_Architecture.html#sec-design-principles",
    "title": "Integration Framework Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\nBackend Abstraction\nAll integrators provide consistent interfaces across computational backends. Switch between NumPy, PyTorch, and JAX without changing integration code:\n# Same interface, different backends\nintegrator_numpy = IntegratorFactory.auto(system, backend='numpy')\nintegrator_torch = IntegratorFactory.auto(system, backend='torch')\nintegrator_jax = IntegratorFactory.auto(system, backend='jax')\n\n\nFactory Pattern for Complexity Management\nFactories encapsulate the complexity of choosing appropriate integrators:\n# User specifies intent, factory handles details\nIntegratorFactory.for_production(system)  # → LSODA\nIntegratorFactory.for_neural_ode(system)  # → dopri5 with adjoint\nIntegratorFactory.for_optimization(system)  # → tsit5 with JAX\n\n\nUnified Result Types\nTypedDict results provide consistent structure with IDE support:\nresult: IntegrationResult = integrator.integrate(...)\n# IDE knows 'success', 'nfev', 'x', 't' are available\n\n\nComposition Over Inheritance\nIntegrators compose with systems rather than inheriting deeply:\nclass Integrator:\n    def __init__(self, system: ContinuousSystemBase):\n        self.system = system  # Composition\n\n\nBuilt-in Performance Tracking\nAll integrators track statistics automatically:\nprint(f\"Function evaluations: {integrator._stats['total_fev']}\")\nprint(f\"Integration steps: {integrator._stats['total_steps']}\")\nprint(f\"Computation time: {integrator._stats['total_time']:.4f}s\")",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#sec-strengths",
    "href": "architecture/Integration_Framework_Architecture.html#sec-strengths",
    "title": "Integration Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\nMulti-backend support: Seamless NumPy/PyTorch/JAX switching\nExtensive method library: 40+ integration methods across ODE and SDE\nCentralized method registry: Unified method normalization, validation, and discovery\nCanonical name support: Use portable names (euler_maruyama, rk45) across backends\nIntelligent factories: Automatic method selection based on system properties\nType safety: TypedDict results with full IDE support\nGPU acceleration: First-class support via PyTorch and JAX\nXLA compilation: Near-native performance with JAX\nJulia integration: Access to world-class DifferentialEquations.jl ecosystem\nSDE support: Comprehensive stochastic integration framework\nNoise exploitation: Automatic detection and optimization for noise structure\nMonte Carlo: Built-in multi-trajectory simulation\nCustom noise: Deterministic testing with user-provided Brownian paths\nProduction ready: Professional error control and performance tracking",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Integration_Framework_Architecture.html#summary",
    "href": "architecture/Integration_Framework_Architecture.html#summary",
    "title": "Integration Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe ControlDESymulation integration framework provides a comprehensive, production-ready solution for numerical integration across deterministic and stochastic systems. With support for multiple backends, extensive method libraries, and intelligent automation through factory patterns, it enables efficient development of control theory and machine learning applications requiring state-of-the-art numerical integration.",
    "crumbs": [
      "Framework Design",
      "Integration Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html",
    "href": "architecture/Control_Framework_Architecture.html",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "The Control Framework provides classical control theory algorithms for analysis and synthesis of dynamical systems. It consists of 3 core modules organized into a clean 2-layer architecture: pure stateless functions and thin composition wrappers.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nPure Function Layer: classical_control_functions.py - Stateless control algorithms\nComposition Layer: control_synthesis.py, system_analysis.py - System integration\nType Layer: control_classical.py - TypedDict result definitions\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nUsers interact with the control framework through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\n\n# Control design\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\n\n# System analysis\nstability = system.analysis.stability(A, system_type='continuous')\ncontrollability = system.analysis.controllability(A, B)\n\n# ✗ INCORRECT: Direct function imports (not recommended)\nfrom cdesym.control.classical_control_functions import design_lqr\nlqr = design_lqr(A, B, Q, R, system_type='continuous')\nThe system properties (system.control, system.analysis) automatically handle backend management and provide a consistent interface. Direct function calls are possible but bypass the system’s backend configuration.",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-overview",
    "href": "architecture/Control_Framework_Architecture.html#sec-overview",
    "title": "Control Framework Architecture",
    "section": "",
    "text": "The Control Framework provides classical control theory algorithms for analysis and synthesis of dynamical systems. It consists of 3 core modules organized into a clean 2-layer architecture: pure stateless functions and thin composition wrappers.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\nPure Function Layer: classical_control_functions.py - Stateless control algorithms\nComposition Layer: control_synthesis.py, system_analysis.py - System integration\nType Layer: control_classical.py - TypedDict result definitions\n\n\n\n\n\n\n\n\nImportantUser Interaction Model\n\n\n\nUsers interact with the control framework through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nA, B = system.linearize(x_eq, u_eq)\n\n# Control design\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\n\n# System analysis\nstability = system.analysis.stability(A, system_type='continuous')\ncontrollability = system.analysis.controllability(A, B)\n\n# ✗ INCORRECT: Direct function imports (not recommended)\nfrom cdesym.control.classical_control_functions import design_lqr\nlqr = design_lqr(A, B, Q, R, system_type='continuous')\nThe system properties (system.control, system.analysis) automatically handle backend management and provide a consistent interface. Direct function calls are possible but bypass the system’s backend configuration.",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Control_Framework_Architecture.html#sec-architecture-philosophy",
    "title": "Control Framework Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nFunctional Design with Composition - The control framework achieves:\n\nPure Functions - Stateless algorithms like scipy (design_lqr, analyze_stability)\nThin Wrappers - Minimal composition layer for system integration\nType Safety - TypedDict results for all algorithms\nBackend Consistency - Automatic backend handling from parent system\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Implements classical control theory correctly\nClean Integration - Natural system.control and system.analysis APIs\n\nDesign principle: Control algorithms are pure functions that work like scipy—take matrices in, return structured results. Thin wrapper classes provide system integration without adding business logic.",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-framework-layers",
    "href": "architecture/Control_Framework_Architecture.html#sec-framework-layers",
    "title": "Control Framework Architecture",
    "section": "Framework Layers",
    "text": "Framework Layers\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│              (ContinuousSystemBase, DiscreteSystemBase)    │\n│                                                            │\n│  system.control   ─────► ControlSynthesis                 │\n│  system.analysis  ─────► SystemAnalysis                   │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ delegates to\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│              PURE FUNCTION LAYER                           │\n│          classical_control_functions.py                    │\n│                                                            │\n│  Control Design:          System Analysis:                 │\n│  • design_lqr()          • analyze_stability()             │\n│  • design_kalman()       • analyze_controllability()       │\n│  • design_lqg()          • analyze_observability()         │\n│                                                            │\n│  All functions are stateless, pure, backend-agnostic       │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ returns\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   TYPE LAYER                               │\n│             control_classical.py                           │\n│                                                            │\n│  • LQRResult           • StabilityInfo                     │\n│  • KalmanFilterResult  • ControllabilityInfo               │\n│  • LQGResult           • ObservabilityInfo                 │\n└────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-pure-function-layer",
    "href": "architecture/Control_Framework_Architecture.html#sec-pure-function-layer",
    "title": "Control Framework Architecture",
    "section": "Pure Function Layer",
    "text": "Pure Function Layer\n\nclassical_control_functions.py: Stateless Algorithms\nFile: classical_control_functions.py\nThe pure function layer provides stateless control algorithms that work like scipy—take matrices in, return structured TypedDict results.\nDesign philosophy:\n\nPure functions - No side effects, no state\nBackend agnostic - Internal conversion to/from NumPy for scipy\nMathematical correctness - Rigorous implementation of control theory\nComprehensive validation - Dimension checks, positive-definiteness\nClear error handling - Actionable exceptions for infeasible problems\n\nKey categories:\n\n\nControl Design Functions\n\nLQR Controller Design\nMathematical background:\nContinuous-time LQR:\n\\[J = \\int_0^\\infty (x'Qx + u'Ru + 2x'Nu) dt\\]\nAlgebraic Riccati Equation (ARE):\n\\[A'P + PA - PBR^{-1}B'P + Q - N'R^{-1}N = 0\\]\nOptimal gain:\n\\[K = R^{-1}(B'P + N')\\]\nDiscrete-time LQR:\n\\[J = \\sum_{k=0}^\\infty (x[k]'Qx[k] + u[k]'Ru[k] + 2x[k]'Nu[k])\\]\nDiscrete ARE:\n\\[P = A'PA - (A'PB + N)(R + B'PB)^{-1}(B'PA + N') + Q\\]\nOptimal gain:\n\\[K = (R + B'PB)^{-1}(B'PA + N')\\]\nFunction signature:\ndef design_lqr(\n    A: StateMatrix,\n    B: InputMatrix,\n    Q: StateMatrix,\n    R: InputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQRResult:\n    \"\"\"\n    Design Linear Quadratic Regulator (LQR) controller.\n    \n    Unified interface for continuous and discrete LQR.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    Q : StateMatrix\n        State cost matrix (nx, nx), Q ≥ 0, (Q,A) detectable\n    R : InputMatrix\n        Control cost matrix (nu, nu), R &gt; 0\n    N : InputMatrix, optional\n        Cross-coupling matrix (nx, nu)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    LQRResult\n        gain : Optimal feedback gain K (nu, nx)\n        cost_to_go : Riccati solution P (nx, nx)\n        closed_loop_eigenvalues : eig(A - BK)\n        stability_margin : Stability robustness measure\n    \n    Raises\n    ------\n    ValueError\n        If Q, R dimensions incompatible or conditions violated\n    LinAlgError\n        If Riccati equation has no stabilizing solution\n    \"\"\"\nUsage example:\n\n\nCode\nsystem = Pendulum()\n\n# Linearize at upright equilibrium\nx_eq = np.array([np.pi, 0.0])\nu_eq = np.array([0.0])\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])   # Penalize angle more than velocity\nR = np.array([[0.1]])   # Small control cost\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Extract results\nK = lqr['gain']\nP = lqr['cost_to_go']\neigs = lqr['controller_eigenvalues']\n\nprint(f\"LQR gain shape: {K.shape}\")\nprint(f\"Closed-loop stable: {np.all(np.real(eigs) &lt; 0)}\")\n\n\n\n\nKalman Filter Design\nMathematical background:\nSystem model:\n\\[x[k+1] = Ax[k] + Bu[k] + w[k], \\quad w \\sim \\mathcal{N}(0, Q)\\]\n\\[y[k] = Cx[k] + v[k], \\quad v \\sim \\mathcal{N}(0, R)\\]\nEstimator dynamics:\n\\[\\hat{x}[k+1] = A\\hat{x}[k] + Bu[k] + L(y[k] - C\\hat{x}[k])\\]\nOptimal gain:\n\\[L = APC'(CPC' + R)^{-1}\\]\nError covariance Riccati equation:\n\\[P = A(P - PC'(CPC' + R)^{-1}CP)A' + Q\\]\nFunction signature:\ndef design_kalman_filter(\n    A: StateMatrix,\n    C: OutputMatrix,\n    Q: StateMatrix,\n    R: OutputMatrix,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; KalmanFilterResult:\n    \"\"\"\n    Design Kalman filter for optimal state estimation.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    Q : StateMatrix\n        Process noise covariance (nx, nx), Q ≥ 0\n    R : OutputMatrix\n        Measurement noise covariance (ny, ny), R &gt; 0\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    KalmanFilterResult\n        gain : Kalman gain L (nx, ny)\n        error_covariance : Steady-state P (nx, nx)\n        innovation_covariance : S = CPC' + R (ny, ny)\n        observer_eigenvalues : eig(A - LC)\n    \"\"\"\nUsage example:\n\n\nCode\n# Define measurement model (measure angle only)\nC = np.array([[1, 0]])\n\n# Define noise covariances\nQ_process = 0.01 * np.eye(2)      # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# Extract results\nL = kalman['gain']\nP = kalman['estimation_error_covariance']\nestimator_eigs = kalman['estimator_eigenvalues']\n\nprint(f\"Kalman gain shape: {L.shape}\")\nprint(f\"Observer stable: {np.all(np.real(estimator_eigs) &lt; 0)}\")\n\n\n\n\nLQG Controller Design\nMathematical background:\nSeparation principle:\n\nDesign LQR assuming full state feedback: \\(u = -Kx\\)\nDesign Kalman filter for state estimation\nCombine via certainty equivalence: \\(u = -K\\hat{x}\\)\n\nClosed-loop system:\n\\[\\begin{bmatrix} x[k+1] \\\\ e[k+1] \\end{bmatrix} = \\begin{bmatrix} A - BK & BK \\\\ 0 & A - LC \\end{bmatrix} \\begin{bmatrix} x[k] \\\\ e[k] \\end{bmatrix} + \\begin{bmatrix} w[k] \\\\ w[k] - Lv[k] \\end{bmatrix}\\]\nEigenvalues:\n\nController poles: \\(\\text{eig}(A - BK)\\)\nObserver poles: \\(\\text{eig}(A - LC)\\)\nCombined: \\(\\text{eig}(A - BK) \\cup \\text{eig}(A - LC)\\)\n\nFunction signature:\ndef design_lqg(\n    A: StateMatrix,\n    B: InputMatrix,\n    C: OutputMatrix,\n    Q_state: StateMatrix,\n    R_control: InputMatrix,\n    Q_process: StateMatrix,\n    R_measurement: OutputMatrix,\n    N: Optional[InputMatrix] = None,\n    system_type: str = \"discrete\",\n    backend: Backend = \"numpy\"\n) -&gt; LQGResult:\n    \"\"\"\n    Design Linear Quadratic Gaussian (LQG) controller.\n    \n    Combines LQR (optimal control) with Kalman filter (optimal estimation)\n    via the separation principle.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    Q_state : StateMatrix\n        LQR state cost (nx, nx)\n    R_control : InputMatrix\n        LQR control cost (nu, nu)\n    Q_process : StateMatrix\n        Process noise covariance (nx, nx)\n    R_measurement : OutputMatrix\n        Measurement noise covariance (ny, ny)\n    N : InputMatrix, optional\n        Cross-coupling (nx, nu)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    LQGResult\n        control_gain : LQR gain K (nu, nx)\n        estimator_gain : Kalman gain L (nx, ny)\n        control_cost_to_go : Controller Riccati P_c\n        estimation_error_covariance : Estimator Riccati P_e\n        separation_verified : bool\n        closed_loop_stable : bool\n        controller_eigenvalues : eig(A - BK)\n        estimator_eigenvalues : eig(A - LC)\n    \"\"\"\nUsage example:\n\n\nCode\n# Design LQG controller\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state=np.diag([10, 1]),\n    R_control=np.array([[0.1]]),\n    Q_process=0.01*np.eye(2),\n    R_measurement=np.array([[0.1]]),\n    system_type='continuous'\n)\n\n# Extract both gains\nK_control = lqg['control_gain']\nL_estimator = lqg['estimator_gain']\n\nprint(f\"LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"Separation verified: {lqg['separation_verified']}\")\nprint(f\"Controller poles: {lqg['controller_eigenvalues']}\")\nprint(f\"Observer poles: {lqg['estimator_eigenvalues']}\")\n\n\n\n\n\nSystem Analysis Functions\n\nStability Analysis\nMathematical background:\nContinuous-time stability criteria: - Asymptotically stable: All \\(\\text{Re}(\\lambda) &lt; 0\\) (left half-plane) - Marginally stable: \\(\\max \\text{Re}(\\lambda) \\approx 0\\) - Unstable: Any \\(\\text{Re}(\\lambda) &gt; 0\\)\nDiscrete-time stability criteria: - Asymptotically stable: All \\(|\\lambda| &lt; 1\\) (inside unit circle) - Marginally stable: \\(\\max |\\lambda| \\approx 1\\) - Unstable: Any \\(|\\lambda| &gt; 1\\)\nFunction signature:\ndef analyze_stability(\n    A: StateMatrix,\n    system_type: str = \"continuous\",\n    backend: Backend = \"numpy\"\n) -&gt; StabilityInfo:\n    \"\"\"\n    Analyze system stability via eigenvalue placement.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    system_type : str\n        'continuous' or 'discrete'\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    StabilityInfo\n        eigenvalues : Complex eigenvalues of A\n        magnitudes : |λ| for each eigenvalue\n        max_magnitude : max |λ| (spectral radius)\n        spectral_radius : Same as max_magnitude\n        is_stable : Asymptotic stability\n        is_marginally_stable : On boundary\n        is_unstable : At least one unstable mode\n    \"\"\"\nUsage example:\n\n\nCode\n# Analyze open-loop stability\nstability_ol = system.analysis.stability(A, system_type='continuous')\n\nprint(f\"Open-loop stable: {stability_ol['is_stable']}\")\nprint(f\"Spectral radius: {stability_ol['spectral_radius']:.3f}\")\nprint(f\"Eigenvalues: {stability_ol['eigenvalues']}\")\n\n# Analyze closed-loop stability (with LQR)\nA_cl = A - B @ K\nstability_cl = system.analysis.stability(A_cl, system_type='continuous')\n\nprint(f\"\\nClosed-loop stable: {stability_cl['is_stable']}\")\nprint(f\"Spectral radius: {stability_cl['spectral_radius']:.3f}\")\n\n\n\n\nControllability Analysis\nMathematical background:\nControllability test:\n\\[\\text{rank}(\\mathcal{C}) = n_x \\quad \\text{where} \\quad \\mathcal{C} = [B, AB, A^2B, \\ldots, A^{n_x-1}B]\\]\nInterpretation: - Controllable: All states can be driven to any value in finite time - Uncontrollable: Some states cannot be influenced by control\nFunction signature:\ndef analyze_controllability(\n    A: StateMatrix,\n    B: InputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ControllabilityInfo:\n    \"\"\"\n    Test system controllability via rank condition.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    B : InputMatrix\n        Input matrix (nx, nu)\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    ControllabilityInfo\n        controllability_matrix : C = [B AB ... A^(n-1)B] (nx, nx*nu)\n        rank : Rank of controllability matrix\n        is_controllable : rank == nx\n        uncontrollable_modes : Eigenvalues of uncontrollable subsystem\n    \"\"\"\nUsage example:\n\n\nCode\n# Check controllability\nctrl = system.analysis.controllability(A, B)\n\nprint(f\"Controllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif ctrl['is_controllable']:\n    print(\"✓ Can design LQR controller\")\nelse:\n    print(\"✗ Cannot design LQR - system not controllable\")\n    if ctrl.get('uncontrollable_modes') is not None:\n        print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n\n\n\nObservability Analysis\nMathematical background:\nObservability test:\n\\[\\text{rank}(\\mathcal{O}) = n_x \\quad \\text{where} \\quad \\mathcal{O} = \\begin{bmatrix} C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n_x-1} \\end{bmatrix}\\]\nInterpretation: - Observable: Initial state can be determined from output measurements - Unobservable: Some states hidden from measurements\nFunction signature:\ndef analyze_observability(\n    A: StateMatrix,\n    C: OutputMatrix,\n    backend: Backend = \"numpy\"\n) -&gt; ObservabilityInfo:\n    \"\"\"\n    Test system observability via rank condition.\n    \n    Parameters\n    ----------\n    A : StateMatrix\n        State matrix (nx, nx)\n    C : OutputMatrix\n        Output matrix (ny, nx)\n    backend : Backend\n        Computational backend\n    \n    Returns\n    -------\n    ObservabilityInfo\n        observability_matrix : O = [C; CA; ...] (nx*ny, nx)\n        rank : Rank of observability matrix\n        is_observable : rank == nx\n        unobservable_modes : Eigenvalues of unobservable subsystem\n    \"\"\"\nUsage example:\n\n\nCode\n# Check observability\nobs = system.analysis.observability(A, C)\n\nprint(f\"Observable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n    if obs.get('unobservable_modes') is not None:\n        print(f\"Unobservable modes: {obs['unobservable_modes']}\")\n\n# Check minimal realization\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"\\n✓ System is minimal (controllable and observable)\")\n    print(\"✓ Can design LQG controller\")",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-composition-wrapper-layer",
    "href": "architecture/Control_Framework_Architecture.html#sec-composition-wrapper-layer",
    "title": "Control Framework Architecture",
    "section": "Composition Wrapper Layer",
    "text": "Composition Wrapper Layer\n\nControlSynthesis: Control Design Wrapper\nFile: control_synthesis.py\nThe ControlSynthesis class provides a thin wrapper for control design algorithms, integrating them with the system’s backend configuration.\nDesign philosophy:\n\nComposition not inheritance - Utility composed by system, not inherited\nNo state - Only stores backend setting from parent system\nNo caching - Delegates immediately to pure functions\nClean API - Methods match control theory terminology\n\nArchitecture:\nclass ControlSynthesis:\n    \"\"\"\n    Control synthesis wrapper for system composition.\n    \n    Thin wrapper that routes to pure control design functions while\n    maintaining backend consistency with parent system.\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def design_lqr(self, A, B, Q, R, N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqr()\"\"\"\n        from cdesym.control.classical_control_functions import design_lqr\n        return design_lqr(A, B, Q, R, N, system_type, self.backend)\n    \n    def design_kalman(self, A, C, Q, R, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_kalman_filter()\"\"\"\n        from cdesym.control.classical_control_functions import design_kalman_filter\n        return design_kalman_filter(A, C, Q, R, system_type, self.backend)\n    \n    def design_lqg(self, A, B, C, Q_state, R_control, Q_process, R_measurement, \n                   N=None, system_type='discrete'):\n        \"\"\"Route to classical_control_functions.design_lqg()\"\"\"\n        from cdesym.control.classical_control_functions import design_lqg\n        return design_lqg(A, B, C, Q_state, R_control, Q_process, R_measurement, \n                         N, system_type, self.backend)\nSystem integration:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef control(self) -&gt; ControlSynthesis:\n    \"\"\"Access control synthesis utilities.\"\"\"\n    if not hasattr(self, '_control_synthesis'):\n        from cdesym.control.control_synthesis import ControlSynthesis\n        self._control_synthesis = ControlSynthesis(backend=self.backend.default_backend)\n    return self._control_synthesis\n\n\nSystemAnalysis: System Analysis Wrapper\nFile: system_analysis.py\nThe SystemAnalysis class provides a thin wrapper for system analysis algorithms, identical in design to ControlSynthesis.\nArchitecture:\nclass SystemAnalysis:\n    \"\"\"\n    System analysis wrapper for composition.\n    \n    Thin wrapper that routes to pure system analysis functions while\n    maintaining backend consistency with parent system.\n    \"\"\"\n    \n    def __init__(self, backend: Backend = \"numpy\"):\n        self.backend = backend\n    \n    def stability(self, A, system_type='continuous'):\n        \"\"\"Route to classical_control_functions.analyze_stability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_stability\n        return analyze_stability(A, system_type, self.backend)\n    \n    def controllability(self, A, B):\n        \"\"\"Route to classical_control_functions.analyze_controllability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_controllability\n        return analyze_controllability(A, B, self.backend)\n    \n    def observability(self, A, C):\n        \"\"\"Route to classical_control_functions.analyze_observability()\"\"\"\n        from cdesym.control.classical_control_functions import analyze_observability\n        return analyze_observability(A, C, self.backend)\nSystem integration:\n# In ContinuousSystemBase / DiscreteSystemBase\n@property\ndef analysis(self) -&gt; SystemAnalysis:\n    \"\"\"Access system analysis utilities.\"\"\"\n    if not hasattr(self, '_system_analysis'):\n        from cdesym.control.system_analysis import SystemAnalysis\n        self._system_analysis = SystemAnalysis(backend=self.backend.default_backend)\n    return self._system_analysis",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-design-patterns",
    "href": "architecture/Control_Framework_Architecture.html#sec-design-patterns",
    "title": "Control Framework Architecture",
    "section": "Design Patterns",
    "text": "Design Patterns\n\nPattern 1: Pure Functions + Thin Wrappers\nPrinciple: Separate stateless algorithms from system integration.\n\n\nCode\n# ✗ ANTI-PATTERN: Methods on system class (violates SRP)\nclass ContinuousSystemBase:\n    def design_lqr(self, Q, R):\n        # LQR implementation mixed with system concerns\n        pass\n\n# ✓ GOOD PATTERN: Pure function + composition\n\n# Pure function (classical_control_functions.py)\ndef design_lqr(A, B, Q, R, system_type, backend):\n    \"\"\"Stateless, testable, reusable.\"\"\"\n    # Focus solely on LQR algorithm\n    return LQRResult(...)\n\n# Thin wrapper (control_synthesis.py)\nclass ControlSynthesis:\n    def design_lqr(self, A, B, Q, R, system_type):\n        return design_lqr(A, B, Q, R, system_type, self.backend)\n\n# System integration (continuous_system_base.py)\n@property\ndef control(self) -&gt; ControlSynthesis:\n    return ControlSynthesis(backend=self.backend.default_backend)\n\n\nBenefits:\n\n✓ Single responsibility per component\n✓ Easy unit testing of pure functions\n✓ Reusable algorithms outside system context\n✓ Maintainability through isolation\n\n\n\nPattern 2: Backend Agnosticism\nPrinciple: Convert to NumPy for scipy, then back to original backend.\ndef design_lqr(..., backend: Backend):\n    \"\"\"Works with NumPy, PyTorch, JAX transparently.\"\"\"\n    \n    # Convert to NumPy for scipy\n    A_np = _to_numpy(A, backend)\n    B_np = _to_numpy(B, backend)\n    Q_np = _to_numpy(Q, backend)\n    R_np = _to_numpy(R, backend)\n    \n    # Solve in NumPy (scipy.linalg)\n    P = solve_continuous_are(A_np, B_np, Q_np, R_np)\n    K = np.linalg.solve(R_np, B_np.T @ P)\n    \n    # Convert back to original backend\n    K_result = _from_numpy(K, backend)\n    P_result = _from_numpy(P, backend)\n    \n    return LQRResult(gain=K_result, cost_to_go=P_result, ...)\n\n\nPattern 3: TypedDict Results\nPrinciple: Structured results with type safety and IDE support.\n\n\nCode\n# All functions return structured TypedDict\nresult: LQRResult = design_lqr(A, B, Q, R, system_type='continuous')\n\n# IDE autocomplete knows all fields\nK = result['gain']                    # ✓ Valid\nP = result['cost_to_go']              # ✓ Valid\neigs = result['controller_eigenvalues']  # ✓ Valid\nbad = result['nonexistent_key']       # ✗ Type error!\n\n# Type checking prevents errors\ndef apply_control(result: LQRResult) -&gt; np.ndarray:\n    return result['gain']  # ✓ Type checker verifies\n\n\n\n\nPattern 4: Unified Continuous/Discrete Interface\nPrinciple: Single function handles both continuous and discrete cases.\ndef design_lqr(A, B, Q, R, N=None, system_type='discrete', backend='numpy'):\n    \"\"\"Unified interface - system_type selects algorithm.\"\"\"\n    \n    if system_type == 'continuous':\n        # Continuous-time algebraic Riccati equation\n        P = solve_continuous_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R, B.T @ P)\n    elif system_type == 'discrete':\n        # Discrete-time algebraic Riccati equation\n        P = solve_discrete_are(A, B, Q, R, s=N)\n        K = np.linalg.solve(R + B.T @ P @ B, B.T @ P @ A)\n    else:\n        raise ValueError(f\"Invalid system_type: {system_type}\")\n    \n    # Rest of implementation identical\n    closed_loop_eigs = np.linalg.eigvals(A - B @ K)\n    \n    return LQRResult(gain=K, cost_to_go=P, ...)\nBenefits:\n\n✓ Single function for both cases\n✓ Less code duplication\n✓ Consistent API across system types\n✓ Easier maintenance",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-usage-workflows",
    "href": "architecture/Control_Framework_Architecture.html#sec-usage-workflows",
    "title": "Control Framework Architecture",
    "section": "Usage Workflows",
    "text": "Usage Workflows\n\nWorkflow 1: LQR Controller Design\nComplete workflow from linearization to closed-loop simulation:\n\n\nCode\n# 1. Create system\nsystem = Pendulum(m_val=1.0, l_val=0.5, g_val=9.81, beta_val=0.1)\n\n# 2. Define equilibrium (upright position)\nx_eq = np.array([np.pi, 0])  # [theta, omega]\nu_eq = np.zeros(1)\n\n# 3. Linearize at equilibrium\nA, B = system.linearize(x_eq, u_eq)\n\n# 4. Design LQR controller\nQ = np.diag([10, 1])   # Penalize angle more than velocity\nR = np.array([[0.1]])   # Small control cost\n\nlqr = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# 5. Extract and verify\nK = lqr['gain']\neigs = lqr['controller_eigenvalues']\n\nprint(f\"✓ LQR gain: {K}\")\nprint(f\"✓ Closed-loop stable: {np.all(np.real(eigs) &lt; 0)}\")\n\n# 6. Implement controller\ndef lqr_controller(t, x):\n    return -K @ (x - x_eq)\n\n# 7. Simulate (closed-loop)\nresult = system.simulate(\n    x0=np.array([np.pi + 0.2, 0]),  # Start near upright\n    controller=lqr_controller,\n    t_span=(0, 10),\n    dt=0.01\n)\n\nprint(f\"✓ Simulation complete: {len(result['time'])} time points\")\n\n\n\n\nWorkflow 2: Kalman Filter Design\nObserver design for partial state measurements:\n\n\nCode\n# 1. Same system and linearization\nA, B = system.linearize(x_eq, u_eq)\n\n# 2. Define measurement model (measure angle only)\nC = np.array([[1, 0]])  # Observe theta, not omega\n\n# 3. Define noise covariances\nQ_process = 0.01 * np.eye(2)      # Process noise\nR_measurement = np.array([[0.1]])  # Measurement noise\n\n# 4. Design Kalman filter\nkalman = system.control.design_kalman(\n    A, C, Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 5. Extract gain\nL = kalman['gain']\nobserver_eigs = kalman['estimator_eigenvalues']\n\nprint(f\"✓ Kalman gain: {L}\")\nprint(f\"✓ Observer stable: {np.all(np.real(observer_eigs) &lt; 0)}\")\n\n# 6. Implement estimator\nx_hat = np.zeros(2)\ndt = 0.01\nN = 1000\n\nfor k in range(N):\n    # Prediction\n    x_hat_pred = A @ x_hat * dt + x_hat + B @ u[k] * dt\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + np.random.randn() * np.sqrt(0.1)\n    innovation = y_meas - C @ x_hat_pred\n    x_hat = x_hat_pred + L @ innovation * dt\n\n\n\n\nWorkflow 3: LQG Controller Design\nCombined optimal control and estimation:\n\n\nCode\n# 1. Define all matrices\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])  # Partial state measurement\n\n# 2. Design weights\nQ_state = np.diag([10, 1])        # LQR state cost\nR_control = np.array([[0.1]])      # LQR control cost\nQ_process = 0.01 * np.eye(2)      # Kalman process noise\nR_measurement = np.array([[0.1]])  # Kalman measurement noise\n\n# 3. Design LQG\nlqg = system.control.design_lqg(\n    A, B, C,\n    Q_state, R_control,\n    Q_process, R_measurement,\n    system_type='continuous'\n)\n\n# 4. Extract both gains\nK = lqg['controller_gain']\nL = lqg['estimator_gain']\n\nprint(f\"✓ LQG stable: {lqg['closed_loop_stable']}\")\nprint(f\"✓ Separation verified: {lqg['separation_verified']}\")\n\n# 5. Implement LQG controller\nx_hat = np.zeros(2)\ndt = 0.01\n\nfor k in range(N):\n    # Control (certainty equivalence)\n    u[k] = -K @ (x_hat - x_eq)\n    \n    # Prediction\n    x_hat = A @ x_hat * dt + x_hat + B @ u[k] * dt\n    \n    # Measurement update\n    y_meas = C @ x_true[k] + measurement_noise[k]\n    innovation = y_meas - C @ x_hat\n    x_hat = x_hat + L @ innovation * dt\n\n\n\n\nWorkflow 4: System Analysis\nComplete system analysis before controller design:\n\n\nCode\n# 1. Linearize system\nA, B = system.linearize(x_eq, u_eq)\nC = np.array([[1, 0]])\n\n# 2. Check stability\nstability = system.analysis.stability(A, system_type='continuous')\nprint(f\"Open-loop stable: {stability['is_stable']}\")\nprint(f\"Eigenvalues: {stability['eigenvalues']}\")\nprint(f\"Spectral radius: {stability['spectral_radius']:.3f}\")\n\n# 3. Check controllability\nctrl = system.analysis.controllability(A, B)\nprint(f\"\\nControllable: {ctrl['is_controllable']}\")\nprint(f\"Rank: {ctrl['rank']} / {A.shape[0]}\")\n\nif not ctrl['is_controllable']:\n    print(f\"Uncontrollable modes: {ctrl['uncontrollable_modes']}\")\n\n# 4. Check observability\nobs = system.analysis.observability(A, C)\nprint(f\"\\nObservable: {obs['is_observable']}\")\nprint(f\"Rank: {obs['rank']} / {A.shape[0]}\")\n\n# 5. Verify conditions for control design\nif ctrl['is_controllable']:\n    print(\"\\n✓ Can design LQR controller\")\nelse:\n    print(\"\\n✗ Cannot design LQR - system not controllable\")\n\nif obs['is_observable']:\n    print(\"✓ Can design Kalman filter\")\nelse:\n    print(\"✗ Cannot design Kalman filter - system not observable\")\n\nif ctrl['is_controllable'] and obs['is_observable']:\n    print(\"✓ System is minimal - can design LQG controller\")",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#sec-key-strengths",
    "href": "architecture/Control_Framework_Architecture.html#sec-key-strengths",
    "title": "Control Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipControl Framework Advantages\n\n\n\n\nPure Functional Core - Stateless algorithms, easy to test and reuse\nThin Wrappers - Minimal composition layer with no business logic\nType Safety - TypedDict results throughout with IDE support\nBackend Agnostic - NumPy/PyTorch/JAX transparency\nSeparation of Concerns - Analysis vs synthesis clearly separated\nMathematical Rigor - Correct implementation of classical control theory\nClean Integration - Natural system.control and system.analysis APIs\nUnified Interface - Single function for continuous/discrete cases\nComprehensive - LQR, Kalman, LQG, stability, controllability, observability\nScipy-like - Familiar API for control engineers",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Control_Framework_Architecture.html#summary",
    "href": "architecture/Control_Framework_Architecture.html#summary",
    "title": "Control Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe Control Framework provides production-quality classical control theory algorithms through a clean two-layer architecture:\n\nPure Function Layer provides stateless, testable algorithms\nComposition Layer integrates algorithms with system backend management\nType Layer ensures type safety with structured TypedDict results\n\nUsers interact through intuitive system properties (system.control, system.analysis) that automatically handle backend management and provide consistent interfaces across continuous and discrete systems.\nThe framework implements classical control theory correctly while maintaining clean software architecture and comprehensive type safety.",
    "crumbs": [
      "Framework Design",
      "Control Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/index.html",
    "href": "architecture/index.html",
    "title": "Architecture",
    "section": "",
    "text": "ControlDESymulation is built on a type-driven, composition-based architecture that achieves mathematical rigor, software engineering excellence, and multi-backend performance simultaneously. This section provides comprehensive documentation of the framework’s internal design for developers and advanced users.\n\n\n\n\n\n\nImportantWho Should Read This?\n\n\n\nMost users do NOT need to read architecture documentation. If you’re:\n\nUsing built-in systems from cdesym.systems.builtin.*\nDefining custom systems by subclassing ContinuousSymbolicSystem or DiscreteSymbolicSystem\nFollowing tutorials and examples\n\nThen you can skip this section entirely. The architecture documentation is intended for:\n\nFramework contributors and maintainers\nAdvanced users implementing custom integrators or utilities\nResearchers studying the framework’s design\nDevelopers extending the framework with new capabilities",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#introduction",
    "href": "architecture/index.html#introduction",
    "title": "Architecture",
    "section": "",
    "text": "ControlDESymulation is built on a type-driven, composition-based architecture that achieves mathematical rigor, software engineering excellence, and multi-backend performance simultaneously. This section provides comprehensive documentation of the framework’s internal design for developers and advanced users.\n\n\n\n\n\n\nImportantWho Should Read This?\n\n\n\nMost users do NOT need to read architecture documentation. If you’re:\n\nUsing built-in systems from cdesym.systems.builtin.*\nDefining custom systems by subclassing ContinuousSymbolicSystem or DiscreteSymbolicSystem\nFollowing tutorials and examples\n\nThen you can skip this section entirely. The architecture documentation is intended for:\n\nFramework contributors and maintainers\nAdvanced users implementing custom integrators or utilities\nResearchers studying the framework’s design\nDevelopers extending the framework with new capabilities",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#architecture-documents",
    "href": "architecture/index.html#architecture-documents",
    "title": "Architecture",
    "section": "Architecture Documents",
    "text": "Architecture Documents\nThe framework consists of 7 architectural layers, each documented separately:\n\n1. Design Philosophy\nStart here to understand the core principles that guide the framework’s design.\nTopics covered:\n\nType-driven design philosophy\nComposition over inheritance\nBackend agnosticism\nZero code duplication\nProgressive disclosure of complexity\nDesign patterns and trade-offs\n\nRead this if: You want to understand why the framework is built the way it is, or you’re contributing new features.\n\n\n2. Type System Architecture\nThe foundational Layer 0 that provides semantic types, structured results, and type-safe interfaces.\nTopics covered:\n\nMulti-backend array types (NumPy, PyTorch, JAX)\nSemantic vector/matrix types (StateVector, GainMatrix, etc.)\nTypedDict structured results (IntegrationResult, LQRResult, etc.)\nProtocol-based interfaces for duck typing with type safety\n200+ type definitions across 8 modules\n\nRead this if: You’re implementing custom components, need to understand type conventions, or want to leverage IDE support.\n\n\n3. UI Framework Architecture\nThe user-facing Layer 3 for defining and working with dynamical systems.\nComponents documented:\n\nLayer 0: SymbolicSystemBase - Time-domain agnostic foundation\nLayer 1: ContinuousSystemBase, DiscreteSystemBase - Time-domain interfaces\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem - Concrete implementations\nLayer 3: ContinuousStochasticSystem, DiscreteStochasticSystem - Stochastic extensions\n\nRead this if: You’re defining custom systems, extending the framework, or need to understand the class hierarchy.\n\n\n4. Delegation Layer\nThe internal service layer that provides specialized utilities through composition.\nComponents documented:\n\nCore Utilities: BackendManager, CodeGenerator, EquilibriumHandler, SymbolicValidator\nDeterministic Evaluation: DynamicsEvaluator, LinearizationEngine, ObservationEngine\nStochastic Support: DiffusionHandler, NoiseCharacterizer, SDEValidator\nLow-Level Utilities: codegen_utils\n\nRead this if: You’re implementing custom system types or need to understand how symbolic-to-numerical compilation works.\n\n\n5. Integration Framework\nMulti-backend numerical integration for ODEs and SDEs.\nTopics covered:\n\nIntegrator architecture and factories\nDeterministic integrators (Scipy, TorchDiffEq, Diffrax, DiffEqPy, Fixed-step)\nStochastic integrators (TorchSDE, Diffrax SDE, DiffEqPy SDE)\n40+ integration methods across 4 backends\nIntegration result types and performance tracking\n\nRead this if: You’re implementing custom integrators, need to understand method selection, or want to optimize integration performance.\n\n\n6. Control Framework Architecture\nClassical control theory algorithms for analysis and synthesis.\nTopics covered:\n\nControl Design: LQR, Kalman filter, LQG controller design\nSystem Analysis: Stability, controllability, observability analysis\nPure functional architecture with thin composition wrappers\nUnified continuous/discrete interface\nTypedDict results (LQRResult, KalmanFilterResult, StabilityInfo, etc.)\n\nRead this if: You’re using control design methods, need to understand the control API, or want to extend control capabilities.\n\n\n7. Visualization Framework\nInteractive, publication-ready plotting for dynamical systems analysis.\nComponents documented:\n\nTheming layer (colors, styles, themes)\nTrajectoryPlotter - Time-domain visualization\nPhasePortraitPlotter - State-space visualization\nControlPlotter - Control analysis plots\n\nRead this if: You’re extending visualization capabilities or need to understand the plotting system architecture.",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#quick-navigation",
    "href": "architecture/index.html#quick-navigation",
    "title": "Architecture",
    "section": "Quick Navigation",
    "text": "Quick Navigation\n\nBy User Level\nBeginners: - Skip architecture docs - use Getting Started instead\nIntermediate Users: - Read Design Philosophy for conceptual understanding - Skim UI Framework for custom system definition - Skim Visualization Framework for plotting capabilities\nAdvanced Users: - Study all architecture documents - Focus on Type System for understanding type conventions - Focus on Integration Framework for custom numerical methods - Reference Delegation Layer for system extension - Reference Control Framework for control design algorithms\n\n\nBy Use Case\nI want to understand the framework’s design principles: → Design Philosophy\nI want to understand the type system and conventions: → Type System Architecture\nI want to define a custom dynamical system: → UI Framework Architecture\nI want to implement a custom integrator: → Integration Framework\nI want to extend the system base classes: → Delegation Layer\nI want to use or extend control design (LQR, Kalman, LQG): → Control Framework Architecture\nI want to customize or extend plotting: → Visualization Framework\nI want to understand symbolic-to-numerical compilation: → Delegation Layer → CodeGenerator\nI want to add a new backend (e.g., TensorFlow): → Design Philosophy → Extension Points → Delegation Layer → BackendManager",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#architecture-statistics",
    "href": "architecture/index.html#architecture-statistics",
    "title": "Architecture",
    "section": "Architecture Statistics",
    "text": "Architecture Statistics\nThe framework consists of:\n\n50+ core files organized into 7 architectural layers\n200+ types for semantic clarity and IDE support\n55+ integration methods across NumPy, PyTorch, JAX, and Julia backends\n11 delegation layer utilities providing specialized services\nClassical control algorithms (LQR, Kalman, LQG, stability, controllability, observability)\n8 core UI framework classes for system definition\n16+ plot types for comprehensive visualization\nZero code duplication through strategic abstraction",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#design-principles-summary",
    "href": "architecture/index.html#design-principles-summary",
    "title": "Architecture",
    "section": "Design Principles Summary",
    "text": "Design Principles Summary\n\n\n\n\n\n\nTipCore Principles\n\n\n\n\nType-Driven Design - Types are not just annotations—they are the architecture\nComposition Over Inheritance - Build systems from specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX\nZero Code Duplication - Every line exists in exactly one place\nStructured Results - TypedDict for all outputs with IDE support\nProtocol-Based Interfaces - Duck typing with type safety\nFactory Pattern - Hide complexity behind simple creation methods\nSemantic Naming - Names convey mathematical meaning\nProgressive Disclosure - Simple things simple, complex things possible",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#common-architectural-questions",
    "href": "architecture/index.html#common-architectural-questions",
    "title": "Architecture",
    "section": "Common Architectural Questions",
    "text": "Common Architectural Questions\n\nWhy composition instead of inheritance?\nShort answer: Single responsibility, testability, and flexibility.\nLong answer: See Design Philosophy\n\n\nWhy support multiple backends?\nShort answer: Different backends excel at different tasks—NumPy for CPU, PyTorch for GPUs/neural networks, JAX for optimization.\nLong answer: See Design Philosophy\n\n\nWhere does symbolic-to-numerical compilation happen?\nShort answer: In the CodeGenerator utility, with per-backend caching.\nLong answer: See Delegation Layer\n\n\nHow are integrators selected automatically?\nShort answer: Through the IntegratorFactory which chooses based on system properties and backend.\nLong answer: See Integration Framework\n\n\nHow does the framework avoid code duplication?\nShort answer: Through SymbolicSystemBase providing shared functionality to both continuous and discrete systems.\nLong answer: See UI Framework Architecture and Design Philosophy\n\n\nWhat types should I use for my custom components?\nShort answer: Use semantic types like StateVector, ControlVector, and TypedDict results like IntegrationResult.\nLong answer: See Type System Architecture\n\n\nHow do I design an LQR controller?\nShort answer: Use system.control.design_lqr(A, B, Q, R) after linearizing your system.\nLong answer: See Control Framework Architecture\n\n\nHow do I define a custom dynamical system?\nShort answer: Subclass ContinuousSymbolicSystem or DiscreteSymbolicSystem and implement define_system().\nLong answer: See UI Framework Architecture",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#contributing-to-the-framework",
    "href": "architecture/index.html#contributing-to-the-framework",
    "title": "Architecture",
    "section": "Contributing to the Framework",
    "text": "Contributing to the Framework\nIf you’re interested in contributing:\n\nStart with Design Philosophy to understand core principles\nReview Type System Architecture to understand type conventions\nStudy the relevant layer docs for your contribution area:\n\nSystem definition → UI Framework Architecture\nInternal utilities → Delegation Layer\nNumerical integration → Integration Framework\nControl algorithms → Control Framework\nVisualization → Visualization Framework\n\nFollow the established patterns (composition, type-driven design, etc.)\nWrite comprehensive tests for each component in isolation\nDocument your additions with clear examples and type annotations\n\nSee Contributing Guidelines for more details.",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "architecture/index.html#getting-help",
    "href": "architecture/index.html#getting-help",
    "title": "Architecture",
    "section": "Getting Help",
    "text": "Getting Help\n\nQuestions about architecture? Open a discussion on GitHub\nFound a design issue? File an issue with the “architecture” label\nWant to propose an enhancement? Start with a discussion to align with design principles\n\n\nRemember: Most users don’t need to read architecture documentation. The framework is designed so you can be productive without understanding its internals. These documents are here when you need them.",
    "crumbs": [
      "Framework Design",
      "Overview"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ControlDESymulation",
    "section": "",
    "text": "ControlDESymulation is a comprehensive Python framework for symbolic modeling, simulation, and control of dynamical systems. The source code is available on GitHub.\n\n\n\nWrite Once, Run Anywhere: Define systems symbolically, execute on any backend (NumPy/PyTorch/JAX)\nNo Backend Lock-in: Switch between CPU, GPU, or TPU without changing your code\nGradient-Aware: Automatic differentiation support for learned controllers and neural ODEs\nType-Safe: Comprehensive type hints for better IDE support and fewer bugs\nResearch to Production: Prototype in NumPy, scale with JAX, integrate with PyTorch models\n\n\n\n\n\nSymbolic Specification: Define systems using SymPy with automatic code generation\nMulti-Backend Support: Seamlessly switch between NumPy, PyTorch, JAX, and Julia\nDual Time Domains: Full support for both continuous-time (ODEs/SDEs) and discrete-time systems\nStochastic Systems: First-class support for stochastic differential equations (SDEs)\n40+ Integration Methods: Adaptive and fixed-step solvers from scipy, torchdiffeq, diffrax, and DiffEqPy\nType Safety: Comprehensive TypedDict definitions with IDE autocomplete support\nGPU Acceleration: Native PyTorch and JAX support for GPU-based simulations\nZero Code Duplication: Clean 4-layer architecture with composition over inheritance\nProduction Ready: Extensive test coverage, comprehensive documentation, CI/CD workflows\n\n\n\n\n\nComposition Over Inheritance - Delegate to specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX/Julia\nType-Driven Design - Comprehensive TypedDict definitions\nZero Code Duplication - Shared functionality in base classes\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance First - Multi-backend support enables GPU and XLA acceleration\n\n\n\n\n\nArchitecture Guides: Deep dives into framework design with working examples\nTutorials: Practical how-to guides with executable code\nExamples Gallery: Complete interactive demonstrations\n\n\n\n\n\nInstallation Guide: Current installation guide"
  },
  {
    "objectID": "index.html#sec-overview",
    "href": "index.html#sec-overview",
    "title": "ControlDESymulation",
    "section": "",
    "text": "ControlDESymulation is a comprehensive Python framework for symbolic modeling, simulation, and control of dynamical systems. The source code is available on GitHub.\n\n\n\nWrite Once, Run Anywhere: Define systems symbolically, execute on any backend (NumPy/PyTorch/JAX)\nNo Backend Lock-in: Switch between CPU, GPU, or TPU without changing your code\nGradient-Aware: Automatic differentiation support for learned controllers and neural ODEs\nType-Safe: Comprehensive type hints for better IDE support and fewer bugs\nResearch to Production: Prototype in NumPy, scale with JAX, integrate with PyTorch models\n\n\n\n\n\nSymbolic Specification: Define systems using SymPy with automatic code generation\nMulti-Backend Support: Seamlessly switch between NumPy, PyTorch, JAX, and Julia\nDual Time Domains: Full support for both continuous-time (ODEs/SDEs) and discrete-time systems\nStochastic Systems: First-class support for stochastic differential equations (SDEs)\n40+ Integration Methods: Adaptive and fixed-step solvers from scipy, torchdiffeq, diffrax, and DiffEqPy\nType Safety: Comprehensive TypedDict definitions with IDE autocomplete support\nGPU Acceleration: Native PyTorch and JAX support for GPU-based simulations\nZero Code Duplication: Clean 4-layer architecture with composition over inheritance\nProduction Ready: Extensive test coverage, comprehensive documentation, CI/CD workflows\n\n\n\n\n\nComposition Over Inheritance - Delegate to specialized utilities\nBackend Agnosticism - Write once, run on NumPy/PyTorch/JAX/Julia\nType-Driven Design - Comprehensive TypedDict definitions\nZero Code Duplication - Shared functionality in base classes\nMathematical Rigor - Proper handling of ODEs, SDEs, difference equations\nPerformance First - Multi-backend support enables GPU and XLA acceleration\n\n\n\n\n\nArchitecture Guides: Deep dives into framework design with working examples\nTutorials: Practical how-to guides with executable code\nExamples Gallery: Complete interactive demonstrations\n\n\n\n\n\nInstallation Guide: Current installation guide"
  },
  {
    "objectID": "api/types.core.TimeVaryingControl.html",
    "href": "api/types.core.TimeVaryingControl.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.TimeVaryingControl.html#parameters",
    "href": "api/types.core.TimeVaryingControl.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nCurrent time\nrequired"
  },
  {
    "objectID": "api/types.core.TimeVaryingControl.html#returns",
    "href": "api/types.core.TimeVaryingControl.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nControlVector\nControl action (nu,) at time t"
  },
  {
    "objectID": "api/types.core.TimeVaryingControl.html#examples",
    "href": "api/types.core.TimeVaryingControl.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Sinusoidal control\n&gt;&gt;&gt; def sine_control(t: float) -&gt; ControlVector:\n...     return np.array([np.sin(t)])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Exponential decay\n&gt;&gt;&gt; def decaying_control(t: float) -&gt; ControlVector:\n...     return u0 * np.exp(-t / tau)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Piecewise constant\n&gt;&gt;&gt; def switched_control(t: float) -&gt; ControlVector:\n...     if t &lt; 5.0:\n...         return np.array([1.0])\n...     else:\n...         return np.array([-1.0])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Use in integration\n&gt;&gt;&gt; result = system.integrate(x0, u=sine_control, t_span=(0, 10))"
  },
  {
    "objectID": "api/types.core.TimeVaryingControl.html#see-also",
    "href": "api/types.core.TimeVaryingControl.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nControlPolicy : State-feedback control u = π(x) FeedbackController : Combined state-time feedback u = π(x, t)"
  },
  {
    "objectID": "api/types.core.ControlInput.html",
    "href": "api/types.core.ControlInput.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.ControlInput.html#type-variants",
    "href": "api/types.core.ControlInput.html#type-variants",
    "title": "",
    "section": "Type Variants",
    "text": "Type Variants\nControlVector : ArrayLike Constant control u(t) = u_const for all t ∈ [t0, tf] Shape: (nu,)\nTimeVaryingControl : Callable[[float], ControlVector] Time-dependent control u(t) = u_func(t) Evaluated by integrator at each time point\nNone Zero control or autonomous dynamics Equivalent to u(t) = 0 for all t"
  },
  {
    "objectID": "api/types.core.ControlInput.html#examples",
    "href": "api/types.core.ControlInput.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nConstant control:\n&gt;&gt;&gt; u_const = np.array([1.0, 0.5])\n&gt;&gt;&gt; result = system.integrate(x0, u=u_const, t_span=(0, 10))\nTime-varying control:\n&gt;&gt;&gt; def u_func(t):\n...     return np.array([np.sin(t), np.cos(t)])\n&gt;&gt;&gt; result = system.integrate(x0, u=u_func, t_span=(0, 10))\nAutonomous (no control):\n&gt;&gt;&gt; result = system.integrate(x0, u=None, t_span=(0, 10))"
  },
  {
    "objectID": "api/types.core.ControlInput.html#usage-in-integration",
    "href": "api/types.core.ControlInput.html#usage-in-integration",
    "title": "",
    "section": "Usage in Integration",
    "text": "Usage in Integration\nThe integration method handles each variant:\n\n\n\ndef integrate(self, x0: StateVector, u: ControlInput = None, …): … def rhs(t, x): … if u is None: … u_t = None … elif callable(u): … u_t = u(t) # Evaluate time-varying control … else: … u_t = u # Use constant control … return self(x, u_t, t)"
  },
  {
    "objectID": "api/types.core.ControlInput.html#notes",
    "href": "api/types.core.ControlInput.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nFor closed-loop simulation with state feedback, use FeedbackController in the simulate() method instead. ControlInput is for open-loop or pre-planned trajectories in integrate()."
  },
  {
    "objectID": "api/types.core.ControlInput.html#see-also",
    "href": "api/types.core.ControlInput.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nFeedbackController : Closed-loop control for simulate() TimeVaryingControl : Component type for time-varying control ControlVector : Component type for constant control"
  },
  {
    "objectID": "api/types.core.FeedthroughMatrix.html",
    "href": "api/types.core.FeedthroughMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.FeedthroughMatrix.html#examples",
    "href": "api/types.core.FeedthroughMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # No feedthrough (most common)\n&gt;&gt;&gt; D: FeedthroughMatrix = np.zeros((2, 1))\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Direct feedthrough (sensor measures control)\n&gt;&gt;&gt; D_direct: FeedthroughMatrix = np.array([[1.0]])"
  },
  {
    "objectID": "api/types.backends.get_backend_default_method.html",
    "href": "api/types.backends.get_backend_default_method.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.get_backend_default_method.html#parameters",
    "href": "api/types.backends.get_backend_default_method.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nComputational backend\nrequired\n\n\nis_stochastic\nbool\nWhether system is stochastic\nFalse"
  },
  {
    "objectID": "api/types.backends.get_backend_default_method.html#returns",
    "href": "api/types.backends.get_backend_default_method.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nDefault method name for this backend"
  },
  {
    "objectID": "api/types.backends.get_backend_default_method.html#examples",
    "href": "api/types.backends.get_backend_default_method.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; get_backend_default_method('numpy', is_stochastic=False)\n'RK45'\n&gt;&gt;&gt; get_backend_default_method('numpy', is_stochastic=True)\n'EM'\n&gt;&gt;&gt; get_backend_default_method('torch', is_stochastic=True)\n'euler'"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA simplified model of atmospheric convection. The system models: - Fluid circulation in a heated layer between two plates - Rate of convective overturning (x) - Horizontal temperature variation (y) - Vertical temperature variation (z)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, y, z] - x: Rate of convective motion [dimensionless] * x &gt; 0: clockwise circulation * x &lt; 0: counterclockwise circulation * Proportional to velocity of fluid flow\n- y: Horizontal temperature variation [dimensionless]\n  * y &gt; 0: warmer on one side\n  * y &lt; 0: warmer on other side\n  * Temperature difference driving convection\n\n- z: Vertical temperature variation from linearity [dimensionless]\n  * z &gt; 0: more stratified (stable)\n  * z &lt; 0: less stratified (unstable)\n  * Deviation from conductive temperature profile\nControl: u = [u] - u: External forcing/perturbation [dimensionless] - Typically u = 0 for studying natural chaos - Can be used to control or suppress chaos\nOutput: y = [x, y] - Partial observation: measures x and y, not z - Models limited sensor availability - Creates observability challenges for state estimation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe Lorenz equations with control:\nẋ = σ(y - x) + u\nẏ = x(ρ - z) - y\nż = xy - βz\nFirst equation (convection rate): - σ(y - x): Proportional to temperature difference - σ (sigma): Prandtl number - ratio of viscosity to thermal diffusivity - Drives x toward y at rate σ - Control u added here for external forcing\nSecond equation (horizontal temperature): - x(ρ - z): Nonlinear coupling - convection affects temperature - ρ (rho): Rayleigh number - ratio of buoyancy to viscous forces - -y: Damping term (heat diffusion) - When z &lt; ρ, convection x amplifies y\nThird equation (vertical temperature): - xy: Nonlinear product - convection creates temperature gradients - -βz: Damping/relaxation toward linear profile - β (beta): Geometric factor (aspect ratio of convection cell)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nsigma : float, default=10.0 Prandtl number [dimensionless]. Ratio of momentum diffusivity (viscosity) to thermal diffusivity. Standard Chaotic Lorenz: σ = 10 Higher σ → faster adjustment of x to y\nrho : float, default=28.0 Rayleigh number [dimensionless]. Measures temperature difference driving convection relative to dissipative effects. Critical values: - ρ &lt; 1: No convection (conduction only) - 1 &lt; ρ &lt; 24.74: Steady convection - ρ &gt; 24.74: Chaotic behavior possible - ρ = 28: Classic chaotic Lorenz attractor Higher ρ → stronger driving force\nbeta : float, default=8/3 Geometric factor [dimensionless]. Related to aspect ratio of convection cell (width/height). Standard value 8/3 ≈ 2.667 gives the classic “butterfly” attractor shape. - Affects dissipation rate in z - Controls attractor shape and size"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nOrigin (unstable for ρ &gt; 1): x_eq = [0, 0, 0] (no convection) u_eq = 0\nStable when ρ &lt; 1 (conduction dominates). Unstable when ρ &gt; 1 (convection develops).\nConvective equilibria (for ρ &gt; 1): C+ = [√(β(ρ-1)), √(β(ρ-1)), ρ-1] C- = [-√(β(ρ-1)), -√(β(ρ-1)), ρ-1]\nThese represent steady clockwise (C+) and counterclockwise (C-) convection cells. Both become unstable for ρ &gt; 24.74, leading to chaos."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#behavior-regimes",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#behavior-regimes",
    "title": "",
    "section": "Behavior Regimes:",
    "text": "Behavior Regimes:\n\nρ &lt; 1 (No convection):\n\nOrigin is stable\nAll trajectories decay to zero\nHeat transported by conduction only\n\n1 &lt; ρ &lt; 13.926 (Steady convection):\n\nOrigin becomes unstable\nC+ or C- are stable (bistable system)\nSteady convection cells form\n\n13.926 &lt; ρ &lt; 24.74 (Periodic/complex):\n\nC+ and C- lose stability\nCan have limit cycles or complex behavior\n\nρ &gt; 24.74 (Chaos):\n\nChaotic behavior emerges\nSensitive dependence on initial conditions\nStrange attractor (Lorenz butterfly)\n\nρ = 28 (Classic chaos):\n\nWell-studied chaotic attractor\nFractal structure\nPositive Lyapunov exponent"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#the-lorenz-attractor",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#the-lorenz-attractor",
    "title": "",
    "section": "The Lorenz Attractor:",
    "text": "The Lorenz Attractor:\nFor standard parameters (σ=10, ρ=28, β=8/3): - Shape: Two wing-like lobes (butterfly shape) - Structure: Strange attractor (fractal dimension ≈ 2.06) - Behavior: Trajectories spiral around C+ or C-, occasionally switching between wings - Predictability: Initial condition error doubles ~every 2 time units - Volume contraction: Phase space volume shrinks → dissipative system"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#physical-interpretation",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation:",
    "text": "Physical Interpretation:\n\nx: Velocity of convection roll\ny: Temperature difference between ascending and descending fluid\nz: Deviation from linear temperature profile\nρ: Driving force (heating from below)\nσ: Fluid properties (viscosity vs. thermal conductivity)\nβ: Cell geometry"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.ControlledLorenz.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDuffingOscillator : Another chaotic system (forced oscillator) VanDerPolOscillator : Limit cycle oscillator NonlinearChainSystem : Coupled oscillators with complex dynamics"
  },
  {
    "objectID": "api/types.linearization.LinearizationResult.html",
    "href": "api/types.linearization.LinearizationResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.LinearizationResult.html#examples",
    "href": "api/types.linearization.LinearizationResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Polymorphic function\n&gt;&gt;&gt; def analyze_linearization(\n...     system,\n...     x_eq: StateVector,\n...     u_eq: ControlVector\n... ) -&gt; dict:\n...     '''Works with deterministic AND stochastic systems.'''\n...     result: LinearizationResult = system.linearize(x_eq, u_eq)\n...     \n...     A = result[0]  # State matrix (always present)\n...     B = result[1]  # Control matrix (always present)\n...     \n...     info = {\n...         'eigenvalues': np.linalg.eigvals(A),\n...         'is_stochastic': len(result) == 3\n...     }\n...     \n...     if len(result) == 3:\n...         G = result[2]\n...         info['process_noise_cov'] = G @ G.T\n...     \n...     return info\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Use with deterministic\n&gt;&gt;&gt; result_det = analyze_linearization(ode_system, x_eq, u_eq)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Use with stochastic\n&gt;&gt;&gt; result_stoch = analyze_linearization(sde_system, x_eq, u_eq)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#stochastic-differential-equation",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#stochastic-differential-equation",
    "title": "",
    "section": "Stochastic Differential Equation",
    "text": "Stochastic Differential Equation\nContinuous-time SDE: dX = σ·dW\nwhere: - X(t): State (position) at time t - σ &gt; 0: Diffusion coefficient (volatility/noise intensity) - W(t): Standard Wiener process - dW: Brownian motion increment (infinitesimal random variable) - No drift term: f(X) = 0 - Additive noise: σ is constant (state-independent)\nKey Distinction from Other SDEs: Unlike most SDEs, Brownian motion has: - Zero drift (f = 0): No deterministic tendency - Constant diffusion (g = σ): Noise intensity independent of state - This makes it the “simplest” non-trivial stochastic process"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nDistribution: Starting at X(0) = x₀, the solution is: X(t) ~ N(x₀, σ²·t)\nMoments: - Mean: E[X(t)] = x₀ (constant for all time) - Variance: Var[X(t)] = σ²·t (grows linearly) - Standard Deviation: Std[X(t)] = σ·√t - Skewness: 0 (symmetric) - Kurtosis: 3 (Gaussian)\nPath Properties: - Continuous everywhere - Differentiable nowhere (fractal) - Hölder continuous: |X(t) - X(s)| ≤ C·|t-s|^α for α &lt; 1/2 - Unbounded variation: paths are infinitely “wiggly” - Quadratic variation: ∫(dX)² = σ²·t (fundamental to Itô calculus)\nMarkov Property: The future evolution depends only on current state, not history: P(X(t) | X(s), s ≤ u) = P(X(t) | X(u)) for t &gt; u\nMartingale Property: Expected future value equals current value: E[X(t) | X(s)] = X(s) for t &gt; s\nThis makes Brownian motion “fair” - no expected gain or loss.\nSelf-Similarity: For any c &gt; 0: {σ·W(c²·t) : t ≥ 0} has the same distribution as {c·σ·W(t) : t ≥ 0}"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nDiffusion Coefficient σ: Controls the “speed” of diffusion: - Larger σ: Faster diffusion, more volatile paths - Smaller σ: Slower diffusion, smoother paths - Diffusion length scale: ℓ ~ σ·√t\nRelationship to Temperature: In physical systems: σ = √(2·D) where D = kᵦT/γ - D: Diffusion coefficient - kᵦ: Boltzmann constant - T: Temperature - γ: Friction coefficient\nHigher temperature → larger σ → faster diffusion"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nDiffusion coefficient (volatility) [units depend on application] - Must be positive: σ &gt; 0 - Controls noise intensity - Units: [state]/√[time] - Standard Brownian motion: σ = 1 Physical Meaning: - σ² = 2D where D is diffusion coefficient - Variance growth rate: dVar/dt = σ² - RMS displacement in unit time: √(σ²·1) = σ\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x ∈ ℝ (unbounded) - Can take any real value: -∞ &lt; x &lt; +∞ - No equilibria (system is non-stationary) - No attractors or repellers - All points equally likely in long-time limit (if unbounded)\nControl: None (autonomous system) - nu = 0: No control input - Purely noise-driven - Cannot be “steered” by external input\nBoundary Conditions: For physical applications, boundaries may be imposed: - Absorbing: Process stops upon hitting boundary - Reflecting: Process bounces back from boundary - Periodic: Wraps around (equivalent to circle topology)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\nNoise Type: ADDITIVE - Diffusion matrix g = σ (constant) - Does not depend on state x - Simplest form of stochastic dynamics\nSDE Type: Itô (standard interpretation) - Can also use Stratonovich (equivalent for additive noise) - No Itô correction needed (f independent of x)\nNoise Dimension: - nw = 1: Single Wiener process drives the system - Scalar noise in scalar system"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#simulation-methods",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#simulation-methods",
    "title": "",
    "section": "Simulation Methods",
    "text": "Simulation Methods\nExact Discrete-Time Solution: For time step Δt: X[k+1] = X[k] + σ·√(Δt)·Z[k] where Z[k] ~ N(0,1) is standard normal.\nThis is EXACT - no discretization error for Brownian motion!"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#statistical-analysis",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#statistical-analysis",
    "title": "",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\nHypothesis Testing: To verify simulated paths are truly Brownian:\n\nMean Test: E[X(T) - X(0)] = 0\n\nSample mean should be ≈0\nStandard error: σ/√(n_samples)\n\nVariance Test: Var[X(T) - X(0)] = σ²·T\n\nSample variance should grow linearly with T\n\nNormality Test: X(T) - X(0) ~ N(0, σ²·T)\n\nUse Shapiro-Wilk or Kolmogorov-Smirnov test\nShould not reject normality\n\nIndependence Test: Increments uncorrelated\n\nAutocorrelation of ΔX should be zero\nLjung-Box test for white noise\n\nQuadratic Variation Test:\n\nΣ(ΔX)² should approach σ²·T as Δt → 0\nFundamental property distinguishing from smooth functions"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Physics: - Particle diffusion in fluids - Thermal noise in electronic circuits - Quantum fluctuations (simplified model) - Langevin equation foundation\n2. Finance: - Building block for stock price models - Interest rate dynamics (Vasicek, Hull-White) - Option pricing (Black-Scholes foundation) - Risk-free asset path (money market account noise)\n3. Biology: - Molecular diffusion in cells - Random walk of bacteria (before chemotaxis) - Genetic drift in population genetics - Neural membrane potential fluctuations\n4. Signal Processing: - White noise integration - Random signal generation - Filter design and testing - Noise modeling\n5. Mathematics: - Foundation of stochastic calculus - Benchmark for SDE solvers - Example of martingales - Study of stochastic processes\n6. Machine Learning: - Stochastic gradient descent noise - Diffusion models (score-based generative models) - Langevin dynamics sampling - Variational inference with reparametrization"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#comparison-with-other-processes",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#comparison-with-other-processes",
    "title": "",
    "section": "Comparison with Other Processes",
    "text": "Comparison with Other Processes\nvs. Geometric Brownian Motion: - GBM: dX = μ·X·dt + σ·X·dW (multiplicative noise) - BM: dX = σ·dW (additive noise) - GBM stays positive, BM can be negative - GBM for stock prices, BM for price returns\nvs. Ornstein-Uhlenbeck: - OU: dX = -α·X·dt + σ·dW (mean-reverting) - BM: dX = σ·dW (no mean reversion) - OU has stationary distribution, BM does not - OU for interest rates, temperatures\nvs. Random Walk: - Random walk: discrete time, discrete space - Brownian motion: continuous time, continuous space - BM is limit of random walk as Δt, Δx → 0 with Δx² ~ Δt\nvs. Lévy Process: - Lévy: Can have jumps (Poisson, stable processes) - Brownian: Continuous paths only - Brownian is special case of Lévy (Gaussian Lévy)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#theoretical-importance",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#theoretical-importance",
    "title": "",
    "section": "Theoretical Importance",
    "text": "Theoretical Importance\nWhy Brownian Motion is Fundamental:\n\nDonsker’s Theorem (Functional CLT): Random walk → Brownian motion as step size → 0 Makes BM the universal limit of random walks\nLévy Characterization: Any continuous martingale with quadratic variation t must be Brownian motion (up to time change)\nFeynman-Kac Formula: Connects SDEs to PDEs via expectation Solution to heat equation = expected value over Brownian paths\nGirsanov Theorem: Change of measure for SDEs Converts drift to diffusion via change of probability measure\nReflection Principle: P(max X(t) &gt; a) = 2·P(X(T) &gt; a) Used in barrier option pricing"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#limitations-and-extensions",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#limitations-and-extensions",
    "title": "",
    "section": "Limitations and Extensions",
    "text": "Limitations and Extensions\nStandard Brownian Motion Limitations: - No memory (Markov property may be unrealistic) - Gaussian increments (real data often heavy-tailed) - Continuous paths (no jumps) - Constant volatility (time-varying in reality) - Linear variance growth (subdiffusion/superdiffusion in complex media)\nExtensions to Address Limitations: - Fractional Brownian motion: Long-range dependence (Hurst parameter) - Lévy processes: Jumps and heavy tails - Stochastic volatility: Time-varying σ(t) - Rough volatility: σ follows rough process - Anomalous diffusion: Variance ~ t^α, α ≠ 1"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nBrownianMotion2D : Two-dimensional independent Brownian motions BrownianBridge : Brownian motion conditioned on endpoints GeometricBrownianMotion : Multiplicative noise (stock prices) OrnsteinUhlenbeck : Mean-reverting Brownian motion"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine standard Brownian motion dynamics.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.BrownianMotion.define_system(sigma=1.0)\nDefine standard Brownian motion dynamics.\nThis sets up the stochastic differential equation: dX = σ·dW\nwith zero drift and constant diffusion.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nDiffusion coefficient (must be positive) - Standard Brownian motion: σ = 1 - Units: [state]/√[time] - Controls noise intensity - Variance growth rate: σ²\n1.0\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf sigma ≤ 0 (diffusion coefficient must be positive)\n\n\n\n\n\nNotes\nSystem Structure: This is a minimal stochastic system with: - Zero drift: f(x) = 0 - Constant diffusion: g(x) = σ - Single noise source: nw = 1 - No control input: nu = 0 - First-order dynamics: order = 1\nSpecial Properties: - Pure diffusion process (no drift component) - Autonomous (no time dependence) - Additive noise (σ independent of state) - Unbounded state space (x ∈ ℝ) - No equilibrium points (non-stationary)\nStandard vs. Scaled Brownian Motion: When σ = 1, this is the standard Wiener process W(t). For σ ≠ 1, we have scaled Brownian motion: X(t) = σ·W(t)\nAll Brownian motions can be written as: X(t) = x₀ + σ·W(t) where W(t) is standard Brownian motion.\nDiscretization: The discrete-time equivalent is: X[k+1] = X[k] + σ·√(dt)·w[k] where w[k] ~ N(0,1) and dt is the time step.\nThis is exact (no discretization error) for Brownian motion.\nComparison with Other SDEs: Unlike most SDEs: - No drift means E[X(t)] = x₀ for all t (constant mean) - Constant diffusion means integration is particularly simple - Euler-Maruyama method is exact (no approximation error) - No stability concerns regardless of time step size"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#discrete-time-stochastic-dynamics",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#discrete-time-stochastic-dynamics",
    "title": "",
    "section": "Discrete-Time Stochastic Dynamics",
    "text": "Discrete-Time Stochastic Dynamics\nEuler discretization with noise:\nθ[k+1] = θ[k] + ω[k]·Δt + w_θ[k]\nω[k+1] = ω[k] + (-(g/L)·sin(θ[k]) - b·ω[k] + u[k])·Δt + w_ω[k]\nwhere: - θ[k]: Angle at time k·Δt [rad] - ω[k]: Angular velocity at time k·Δt [rad/s] - u[k]: Applied torque (zero-order hold) [rad/s²] - w_θ[k]: Angle noise [rad per step] - w_ω[k]: Angular velocity noise [rad/s per step] - Δt: Sampling period [s]\nDeterministic Part: Same nonlinear pendulum dynamics as continuous.\nStochastic Part: Noise accumulated over sampling interval [k·Δt, (k+1)·Δt].\nZero-Order Hold: Control u[k] constant during interval (digital implementation)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nDigital Control Loop:\n\nSample: Read encoder at t = k·Δt\n\nMeasure θ[k] (with quantization)\nEstimate ω[k] (from differences or gyro)\n\nCompute: Calculate control u[k]\n\nLQR, swing-up, learned policy\nComputation time: τ_comp (typically &lt;&lt; Δt)\n\nActuate: Output u[k] via DAC/PWM\n\nHeld constant until t = (k+1)·Δt\nZero-order hold\n\nDisturbances: Between samples\n\nWind gusts: w_ω\nGround vibration: w_θ\nFriction variations\nUnmodeled dynamics\n\n\nNoise Sources:\nAngle noise w_θ[k]: - Direct angle disturbances (rare physically) - Encoder quantization (measurement as process noise) - Model uncertainty - Typical: 0.001-0.01 rad per step\nAngular velocity noise w_ω[k]: - Torque disturbances (wind, vibration) - Motor ripple, cogging - Bearing friction variations - Most critical for stability - Typical: 0.01-0.1 rad/s per step\nConversion from Continuous:\nFor continuous σ_c [rad/(s²·√s)]: σ_d = σ_c·√Δt [rad/s per step]\nExample: σ_c = 1.0, Δt = 0.01 s → σ_d = 0.1 rad/s per step"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nNonlinearity: sin(θ) creates bistability and complex dynamics.\nUnstable Equilibrium: Upright (θ=0) exponentially unstable without control.\nBistability: Two potential wells (downward stable, upward unstable).\nDiscrete Sampling: Finite Δt creates sampling effects (aliasing, delay).\nZero-Order Hold: Control discontinuous (step-wise).\nProcess Noise: Disturbances between samples."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nEquilibria (Deterministic Part):\nDownward: θ = 0, ω = 0 (stable) Upward: θ = π, ω = 0 (unstable)\nLinearization (Small Angle):\nNear downward (θ ≈ 0): [θ[k+1]] ≈ [1 Δt ]·[θ[k]] + [0 ]·u[k] [ω[k+1]] [-g/L·Δt 1-b·Δt] [ω[k]] [Δt]\nEigenvalues determine discrete stability.\nStability Condition (Linear):\nFor stable downward equilibrium: Eigenvalues of Φ must satisfy |λ| &lt; 1.\nRequires: Δt &lt; 2/(b + √(b² + 4g/L))\nUpright (θ ≈ π):\nUnstable - one eigenvalue |λ| &gt; 1. Requires fast sampling and feedback."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nSampling Period Δt: - Digital control rate - Critical for unstable upright - Affects noise accumulation - Trade-off: Fast vs computation\nDamping b: - Energy dissipation [1/s] - Higher b: Easier to control - Typical: 0.1-1.0\nNoise Intensity σ: - Angular disturbance magnitude - Higher σ: More falls, harder balance - Typical: 0.01-0.1 rad/s per step"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X[k] = [θ[k], ω[k]] - θ: Angle (periodic, or unwrapped) - ω: Angular velocity\nControl: u[k] ∈ ℝ - Torque (zero-order hold) - Bounded: |u| ≤ u_max typically\nNoise: w[k] = [w_θ[k], w_ω[k]] - Gaussian per step - Accumulated over Δt"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ng\nfloat\nGravity [m/s²]\n9.81\n\n\nL\nfloat\nPendulum length [m]\n1.0\n\n\nb\nfloat\nDamping [1/s]\n0.5\n\n\nsigma_theta\nfloat\nAngle noise [rad per step] - Encoder noise, model uncertainty - Typical: 0.001-0.01\n0.01\n\n\nsigma_omega\nfloat\nAngular velocity noise [rad/s per step] - Torque disturbances (most critical) - Convert from continuous: σ_c·√Δt - Typical: 0.01-0.1\n0.05\n\n\ndt\nfloat\nSampling period [s] - Critical parameter - Typical: 0.001-0.1 s - Faster for upright stabilization\n0.01\n\n\nm\nfloat\nMass [kg] (optional)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR\nNoise Type: ADDITIVE\nDiscrete: Yes (native discrete-time)\nStationary: No (open-loop)\nBistable: Yes (two equilibria)\nUnstable: Yes (upright)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Digital Control: - Microcontroller implementation - Real-time OS (RTOS) - Fixed-point arithmetic\n2. State Estimation: - Discrete EKF/UKF - Particle filter - Complementary filter (IMU+encoder)\n3. Reinforcement Learning: - OpenAI Gym Pendulum-v1 - Discrete action spaces - Robust RL with noise\n4. Embedded Systems: - Arduino, STM32 implementation - FPGA for ultra-fast control - Education/research platforms\n5. Robustness Analysis: - Monte Carlo falling probability - Mean time to failure - Sensitivity to noise"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nDirect Evaluation: X[k+1] = f(X[k], u[k]) + w[k]\nNo integration needed (discrete-time native).\nEuler Discretization: Standard for discrete pendulum (matches RL benchmarks).\nHigher-Order (RK4): More accurate but less common in practice."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#discrete-ekf-implementation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#discrete-ekf-implementation",
    "title": "",
    "section": "Discrete EKF Implementation",
    "text": "Discrete EKF Implementation\nJacobian (Linearization):\nF = ∂f/∂X = [1 Δt ] [-g/L·cos(θ)·Δt 1 - b·Δt]\nAt θ=0 (downward): cos(0) = 1 At θ=π (upright): cos(π) = -1 (sign flip!)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#comparison-with-continuous",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#comparison-with-continuous",
    "title": "",
    "section": "Comparison with Continuous",
    "text": "Comparison with Continuous\nContinuous Stochastic: - dW Brownian motion - σ in [rad/(s²·√s)] - SDE integration (Euler-Maruyama) - Theoretical foundation\nDiscrete Stochastic: - w[k] Gaussian per step - σ in [rad/s per step] - Direct evaluation - Practical implementation\nConversion: σ_discrete = σ_continuous·√Δt"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nEuler discretization: O(Δt) error\nAdditive noise (not multiplicative)\n1D pendulum (no 3D motion)\nRigid body (no flexibility)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nRK4 discretization (higher accuracy)\nDouble pendulum (chaos + noise)\nFlexible pendulum\n3D pendulum (spherical)\nMultiplicative noise"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nStochasticPendulum : Continuous-time version Pendulum : Deterministic discrete version DiscreteStochasticDoubleIntegrator : Simpler linear system"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticPendulum.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_energy\nCompute mechanical energy.\n\n\ndefine_system\nDefine discrete stochastic pendulum dynamics.\n\n\nget_natural_frequency\nGet natural frequency ω₀ = √(g/L) [rad/s].\n\n\nget_noise_intensities\nGet noise parameters.\n\n\nget_nyquist_limit\nGet approximate Nyquist-like sampling limit.\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ncompute_energy\nsystems.builtin.stochastic.discrete.DiscreteStochasticPendulum.compute_energy(x)\nCompute mechanical energy.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState [θ, ω]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEnergy [J/kg]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; pend = DiscreteStochasticPendulum()\n&gt;&gt;&gt; x = np.array([0.5, 1.0])\n&gt;&gt;&gt; E = pend.compute_energy(x)\n&gt;&gt;&gt; print(f\"Energy: {E:.3f}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteStochasticPendulum.define_system(\n    g=9.81,\n    L=1.0,\n    b=0.5,\n    sigma_theta=0.01,\n    sigma_omega=0.05,\n    dt=0.01,\n    m=1.0,\n)\nDefine discrete stochastic pendulum dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ng\nfloat\nGravity [m/s²]\n9.81\n\n\nL\nfloat\nPendulum length [m]\n1.0\n\n\nb\nfloat\nDamping [1/s]\n0.5\n\n\nsigma_theta\nfloat\nAngle noise per step [rad] - Encoder quantization, model error - Typical: 0.001-0.01\n0.01\n\n\nsigma_omega\nfloat\nAngular velocity noise per step [rad/s] - Torque disturbances (critical for upright) - Convert: σ_c·√Δt from continuous - Typical: 0.01-0.1\n0.05\n\n\ndt\nfloat\nSampling period [s] - Typical: 0.001-0.1 - Faster for upright control - Balance: Fast enough vs computation\n0.01\n\n\nm\nfloat\nMass [kg]\n1.0\n\n\n\n\n\nNotes\nSampling Rate Selection:\nFor upright stabilization: - Minimum: Δt &lt; π/√(g/L) (Nyquist-like) - Recommended: Δt &lt; 0.1·√(L/g) (10× rule) - For L=1m, g=9.81: Δt &lt; 0.03 s = 30 ms\nPractical: - Fast (research): 1-5 ms - Moderate (education): 10-20 ms - Slow (demo): 50-100 ms\nNoise Scaling:\nFrom continuous σ_c [rad/(s²·√s)]: σ_discrete = σ_c·√Δt\nExample: σ_c = 1.0, Δt = 0.01 → σ_d = 0.1 rad/s per step\nStability (Discrete Linearized):\nAt downward (θ=0): Eigenvalues of: Φ = [1 Δt ] [-g/L·Δt 1-b·Δt]\nStable if |λ| &lt; 1 for both eigenvalues.\nRequires: Δt small enough.\nDiscretization Method:\nThis uses Euler (most common for RL/embedded): - Simple, explicit - O(Δt) error - Matches OpenAI Gym\nAlternative: RK4 (more accurate, more computation).\nNoise Placement:\nOn both θ and ω equations (general).\nPhysical: Primarily on ω (torque disturbances). Can set σ_θ = 0 for purely physical model.\n\n\n\nget_natural_frequency\nsystems.builtin.stochastic.discrete.DiscreteStochasticPendulum.get_natural_frequency(\n)\nGet natural frequency ω₀ = √(g/L) [rad/s].\n\n\nget_noise_intensities\nsystems.builtin.stochastic.discrete.DiscreteStochasticPendulum.get_noise_intensities(\n)\nGet noise parameters.\n\n\nget_nyquist_limit\nsystems.builtin.stochastic.discrete.DiscreteStochasticPendulum.get_nyquist_limit(\n)\nGet approximate Nyquist-like sampling limit.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nMaximum recommended Δt [s]\n\n\n\n\n\nNotes\nRule: Δt &lt; π/ω₀ for capturing dynamics.\n\n\nExamples\n&gt;&gt;&gt; pend = DiscreteStochasticPendulum(g=9.81, L=1.0)\n&gt;&gt;&gt; dt_max = pend.get_nyquist_limit()\n&gt;&gt;&gt; print(f\"Max Δt ≈ {dt_max:.3f} s\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.discrete.DiscreteStochasticPendulum.setup_equilibria(\n)\nSet up equilibrium points."
  },
  {
    "objectID": "api/types.linearization.FullStochasticLinearization.html",
    "href": "api/types.linearization.FullStochasticLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.FullStochasticLinearization.html#examples",
    "href": "api/types.linearization.FullStochasticLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; A, B, G, C, D = sde_system.full_linearization(x_eq, u_eq)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # LQG design\n&gt;&gt;&gt; K_lqr = design_lqr(A, B, Q_control, R_control)\n&gt;&gt;&gt; L_kalman = design_kalman(A, C, G@G.T, R_meas)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#physical-system-economic-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#physical-system-economic-system",
    "title": "",
    "section": "Physical System (Economic System):",
    "text": "Physical System (Economic System):\nThe Solow model describes how an economy's capital stock evolves over time\nthrough the interplay of:\n- **Investment:** Savings channeled into new capital\n- **Depreciation:** Capital wears out and becomes obsolete\n- **Population growth:** Dilutes per-capita capital\n- **Technological progress:** Increases productivity\n\n**The Central Equation (Continuous Time):**\n    k̇ = s·f(k) - (δ + n)·k\n\nwhere:\n    k: Capital per worker (capital intensity)\n    s: Savings rate (fraction of output saved)\n    f(k): Production function (output per worker)\n    δ: Depreciation rate\n    n: Population growth rate\n\n**Production Function (Cobb-Douglas):**\nThe standard form is:\n    y = f(k) = A·k^α\n\nwhere:\n    y: Output per worker (GDP per capita)\n    A: Total factor productivity (TFP), technology level\n    k: Capital per worker\n    α: Output elasticity of capital (0 &lt; α &lt; 1)\n\n**Key Properties:**\n1. **Positive but diminishing marginal product:**\n   f'(k) &gt; 0, f''(k) &lt; 0\n   - More capital → more output\n   - But each additional unit contributes less (diminishing returns)\n\n2. **Inada conditions:**\n   f(0) = 0, f'(0) = ∞, f'(∞) = 0\n   - No capital → no output\n   - Initially very productive\n   - Eventually saturates\n\n3. **Constant returns to scale (with labor):**\n   F(K, L) = A·K^α·L^(1-α)\n   - Doubling both K and L doubles output\n\n**Discrete-Time Dynamics:**\nThe discrete version models year-to-year changes:\n\n    k[t+1] = (1 - δ)·k[t] + s·f(k[t])\n\nOr with population growth:\n    k[t+1] = [(1 - δ)·k[t] + s·f(k[t])] / (1 + n)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[t] = [k[t]]\n    Capital per worker:\n    - k: Capital intensity [$/worker] or [capital units per worker]\n      * k ≥ 0: Non-negative by definition\n      * k = 0: No capital (subsistence economy)\n      * k → k*: Converges to steady state\n      * Typical range: 0-500 for normalized units\n\n**Physical/Economic Meaning:**\nCapital per worker represents:\n- Machines, equipment, tools available per person\n- Infrastructure (roads, buildings) per capita\n- Technology embodied in physical capital\n- Higher k → higher productivity → higher income\n\nControl: u[t] (optional, for policy intervention)\n    - Can represent:\n      * Temporary savings rate change: s → s + u[t]\n      * Government investment/stimulus\n      * Technology adoption rate change\n      * Foreign aid or capital injection\n    - Standard model: u = 0 (no intervention)\n\nOutput: y[t] = [k[t]] or [k[t], y[t], c[t]]\n    Standard outputs:\n    - k[t]: Capital per worker (state variable)\n    - y[t]: Output per worker (GDP per capita)\n    - c[t]: Consumption per worker\n\n    Where:\n        y[t] = A·k[t]^α\n        c[t] = (1 - s)·y[t]"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#dynamics-economic-interpretation",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#dynamics-economic-interpretation",
    "title": "",
    "section": "Dynamics (Economic Interpretation):",
    "text": "Dynamics (Economic Interpretation):\nThe discrete dynamics:\n    k[t+1] = (1 - δ)·k[t] + s·A·k[t]^α\n\n**Capital Evolution Has Three Components:**\n\n1. **Undepreciated capital: (1 - δ)·k[t]**\n   - Fraction (1 - δ) survives to next period\n   - δ represents wearing out, obsolescence\n   - If δ = 0.05: 5% of capital lost each year\n\n2. **New investment: s·f(k[t])**\n   - Savings rate s fraction of output is invested\n   - f(k) = A·k^α is output per worker\n   - Higher s → more investment → faster growth\n\n3. **Population dilution (if n &gt; 0):**\n   - Growing population dilutes per-capita capital\n   - k[t+1] must be divided by (1 + n)\n   - Higher n → slower per-capita growth\n\n**Steady State (Golden Rule):**\nAt steady state: k[t+1] = k[t] = k*\n\n    (1 - δ)·k* + s·A·(k*)^α = k*\n    s·A·(k*)^α = δ·k*\n    k* = (s·A/δ)^(1/(1-α))\n\nThe steady-state capital is unique and globally stable (under standard\nassumptions).\n\n**Convergence to Steady State:**\n- If k[0] &lt; k*: Capital accumulates (growth)\n- If k[0] &gt; k*: Capital decumulates (decline)\n- Convergence is monotonic (no oscillations for standard parameters)\n- Speed of convergence: Faster when far from k*, slower when near"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\ns : float, default=0.3\n    Savings rate (fraction of output saved/invested)\n    - Must satisfy: 0 &lt; s &lt; 1\n    - Typical values: 0.15-0.40\n    - Developed countries: ~0.20-0.25\n    - Developing countries: ~0.30-0.40\n    - China (historically): ~0.45-0.50\n\n    **Economic Meaning:**\n    - Higher s → more investment → higher steady-state k*\n    - But also lower consumption (1-s)·y\n    - Golden rule: s that maximizes steady-state consumption\n\ndelta : float, default=0.05\n    Depreciation rate (fraction of capital lost per period)\n    - Must satisfy: 0 &lt; δ &lt; 1\n    - Typical annual values: 0.03-0.10\n    - Physical capital: ~0.05-0.08\n    - Structures: ~0.03\n    - Equipment: ~0.10\n\n    **Economic Meaning:**\n    - Higher δ → more replacement needed → lower k*\n    - Represents obsolescence, wear and tear\n\nalpha : float, default=0.33\n    Capital share of income (output elasticity of capital)\n    - Must satisfy: 0 &lt; α &lt; 1\n    - Typical values: 0.25-0.40\n    - Empirically: ~0.33 (one-third)\n    - Labor share: 1 - α ≈ 0.67 (two-thirds)\n\n    **Economic Meaning:**\n    - Measures importance of capital vs labor\n    - α = 0.5: Equal importance (Cobb-Douglas symmetric)\n    - α &lt; 0.5: Labor more important\n    - α &gt; 0.5: Capital more important (rare)\n\nA : float, default=1.0\n    Total Factor Productivity (TFP) / technology level\n    - Must satisfy: A &gt; 0\n    - Captures: Technology, institutions, efficiency\n    - Grows over time via technological progress\n    - Typical growth: 1-2% per year\n\n    **Economic Meaning:**\n    - Higher A → more output for same k\n    - Represents \"technological level\"\n    - Solow residual: Growth not explained by capital/labor\n\nn : float, default=0.0\n    Population/labor force growth rate\n    - Can be positive, zero, or negative\n    - Typical values: -0.01 to 0.03 (annually)\n    - Developed countries: ~0.00-0.01\n    - Developing countries: ~0.01-0.03\n\n    **Economic Meaning:**\n    - Higher n → dilutes per-capita capital\n    - Must invest more just to maintain k\n    - Effective depreciation: δ + n\n\ndt : float, default=1.0\n    Time period (typically 1 year for macroeconomic data)\n    - Units: years\n    - dt = 1: Annual model (most common)\n    - dt = 0.25: Quarterly model\n\ninclude_population_growth : bool, default=False\n    If True, include population growth in dynamics\n    If False, assume n = 0\n\nuse_technology_growth : bool, default=False\n    If True, allow A to grow over time\n    If False, A is constant"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\n**Steady State (k*):**\nThe unique non-zero equilibrium where capital per worker is constant:\n\n    k* = (s·A/δ)^(1/(1-α))\n\nAt steady state:\n- Capital accumulation exactly balances depreciation\n- Investment = Depreciation: s·y* = δ·k*\n- No growth in per-capita variables (k, y, c constant)\n- But total output grows at rate n (population growth)\n\n**Stability:**\nThe steady state is GLOBALLY ASYMPTOTICALLY STABLE:\n- For ANY initial k[0] &gt; 0, system converges to k*\n- Convergence is monotonic (no oscillations)\n- Speed: |λ| = (1 - δ) + s·α·A·(k*)^(α-1) &lt; 1\n\n**Output at Steady State:**\n    y* = A·(k*)^α = A^(1/(1-α))·(s/δ)^(α/(1-α))\n\n**Consumption at Steady State:**\n    c* = (1 - s)·y*\n\n**Golden Rule Capital Level:**\nThe capital level that maximizes steady-state consumption:\n    k_gold = (α·A/δ)^(1/(1-α))\n\nGolden rule savings rate:\n    s_gold = α\n\nIf s = α, the economy is at the golden rule (max consumption).\nIf s &gt; α, the economy is \"over-saving\" (dynamic inefficiency).\nIf s &lt; α, the economy could save more to increase consumption."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#convergence-dynamics",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#convergence-dynamics",
    "title": "",
    "section": "Convergence Dynamics:",
    "text": "Convergence Dynamics:\n**Conditional Convergence:**\nCountries with same parameters (s, δ, α, A) converge to same k*.\n- Poor countries (low k) grow faster initially\n- Rich countries (high k) grow slower\n- Convergence rate: β = (1 - α)(δ + n)\n- Half-life: t_half = ln(2)/β\n\n**Absolute Convergence:**\nEmpirically NOT observed - poor countries don't always catch up.\nReasons:\n- Different savings rates s\n- Different technology levels A\n- Different institutional quality\n- Different human capital\n\n**Speed of Convergence:**\nEmpirical estimate: β ≈ 0.02 (2% per year)\n- Half-life: ~35 years\n- Slow convergence due to diminishing returns"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#economic-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#economic-insights",
    "title": "",
    "section": "Economic Insights:",
    "text": "Economic Insights:\n**The Fundamental Question:**\nWhy are some countries rich and others poor?\n\nSolow model answers:\n1. **Capital accumulation:** Rich countries have more k\n2. **Savings rates:** Higher s → higher k*\n3. **Technology:** Higher A → higher productivity\n4. **Population:** Lower n → easier to maintain high k\n\n**The Growth Puzzle:**\nSolow model predicts:\n- Long-run growth ONLY from technological progress (A growing)\n- Capital accumulation alone cannot sustain growth (diminishing returns)\n- Saving more raises level but not long-run growth rate\n\n**Policy Implications:**\n1. **Increase savings rate s:**\n   - Raises steady-state income\n   - Temporary growth boost during transition\n   - Reduces consumption in short run\n\n2. **Reduce depreciation δ:**\n   - Better infrastructure maintenance\n   - Raises k* and y*\n\n3. **Improve technology A:**\n   - Education, R&D, technology adoption\n   - Permanent growth effects\n   - Most important for long run\n\n4. **Control population n:**\n   - Lower n → higher k* per capita\n   - But total output growth slower"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#control-objectives-policy",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#control-objectives-policy",
    "title": "",
    "section": "Control Objectives (Policy):",
    "text": "Control Objectives (Policy):\n**1. Maximize Steady-State Consumption:**\n   Goal: Choose s to maximize c* = (1 - s)·y*\n   Solution: Golden rule s* = α\n\n**2. Convergence Acceleration:**\n   Goal: Reach k* faster via temporary policy\n   Method: Increase s temporarily, then reduce\n   Challenge: Political economy (delayed gratification)\n\n**3. Poverty Trap Escape:**\n   Goal: Overcome low-level equilibrium trap\n   Method: Large temporary investment (foreign aid, stimulus)\n   Extension: Add threshold effects, multiple equilibria\n\n**4. Optimal Savings Path:**\n   Goal: Maximize discounted utility ∫e^(-ρt)·u(c[t])dt\n   Solution: Ramsey-Cass-Koopmans model (extends Solow)\n\n**5. Technological Catch-Up:**\n   Goal: Model technology diffusion from frontier\n   Extension: A[t+1] = A[t] + φ(A_frontier - A[t])"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\n**1. Non-negativity: k[t] ≥ 0**\n   - Capital cannot be negative\n   - Economic necessity\n   - k = 0 is absorbing state (poverty trap if no external help)\n\n**2. Feasibility: k[t] ≤ k_max**\n   - Some maximum possible capital\n   - Typically not binding (grows without bound theoretically)\n\n**3. Savings rate bounds: 0 &lt; s &lt; 1**\n   - Cannot save more than 100% of output\n   - Cannot save negative amount\n   - Policy variable, not state constraint\n\n**4. Non-negative output: y[t] ≥ 0**\n   - Automatic if k ≥ 0 and A &gt; 0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\n**Stability:**\nThe discrete Solow model is always stable (under standard parameters):\n- Eigenvalue at k*: λ = (1 - δ) + s·α·A·(k*)^(α-1)\n- For typical parameters: 0 &lt; λ &lt; 1\n- Monotonic convergence (no oscillations)\n\n**Accuracy:**\nDiscrete vs continuous models differ for large dt:\n- Annual data (dt = 1): Discrete appropriate\n- Continuous time limit as dt → 0\n\n**Numerical Precision:**\nNo special considerations - well-conditioned problem."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n&gt;&gt;&gt; # Create Solow model with US-like parameters\n&gt;&gt;&gt; model = DiscreteSolowModel(\n...     s=0.25,      # 25% savings rate\n...     delta=0.05,  # 5% annual depreciation\n...     alpha=0.33,  # 1/3 capital share\n...     A=1.0,       # Normalized technology\n...     n=0.01,      # 1% population growth\n...     dt=1.0,      # Annual periods\n...     include_population_growth=True\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute steady state\n&gt;&gt;&gt; k_star = model.compute_steady_state()\n&gt;&gt;&gt; y_star = model.compute_output(k_star)\n&gt;&gt;&gt; c_star = model.compute_consumption(k_star)\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"Steady-state capital: k* = {k_star:.2f}\")\n&gt;&gt;&gt; print(f\"Steady-state output: y* = {y_star:.2f}\")\n&gt;&gt;&gt; print(f\"Steady-state consumption: c* = {c_star:.2f}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check golden rule\n&gt;&gt;&gt; k_gold = model.compute_golden_rule_capital()\n&gt;&gt;&gt; s_gold = model.alpha\n&gt;&gt;&gt; print(f\"\nGolden rule capital: k_gold = {k_gold:.2f}“) &gt;&gt;&gt; print(f”Golden rule savings rate: s_gold = {s_gold:.2f}“) &gt;&gt;&gt; print(f”Current vs optimal: {‘Over-saving’ if model.s &gt; s_gold else ‘Under-saving’}“) &gt;&gt;&gt; &gt;&gt;&gt; # Simulate convergence from low initial capital (poor country) &gt;&gt;&gt; k0_poor = np.array([10.0]) # Low starting capital &gt;&gt;&gt; result_poor = model.simulate( … x0=k0_poor, … u_sequence=None, … n_steps=100 # 100 years … ) &gt;&gt;&gt; &gt;&gt;&gt; # Simulate from high initial capital (rich country) &gt;&gt;&gt; k0_rich = np.array([100.0]) # High starting capital &gt;&gt;&gt; result_rich = model.simulate( … x0=k0_rich, … u_sequence=None, … n_steps=100 … ) &gt;&gt;&gt; &gt;&gt;&gt; # Plot convergence &gt;&gt;&gt; import plotly.graph_objects as go &gt;&gt;&gt; from plotly.subplots import make_subplots &gt;&gt;&gt; &gt;&gt;&gt; fig = make_subplots( … rows=2, cols=2, … subplot_titles=[‘Capital per Worker’, ‘Output per Worker’, … ‘Growth Rate’, ‘Consumption per Worker’] … ) &gt;&gt;&gt; &gt;&gt;&gt; t = result_poor[‘time_steps’] &gt;&gt;&gt; &gt;&gt;&gt; # Capital &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=result_poor[‘states’][:, 0], … name=‘Poor’, line=dict(color=‘blue’)), row=1, col=1) &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=result_rich[‘states’][:, 0], … name=‘Rich’, line=dict(color=‘red’)), row=1, col=1) &gt;&gt;&gt; fig.add_hline(y=k_star, line_dash=‘dash’, line_color=‘green’, row=1, col=1) &gt;&gt;&gt; &gt;&gt;&gt; # Output &gt;&gt;&gt; y_poor = model.compute_output(result_poor[‘states’][:, 0]) &gt;&gt;&gt; y_rich = model.compute_output(result_rich[‘states’][:, 0]) &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=y_poor, showlegend=False, … line=dict(color=‘blue’)), row=1, col=2) &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=y_rich, showlegend=False, … line=dict(color=‘red’)), row=1, col=2) &gt;&gt;&gt; fig.add_hline(y=y_star, line_dash=‘dash’, line_color=‘green’, row=1, col=2) &gt;&gt;&gt; &gt;&gt;&gt; # Growth rate &gt;&gt;&gt; growth_poor = np.diff(result_poor[‘states’][:, 0]) / result_poor[‘states’][:-1, 0] &gt;&gt;&gt; growth_rich = np.diff(result_rich[‘states’][:, 0]) / result_rich[‘states’][:-1, 0] &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t[:-1], y=growth_poor100, showlegend=False, … line=dict(color=‘blue’)), row=2, col=1) &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t[:-1], y=growth_rich100, showlegend=False, … line=dict(color=‘red’)), row=2, col=1) &gt;&gt;&gt; &gt;&gt;&gt; # Consumption &gt;&gt;&gt; c_poor = model.compute_consumption(result_poor[‘states’][:, 0]) &gt;&gt;&gt; c_rich = model.compute_consumption(result_rich[‘states’][:, 0]) &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=c_poor, showlegend=False, … line=dict(color=‘blue’)), row=2, col=2) &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=c_rich, showlegend=False, … line=dict(color=‘red’)), row=2, col=2) &gt;&gt;&gt; &gt;&gt;&gt; fig.update_xaxes(title_text=‘Time [years]’) &gt;&gt;&gt; fig.update_yaxes(title_text=‘k’, row=1, col=1) &gt;&gt;&gt; fig.update_yaxes(title_text=‘y’, row=1, col=2) &gt;&gt;&gt; fig.update_yaxes(title_text=‘Growth [%]’, row=2, col=1) &gt;&gt;&gt; fig.update_yaxes(title_text=‘c’, row=2, col=2) &gt;&gt;&gt; fig.update_layout(height=800, width=1000, title_text=‘Solow Model: Convergence Dynamics’) &gt;&gt;&gt; fig.show() &gt;&gt;&gt; &gt;&gt;&gt; # Phase diagram (Solow diagram) &gt;&gt;&gt; fig_phase = model.plot_solow_diagram() &gt;&gt;&gt; fig_phase.show() &gt;&gt;&gt; &gt;&gt;&gt; # Sensitivity analysis: Vary savings rate &gt;&gt;&gt; s_values = np.linspace(0.1, 0.5, 20) &gt;&gt;&gt; k_stars = [] &gt;&gt;&gt; y_stars = [] &gt;&gt;&gt; c_stars = [] &gt;&gt;&gt; &gt;&gt;&gt; for s_test in s_values: … model_temp = DiscreteSolowModel( … s=s_test, delta=0.05, alpha=0.33, A=1.0 … ) … k_ss = model_temp.compute_steady_state() … y_ss = model_temp.compute_output(k_ss) … c_ss = model_temp.compute_consumption(k_ss) … k_stars.append(k_ss) … y_stars.append(y_ss) … c_stars.append(c_ss) &gt;&gt;&gt; &gt;&gt;&gt; fig_sens = go.Figure() &gt;&gt;&gt; fig_sens.add_trace(go.Scatter(x=s_values, y=k_stars, name=‘k’)) &gt;&gt;&gt; fig_sens.add_trace(go.Scatter(x=s_values, y=y_stars, name=’y’)) &gt;&gt;&gt; fig_sens.add_trace(go.Scatter(x=s_values, y=c_stars, name=’c*‘)) &gt;&gt;&gt; fig_sens.add_vline(x=model.alpha, line_dash=’dash’, … annotation_text=‘Golden Rule’) &gt;&gt;&gt; fig_sens.update_layout( … title=‘Steady State vs Savings Rate’, … xaxis_title=‘Savings Rate s’, … yaxis_title=‘Steady-State Value’ … ) &gt;&gt;&gt; fig_sens.show() &gt;&gt;&gt; &gt;&gt;&gt; # Simulate policy experiment: Increase savings temporarily &gt;&gt;&gt; k0 = np.array([20.0]) # Below steady state &gt;&gt;&gt; &gt;&gt;&gt; # Baseline: constant s = 0.25 &gt;&gt;&gt; result_baseline = model.simulate(x0=k0, u_sequence=None, n_steps=50) &gt;&gt;&gt; &gt;&gt;&gt; # Policy: Increase s to 0.35 for 10 years, then back to 0.25 &gt;&gt;&gt; def policy_intervention(x, k_time): … if 10 &lt;= k_time &lt; 20: … # Increase savings rate temporarily … model_temp = DiscreteSolowModel( … s=0.35, delta=model.delta, alpha=model.alpha, A=model.A … ) … # Compute additional investment … extra_savings = 0.35 - 0.25 … y_current = model.compute_output(x[0]) … # This requires modifying the system… … # For now, return zero (standard model doesn’t have control) … return np.array([]) … return np.array([]) &gt;&gt;&gt; &gt;&gt;&gt; # For policy experiments, better to simulate with modified parameters &gt;&gt;&gt; # Create model with higher savings for intervention period &gt;&gt;&gt; model_high_s = DiscreteSolowModel(s=0.35, delta=0.05, alpha=0.33, A=1.0) &gt;&gt;&gt; &gt;&gt;&gt; # Simulate in segments &gt;&gt;&gt; # Years 0-10: Normal savings &gt;&gt;&gt; result_seg1 = model.simulate(x0=k0, u_sequence=None, n_steps=10) &gt;&gt;&gt; # Years 10-20: High savings &gt;&gt;&gt; k_10 = result_seg1[‘states’][-1, :] &gt;&gt;&gt; result_seg2 = model_high_s.simulate(x0=k_10, u_sequence=None, n_steps=10) &gt;&gt;&gt; # Years 20-50: Back to normal &gt;&gt;&gt; k_20 = result_seg2[‘states’][-1, :] &gt;&gt;&gt; result_seg3 = model.simulate(x0=k_20, u_sequence=None, n_steps=30) &gt;&gt;&gt; &gt;&gt;&gt; # Combine results &gt;&gt;&gt; k_policy = np.concatenate([ … result_seg1[‘states’][:, 0], … result_seg2[‘states’][1:, 0], … result_seg3[‘states’][1:, 0] … ]) &gt;&gt;&gt; &gt;&gt;&gt; fig_policy = go.Figure() &gt;&gt;&gt; fig_policy.add_trace(go.Scatter( … x=np.arange(51), … y=result_baseline[‘states’][:, 0], … name=‘Baseline (s=0.25)’, … line=dict(color=‘blue’) … )) &gt;&gt;&gt; fig_policy.add_trace(go.Scatter( … x=np.arange(51), … y=k_policy, … name=‘Policy (s=0.35 for years 10-20)’, … line=dict(color=‘red’) … )) &gt;&gt;&gt; fig_policy.add_vrect(x0=10, x1=20, fillcolor=‘gray’, opacity=0.2, … annotation_text=‘High Savings’) &gt;&gt;&gt; fig_policy.update_layout( … title=‘Policy Experiment: Temporary Savings Increase’, … xaxis_title=‘Time [years]’, … yaxis_title=‘Capital per Worker k’ … ) &gt;&gt;&gt; fig_policy.show()"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#economic-paradoxes-and-puzzles",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#economic-paradoxes-and-puzzles",
    "title": "",
    "section": "Economic Paradoxes and Puzzles:",
    "text": "Economic Paradoxes and Puzzles:\n**1. Solow Paradox (Computer Age):**\n\"You can see the computer age everywhere but in the productivity statistics\"\n- Massive IT investment in 1980s-90s\n- But productivity growth didn't accelerate much\n- Possible explanations: Mismeasurement, adjustment lags, diminishing returns\n\n**2. Productivity Puzzle:**\nWhy does α ≈ 0.33 (Kaldor fact)?\n- Empirically robust across countries and time\n- Suggests deep structural feature of production\n- Labor share stable despite technological change\n\n**3. Growth Miracle Puzzle:**\nSome countries grow much faster than Solow predicts:\n- East Asian tigers: 7-10% growth for decades\n- China: 10% growth for 30+ years\n- Solow: Convergence only, not sustained super-growth\n- Answer: Rapid A growth, human capital, institutions\n\n**4. Poverty Trap:**\nBasic Solow predicts convergence, but some countries stay poor:\n- Extensions: Threshold effects, multiple equilibria\n- S-shaped production function\n- Institutional quality matters"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n1. **Confusing levels with growth rates:**\n   Higher s → higher k* (level effect)\n   But NOT higher long-run growth rate\n   Growth sustained only by technological progress\n\n2. **Ignoring diminishing returns:**\n   Cannot grow forever by capital accumulation alone\n   α &lt; 1 ensures diminishing returns\n\n3. **Misinterpreting steady state:**\n   k* constant doesn't mean economy stopped growing\n   Total output Y = y·L grows at rate n (population)\n   Per-capita y constant, but total Y growing\n\n4. **Assuming instant convergence:**\n   Convergence takes decades (half-life ~35 years)\n   Short-run dynamics matter for policy\n\n5. **Forgetting population dilution:**\n   With n &gt; 0, investment must first offset dilution\n   Effective depreciation: δ + n\n\n6. **Using wrong α:**\n   α should be capital share, empirically ~0.33\n   α = 0.5 gives equal capital/labor importance (unrealistic)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#extensions",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#extensions",
    "title": "",
    "section": "Extensions:",
    "text": "Extensions:\n1. **Human capital:**\n   k → (k_physical, k_human)\n   Education and skills accumulation\n\n2. **Technology diffusion:**\n   A[t+1] = A[t] + g·A[t] + φ(A_frontier - A[t])\n   Catch-up dynamics\n\n3. **Multiple sectors:**\n   Agriculture, manufacturing, services\n   Structural transformation\n\n4. **Open economy:**\n   Include international trade, capital flows\n   Foreign investment, remittances\n\n5. **Endogenous growth:**\n   Make technology growth endogenous\n   R&D, learning-by-doing, spillovers\n\n6. **Resource constraints:**\n   Add natural resources (oil, land)\n   Environmental limits to growth"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nLogisticMap : Similar mathematical structure (but very different interpretation)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteSolowModel.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_consumption\nCompute consumption per worker c = (1-s)·y.\n\n\ncompute_convergence_speed\nCompute speed of convergence β.\n\n\ncompute_golden_rule_capital\nCompute golden rule capital level k_gold.\n\n\ncompute_investment\nCompute investment per worker i = s·y.\n\n\ncompute_output\nCompute output per worker y = A·k^α.\n\n\ncompute_steady_state\nCompute steady-state capital per worker k*.\n\n\ndefine_system\nDefine discrete-time Solow growth model.\n\n\nplot_solow_diagram\nPlot classic Solow diagram (phase diagram).\n\n\nsetup_equilibria\nSet up steady-state equilibrium.\n\n\n\n\ncompute_consumption\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.compute_consumption(k)\nCompute consumption per worker c = (1-s)·y.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nnp.ndarray\nCapital per worker\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nConsumption per worker\n\n\n\n\n\n\ncompute_convergence_speed\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.compute_convergence_speed(\n)\nCompute speed of convergence β.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nConvergence coefficient β\n\n\n\n\n\nNotes\nLinearization around k* gives: k[t+1] - k* ≈ λ·(k[t] - k*)\nwhere λ = 1 - β and: β = (1 - α)(δ + n)\nHalf-life: t_half = ln(2)/β\n\n\nExamples\n&gt;&gt;&gt; model = DiscreteSolowModel()\n&gt;&gt;&gt; beta = model.compute_convergence_speed()\n&gt;&gt;&gt; print(f\"Convergence rate: {beta:.4f}\")\n&gt;&gt;&gt; print(f\"Half-life: {np.log(2)/beta:.1f} years\")\n\n\n\ncompute_golden_rule_capital\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.compute_golden_rule_capital(\n)\nCompute golden rule capital level k_gold.\nThe golden rule maximizes steady-state consumption.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nGolden rule capital\n\n\n\n\n\nNotes\nAt golden rule: MPK = δ + n α·A·k_gold^(α-1) = δ + n k_gold = (α·A/(δ + n))^(1/(1-α))\n\n\nExamples\n&gt;&gt;&gt; model = DiscreteSolowModel()\n&gt;&gt;&gt; k_gold = model.compute_golden_rule_capital()\n&gt;&gt;&gt; k_star = model.compute_steady_state()\n&gt;&gt;&gt; print(f\"Current k*: {k_star:.2f}\")\n&gt;&gt;&gt; print(f\"Golden rule k_gold: {k_gold:.2f}\")\n\n\n\ncompute_investment\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.compute_investment(k)\nCompute investment per worker i = s·y.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nnp.ndarray\nCapital per worker\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nInvestment per worker\n\n\n\n\n\n\ncompute_output\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.compute_output(k)\nCompute output per worker y = A·k^α.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nnp.ndarray\nCapital per worker\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nOutput per worker\n\n\n\n\n\n\ncompute_steady_state\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.compute_steady_state()\nCompute steady-state capital per worker k*.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nSteady-state capital k*\n\n\n\n\n\nNotes\nAt steady state: k[t+1] = k[t] = k (1 - δ)·k + s·A·(k)^α = k·(1 + n) s·A·(k)^α = (δ + n)·k k* = (s·A/(δ + n))^(1/(1-α))\n\n\nExamples\n&gt;&gt;&gt; model = DiscreteSolowModel(s=0.25, delta=0.05, alpha=0.33)\n&gt;&gt;&gt; k_star = model.compute_steady_state()\n&gt;&gt;&gt; print(f\"Steady-state capital: {k_star:.2f}\")\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.define_system(\n    s=0.3,\n    delta=0.05,\n    alpha=0.33,\n    A=1.0,\n    n=0.0,\n    dt=1.0,\n    include_population_growth=False,\n    use_technology_growth=False,\n    g_A=0.0,\n)\nDefine discrete-time Solow growth model.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ns\nfloat\nSavings rate (0 &lt; s &lt; 1)\n0.3\n\n\ndelta\nfloat\nDepreciation rate (0 &lt; δ &lt; 1)\n0.05\n\n\nalpha\nfloat\nCapital share / output elasticity (0 &lt; α &lt; 1)\n0.33\n\n\nA\nfloat\nTechnology level / TFP (A &gt; 0)\n1.0\n\n\nn\nfloat\nPopulation growth rate\n0.0\n\n\ndt\nfloat\nTime period [years]\n1.0\n\n\ninclude_population_growth\nbool\nIf True, include population growth in dynamics\nFalse\n\n\nuse_technology_growth\nbool\nIf True, allow A to grow at rate g_A\nFalse\n\n\ng_A\nfloat\nTechnology growth rate (if use_technology_growth=True)\n0.0\n\n\n\n\n\n\nplot_solow_diagram\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.plot_solow_diagram(\n    k_range=None,\n)\nPlot classic Solow diagram (phase diagram).\nShows: - Investment curve: s·f(k) - Depreciation line: δ·k (or (δ+n)·k) - Steady state at intersection\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk_range\nOptional[tuple]\nRange of k values to plot\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nSolow diagram\n\n\n\n\n\nExamples\n&gt;&gt;&gt; model = DiscreteSolowModel()\n&gt;&gt;&gt; fig = model.plot_solow_diagram()\n&gt;&gt;&gt; fig.show()\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscreteSolowModel.setup_equilibria()\nSet up steady-state equilibrium."
  },
  {
    "objectID": "api/types.robustness.RobustStabilityResult.html",
    "href": "api/types.robustness.RobustStabilityResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.robustness.RobustStabilityResult.html#fields",
    "href": "api/types.robustness.RobustStabilityResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nrobustly_stable : bool True if stable for all θ ∈ Θ worst_case_eigenvalue : complex Eigenvalue closest to instability stability_margin : float Minimum distance to instability boundary critical_parameter : Optional[ParameterVector] Worst-case parameter θ* method : str Analysis method (‘polytope’, ‘Lyapunov’, ‘gridding’) conservatism : Optional[float] Conservatism estimate (0 = exact, 1 = very conservative)"
  },
  {
    "objectID": "api/types.robustness.RobustStabilityResult.html#examples",
    "href": "api/types.robustness.RobustStabilityResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Define uncertain system\n&gt;&gt;&gt; # A(θ) = A_nom + θ₁*ΔA₁ + θ₂*ΔA₂\n&gt;&gt;&gt; A_nom = np.array([[0, 1], [-2, -1]])\n&gt;&gt;&gt; uncertainty = ([-0.2, -0.1], [0.2, 0.1])\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: RobustStabilityResult = analyze_robust_stability(\n...     A_nom, uncertainty, method='polytope'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['robustly_stable']:\n...     print(f\"System is robustly stable!\")\n...     print(f\"Stability margin: {result['stability_margin']:.3f}\")\n... else:\n...     print(f\"Instability at θ = {result['critical_parameter']}\")\n...     print(f\"Critical eigenvalue: {result['worst_case_eigenvalue']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check conservatism\n&gt;&gt;&gt; if result.get('conservatism', 0) &gt; 0.5:\n...     print(\"Analysis is conservative - true margin may be larger\")"
  },
  {
    "objectID": "api/types.core.ParameterVector.html",
    "href": "api/types.core.ParameterVector.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.ParameterVector.html#examples",
    "href": "api/types.core.ParameterVector.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Physical parameters\n&gt;&gt;&gt; theta: ParameterVector = np.array([mass, damping, stiffness])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Neural network parameters (flattened)\n&gt;&gt;&gt; theta_nn: ParameterVector = flatten(model.parameters())"
  },
  {
    "objectID": "api/types.control_advanced.AdaptiveControlResult.html",
    "href": "api/types.control_advanced.AdaptiveControlResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_advanced.AdaptiveControlResult.html#fields",
    "href": "api/types.control_advanced.AdaptiveControlResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ncurrent_gain : GainMatrix Current adapted controller gain K(t) (nu, nx) parameter_estimate : ParameterVector Current parameter estimate θ̂(t) (nθ,) parameter_covariance : CovarianceMatrix Parameter uncertainty P_θ(t) (nθ, nθ) adaptation_rate : float Current learning rate Γ tracking_error : float Output tracking error ‖y - y_ref‖ parameter_error : Optional[ParameterVector] True error θ̂ - θ (if θ known, for testing)"
  },
  {
    "objectID": "api/types.control_advanced.AdaptiveControlResult.html#examples",
    "href": "api/types.control_advanced.AdaptiveControlResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Model Reference Adaptive Control (MRAC)\n&gt;&gt;&gt; adaptive_ctrl = AdaptiveController(\n...     reference_model, adaptation_rate=0.1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update at each time step\n&gt;&gt;&gt; result: AdaptiveControlResult = adaptive_ctrl.update(\n...     x_current, y_measured, y_reference\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply adapted control\n&gt;&gt;&gt; K = result['current_gain']\n&gt;&gt;&gt; u = -K @ x_current\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Monitor adaptation\n&gt;&gt;&gt; theta_hat = result['parameter_estimate']\n&gt;&gt;&gt; tracking_err = result['tracking_error']\n&gt;&gt;&gt; print(f\"Tracking error: {tracking_err:.3f}\")\n&gt;&gt;&gt; print(f\"Parameter estimate: {theta_hat}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check convergence (if true parameters known)\n&gt;&gt;&gt; if result['parameter_error'] is not None:\n...     param_err_norm = np.linalg.norm(result['parameter_error'])\n...     print(f\"Parameter error: {param_err_norm:.3f}\")"
  },
  {
    "objectID": "api/observers.LinearObserver.html",
    "href": "api/observers.LinearObserver.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/observers.LinearObserver.html#methods",
    "href": "api/observers.LinearObserver.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nreset\nReset observer to initial state estimate.\n\n\nto\nMove observer to specified device (CPU/GPU).\n\n\nupdate\nUpdate observer state estimate.\n\n\n\n\nreset\nobservers.LinearObserver.reset(x0=None)\nReset observer to initial state estimate.\nArgs: x0: Initial state estimate (nx,). Uses equilibrium if None.\nExample: &gt;&gt;&gt; # Reset to known initial condition &gt;&gt;&gt; observer.reset(x0=torch.tensor([0.1, 0.0])) &gt;&gt;&gt; &gt;&gt;&gt; # Reset to equilibrium &gt;&gt;&gt; observer.reset() # Uses system.x_equilibrium\nNotes: - Called automatically in init() - Unlike EKF, no covariance to reset - Start observer from best available estimate\n\n\nto\nobservers.LinearObserver.to(device)\nMove observer to specified device (CPU/GPU).\nArgs: device: torch.device or string (‘cpu’, ‘cuda’)\nReturns: Self for chaining\n\n\nupdate\nobservers.LinearObserver.update(u, y, dt)\nUpdate observer state estimate.\nContinuous-time: d x̂/dt = f(x̂, u) + L(y - h(x̂)) x̂_new ≈ x̂_old + dt * [f(x̂, u) + L(y - h(x̂))]\nDiscrete-time: x̂_pred = f(x̂, u) x̂_new = x̂_pred + L(y - h(x̂_pred))\nArgs: u: Control input (nu,) y: Measurement (ny,) dt: Time step (used for continuous systems, ignored for discrete)\nExample: &gt;&gt;&gt; u = torch.tensor([1.0]) &gt;&gt;&gt; y_measured = torch.tensor([0.15]) # Noisy angle measurement &gt;&gt;&gt; observer.update(u, y_measured, dt=0.01) &gt;&gt;&gt; print(f”Estimate: {observer.x_hat}“)\nNotes: - For continuous systems: uses Euler integration - For discrete systems: dt parameter is ignored - Innovation = y - h(x̂_pred) is the measurement residual - Large innovation suggests either bad estimate or bad measurement - Gain L determines how much to trust innovation vs model"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#difference-equation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#difference-equation",
    "title": "",
    "section": "Difference Equation",
    "text": "Difference Equation\nX[k] = σ·w[k]\nwhere w[k] ~ N(0,1) are iid standard normal random variables.\nAlternative View: X[k+1] = 0·X[k] + σ·w[k]\nThis shows white noise as AR(0) - no dependence on past."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nMemorylessness: Zero autocorrelation: Cov[X[k], X[j]] = 0 for k ≠ j\nEach observation independent of all others.\nUnpredictability: Best prediction: E[X[k+1] | past] = 0 Prediction error: MSE = σ²\nCannot be improved by using past information.\nStationarity: Strictly stationary - distribution invariant to time shifts.\nFlat Spectrum: Power spectral density: S(f) = σ² (constant across frequencies)\nHence “white” - equal power at all frequencies."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nMoments: Mean: E[X[k]] = 0 for all k Variance: Var[X[k]] = σ² for all k Higher moments: Standard Gaussian if w ~ N(0,1)\nAutocorrelation: γ(h) = σ²·δ_h where δ_h is Kronecker delta: γ(0) = σ² γ(h) = 0 for h ≠ 0\nPower Spectrum: S(f) = σ² for all f ∈ [-f_s/2, f_s/2]\nwhere f_s = 1/Δt is sampling frequency."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nStandard Deviation σ: - Units: [state] - Scale of random fluctuations - Examples: * Measurement noise: instrument precision * Thermal noise: √(4·k_B·T·R·Δf) * Financial: daily return volatility\nNo Parameters Besides σ: White noise is completely characterized by variance σ². No memory, no time constants, no structure."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x ∈ ℝ (unbounded) - No persistence between samples - Each value independent - Gaussian: X[k] ~ N(0, σ²)\nControl: None (autonomous) - Pure random process - Cannot be controlled or predicted"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nStandard deviation of white noise - Must be positive - σ = 1: Standard white noise - Variance: σ²\n1.0\n\n\ndt\nfloat\nSampling period [time units] - Required for discrete system - Sets time scale\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nType: Pure random (no deterministic component)\nInnovation: w[k] ~ N(0,1) iid\nMemory: None (memoryless)\nStationary: Yes (strictly stationary)\nErgodic: Yes\nPredictable: No"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Signal Processing: - Noise modeling in measurements - Filter testing and validation - System identification (input signal) - Detection theory (null hypothesis)\n2. Communications: - AWGN channel model - Error analysis - Channel capacity calculations\n3. Time Series: - Innovation sequence for ARMA models - Residual diagnostics (should be white) - Benchmark for forecasting performance\n4. Control Systems: - Process noise in Kalman filter - Disturbance modeling - Robustness analysis\n5. Finance: - Efficient market hypothesis (returns should be white) - Monte Carlo simulation - Risk modeling baseline\n6. Testing: - Null hypothesis for independence tests - Benchmark for signal detection - Residual analysis"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nDirect Generation: X[k] = σ·randn()\nSimple, exact, no approximation.\nQuality Checks: - Mean ≈ 0 - Variance ≈ σ² - Autocorrelation ≈ 0 for h &gt; 0 - Within confidence bands: ±1.96/√N"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#statistical-analysis",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#statistical-analysis",
    "title": "",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\nTests for White Noise: - Ljung-Box Q-test (joint autocorrelation) - Durbin-Watson (first-order autocorrelation) - Runs test (randomness) - Portmanteau test\nDiagnostics: - ACF plot: Only lag 0 significant - Periodogram: Approximately flat - Q-Q plot: Linear (if Gaussian)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#comparison-with-other-processes",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#comparison-with-other-processes",
    "title": "",
    "section": "Comparison with Other Processes",
    "text": "Comparison with Other Processes\nvs. Random Walk: - RW: Cumulative sum of white noise - WN: Memoryless, stationary\nvs. AR(1): - AR(1): X[k] = φ·X[k-1] + w[k] - WN: AR(1) with φ = 0\nvs. Brownian Motion: - BM: Continuous-time integral of white noise - WN: Discrete-time, no integration"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nIdealization (infinite bandwidth)\nReal noise often band-limited\nMay have weak temporal dependence\nGaussian assumption may not hold"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDiscreteAR1 : White noise is AR(1) with φ=0 DiscreteRandomWalk : Cumulative sum of white noise BrownianMotion : Continuous-time analog"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteWhiteNoise.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine white noise process.\n\n\nget_autocorrelation\nGet theoretical autocorrelation at given lag.\n\n\nget_standard_deviation\nGet theoretical standard deviation σ.\n\n\nget_variance\nGet theoretical variance σ².\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteWhiteNoise.define_system(\n    sigma=1.0,\n    dt=1.0,\n)\nDefine white noise process.\nSets up pure random sequence: X[k] = σ·w[k]\nwhere w[k] ~ N(0,1) are iid.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nStandard deviation (must be positive) - σ = 1: Standard white noise - σ² = variance - Typical: 0.1 to 10.0 depending on application\n1.0\n\n\ndt\nfloat\nSampling period [time units] - Required for discrete system - Sets time scale - Does not affect statistics (memoryless)\n1.0\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf sigma ≤ 0\n\n\n\n\n\nNotes\nComplete Characterization: White noise is completely specified by variance σ². No other parameters needed - no memory, no time constants.\nIndependence: Each sample is independent: P(X[k] | X[k-1], …) = P(X[k])\nThis is the strongest form of memorylessness.\nGaussian White Noise: If w[k] ~ N(0,1), then X[k] ~ N(0, σ²). Uncorrelated + Gaussian ⟹ Independent\nNon-Gaussian Extensions: Can use other distributions: - Uniform: w[k] ~ U(-√3, √3) (variance 1) - Laplace: Heavier tails - Student-t: Fat tails\nSampling Period dt: Unlike AR(1) or OU, dt doesn’t affect white noise statistics. Samples at any interval are independent with same variance.\nPower Spectral Density: S(f) = σ² for |f| ≤ f_Nyquist = 1/(2·dt)\nFlat spectrum - equal power at all frequencies.\nUse Cases: - Testing: Null hypothesis for independence - Simulation: Generate innovations for ARMA - Benchmarking: Compare signal detection performance - Modeling: Measurement noise, residuals\nRelationship to AR(1): White noise is AR(1) with φ = 0: X[k+1] = 0·X[k] + σ·w[k]\nWold Decomposition: Any stationary process can be written as: X[k] = μ + Σ ψ_j·w[k-j] where w[k] is white noise.\n\n\n\nget_autocorrelation\nsystems.builtin.stochastic.discrete.DiscreteWhiteNoise.get_autocorrelation(lag)\nGet theoretical autocorrelation at given lag.\nFor white noise: ρ(0) = 1 ρ(h) = 0 for h ≠ 0\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlag\nint\nLag h (non-negative)\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nAutocorrelation: 1 if lag=0, else 0\n\n\n\n\n\nExamples\n&gt;&gt;&gt; wn = DiscreteWhiteNoise(sigma=1.0, dt=1.0)\n&gt;&gt;&gt; print(f\"ρ(0) = {wn.get_autocorrelation(0)}\")  # 1.0\n&gt;&gt;&gt; print(f\"ρ(1) = {wn.get_autocorrelation(1)}\")  # 0.0\n&gt;&gt;&gt; print(f\"ρ(10) = {wn.get_autocorrelation(10)}\")  # 0.0\n\n\n\nget_standard_deviation\nsystems.builtin.stochastic.discrete.DiscreteWhiteNoise.get_standard_deviation()\nGet theoretical standard deviation σ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nStandard deviation\n\n\n\n\n\nExamples\n&gt;&gt;&gt; wn = DiscreteWhiteNoise(sigma=1.5, dt=1.0)\n&gt;&gt;&gt; std = wn.get_standard_deviation()\n&gt;&gt;&gt; print(f\"Std: {std:.3f}\")  # 1.5\n\n\n\nget_variance\nsystems.builtin.stochastic.discrete.DiscreteWhiteNoise.get_variance()\nGet theoretical variance σ².\nFor white noise, variance is simply σ².\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nVariance\n\n\n\n\n\nNotes\nUnlike AR(1) or OU, white noise variance doesn’t depend on any time constants - it’s just σ²."
  },
  {
    "objectID": "api/types.backends.SDEIntegrationMethod.html",
    "href": "api/types.backends.SDEIntegrationMethod.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\ntypes.backends.SDEIntegrationMethod\ntypes.backends.SDEIntegrationMethod\nSDE integration method for stochastic differential equations."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA mass-spring-damper system where the spring force is nonlinear, containing both linear and cubic terms.\nThe system consists of: - A mass attached to a nonlinear spring - Linear viscous damping - Optional periodic forcing - Additional optional external forcing\nKey feature: Depending on parameters, can exhibit: - Bistability (two stable equilibria) - Jump phenomena (sudden changes in amplitude) - Chaos (for certain forcing parameters) - Multiple periodic solutions for same forcing"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, v] - x: Displacement from equilibrium [m or dimensionless] * x = 0: Neutral position (for symmetric case) * Multiple equilibria possible depending on α, β\n- v: Velocity [m/s or dimensionless]\n  * v = ẋ (rate of change of displacement)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe Duffing equation in first-order form:\nẋ = v\nv̇ = -δv - αx - βx³ + γ·cos(ω·t) + u\nOr as a second-order ODE: ẍ + δẋ + αx + βx³ = γ·cos(ω·t) + u\nVelocity equation (v̇): - -δv: Linear damping (energy dissipation) * δ &gt; 0: Positive damping (stable) * δ = 0: Undamped (conservative) * δ &lt; 0: Negative damping (unstable, pumps energy in)\n\n-αx: Linear restoring force (like Hooke’s law)\n\nα &gt; 0: Hardening spring at origin (stable)\nα &lt; 0: Softening spring at origin (unstable) → bistable\nα = 0: Purely cubic spring\n\n-βx³: Cubic nonlinear term\n\nβ &gt; 0: Hardening nonlinearity (stiffens at large x)\nβ &lt; 0: Softening nonlinearity (weakens at large x)\nDominates at large displacements\n\nγ·cos(ω·t) + u: Periodic forcing and additional external forcing/control"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#spring-force-types",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#spring-force-types",
    "title": "",
    "section": "Spring Force Types:",
    "text": "Spring Force Types:\nThe total spring force is F_spring = αx + βx³\n\nHardening spring (α &gt; 0, β &gt; 0):\n\nGets stiffer with displacement\nSingle stable equilibrium at origin\nNatural frequency increases with amplitude\n\nSoftening spring (α &gt; 0, β &lt; 0):\n\nGets softer with displacement\nCan lose stability at large amplitude\nNatural frequency decreases with amplitude\n\nBistable (α &lt; 0, β &gt; 0):\n\nDouble-well potential\nThree equilibria: unstable origin + two stable wells\nCan “snap through” between wells\nClassic case: α = -1, β = 1"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nalpha : float, default=-1.0 Linear stiffness coefficient [1/s² or dimensionless]. - α &gt; 0: Monostable (single well) - α &lt; 0: Bistable (double well) Standard Duffing: α = -1 (bistable)\nbeta : float, default=1.0 Cubic stiffness coefficient [1/(m²·s²) or dimensionless]. - β &gt; 0: Hardening spring - β &lt; 0: Softening spring Standard Duffing: β = 1 (hardening) Together with α &lt; 0, creates double-well potential.\ndelta : float, default=0.3 Damping coefficient [1/s or dimensionless]. - δ = 0: Conservative (Hamiltonian) - δ &gt; 0: Dissipative (stable attractors) - δ &lt; 0: Negative damping (self-excited oscillations) Standard: δ = 0.3 (light damping)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#potential-energy",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#potential-energy",
    "title": "",
    "section": "Potential Energy:",
    "text": "Potential Energy:\nFor unforced, undamped case (γ·cos(ω·t) + u = 0, δ = 0), the system is conservative with potential: V(x) = (α/2)x² + (β/4)x⁴\nBistable case (α = -1, β = 1): V(x) = -x²/2 + x⁴/4 = (x² - 1)²/4 - 1/4\nThis creates a double-well potential: - Two minima (stable): x = ±1 - One maximum (unstable): x = 0 - Barrier height: V(0) - V(±1) = 1/4"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nFor unforced system (γ·cos(ω·t) + u = 0):\nMonostable case (α &gt; 0, β &gt; 0): x_eq = [0, 0] (only equilibrium, stable)\nBistable case (α &lt; 0, β &gt; 0): Origin (unstable): x_eq = [0, 0]\nTwo stable wells:\n    x_eq = [±√(-α/β), 0]\n\nFor α = -1, β = 1:\n    x_eq = [±1, 0]  (stable)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#behavior-regimes",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#behavior-regimes",
    "title": "",
    "section": "Behavior Regimes:",
    "text": "Behavior Regimes:\n1. Unforced (γ·cos(ω·t) + u = 0): - Monostable: Oscillations decay to origin - Bistable: Oscillations decay to one of two wells - Basin boundary separates initial conditions\n2. Periodic forcing (u = 0, γ·cos(ω·t) != 0): - Periodic response: For small γ, system responds at ω - Subharmonics: Response at ω/n (frequency division) - Superharmonics: Response at n·ω (frequency multiplication) - Jump phenomenon: Sudden amplitude change at certain ω - Hysteresis: Different response for increasing vs. decreasing ω\n3. Chaotic forcing (moderate γ, ω near 1): - Sensitive dependence: Small changes → large differences - Strange attractor: Fractal structure in phase space - Unpredictable: Despite deterministic equations - Window of chaos: Chaos between periodic windows\nClassic chaotic parameters: - α = -1, β = 1, δ = 0.3, γ = 0.3, ω = 1.0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#jump-phenomenon",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#jump-phenomenon",
    "title": "",
    "section": "Jump Phenomenon:",
    "text": "Jump Phenomenon:\nFor softening springs (β &lt; 0) or hardening with forcing: - As forcing frequency ω is slowly varied, amplitude changes smoothly - At critical frequency, amplitude suddenly jumps - Hysteresis: different response for sweep up vs. sweep down - Bistability: two stable periodic solutions for same ω"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.DuffingOscillator.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nVanDerPolOscillator : Self-excited oscillator with limit cycle Lorenz : Another famous chaotic system SymbolicPendulum : Related but with sin(θ) nonlinearity"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#attributes",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsde_system\nStochasticDynamicalSystem\nSDE system to integrate\n\n\nsde_type\nSDEType\nSDE interpretation (Ito or Stratonovich)\n\n\nconvergence_type\nConvergenceType\nConvergence criterion (strong or weak)\n\n\nseed\nOptional[int]\nRandom seed for reproducibility"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#result-types",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#result-types",
    "title": "",
    "section": "Result Types",
    "text": "Result Types\nReturns SDEIntegrationResult TypedDict with: - t: Time points (T,) - x: State trajectory (T, nx) or (n_paths, T, nx) - diffusion_evals: Number of diffusion evaluations - noise_samples: Brownian increments used - n_paths: Number of trajectories - convergence_type: ‘strong’ or ‘weak’ - sde_type: ‘ito’ or ‘stratonovich’"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#examples",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Create SDE integrator\n&gt;&gt;&gt; integrator = EulerMaruyamaIntegrator(\n...     sde_system,\n...     dt=0.01,\n...     backend='numpy',\n...     seed=42\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Single trajectory\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.zeros(1),\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"State shape: {result['x'].shape}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Multiple trajectories (Monte Carlo)\n&gt;&gt;&gt; result = integrator.integrate_monte_carlo(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.zeros(1),\n...     t_span=(0.0, 10.0),\n...     n_paths=1000\n... )\n&gt;&gt;&gt; stats = get_trajectory_statistics(result)\n&gt;&gt;&gt; print(f\"Mean trajectory: {stats['mean']}\")\n&gt;&gt;&gt; print(f\"Standard deviation: {stats['std']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#methods",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorBase.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nget_noise_info\nGet information about noise structure and optimizations.\n\n\nget_sde_stats\nGet SDE-specific integration statistics.\n\n\nintegrate\nIntegrate SDE over time interval.\n\n\nintegrate_monte_carlo\nIntegrate multiple SDE trajectories for Monte Carlo analysis.\n\n\nreset_stats\nReset all statistics including SDE-specific counters.\n\n\nset_seed\nSet random seed for reproducibility.\n\n\nstep\nTake one SDE integration step with noise.\n\n\n\n\nget_noise_info\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase.get_noise_info()\nGet information about noise structure and optimizations.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nNoise structure information\n\n\n\n\n\n\nget_sde_stats\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase.get_sde_stats()\nGet SDE-specific integration statistics.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nStatistics including drift/diffusion evaluations\n\n\n\n\n\n\nintegrate\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n)\nIntegrate SDE over time interval.\nAPI Level: This is a low-level stochastic integration method that directly interfaces with numerical SDE solvers. For typical use cases, prefer the high-level simulate() method if available in your stochastic system class.\nControl Function Convention: This method uses the scipy/ODE solver convention where control functions have signature (t, x) → u, with time as the FIRST argument. This differs from high-level simulation APIs which use (x, t) → u with state as the primary argument. The difference is intentional:\n\nLow-level integrate(): Uses (t, x) for direct solver compatibility\nHigh-level simulate(): Uses (x, t) for intuitive control-theoretic API\n\nStochastic Integration: Unlike deterministic ODE integration, SDE integration involves random Brownian motion increments. Each call with the same initial condition will produce different trajectories unless the random seed is fixed. For statistical analysis, use integrate_monte_carlo() to simulate multiple paths.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nArrayLike\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable[[float, ArrayLike], Optional[ArrayLike]]\nControl policy with low-level convention: (t, x) → u - t: float - current time (FIRST argument, scipy convention) - x: ArrayLike - current state (SECOND argument) - Returns: Optional[ArrayLike] - control input u, or None for autonomous Can be: - Autonomous: lambda t, x: None - Constant control: lambda t, x: u_const - State feedback: lambda t, x: -K @ x - Time-varying: lambda t, x: u(t) - Stochastic policy: lambda t, x: policy(x) + noise\nrequired\n\n\nt_span\nTuple[float, float]\nIntegration interval (t_start, t_end)\nrequired\n\n\nt_eval\nOptional[ArrayLike]\nSpecific times at which to store solution If None, uses solver’s internal time points (typically uniform grid) For SDEs, irregular grids may affect statistical properties\nNone\n\n\ndense_output\nbool\nIf True, return dense interpolated solution (if supported by solver) Note: Most SDE solvers do not support dense output\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegrationResult\nTypedDict containing: - t: Time points (T,) - x: State trajectory (T, nx) - time-major ordering - success: Whether integration succeeded - message: Status message - nfev: Number of drift function evaluations - diffusion_evals: Number of diffusion function evaluations - noise_samples: Number of Brownian motion samples generated - nsteps: Number of integration steps taken - integration_time: Computation time (seconds) - solver: Integrator name - convergence_type: ‘strong’ or ‘weak’ convergence - sde_type: ‘ito’ or ‘stratonovich’ interpretation - n_paths: Number of trajectories (1 for single path)\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf integration fails (numerical instability, step size issues, etc.)\n\n\n\n\n\nNotes\nStochastic Nature: Each call generates a new random trajectory. For reproducible results, set the integrator’s random seed via set_seed() before calling integrate().\nConvergence Types: - Strong convergence: Pathwise accuracy - each trajectory is accurate - Weak convergence: Moment accuracy - statistics (mean, variance) are accurate\nSDE Interpretations: - Itô: Most common, natural for stochastic calculus - Stratonovich: Physics-based, matches ordinary calculus rules\nTime-Major Ordering: Unlike some high-level APIs that use (nx, T) for backward compatibility, integrate() returns (T, nx) time-major ordering for consistency with numerical solver conventions and efficient time-series operations.\n\n\nExamples\nLow-level integrate() usage (uses (t, x) convention):\nAutonomous stochastic system:\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,  # Autonomous\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Final state: {result['x'][-1]}\")\n&gt;&gt;&gt; print(f\"Convergence: {result['convergence_type']}\")\nControlled stochastic system with constant control:\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.array([0.5]),  # Note: (t, x) order\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Diffusion evaluations: {result['diffusion_evals']}\")\nState feedback for stochastic stabilization:\n&gt;&gt;&gt; K = np.array([[1.0, 2.0]])\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: -K @ x,  # (t, x) order for integrate()\n...     t_span=(0.0, 10.0)\n... )\nTime-varying stochastic control:\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.array([0.5 * np.sin(t)]),\n...     t_span=(0.0, 10.0)\n... )\nReproducible stochastic simulation:\n&gt;&gt;&gt; integrator.set_seed(42)\n&gt;&gt;&gt; result1 = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; integrator.set_seed(42)\n&gt;&gt;&gt; result2 = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; np.allclose(result1['x'], result2['x'])  # True - same random trajectory\nTrue\nEvaluate at specific times:\n&gt;&gt;&gt; t_eval = np.linspace(0, 10, 101)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0, 10),\n...     t_eval=t_eval\n... )\n&gt;&gt;&gt; assert len(result['t']) == 101\nMonte Carlo simulation (multiple trajectories):\nFor statistical analysis, use integrate_monte_carlo():\n&gt;&gt;&gt; # Simulate 1000 paths\n&gt;&gt;&gt; mc_result = integrator.integrate_monte_carlo(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0),\n...     n_paths=1000\n... )\n&gt;&gt;&gt; # Result has shape (n_paths, T, nx)\n&gt;&gt;&gt; print(mc_result['x'].shape)  # (1000, 101, 2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute statistics\n&gt;&gt;&gt; from controldesymulation.systems.base.numerical_integration.stochastic.sde_integrator_base import get_trajectory_statistics\n&gt;&gt;&gt; stats = get_trajectory_statistics(mc_result)\n&gt;&gt;&gt; print(f\"Mean at t=10: {stats['mean'][-1]}\")\n&gt;&gt;&gt; print(f\"Std at t=10: {stats['std'][-1]}\")\nHigh-level simulate() usage (if available, uses (x, t) convention):\nIf your stochastic system provides a high-level simulate() method, prefer it for the more intuitive (x, t) convention:\n&gt;&gt;&gt; # Controller with (x, t) order - state is primary\n&gt;&gt;&gt; def controller(x, t):  # Note: (x, t) order\n...     K = np.array([[1.0, 2.0]])\n...     return -K @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = sde_system.simulate(\n...     x0=np.array([1.0, 0.0]),\n...     controller=controller,  # Uses (x, t) signature\n...     t_span=(0.0, 10.0),\n...     dt=0.01\n... )\nConverting between conventions:\nIf you have a controller designed for simulate() and need to use integrate():\n&gt;&gt;&gt; # Controller for simulate() - uses (x, t)\n&gt;&gt;&gt; def my_controller(x, t):\n...     return -K @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Wrap for integrate() - convert to (t, x)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=x0,\n...     u_func=lambda t, x: my_controller(x, t),  # Swap argument order\n...     t_span=(0, 10)\n... )\nComparing SDE with ODE integration:\n&gt;&gt;&gt; # Deterministic (ODE) - same result every time\n&gt;&gt;&gt; ode_result = ode_integrator.integrate(x0, u_func, t_span)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stochastic (SDE) - different result each time\n&gt;&gt;&gt; sde_result1 = sde_integrator.integrate(x0, u_func, t_span)\n&gt;&gt;&gt; sde_result2 = sde_integrator.integrate(x0, u_func, t_span)\n&gt;&gt;&gt; # Trajectories will differ due to randomness\n\n\nSee Also\nintegrate_monte_carlo : Simulate multiple paths for statistical analysis get_trajectory_statistics : Compute statistics from Monte Carlo results set_seed : Set random seed for reproducibility step : Single SDE integration step with noise simulate : High-level simulation with (x, t) convention (if available)\n\n\n\nintegrate_monte_carlo\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase.integrate_monte_carlo(\n    x0,\n    u_func,\n    t_span,\n    n_paths,\n    t_eval=None,\n    store_paths=True,\n    parallel=False,\n)\nIntegrate multiple SDE trajectories for Monte Carlo analysis.\nSimulates n_paths independent realizations of the SDE to estimate statistical properties (mean, variance, probability distributions).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nArrayLike\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable\nControl policy (or None for autonomous)\nrequired\n\n\nt_span\nTuple[float, float]\nTime interval\nrequired\n\n\nn_paths\nint\nNumber of trajectories to simulate\nrequired\n\n\nt_eval\nOptional[ArrayLike]\nEvaluation times\nNone\n\n\nstore_paths\nbool\nIf True, store all trajectories (memory intensive) If False, only compute statistics online\nTrue\n\n\nparallel\nbool\nIf True, use parallel execution (if backend supports)\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegrationResult\nResult with shape (n_paths, T, nx) if store_paths=True Result with statistics only if store_paths=False\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Monte Carlo with 1000 paths\n&gt;&gt;&gt; result = integrator.integrate_monte_carlo(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.zeros(1),\n...     t_span=(0.0, 10.0),\n...     n_paths=1000\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get statistics\n&gt;&gt;&gt; stats = get_trajectory_statistics(result)\n&gt;&gt;&gt; print(f\"Mean at t=10: {stats['mean'][-1]}\")\n&gt;&gt;&gt; print(f\"Std at t=10: {stats['std'][-1]}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Confidence intervals\n&gt;&gt;&gt; lower = stats['mean'] - 1.96 * stats['std']\n&gt;&gt;&gt; upper = stats['mean'] + 1.96 * stats['std']\n\n\n\nreset_stats\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase.reset_stats()\nReset all statistics including SDE-specific counters.\n\n\nset_seed\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase.set_seed(seed)\nSet random seed for reproducibility.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nseed\nint\nRandom seed\nrequired\n\n\n\n\n\nExamples\n&gt;&gt;&gt; integrator.set_seed(42)\n&gt;&gt;&gt; result1 = integrator.integrate(x0, u_func, t_span)\n&gt;&gt;&gt; integrator.set_seed(42)\n&gt;&gt;&gt; result2 = integrator.integrate(x0, u_func, t_span)\n&gt;&gt;&gt; # result1 and result2 are identical\n\n\n\nstep\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase.step(\n    x,\n    u=None,\n    dt=None,\n    dW=None,\n)\nTake one SDE integration step with noise.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nArrayLike\nCurrent state (nx,)\nrequired\n\n\nu\nOptional[ArrayLike]\nControl input (nu,) or None for autonomous\nNone\n\n\ndt\nOptional[float]\nStep size (uses self.dt if None)\nNone\n\n\ndW\nOptional[ArrayLike]\nBrownian increment (nw,) - if None, generates random\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nNext state x(t + dt)\n\n\n\n\n\nNotes\nSubclasses implement specific SDE methods: - Euler-Maruyama (order 0.5 strong, order 1 weak) - Milstein (order 1 strong) - Runge-Kutta SDE methods - etc.\n\n\nExamples\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01)\n&gt;&gt;&gt; # With custom noise\n&gt;&gt;&gt; dW = np.random.randn(nw) * np.sqrt(0.01)\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01, dW=dW)"
  },
  {
    "objectID": "api/types.estimation.EKFResult.html",
    "href": "api/types.estimation.EKFResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.estimation.EKFResult.html#fields",
    "href": "api/types.estimation.EKFResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nstate_estimate : StateVector Current state estimate x̂[k] (nx,) covariance : CovarianceMatrix Current error covariance P[k] (nx, nx) innovation : OutputVector Measurement innovation y[k] - h(x̂⁻[k]) (ny,) innovation_covariance : CovarianceMatrix Innovation covariance S[k] = H P⁻ H’ + R (ny, ny) kalman_gain : GainMatrix Kalman gain K[k] = P⁻ H’ S⁻¹ (nx, ny) likelihood : float Log-likelihood of measurement log p(y[k]|y[1:k-1])"
  },
  {
    "objectID": "api/types.estimation.EKFResult.html#examples",
    "href": "api/types.estimation.EKFResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Nonlinear pendulum system\n&gt;&gt;&gt; def dynamics(x, u):\n...     theta, omega = x\n...     return np.array([omega, -np.sin(theta) + u[0]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; def measurement(x):\n...     return np.array([x[0]])  # Measure angle only\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create EKF\n&gt;&gt;&gt; ekf = ExtendedKalmanFilter(\n...     dynamics_fn=dynamics,\n...     measurement_fn=measurement,\n...     Q=0.01 * np.eye(2),\n...     R=0.1 * np.eye(1)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Initialize\n&gt;&gt;&gt; ekf.initialize(x0=np.array([0.1, 0.0]), P0=np.eye(2))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update loop\n&gt;&gt;&gt; for k in range(N):\n...     # Predict\n...     ekf.predict(u[k])\n...\n...     # Update with measurement\n...     result: EKFResult = ekf.update(y[k])\n...\n...     # Extract estimate\n...     x_hat = result['state_estimate']\n...     P = result['covariance']\n...\n...     # Check innovation\n...     innovation = result['innovation']\n...     if np.linalg.norm(innovation) &gt; 3.0:\n...         print(f\"Large innovation at k={k}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Examine likelihood for outlier detection\n&gt;&gt;&gt; log_likelihood = result['likelihood']\n&gt;&gt;&gt; if log_likelihood &lt; -10:\n...     print(\"Possible outlier measurement\")"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nState-space form: dθ = ω·dt dω = (-(g/L)·sin(θ) - b·ω + u)·dt + σ·dW\nNormalized form (g/L = 1): dθ = ω·dt dω = (-sin(θ) - b·ω + u)·dt + σ·dW\nwhere: - θ: Angle from downward vertical [rad] - ω: Angular velocity [rad/s] - g/L: Gravitational constant (normalized to 1) - b: Damping coefficient [1/s] - u: Applied torque [rad/s²] - σ: Noise intensity [rad/(s²·√s)] - W(t): Standard Wiener process"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nEquation of Motion:\nNewton’s rotational law: I·θ̈ = τ_total\nFor unit moment of inertia (I=1): θ̈ = τ_gravity + τ_damping + τ_control + τ_noise θ̈ = -(g/L)·sin(θ) - b·θ̇ + u + σ·ξ(t)\nwhere ξ(t) is white noise (formal derivative of W).\nTorque Components: 1. Gravity: -(g/L)·sin(θ) - Restoring torque toward θ=0 2. Damping: -b·ω - Dissipative (energy removal) 3. Control: u - Applied torque 4. Noise: σ·dW/dt - Random disturbances\nEnergy: E = (1/2)·ω² + (g/L)·(1 - cos(θ))\nKinetic + potential (normalized).\nNoise Sources: - Mechanical: Air currents, vibrations - Thermal: Brownian motion at pivot - Model uncertainty: Unmodeled dynamics"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nNonlinearity: sin(θ) creates fundamentally different behavior from linear oscillator.\nBistability: Two potential wells (θ = 0, ±2π, …). Noise causes transitions.\nEnergy Barrier: ΔE = 2·g/L separates downward from inverted.\nAdditive Noise: Constant σ (state-independent). Enters velocity equation (physical forces).\nDamping: b &gt; 0 required for stationary distribution. Without damping: Energy fluctuates, no equilibrium."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nSmall Angle Approximation (|θ| &lt;&lt; 1):\nsin(θ) ≈ θ gives linearized SDE: dθ = ω·dt dω = (-(g/L)·θ - b·ω + u)·dt + σ·dW\nThis is linear (harmonic oscillator with noise).\nStationary Distribution (b &gt; 0, u = 0):\nFor damped pendulum: p_∞(θ, ω) ∝ exp(-E(θ,ω)/(σ²/b))\nwhere E = (1/2)·ω² - (g/L)·cos(θ).\nEffective Temperature: T_eff = σ²/b\nRatio of noise injection to dissipation.\nKramers’ Escape Rate:\nFrom θ = 0 over barrier to θ = π: k_escape ≈ (ω_well²/2πb)·exp(-ΔE·b/σ²)\nExponentially small for σ &lt;&lt; √(ΔE·b)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nDamping b: - Units: [1/s] - Controls energy dissipation - Time constant: τ = 1/b - Quality factor: Q = (g/L)^(1/2)/b\nExamples: - b = 0.1: Underdamped (Q = 10) - b = 1.0: Moderate damping - b = 10.0: Overdamped (creeping motion)\nNoise Intensity σ: - Units: [rad/(s²·√s)] - Controls random torque magnitude - Effective temperature: σ²/b\nExamples: - σ = 0.1: Small noise (rare escapes) - σ = 0.5: Moderate (occasional escapes) - σ = 1.0: Large (frequent escapes)\nRatio σ/√b: Dimensionless noise level: - Small: Deep potential wells, rare transitions - Large: Shallow effective wells, frequent transitions"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X = [θ, ω] - θ ∈ ℝ or S¹: Angle (unwrapped or periodic) - ω ∈ ℝ: Angular velocity\nControl: u ∈ ℝ - Applied torque\nNoise: w ∈ ℝ - Single Wiener process - Enters velocity equation"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ng\nfloat\nGravitational acceleration [m/s²]\n9.81\n\n\nL\nfloat\nPendulum length [m]\n1.0\n\n\nb\nfloat\nDamping coefficient [1/s] - b &gt; 0 for stationary distribution - Typical: 0.1-10.0\n0.5\n\n\nsigma\nfloat\nNoise intensity [rad/(s²·√s)] - Controls random torque - Typical: 0.1-2.0\n0.5\n\n\nm\nfloat\nMass [kg] (optional, for dimensional analysis)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR\nNoise Type: ADDITIVE\nSDE Type: Itô\nNoise Dimension: nw = 1\nStationary: Yes (if b &gt; 0)\nErgodic: Yes (if b &gt; 0)\nBistable: Yes (multiple wells)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Kramers’ Escape Theory: - Noise-activated barrier crossing - Chemical reaction rates - Exponential escape time\n2. Stochastic Resonance: - Weak periodic signal enhanced by noise - Optimal noise level exists - Biology, climate, electronics\n3. Coherence Resonance: - Noise creates coherent oscillations - No periodic forcing needed - Maximum regularity at optimal σ\n4. Nonlinear Control: - Swing-up with noise - Stabilization at inverted - Robust control design\n5. Synchronization: - Coupled oscillators - Common noise induces correlation - Phase locking"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nRecommended: - Euler-Maruyama: dt = 0.01-0.1 s - Check angle wrapping (if needed) - Monitor energy (should fluctuate)\nConvergence: - Weak: O(dt) for moments - Strong: O(√dt) for paths"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#kramers-escape-analysis",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#kramers-escape-analysis",
    "title": "",
    "section": "Kramers Escape Analysis",
    "text": "Kramers Escape Analysis\nEscape Time: Mean time to cross barrier: τ ~ exp(ΔE·b/σ²)\nExponentially sensitive to: - Barrier height ΔE - Damping b (appears in exponent!) - Noise σ² (inverse in exponent)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#comparison-with-linear-oscillator",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#comparison-with-linear-oscillator",
    "title": "",
    "section": "Comparison with Linear Oscillator",
    "text": "Comparison with Linear Oscillator\nLinear (Harmonic): - sin(θ) ≈ θ - Gaussian stationary distribution - No bistability\nNonlinear (Pendulum): - Full sin(θ) - Non-Gaussian stationary distribution - Bistable (multiple wells)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\n1D angle (no spatial motion)\nAdditive noise only\nConstant parameters\nNo joint flexibility\nRigid body assumption"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nDouble pendulum (chaos + noise)\nElastic pendulum (variable length)\nSpherical pendulum (2D angle)\nCoupled pendulums (arrays)\nParametric noise (variable g or L)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nPendulum : Deterministic version StochasticDoubleIntegrator : Linear analog"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticPendulum.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_energy\nCompute mechanical energy.\n\n\ndefine_system\nDefine stochastic pendulum dynamics.\n\n\nestimate_kramers_escape_time\nEstimate mean escape time using Kramers formula.\n\n\nget_effective_temperature\nGet effective temperature T_eff = σ²/b.\n\n\nget_natural_frequency\nGet natural frequency ω_0 = √(g/L).\n\n\nsetup_equilibria\nSet up equilibrium points (deterministic part).\n\n\n\n\ncompute_energy\nsystems.builtin.stochastic.continuous.ContinuousStochasticPendulum.compute_energy(\n    theta,\n    omega,\n)\nCompute mechanical energy.\nE = (1/2)·ω² + (g/L)·(1 - cos(θ))\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntheta\nfloat\nAngle [rad]\nrequired\n\n\nomega\nfloat\nAngular velocity [rad/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEnergy [J/kg] (or normalized)\n\n\n\n\n\nNotes\nEnergy fluctuates randomly due to noise. With damping: Mean energy dissipates to T_eff = σ²/b.\n\n\nExamples\n&gt;&gt;&gt; pend = ContinuousStochasticPendulum()\n&gt;&gt;&gt; E = pend.compute_energy(theta=0.5, omega=1.0)\n&gt;&gt;&gt; print(f\"Energy: {E:.3f}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.ContinuousStochasticPendulum.define_system(\n    g=9.81,\n    L=1.0,\n    b=0.5,\n    sigma=0.5,\n    m=1.0,\n)\nDefine stochastic pendulum dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ng\nfloat\nGravitational acceleration [m/s²]\n9.81\n\n\nL\nfloat\nPendulum length [m]\n1.0\n\n\nb\nfloat\nDamping coefficient [1/s] - b &gt; 0 required for stationary distribution - Typical: 0.1-10.0 - Quality factor: Q = √(g/L)/b\n0.5\n\n\nsigma\nfloat\nNoise intensity [rad/(s²·√s)] - Controls random torque magnitude - Typical: 0.1-2.0 - Effective temperature: T_eff = σ²/b\n0.5\n\n\nm\nfloat\nMass [kg] (optional, for dimensional analysis)\n1.0\n\n\n\n\n\nNotes\nNatural Frequency: ω_0 = √(g/L)\nFor g=9.81, L=1: ω_0 ≈ 3.13 rad/s, Period ≈ 2 s\nDamping Regimes:\nDamping ratio: ζ = b/(2·ω_0) - ζ &lt; 1: Underdamped (oscillatory decay) - ζ = 1: Critically damped (fastest non-oscillatory) - ζ &gt; 1: Overdamped (slow exponential decay)\nEffective Temperature: T_eff = σ²/b\nAnalogy with thermodynamics: - Noise injects energy: ~ σ² - Damping removes energy: ~ b - Equilibrium: Balance at T_eff\nEnergy Barrier: From stable (θ=0) to unstable (θ=π): ΔE = 2·g/L\nFor g=9.81, L=1: ΔE = 19.62 J/kg\nKramers Time: Mean escape time: τ_escape ~ (b/ω_0²)·exp(ΔE·b/σ²)\nExample: b=0.5, σ=0.5, ΔE≈20 → τ ~ 0.05·exp(20) ~ 2.4×10⁸ seconds!\nNoise Level Guidelines:\nLow noise (σ &lt; 0.3): - Rare escapes (τ &gt; hours) - Nearly deterministic - Small fluctuations around equilibrium\nModerate noise (σ = 0.3-1.0): - Occasional escapes (τ ~ minutes to hours) - Visible stochastic effects - Coherence resonance regime\nHigh noise (σ &gt; 1.0): - Frequent escapes (τ ~ seconds) - Dominated by randomness - Large fluctuations\nStochastic Resonance Regime: For periodic forcing u = A·cos(ω·t): - Optimal σ ≈ √(ΔE·b) ≈ √(2·g/L·b) - Maximizes response to weak signal\n\n\n\nestimate_kramers_escape_time\nsystems.builtin.stochastic.continuous.ContinuousStochasticPendulum.estimate_kramers_escape_time(\n)\nEstimate mean escape time using Kramers formula.\nτ ~ (2πb/ω_0²)·exp(ΔE·b/σ²)\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEstimated mean escape time [s]\n\n\n\n\n\nNotes\nThis is approximate, valid for: - Small noise: σ² &lt;&lt; ΔE·b - Moderate damping: b ~ ω_0\nFor accurate times, use Monte Carlo simulation.\n\n\nExamples\n&gt;&gt;&gt; pend = ContinuousStochasticPendulum(b=0.5, sigma=0.5)\n&gt;&gt;&gt; tau = pend.estimate_kramers_escape_time()\n&gt;&gt;&gt; print(f\"Mean escape time: {tau:.2e} s\")\n\n\n\nget_effective_temperature\nsystems.builtin.stochastic.continuous.ContinuousStochasticPendulum.get_effective_temperature(\n)\nGet effective temperature T_eff = σ²/b.\nRatio of noise injection to dissipation.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEffective temperature\n\n\n\n\n\nNotes\nAnalogy with thermodynamics: - Higher T_eff: More energetic fluctuations - Lower T_eff: Smaller fluctuations - Controls stationary distribution width\n\n\nExamples\n&gt;&gt;&gt; pend = ContinuousStochasticPendulum(b=0.5, sigma=0.5)\n&gt;&gt;&gt; T_eff = pend.get_effective_temperature()\n&gt;&gt;&gt; print(f\"T_eff: {T_eff:.3f}\")\n\n\n\nget_natural_frequency\nsystems.builtin.stochastic.continuous.ContinuousStochasticPendulum.get_natural_frequency(\n)\nGet natural frequency ω_0 = √(g/L).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nNatural frequency [rad/s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; pend = ContinuousStochasticPendulum(g=9.81, L=1.0)\n&gt;&gt;&gt; omega_0 = pend.get_natural_frequency()\n&gt;&gt;&gt; period = 2 * np.pi / omega_0\n&gt;&gt;&gt; print(f\"Period: {period:.2f} s\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.continuous.ContinuousStochasticPendulum.setup_equilibria(\n)\nSet up equilibrium points (deterministic part).\nPendulum has periodic equilibria at θ = n·π."
  },
  {
    "objectID": "api/types.core.DynamicsFunction.html",
    "href": "api/types.core.DynamicsFunction.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.DynamicsFunction.html#parameters",
    "href": "api/types.core.DynamicsFunction.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input (nu,) or None for autonomous\nrequired"
  },
  {
    "objectID": "api/types.core.DynamicsFunction.html#returns",
    "href": "api/types.core.DynamicsFunction.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nDynamics evaluation (nx,)"
  },
  {
    "objectID": "api/types.core.DynamicsFunction.html#examples",
    "href": "api/types.core.DynamicsFunction.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Linear dynamics\n&gt;&gt;&gt; def f_linear(x: StateVector, u: ControlVector) -&gt; StateVector:\n...     return A @ x + B @ u\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Nonlinear dynamics\n&gt;&gt;&gt; def f_nonlinear(x: StateVector, u: ControlVector) -&gt; StateVector:\n...     x1, x2 = x\n...     return np.array([x2, -np.sin(x1) + u[0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Autonomous\n&gt;&gt;&gt; def f_autonomous(x: StateVector, u: Optional[ControlVector] = None) -&gt; StateVector:\n...     return -alpha * x"
  },
  {
    "objectID": "api/types.core.ControlVector.html",
    "href": "api/types.core.ControlVector.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.ControlVector.html#examples",
    "href": "api/types.core.ControlVector.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Single control\n&gt;&gt;&gt; u: ControlVector = np.array([0.5])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Control sequence (100 steps)\n&gt;&gt;&gt; u_seq: ControlVector = np.zeros((100, 1))\n&gt;&gt;&gt; \n&gt;&gt;&gt; # For autonomous systems (nu=0)\n&gt;&gt;&gt; u_autonomous: Optional[ControlVector] = None"
  },
  {
    "objectID": "api/systems.base.utils.DynamicsEvaluator.html",
    "href": "api/systems.base.utils.DynamicsEvaluator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.DynamicsEvaluator.html#methods",
    "href": "api/systems.base.utils.DynamicsEvaluator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nevaluate\nEvaluate forward dynamics: dx/dt = f(x, u) or dx/dt = f(x).\n\n\nget_stats\nGet performance statistics.\n\n\nreset_stats\nReset performance counters.\n\n\n\n\nevaluate\nsystems.base.utils.DynamicsEvaluator.evaluate(x, u=None, backend=None)\nEvaluate forward dynamics: dx/dt = f(x, u) or dx/dt = f(x).\nArgs: x: State vector u: Control vector (None for autonomous systems) backend: Backend selection: - None: Auto-detect from input type (default) - ‘numpy’, ‘torch’, ‘jax’: Force specific backend - ‘default’: Use system’s default backend\nReturns: State derivative vector (type matches backend)\nRaises: ValueError: If u is None for non-autonomous system\nExample: &gt;&gt;&gt; # Controlled system - auto-detect backend &gt;&gt;&gt; dx = evaluator.evaluate(x_numpy, u_numpy) # Returns NumPy &gt;&gt;&gt; &gt;&gt;&gt; # Autonomous system &gt;&gt;&gt; dx = evaluator.evaluate(x_numpy) # u=None &gt;&gt;&gt; &gt;&gt;&gt; # Force specific backend (converts input) &gt;&gt;&gt; dx = evaluator.evaluate(x_numpy, u_numpy, backend=‘torch’) # Returns PyTorch\n\n\nget_stats\nsystems.base.utils.DynamicsEvaluator.get_stats()\nGet performance statistics.\nReturns: ExecutionStats Structured performance metrics with call count and timing\nExample: &gt;&gt;&gt; stats: ExecutionStats = evaluator.get_stats() &gt;&gt;&gt; print(f”Calls: {stats[‘calls’]}“) &gt;&gt;&gt; print(f”Avg time: {stats[‘avg_time’]:.6f}s”)\n\n\nreset_stats\nsystems.base.utils.DynamicsEvaluator.reset_stats()\nReset performance counters.\nExample: &gt;&gt;&gt; evaluator.reset_stats() &gt;&gt;&gt; # Stats are now zero"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html",
    "href": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#parameters",
    "href": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nStochasticDynamicalSystem\nSDE system to integrate (controlled or autonomous)\nrequired\n\n\ndt\nOptional[float]\nTime step (initial guess for adaptive, fixed for non-adaptive)\n0.01\n\n\nstep_mode\nStepMode\nFIXED or ADAPTIVE stepping (default: FIXED) Note: Many Julia SDE solvers (like EM) only support fixed stepping Use adaptive algorithms like ‘LambaEM’ for adaptive stepping\nStepMode.FIXED\n\n\nbackend\nstr\nMust be ‘numpy’ (Julia returns NumPy arrays via diffeqpy)\n'numpy'\n\n\nalgorithm\nstr\nJulia SDE algorithm name (default: ‘EM’) See list_algorithms() for available options\n'EM'\n\n\nsde_type\nOptional[SDEType]\nSDE interpretation (None = use system’s type)\nNone\n\n\nconvergence_type\nConvergenceType\nStrong or weak convergence\nConvergenceType.STRONG\n\n\nseed\nOptional[int]\nRandom seed for reproducibility NOTE: Seed control via diffeqpy is limited. Julia generates random numbers internally and setting the seed via Python is unreliable. For reproducible results, use JAX/PyTorch integrators instead.\nNone\n\n\n**options\n\nAdditional options: - rtol : float (default: 1e-3) - Relative tolerance - atol : float (default: 1e-6) - Absolute tolerance - save_everystep : bool (default: True) - Save at every step - dense : bool (default: False) - Dense output interpolation\n{}"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#raises",
    "href": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#raises",
    "title": "",
    "section": "Raises",
    "text": "Raises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImportError\nIf diffeqpy is not installed\n\n\n\nRuntimeError\nIf Julia DifferentialEquations.jl is not available"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#notes",
    "href": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nBackend must be ‘numpy’ (Julia/Python bridge uses NumPy)\nStatistics tracking is estimated (Julia doesn’t expose call counts)\nRandom seed control is limited (Julia manages its own RNG)\nFor reproducible Monte Carlo, use JAX or PyTorch integrators\nFor custom noise specification, use JAX/Diffrax (simpler API)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#examples",
    "href": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Basic usage with Euler-Maruyama\n&gt;&gt;&gt; integrator = DiffEqPySDEIntegrator(\n...     sde_system,\n...     dt=0.01,\n...     algorithm='EM'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # High accuracy adaptive solver\n&gt;&gt;&gt; integrator = DiffEqPySDEIntegrator(\n...     sde_system,\n...     dt=0.001,\n...     algorithm='SRIW1',\n...     rtol=1e-6,\n...     atol=1e-8\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stiff drift with implicit solver\n&gt;&gt;&gt; integrator = DiffEqPySDEIntegrator(\n...     stiff_sde,\n...     algorithm='ImplicitEM',\n...     dt=0.01\n... )"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#attributes",
    "href": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nname\nReturn integrator name."
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#methods",
    "href": "api/systems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nget_algorithm_info\nGet detailed information about a specific algorithm.\n\n\nintegrate\nIntegrate SDE over time interval using Julia solver.\n\n\nlist_algorithms\nList available Julia SDE algorithms by category.\n\n\nrecommend_algorithm\nRecommend Julia SDE algorithm based on problem characteristics.\n\n\nstep\nTake one SDE integration step.\n\n\nvalidate_julia_setup\nValidate that Julia and DifferentialEquations.jl are properly set up.\n\n\n\n\nget_algorithm_info\nsystems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.get_algorithm_info(\n    algorithm,\n)\nGet detailed information about a specific algorithm.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nalgorithm\nstr\nAlgorithm name\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nAlgorithm properties and recommendations\n\n\n\n\n\nExamples\n&gt;&gt;&gt; info = DiffEqPySDEIntegrator.get_algorithm_info('SRIW1')\n&gt;&gt;&gt; print(info['description'])\n'High accuracy for diagonal noise'\n\n\n\nintegrate\nsystems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n)\nIntegrate SDE over time interval using Julia solver.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nArrayLike\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable\nControl policy: (t, x) -&gt; u (or None for autonomous)\nrequired\n\n\nt_span\nTuple[float, float]\nIntegration interval (t_start, t_end)\nrequired\n\n\nt_eval\nOptional[ArrayLike]\nSpecific times at which to save solution\nNone\n\n\ndense_output\nbool\nIf True, enable dense output interpolation\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegrationResult\nIntegration result with trajectory and statistics\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Autonomous SDE\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Controlled SDE\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: -K @ x,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Save at specific times\n&gt;&gt;&gt; t_eval = np.linspace(0, 10, 1001)\n&gt;&gt;&gt; result = integrator.integrate(x0, u_func, (0, 10), t_eval=t_eval)\n\n\n\nlist_algorithms\nsystems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.list_algorithms(\n)\nList available Julia SDE algorithms by category.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, List[str]]\nAlgorithms organized by category\n\n\n\n\n\nExamples\n&gt;&gt;&gt; algorithms = DiffEqPySDEIntegrator.list_algorithms()\n&gt;&gt;&gt; print(algorithms['euler_maruyama'])\n['EM', 'LambaEM', 'EulerHeun']\n\n\n\nrecommend_algorithm\nsystems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.recommend_algorithm(\n    noise_type,\n    stiffness='none',\n    accuracy='medium',\n)\nRecommend Julia SDE algorithm based on problem characteristics.\nIMPORTANT: Not all recommended algorithms work via diffeqpy! - SRIW1/SRIW2: Don’t work (use JAX/Diffrax instead) - EM: Always works - SRA3: Verified to work\nFor guaranteed compatibility, use ‘EM’ or ‘SRA3’ only. For high accuracy with diagonal noise, use JAX/Diffrax.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnoise_type\nstr\n‘additive’, ‘diagonal’, ‘scalar’, or ‘general’\nrequired\n\n\nstiffness\nstr\n‘none’, ‘moderate’, or ‘severe’\n'none'\n\n\naccuracy\nstr\n‘low’, ‘medium’, or ‘high’\n'medium'\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nRecommended algorithm name\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Additive noise, high accuracy (WORKS)\n&gt;&gt;&gt; alg = DiffEqPySDEIntegrator.recommend_algorithm(\n...     noise_type='additive',\n...     stiffness='none',\n...     accuracy='high'\n... )\n&gt;&gt;&gt; print(alg)\n'SRA3'  # Verified to work\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Diagonal noise, high accuracy (DOESN'T WORK via diffeqpy)\n&gt;&gt;&gt; alg = DiffEqPySDEIntegrator.recommend_algorithm(\n...     noise_type='diagonal',\n...     stiffness='none',\n...     accuracy='high'\n... )\n&gt;&gt;&gt; print(alg)\n'SRIW1'  # Won't work - use JAX/Diffrax SHARK instead\n\n\n\nstep\nsystems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.step(\n    x,\n    u=None,\n    dt=None,\n    dW=None,\n)\nTake one SDE integration step.\nNote: Julia’s solvers are optimized for full trajectory integration. Single-step interface is less efficient due to problem setup overhead.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nArrayLike\nCurrent state\nrequired\n\n\nu\nOptional[ArrayLike]\nControl input (None for autonomous)\nNone\n\n\ndt\nOptional[float]\nStep size\nNone\n\n\ndW\nOptional[ArrayLike]\nBrownian increments (nw,) EXPERIMENTAL: Julia DOES support custom noise via NoiseGrid, but implementing it reliably for single-step integration through diffeqpy is complex and may not work as expected. Current behavior: - If dW provided: Attempts to create NoiseGrid (may fail or be ignored) - If dW is None: Uses Julia’s default random Brownian motion For reliable custom noise, use backend=‘jax’ (Diffrax) instead.\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nNext state\n\n\n\n\n\nNotes\nCustom noise limitations with Julia/diffeqpy: 1. NoiseGrid requires cumulative Brownian values, not just increments 2. Python-Julia bridging for noise objects is fragile 3. Single-step interface makes this awkward (need full grid) 4. May require DiffEqNoiseProcess.jl which isn’t always exposed\nRecommendation: For custom noise (deterministic testing, antithetic variates, etc.), use JAX/Diffrax which has clean custom noise support.\n\n\nExamples\n&gt;&gt;&gt; # Standard usage (random noise)\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Attempted custom noise (experimental, may not work)\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01, dW=np.array([0.5]))\n&gt;&gt;&gt; # Warning: May generate random noise anyway\n\n\n\nvalidate_julia_setup\nsystems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator.validate_julia_setup(\n)\nValidate that Julia and DifferentialEquations.jl are properly set up.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if setup is valid\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf validation fails with details"
  },
  {
    "objectID": "api/types.trajectories.SimulationResult.html",
    "href": "api/types.trajectories.SimulationResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.SimulationResult.html#attributes",
    "href": "api/types.trajectories.SimulationResult.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntime\nTimePoints\nRegular time points (n_steps+1,) with spacing dt\n\n\nstates\nStateTrajectory\nState trajectory (nx, n_steps+1) - includes initial state NOTE: State-major ordering for backward compatibility\n\n\ncontrols\nOptional[ControlSequence]\nControl sequence used (nu, n_steps) if controller provided\n\n\noutputs\nOptional[OutputSequence]\nOutput sequence (ny, n_steps+1) if computed\n\n\nnoise\nOptional[NoiseSequence]\nNoise sequence (n_steps, nw) for stochastic systems\n\n\nsuccess\nbool\nWhether simulation succeeded\n\n\nmetadata\nDict[str, Any]\nAdditional information: - ‘method’: Integration method used - ‘dt’: Time step used - ‘nfev’: Number of function evaluations - ‘cost’: Trajectory cost (if applicable)"
  },
  {
    "objectID": "api/types.trajectories.SimulationResult.html#notes",
    "href": "api/types.trajectories.SimulationResult.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nThis is the result from simulate() which provides a regular time grid by wrapping the lower-level integrate() method.\nArray Ordering: Currently uses (nx, T) state-major ordering for backward compatibility with legacy code. Access states as states[:, k] for state at time k, or states[i, :] for trajectory of state i.\nFor the raw adaptive-grid integration result, use integrate() which may use different conventions depending on the backend."
  },
  {
    "objectID": "api/types.trajectories.SimulationResult.html#examples",
    "href": "api/types.trajectories.SimulationResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nContinuous simulation with state feedback:\n&gt;&gt;&gt; def controller(x, t):  # Note: (x, t) order\n...     K = np.array([[-1.0, -2.0]])\n...     return -K @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: SimulationResult = system.simulate(\n...     x0=np.array([1.0, 0.0]),\n...     controller=controller,\n...     t_span=(0.0, 10.0),\n...     dt=0.01\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; time = result['time']           # (1001,)\n&gt;&gt;&gt; states = result['states']       # (2, 1001) - state-major!\n&gt;&gt;&gt; controls = result['controls']   # (1, 1000)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Access state trajectory of first state variable\n&gt;&gt;&gt; x1_trajectory = states[0, :]    # (1001,)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Access state at time step k\n&gt;&gt;&gt; x_at_k = states[:, k]           # (2,)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(time, states[0, :], label='x1')\n&gt;&gt;&gt; plt.plot(time, states[1, :], label='x2')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check success\n&gt;&gt;&gt; if result['success']:\n...     print(f\"Simulation completed with {result['metadata']['nfev']} evaluations\")\nStochastic simulation:\n&gt;&gt;&gt; result: SimulationResult = sde_system.simulate(\n...     x0=np.zeros(2),\n...     controller=None,  # Open-loop\n...     t_span=(0, 5),\n...     dt=0.01\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if 'noise' in result:\n...     print(\"Stochastic simulation\")\n...     noise_used = result['noise']"
  },
  {
    "objectID": "api/types.trajectories.SimulationResult.html#see-also",
    "href": "api/types.trajectories.SimulationResult.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nintegrate : Lower-level integration with adaptive time grid IntegrationResult : Result type from integrate()"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem.html",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nState coefficient (positive = stable)\n1.0\n\n\nb\nfloat\nControl gain\n1.0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem.html#examples",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; system = LinearSystem(a=2.0, b=1.0)\n&gt;&gt;&gt; x = np.array([1.0])\n&gt;&gt;&gt; u = np.array([0.5])\n&gt;&gt;&gt; dx = system(x, u)  # -2*1 + 1*0.5 = -1.5"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem.html#methods",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine linear system dynamics.\n\n\n\n\ndefine_system\nsystems.builtin.deterministic.continuous.LinearSystem.define_system(\n    a=1.0,\n    b=1.0,\n)\nDefine linear system dynamics."
  },
  {
    "objectID": "api/types.trajectories.TrajectoryStatistics.html",
    "href": "api/types.trajectories.TrajectoryStatistics.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.TrajectoryStatistics.html#attributes",
    "href": "api/types.trajectories.TrajectoryStatistics.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nmean\nArrayLike\nMean state over trajectory (nx,)\n\n\nstd\nArrayLike\nStandard deviation over trajectory (nx,)\n\n\nmin\nArrayLike\nMinimum values (nx,)\n\n\nmax\nArrayLike\nMaximum values (nx,)\n\n\ninitial\nArrayLike\nInitial state x[0] (nx,)\n\n\nfinal\nArrayLike\nFinal state x[-1] (nx,)\n\n\nlength\nint\nNumber of time steps\n\n\nduration\nfloat\nTime duration (t_end - t_start)"
  },
  {
    "objectID": "api/types.trajectories.TrajectoryStatistics.html#examples",
    "href": "api/types.trajectories.TrajectoryStatistics.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; def compute_trajectory_stats(trajectory: StateTrajectory) -&gt; TrajectoryStatistics:\n...     '''Compute statistics of trajectory.'''\n...     return TrajectoryStatistics(\n...         mean=np.mean(trajectory, axis=0),\n...         std=np.std(trajectory, axis=0),\n...         min=np.min(trajectory, axis=0),\n...         max=np.max(trajectory, axis=0),\n...         initial=trajectory[0],\n...         final=trajectory[-1],\n...         length=len(trajectory),\n...     )\n&gt;&gt;&gt;\n&gt;&gt;&gt; stats: TrajectoryStatistics = compute_trajectory_stats(trajectory)\n&gt;&gt;&gt; print(f\"Mean state: {stats['mean']}\")\n&gt;&gt;&gt; print(f\"Final state: {stats['final']}\")\n&gt;&gt;&gt; print(f\"Max deviation: {np.max(stats['std'])}\")"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.SDEValidator.html",
    "href": "api/systems.base.utils.stochastic.SDEValidator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.SDEValidator.html#examples",
    "href": "api/systems.base.utils.stochastic.SDEValidator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; from sympy import symbols, Matrix\n&gt;&gt;&gt; x1, x2, u = symbols('x1 x2 u')\n&gt;&gt;&gt;\n&gt;&gt;&gt; drift = Matrix([[x2], [-x1 + u]])\n&gt;&gt;&gt; diffusion = Matrix([[0.1], [0.2]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; validator = SDEValidator(drift, diffusion, [x1, x2], [u])\n&gt;&gt;&gt; result = validator.validate()\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result.is_valid:\n...     print(\"System is valid!\")\n... else:\n...     print(f\"Errors: {result.errors}\")"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.SDEValidator.html#methods",
    "href": "api/systems.base.utils.stochastic.SDEValidator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nvalidate\nPerform comprehensive SDE validation.\n\n\n\n\nvalidate\nsystems.base.utils.stochastic.SDEValidator.validate(\n    claimed_noise_type=None,\n    raise_on_error=False,\n)\nPerform comprehensive SDE validation.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclaimed_noise_type\nstr\nUser’s claim about noise type (‘additive’, ‘diagonal’, ‘scalar’) If provided, validates claim matches actual structure\nNone\n\n\nraise_on_error\nbool\nIf True, raise ValidationError on validation failure\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSymbolicValidationResult\nValidation results with errors, warnings, and info\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValidationError\nIf validation fails and raise_on_error=True\n\n\n\n\n\nExamples\n&gt;&gt;&gt; result = validator.validate()\n&gt;&gt;&gt; if not result.is_valid:\n...     print(f\"Validation failed: {result.errors}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Validate claimed noise type\n&gt;&gt;&gt; result = validator.validate(claimed_noise_type='additive')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Raise exception on error\n&gt;&gt;&gt; try:\n...     result = validator.validate(raise_on_error=True)\n... except ValidationError as e:\n...     print(f\"Validation failed: {e}\")"
  },
  {
    "objectID": "api/systems.base.core.DiscreteSymbolicSystem.html",
    "href": "api/systems.base.core.DiscreteSymbolicSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.DiscreteSymbolicSystem.html#examples",
    "href": "api/systems.base.core.DiscreteSymbolicSystem.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; class DiscreteOscillator(DiscreteSymbolicSystem):\n...     def define_system(self, a=0.95, b=0.05, dt=0.1):\n...         x, v = sp.symbols('x v', real=True)\n...         u = sp.symbols('u', real=True)\n...         a_sym, b_sym = sp.symbols('a b', real=True)\n...\n...         self.state_vars = [x, v]\n...         self.control_vars = [u]\n...         self._f_sym = sp.Matrix([\n...             a_sym*x + (1-a_sym)*v,\n...             v + b_sym*u\n...         ])\n...         self.parameters = {a_sym: a, b_sym: b}\n...         self._dt = dt  # REQUIRED!\n...         self.order = 1"
  },
  {
    "objectID": "api/systems.base.core.DiscreteSymbolicSystem.html#attributes",
    "href": "api/systems.base.core.DiscreteSymbolicSystem.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ndt\nSampling period / time step."
  },
  {
    "objectID": "api/systems.base.core.DiscreteSymbolicSystem.html#methods",
    "href": "api/systems.base.core.DiscreteSymbolicSystem.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nforward\nAlias for step() with explicit backend specification.\n\n\nget_performance_stats\nGet performance statistics from evaluators.\n\n\nh\nEvaluate output: y[k] = h(x[k]).\n\n\nlinearize\nCompute discrete linearization: Ad = ∂f/∂x, Bd = ∂f/∂u.\n\n\nlinearized_dynamics\nCompute discrete linearization (alias for linearize()).\n\n\nlinearized_dynamics_symbolic\nCompute symbolic discrete linearization.\n\n\nlinearized_observation\nCompute C = ∂h/∂x.\n\n\nlinearized_observation_symbolic\nCompute symbolic observation Jacobian: C = ∂h/∂x.\n\n\nprint_equations\nPrint symbolic equations using discrete-time notation.\n\n\nreset_performance_stats\nReset performance counters.\n\n\nsimulate\nSimulate discrete system for multiple steps.\n\n\nstep\nCompute next state: x[k+1] = f(x[k], u[k]).\n\n\nverify_jacobians\nVerify symbolic Jacobians against automatic differentiation.\n\n\nwarmup\nWarm up backend by compiling and running test evaluation.\n\n\n\n\nforward\nsystems.base.core.DiscreteSymbolicSystem.forward(x, u=None, backend=None)\nAlias for step() with explicit backend specification.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state x[k]\nrequired\n\n\nu\nOptional[ControlVector]\nControl u[k]\nNone\n\n\nbackend\nOptional[Backend]\nBackend override\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x[k+1]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x_next = system.forward(x, u)\n&gt;&gt;&gt; x_next = system.forward(x, u, backend='torch')\n\n\n\nget_performance_stats\nsystems.base.core.DiscreteSymbolicSystem.get_performance_stats()\nGet performance statistics from evaluators.\n\n\nh\nsystems.base.core.DiscreteSymbolicSystem.h(x, backend=None)\nEvaluate output: y[k] = h(x[k]).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState x[k]\nrequired\n\n\nbackend\nOptional[Backend]\nBackend selection\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nOutput y[k]\n\n\n\n\n\n\nlinearize\nsystems.base.core.DiscreteSymbolicSystem.linearize(x_eq, u_eq=None)\nCompute discrete linearization: Ad = ∂f/∂x, Bd = ∂f/∂u.\nFor discrete systems: δx[k+1] = Ad·δx[k] + Bd·δu[k]\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control (nu,)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteLinearization\nTuple (Ad, Bd) where: - Ad: State transition matrix, shape (nx, nx) - Bd: Control matrix, shape (nx, nu)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; Ad, Bd = system.linearize(np.zeros(2), np.zeros(1))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check discrete stability: |λ| &lt; 1\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(Ad)\n&gt;&gt;&gt; is_stable = np.all(np.abs(eigenvalues) &lt; 1.0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discrete LQR\n&gt;&gt;&gt; from scipy.linalg import solve_discrete_are\n&gt;&gt;&gt; P = solve_discrete_are(Ad, Bd, Q, R)\n&gt;&gt;&gt; K = np.linalg.inv(R + Bd.T @ P @ Bd) @ (Bd.T @ P @ Ad)\n\n\n\nlinearized_dynamics\nsystems.base.core.DiscreteSymbolicSystem.linearized_dynamics(\n    x,\n    u=None,\n    backend=None,\n)\nCompute discrete linearization (alias for linearize()).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[StateVector, str]\nState or equilibrium name\nrequired\n\n\nu\nOptional[ControlVector]\nControl\nNone\n\n\nbackend\nOptional[Backend]\nBackend for result\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[ArrayLike, ArrayLike]\n(Ad, Bd) discrete Jacobians\n\n\n\n\n\nExamples\n&gt;&gt;&gt; Ad, Bd = system.linearized_dynamics(np.zeros(2), np.zeros(1))\n&gt;&gt;&gt; Ad, Bd = system.linearized_dynamics('origin')\n\n\n\nlinearized_dynamics_symbolic\nsystems.base.core.DiscreteSymbolicSystem.linearized_dynamics_symbolic(\n    x_eq=None,\n    u_eq=None,\n)\nCompute symbolic discrete linearization.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nOptional[Union[sp.Matrix, str]]\nEquilibrium state or name\nNone\n\n\nu_eq\nOptional[sp.Matrix]\nEquilibrium control\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[sp.Matrix, sp.Matrix]\n(Ad, Bd) symbolic matrices\n\n\n\n\n\nExamples\n&gt;&gt;&gt; Ad_sym, Bd_sym = system.linearized_dynamics_symbolic()\n\n\n\nlinearized_observation\nsystems.base.core.DiscreteSymbolicSystem.linearized_observation(x, backend=None)\nCompute C = ∂h/∂x.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState\nrequired\n\n\nbackend\nOptional[Backend]\nBackend\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nC matrix (ny, nx)\n\n\n\n\n\n\nlinearized_observation_symbolic\nsystems.base.core.DiscreteSymbolicSystem.linearized_observation_symbolic(\n    x_eq=None,\n)\nCompute symbolic observation Jacobian: C = ∂h/∂x.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nOptional[sp.Matrix]\nEquilibrium state (symbolic), None = zeros\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsp.Matrix\nSymbolic C matrix\n\n\n\n\n\nExamples\n&gt;&gt;&gt; C_sym = system.linearized_observation_symbolic()\n&gt;&gt;&gt; print(C_sym)\n\n\n\nprint_equations\nsystems.base.core.DiscreteSymbolicSystem.print_equations(simplify=True)\nPrint symbolic equations using discrete-time notation.\nUses x[k+1] notation appropriate for difference equations.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nIf True, simplify expressions before printing\nTrue\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.print_equations()\n======================================================================\nDiscreteLinear (Discrete-Time, dt=0.01)\n======================================================================\nState Variables: [x]\nControl Variables: [u]\nDimensions: nx=1, nu=1, ny=1\nDynamics: x[k+1] = f(x[k], u[k]) x[k+1] = 0.9x[k] + 0.1u[k] ======================================================================\n\n\n\nreset_performance_stats\nsystems.base.core.DiscreteSymbolicSystem.reset_performance_stats()\nReset performance counters.\n\n\nsimulate\nsystems.base.core.DiscreteSymbolicSystem.simulate(\n    x0,\n    u_sequence=None,\n    n_steps=100,\n    **kwargs,\n)\nSimulate discrete system for multiple steps.\nRepeatedly applies step() to generate state trajectory.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_sequence\nUnion[ControlVector, Sequence, Callable, None]\nControl sequence: - None: Zero control - Array (nu,): Constant control - Array (n_steps, nu): Pre-computed sequence - Callable(k): Time-indexed u[k] = u_func(k)\nNone\n\n\nn_steps\nint\nNumber of simulation steps\n100\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteSimulationResult\nTypedDict containing: - states: State trajectory (nx, n_steps+1) - includes x[0] - controls: Control sequence (nu, n_steps) - time_steps: [0, 1, 2, …, n_steps] - dt: Sampling period - metadata: Additional info\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Constant control\n&gt;&gt;&gt; result = system.simulate(\n...     x0=np.array([1.0]),\n...     u_sequence=np.array([0.5]),\n...     n_steps=100\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Pre-computed sequence\n&gt;&gt;&gt; u_seq = np.random.randn(100, 1)\n&gt;&gt;&gt; result = system.simulate(x0, u_seq, n_steps=100)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Time-indexed function\n&gt;&gt;&gt; result = system.simulate(\n...     x0,\n...     u_sequence=lambda k: np.array([np.sin(k*system.dt)]),\n...     n_steps=100\n... )\n\n\n\nstep\nsystems.base.core.DiscreteSymbolicSystem.step(x, u=None, k=0, backend=None)\nCompute next state: x[k+1] = f(x[k], u[k]).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state x[k], shape (nx,)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input u[k], shape (nu,) None for autonomous systems\nNone\n\n\nk\nint\nTime step index (currently ignored for time-invariant systems)\n0\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x[k+1], same shape and backend as input\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x_k = np.array([1.0, 0.0])\n&gt;&gt;&gt; u_k = np.array([0.5])\n&gt;&gt;&gt; x_next = system.step(x_k, u_k)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous\n&gt;&gt;&gt; x_next = system.step(x_k)  # u=None\n\n\n\nverify_jacobians\nsystems.base.core.DiscreteSymbolicSystem.verify_jacobians(\n    x,\n    u=None,\n    tol=0.001,\n    backend='torch',\n)\nVerify symbolic Jacobians against automatic differentiation.\nCompares analytically-derived discrete Jacobians (from SymPy) against numerically-computed Jacobians (from PyTorch/JAX autodiff).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState at which to verify\nrequired\n\n\nu\nOptional[ControlVector]\nControl at which to verify (None for autonomous)\nNone\n\n\ntol\nfloat\nTolerance for considering Jacobians equal\n0.001\n\n\nbackend\nstr\nBackend for autodiff (‘torch’ or ‘jax’, not ‘numpy’)\n'torch'\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Union[bool, float]]\nVerification results: - ‘Ad_match’: bool - True if Ad matches - ‘Bd_match’: bool - True if Bd matches - ‘Ad_error’: float - Maximum absolute error in Ad - ‘Bd_error’: float - Maximum absolute error in Bd\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([0.1, 0.0])\n&gt;&gt;&gt; u = np.array([0.0])\n&gt;&gt;&gt; results = system.verify_jacobians(x, u, backend='torch')\n&gt;&gt;&gt;\n&gt;&gt;&gt; if results['Ad_match'] and results['Bd_match']:\n...     print(\"✓ Jacobians verified!\")\n... else:\n...     print(f\"✗ Ad error: {results['Ad_error']:.2e}\")\n...     print(f\"✗ Bd error: {results['Bd_error']:.2e}\")\n\n\nNotes\nRequires PyTorch or JAX for automatic differentiation. Small errors (&lt; 1e-6) are usually numerical precision issues. Large errors indicate bugs in symbolic Jacobian computation.\n\n\n\nwarmup\nsystems.base.core.DiscreteSymbolicSystem.warmup(backend=None, test_point=None)\nWarm up backend by compiling and running test evaluation.\nUseful for JIT compilation warmup (especially JAX) and validating backend configuration before critical operations.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nOptional[Backend]\nBackend to warm up (None = default)\nNone\n\n\ntest_point\nOptional[Tuple[StateVector, ControlVector]]\nTest (x, u) point (None = use equilibrium)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if warmup successful\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.set_default_backend('jax', device='gpu:0')\n&gt;&gt;&gt; success = system.warmup()\n&gt;&gt;&gt; # First call triggers JIT compilation"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#model-equations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#model-equations",
    "title": "",
    "section": "Model Equations",
    "text": "Model Equations\nReturn process: r[k] = μ + ε[k] ε[k] = σ[k]·w[k]\nVariance process (GARCH): σ²[k] = ω + α·ε²[k-1] + β·σ²[k-1]\nwhere: - r[k]: Return (observable) - μ: Mean return (typically ≈ 0 for daily) - ε[k]: Innovation (zero-mean shock) - σ²[k]: Conditional variance (time-varying, latent) - w[k] ~ N(0,1): Standardized innovation (iid) - ω &gt; 0: Constant term - α ≥ 0: ARCH coefficient (shock effect) - β ≥ 0: GARCH coefficient (persistence)\nState-Space Form:\nAugmented state: Z = [r, σ²] (return and variance)\nDynamics (nonlinear!): r[k] = μ + σ[k]·w[k] σ²[k+1] = ω + α·(r[k] - μ)² + β·σ²[k]"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nWhat GARCH Models:\nFinancial markets exhibit volatility clustering: - Large price movements followed by large movements - Calm periods followed by calm periods - “Volatility begets volatility”\nWhy This Happens:\n\nInformation Flow:\n\nNews arrives in clusters\nUncertainty propagates\n\nMarket Microstructure:\n\nFeedback: Vol → wider spreads → more vol\nHerding behavior\n\nRisk Preferences:\n\nRisk-off → sell → higher vol → more risk-off\nFeedback loops\n\n\nGARCH Equation Interpretation:\nσ²[k] = ω + α·ε²[k-1] + β·σ²[k-1]\nComponents: 1. ω: Baseline variance (floor) 2. α·ε²[k-1]: Recent shock (ARCH effect) - Large |ε[k-1]| → high σ²[k] - “News impact curve” 3. β·σ²[k-1]: Past variance (persistence) - High σ²[k-1] → high σ²[k] - Volatility clustering"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nTime-Varying Variance: Unlike constant-variance models, σ²[k] changes every period.\nVolatility Clustering: High volatility tends to persist (α + β near 1).\nMean Reversion: Variance reverts to ω/(1-α-β) over time.\nConditional vs Unconditional: - Conditional: Var[r[k]|past] = σ²[k] (time-varying) - Unconditional: Var[r[k]] = ω/(1-α-β) (constant)\nHeavy Tails: Even with Gaussian w[k], unconditional distribution has excess kurtosis.\nPredictable Volatility: Can forecast σ²[k+h] from past (even if returns unpredictable)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nStationarity Condition: α + β &lt; 1\nIf α + β = 1: IGARCH (integrated, non-stationary variance) If α + β &gt; 1: Explosive (unstable)\nUnconditional Moments:\nMean: E[r] = μ\nVariance: Var[r] = ω/(1 - α - β)\nKurtosis: Excess kurtosis &gt; 0 (heavy tails) Kurt = 3·(1 - (α+β)²)/(1 - (α+β)² - 2α²)\nAutocorrelation: - Returns r[k]: ρ(h) ≈ 0 (unpredictable) - Squared returns ε²[k]: ρ(h) = (α+β)^h (geometric decay)\nPersistence: Measured by α + β (sum of ARCH and GARCH): - α + β ≈ 0.99: Very persistent (typical stocks) - α + β ≈ 0.95: Persistent - α + β ≈ 0.80: Moderate persistence\nVolatility Forecast: h-step ahead: σ²[k+h|k] = σ̄² + (α+β)^h·(σ²[k] - σ̄²)\nwhere σ̄² = ω/(1-α-β) is long-run variance.\nExponential decay to long-run average."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nParameter ω (Baseline): - Units: [return]² - Long-run variance: σ̄² = ω/(1-α-β) - Typical: Relates to annual volatility\nParameter α (ARCH Effect): - Dimensionless - Weight on recent shock - Typical: 0.05-0.15 - Higher α: More reactive to news\nParameter β (GARCH Effect): - Dimensionless - Weight on past variance - Typical: 0.80-0.92 - Higher β: More persistent\nSum α + β (Total Persistence): - Typical: 0.95-0.99 (very high!) - Near 1: “Volatility never dies” - Financial data: Usually &gt;0.90\nTypical Values (Daily Stock Returns): - ω ≈ 0.000001-0.00001 (depends on scaling) - α ≈ 0.05-0.10 - β ≈ 0.85-0.92 - α + β ≈ 0.95-0.98"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nAugmented state: Z = [r, σ²] ∈ ℝ² - r: Observable return - σ²: Latent conditional variance\nObservable: r ∈ ℝ - What we actually measure (price changes)\nLatent: σ² ∈ ℝ₊ - Unobserved (must be estimated/filtered)\nControl: u (typically none for GARCH) - Could add for interventions"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nomega\nfloat\nConstant term (must be positive) - Sets baseline variance - Typical: 1e-6 to 1e-4 (daily returns)\n0.00001\n\n\nalpha\nfloat\nARCH coefficient (must be non-negative) - News impact (shock sensitivity) - Typical: 0.05-0.15\n0.1\n\n\nbeta\nfloat\nGARCH coefficient (must be non-negative) - Persistence (volatility memory) - Typical: 0.80-0.92\n0.85\n\n\nmu\nfloat\nMean return - Often ≈ 0 for daily returns - Can estimate or fix\n0.0\n\n\ndt\nfloat\nSampling period (1 = daily typical)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR (σ² equation)\nConditional: Variance time-varying\nStationary: If α + β &lt; 1\nHeavy Tails: Yes (excess kurtosis)\nVolatility Clustering: Yes (by design)\nLeverage Effect: No (symmetric)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Risk Management: - VaR calculation - Expected shortfall (CVaR) - Stress testing\n2. Option Pricing: - Volatility forecasting - Monte Carlo with GARCH - Implied vs realized vol\n3. Portfolio: - Time-varying covariance (MGARCH) - Dynamic hedging - Risk parity\n4. Trading: - Volatility strategies - Position sizing (risk targeting) - Options trading signals\n5. Regulation: - Basel capital requirements - Internal VaR models - Stress testing"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nRecursion:\nInitialize: σ²[0] = ω/(1-α-β)\nFor k = 0, 1, 2, …: 1. Draw w[k] ~ N(0,1) 2. Compute r[k] = μ + σ[k]·w[k] 3. Update σ²[k+1] = ω + α·(r[k]-μ)² + β·σ²[k]\nState-Space: State Z = [r, σ²] - r observable - σ² latent (filtered in practice)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#comparison-with-constant-variance",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#comparison-with-constant-variance",
    "title": "",
    "section": "Comparison with Constant Variance",
    "text": "Comparison with Constant Variance\nConstant Variance: r[k] = μ + σ·w[k]\nProblems: - Misses volatility clustering - Underestimates tail risk - Poor VaR forecasts\nGARCH: r[k] = μ + σ[k]·w[k] σ²[k] = f(past)\nAdvantages: - Captures clustering - Better tail risk - Accurate VaR"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nSymmetric (leverage effect ignored)\nGaussian (can extend to Student-t)\nLow frequency (daily typically, not intraday)\nUnivariate (for MGARCH extension)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nEGARCH: Asymmetry\nGJR-GARCH: Threshold effects\nFIGARCH: Long memory\nDCC-GARCH: Dynamic conditional correlation\nGARCH-M: Risk premium in mean"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteGARCH11.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine GARCH(1,1) dynamics.\n\n\nforecast_variance\nForecast variance h steps ahead.\n\n\nget_half_life\nGet volatility shock half-life (periods to decay by 50%).\n\n\nget_persistence\nGet volatility persistence α + β.\n\n\nget_unconditional_variance\nGet long-run (unconditional) variance σ̄² = ω/(1-α-β).\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteGARCH11.define_system(\n    omega=1e-05,\n    alpha=0.1,\n    beta=0.85,\n    mu=0.0,\n    dt=1.0,\n)\nDefine GARCH(1,1) dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nomega\nfloat\nConstant term in variance equation (must be positive) - Sets baseline variance - Typical daily: 1e-6 to 1e-4\n0.00001\n\n\nalpha\nfloat\nARCH coefficient (must be non-negative) - Weight on past squared shock - Typical: 0.05-0.15 - Higher: More reactive to news\n0.1\n\n\nbeta\nfloat\nGARCH coefficient (must be non-negative) - Weight on past variance - Typical: 0.80-0.92 - Higher: More persistent\n0.85\n\n\nmu\nfloat\nMean return - Typically ≈ 0 for daily - Can be non-zero for longer horizons\n0.0\n\n\ndt\nfloat\nSampling period (1 = daily typical)\n1.0\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf ω ≤ 0, α &lt; 0, β &lt; 0, or α + β ≥ 1\n\n\n\n\n\nNotes\nParameter Constraints:\n\nPositivity:\n\nω &gt; 0: Ensures σ²[k] &gt; 0\nα ≥ 0, β ≥ 0: Non-negativity\n\nStationarity:\n\nα + β &lt; 1: Variance mean-reverting\nα + β = 1: IGARCH (non-stationary)\nα + β &gt; 1: Explosive (invalid)\n\n\nLong-Run Variance: σ̄² = ω/(1 - α - β)\nMust be finite (requires α + β &lt; 1).\nPersistence: α + β\nTypical values: - Stocks: 0.95-0.99 (very persistent!) - Bonds: 0.90-0.95 - FX: 0.93-0.97\nHalf-Life: Time for variance shock to decay by 50%: h_{1/2} ≈ ln(0.5)/ln(α+β)\nExample: α + β = 0.95 → h ≈ 13.5 days\nTypical Configurations:\nS&P 500 (daily): - ω ≈ 0.000001 - α ≈ 0.10 - β ≈ 0.88 - α + β = 0.98 (very persistent)\nEmerging Market (more volatile): - ω ≈ 0.00005 - α ≈ 0.15 - β ≈ 0.80 - α + β = 0.95\nLow Volatility Stock: - ω ≈ 0.0000005 - α ≈ 0.05 - β ≈ 0.92 - α + β = 0.97\nInitialization:\nFor σ²[0], common choices: 1. Unconditional: ω/(1-α-β) 2. Sample variance from data 3. Estimated as parameter\nState-Space Structure:\nThis is NONLINEAR state-space: - r[k] depends on σ[k] (multiplicatively) - σ²[k+1] depends on ε²[k] (quadratically)\nNot amenable to standard Kalman filter. Need extended/unscented/particle filter.\n\n\nExamples\n&gt;&gt;&gt; # Standard stock GARCH\n&gt;&gt;&gt; stock = DiscreteGARCH11(\n...     omega=0.000002,\n...     alpha=0.08,\n...     beta=0.90,\n...     mu=0.0005\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check constraints\n&gt;&gt;&gt; persistence = 0.08 + 0.90\n&gt;&gt;&gt; print(f\"Stationary: {persistence &lt; 1}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Long-run volatility\n&gt;&gt;&gt; sigma_lr = np.sqrt(0.000002 / (1 - persistence))\n&gt;&gt;&gt; print(f\"Long-run daily vol: {sigma_lr:.4f}\")\n&gt;&gt;&gt; annual_vol = sigma_lr * np.sqrt(252)\n&gt;&gt;&gt; print(f\"Annualized: {annual_vol:.2%}\")\n\n\n\nforecast_variance\nsystems.builtin.stochastic.discrete.DiscreteGARCH11.forecast_variance(\n    current_variance,\n    horizon=10,\n)\nForecast variance h steps ahead.\nσ²[k+h|k] = σ̄² + (α+β)^h·(σ²[k] - σ̄²)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncurrent_variance\nfloat\nCurrent conditional variance σ²[k]\nrequired\n\n\nhorizon\nint\nForecast horizon\n10\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nVariance forecasts for h=1,…,horizon\n\n\n\n\n\nExamples\n&gt;&gt;&gt; garch = DiscreteGARCH11(omega=0.00001, alpha=0.1, beta=0.85)\n&gt;&gt;&gt; forecasts = garch.forecast_variance(current_variance=0.0001, horizon=20)\n&gt;&gt;&gt; print(f\"1-day: {np.sqrt(forecasts[0]):.4f}\")\n&gt;&gt;&gt; print(f\"20-day: {np.sqrt(forecasts[-1]):.4f}\")\n\n\n\nget_half_life\nsystems.builtin.stochastic.discrete.DiscreteGARCH11.get_half_life()\nGet volatility shock half-life (periods to decay by 50%).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nHalf-life [periods]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; garch = DiscreteGARCH11(alpha=0.1, beta=0.85)\n&gt;&gt;&gt; hl = garch.get_half_life()\n&gt;&gt;&gt; print(f\"Volatility half-life: {hl:.1f} days\")\n\n\n\nget_persistence\nsystems.builtin.stochastic.discrete.DiscreteGARCH11.get_persistence()\nGet volatility persistence α + β.\n\n\nget_unconditional_variance\nsystems.builtin.stochastic.discrete.DiscreteGARCH11.get_unconditional_variance()\nGet long-run (unconditional) variance σ̄² = ω/(1-α-β).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nUnconditional variance\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf α + β ≥ 1 (non-stationary)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; garch = DiscreteGARCH11(omega=0.00001, alpha=0.1, beta=0.85)\n&gt;&gt;&gt; var_uncond = garch.get_unconditional_variance()\n&gt;&gt;&gt; vol_uncond = np.sqrt(var_uncond)\n&gt;&gt;&gt; print(f\"Long-run daily vol: {vol_uncond:.4f}\")"
  },
  {
    "objectID": "api/types.linearization.ControlJacobian.html",
    "href": "api/types.linearization.ControlJacobian.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.ControlJacobian.html#examples",
    "href": "api/types.linearization.ControlJacobian.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Bc: ControlJacobian = system.control_jacobian(x_eq, u_eq)\n&gt;&gt;&gt; # Often constant: Bc = [[0], [1/m]]"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nOriginally meant to model electronic oscillator circuits. The system exhibits self-sustained oscillations.\nThe key feature is nonlinear damping: - Near origin: negative damping (pumps energy in) - Far from origin: positive damping (dissipates energy) - Result: stable limit cycle (periodic orbit)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, y] - x: Primary variable [V or dimensionless] * In electrical circuit: voltage or current * In general: oscillating quantity\n- y: Derivative-related variable [V/s or dimensionless]\n  * y ≈ ẋ for μ → 0\n  * Not exactly velocity for μ &gt; 0 (includes nonlinear term)\nOutput: y_out = [x] - Measures only x (the oscillating variable) - Partial observation (y not directly measured)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe Van der Pol equation in standard form:\nẋ = y\nẏ = μ(1 - x²)y - x\nOr as a second-order ODE: ẍ - μ(1 - x²)ẋ + x = 0\nFirst equation: Simply defines y ≈ ẋ\nSecond equation: - μ(1 - x²)y: Nonlinear damping (Van der Pol term) * When |x| &lt; 1: (1 - x²) &gt; 0 → negative damping (adds energy) * When |x| &gt; 1: (1 - x²) &lt; 0 → positive damping (removes energy) * Balance creates stable limit cycle\n\n-x: Linear restoring force (like harmonic oscillator)\n\nProvides natural frequency ω₀ ≈ 1"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nmu : float, default=1.0 Nonlinearity parameter [dimensionless]. Controls strength of nonlinear damping and oscillation shape:\n- **μ → 0**: Nearly sinusoidal (harmonic oscillator)\n  * Period T ≈ 2π\n  * Smooth, sinusoidal limit cycle\n\n- **μ = 1**: Standard Van der Pol\n  * Period T ≈ 6.7\n  * Mildly distorted sinusoid\n\n- **μ &gt;&gt; 1**: Relaxation oscillations\n  * Period T ≈ (3 - 2ln(2))μ ≈ 1.614μ\n  * Sharp \"fast\" and \"slow\" phases\n  * Almost discontinuous (spikes and plateaus)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#behavior-regimes",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#behavior-regimes",
    "title": "",
    "section": "Behavior Regimes:",
    "text": "Behavior Regimes:\n1. Small μ (μ &lt; 0.1): Harmonic-like - Nearly sinusoidal oscillations - Frequency ≈ 1 rad/s - Smooth limit cycle - Weak nonlinearity\n2. Moderate μ (0.1 &lt; μ &lt; 3): Nonlinear oscillations - Visible waveform distortion - Frequency slightly reduced - Standard Van der Pol behavior\n3. Large μ (μ &gt; 3): Relaxation oscillations - Two-timescale dynamics - Fast jumps between slow plateaus - Very non-sinusoidal - Period proportional to μ"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#equilibrium",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#equilibrium",
    "title": "",
    "section": "Equilibrium:",
    "text": "Equilibrium:\nOrigin (unstable): x_eq = [0, 0]\nThe origin is: - Unstable focus (spiral): trajectories spiral outward - All trajectories (except origin) approach the limit cycle - Eigenvalues: λ = μ/2 ± i√(4-μ²)/2 * Real part positive (unstable) * Imaginary part gives oscillation frequency"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#limit-cycle",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#limit-cycle",
    "title": "",
    "section": "Limit Cycle:",
    "text": "Limit Cycle:\nThe system has a unique stable limit cycle:\nProperties: - Globally attracting (except from origin) - Isolated (no nearby periodic orbits) - Amplitude ≈ 2 for all μ (approximately) - Period depends on μ: * μ → 0: T → 2π (harmonic) * μ = 1: T ≈ 6.7 * μ &gt;&gt; 1: T ≈ 1.614μ\nBasin of attraction: Entire plane except origin - Any non-zero initial condition → limit cycle - Time to converge depends on distance from cycle"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#relaxation-oscillations-μ-1",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#relaxation-oscillations-μ-1",
    "title": "",
    "section": "Relaxation Oscillations (μ >> 1):",
    "text": "Relaxation Oscillations (μ &gt;&gt; 1):\nFor large μ, the system exhibits relaxation oscillations:\nMechanism: 1. Slow phase: x grows slowly along stable manifold 2. Jump: At x ≈ 1, rapid transition (fast manifold) 3. Slow phase: x decreases slowly along stable manifold 4. Jump: At x ≈ -1, rapid transition back 5. Repeat\nCharacteristics: - Distinct timescales (ε = 1/μ is small parameter) - Almost piecewise linear trajectory - Useful model for on-off systems (heart beats, neurons)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.VanDerPolOscillator.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDuffingOscillator : Another nonlinear oscillator (can be chaotic) Lorenz : 3D system that exhibits chaos NonlinearChainSystem : Multiple coupled oscillators"
  },
  {
    "objectID": "api/types.core.InputMatrix.html",
    "href": "api/types.core.InputMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.InputMatrix.html#examples",
    "href": "api/types.core.InputMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Simple integrator: ẋ = u\n&gt;&gt;&gt; B: InputMatrix = np.array([[1.0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Double integrator (position-velocity)\n&gt;&gt;&gt; # Only velocity is directly actuated\n&gt;&gt;&gt; B: InputMatrix = np.array([[0.0],   # position\n...                            [1.0]])  # velocity\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Quadrotor (multi-input)\n&gt;&gt;&gt; # 4 motors, 6 states (x, y, z, roll, pitch, yaw)\n&gt;&gt;&gt; B: InputMatrix = np.zeros((6, 4))\n&gt;&gt;&gt; B[2, :] = [1, 1, 1, 1]      # z affected by all motors\n&gt;&gt;&gt; B[3, :] = [1, -1, -1, 1]    # roll differential\n&gt;&gt;&gt; B[4, :] = [1, 1, -1, -1]    # pitch differential\n&gt;&gt;&gt; B[5, :] = [1, -1, 1, -1]    # yaw differential\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Linearized from Jacobian\n&gt;&gt;&gt; # B = ∂f/∂u|_(x_eq, u_eq)\n&gt;&gt;&gt; def dynamics(x, u):\n...     return np.array([x[1], -np.sin(x[0]) + u[0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Jacobian at equilibrium\n&gt;&gt;&gt; B_lin: InputMatrix = np.array([[0.0],    # ∂f₁/∂u = 0\n...                                [1.0]])   # ∂f₂/∂u = 1"
  },
  {
    "objectID": "api/types.linearization.DiscreteStochasticLinearization.html",
    "href": "api/types.linearization.DiscreteStochasticLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.DiscreteStochasticLinearization.html#examples",
    "href": "api/types.linearization.DiscreteStochasticLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Ad, Bd, Gd = discrete_stochastic.linearize(x_eq, u_eq)\n&gt;&gt;&gt; # Mean-square stability (drift only)\n&gt;&gt;&gt; ms_stable = np.all(np.abs(np.linalg.eigvals(Ad)) &lt; 1.0)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nThe reactor dynamics with additive noise:\ndC_A = (-r₁)·dt + σ_A·dW_A\ndC_B = (r₁ - r₂)·dt + σ_B·dW_B\ndT = (Q - α·(T - T_amb))·dt + σ_T·dW_T\nwhere: - r₁ = k₁·C_A·exp(-E₁/T): Reaction 1 rate (A → B) - r₂ = k₂·C_B·exp(-E₂/T): Reaction 2 rate (B → C) - σ_A, σ_B: Concentration noise intensities [mol/(L·√s)] - σ_T: Temperature noise intensity [K/√s] - W_A, W_B, W_T: Independent Wiener processes"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nNoise Sources:\n\nConcentration Noise (σ_A, σ_B):\n\nFeed composition variability\nMixing imperfections\nSampling uncertainty\nKinetic parameter fluctuations\n\nTemperature Noise (σ_T):\n\nHeat transfer variations\nAmbient temperature changes\nControl system imperfections\nMeasurement noise\n\n\nWhy Three Independent Sources? - Different physical mechanisms - Spatial separation (bulk vs jacket) - Independent control loops"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x = [C_A, C_B, T] Same as deterministic model but now stochastic: - C_A(t): Random process, not deterministic function - C_B(t): Random process - T(t): Random process\nEach trajectory is one realization from probability distribution.\nControl: u = [Q] - Q: Heating/cooling rate [K/s] - Same as deterministic (no noise in control)\nNoise: w = [w_A, w_B, w_T] - Three independent Wiener processes - Dimension: nw = 3 - Structure: Diagonal (uncorrelated)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#key-properties",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#key-properties",
    "title": "",
    "section": "Key Properties",
    "text": "Key Properties\nStochastic Nature: - Multiple runs give different trajectories - Statistics (mean, variance) evolve over time - Need ensemble analysis (Monte Carlo)\nMean Behavior: For additive noise: E[X(t)] follows deterministic dynamics approximately.\nVariance Growth: Variance increases with time due to noise accumulation: Var[C_A(t)] ≈ Var[C_A(0)] + σ_A²·t\nNon-Gaussian: Even with Gaussian noise, nonlinear dynamics create non-Gaussian distributions (except in linear approximation)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk1\nfloat\nPre-exponential factor for A→B reaction [1/s]\nrequired\n\n\nk2\nfloat\nPre-exponential factor for B→C reaction [1/s]\nrequired\n\n\nE1\nfloat\nActivation energy for reaction 1 [K]\nrequired\n\n\nE2\nfloat\nActivation energy for reaction 2 [K]\nrequired\n\n\nalpha\nfloat\nHeat transfer coefficient [1/s]\nrequired\n\n\nT_amb\nfloat\nAmbient temperature [K]\nrequired\n\n\nC_A0\nOptional[float]\nInitial concentration of A for equilibrium setup [mol/L]\nrequired\n\n\nT0\nOptional[float]\nInitial temperature for equilibrium setup [K]\nrequired\n\n\nsigma_A\nfloat\nConcentration noise for A [mol/(L·√s)] - Controls C_A fluctuations - Typical: 0.001-0.1 - Should be &lt;&lt; C_A0 for realistic noise\n0.01\n\n\nsigma_B\nfloat\nConcentration noise for B [mol/(L·√s)] - Controls C_B fluctuations - Typical: 0.001-0.1\n0.01\n\n\nsigma_T\nfloat\nTemperature noise [K/√s] - Controls T fluctuations - Typical: 0.1-5.0 - More critical than concentration noise (exponential effect via Arrhenius)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Robust Optimal Control: Design controllers accounting for uncertainty: - Stochastic MPC with chance constraints - Risk-sensitive control - Robust trajectory optimization\n2. State Estimation: Kalman filter for noisy measurements: - Extended Kalman Filter (EKF) - Unscented Kalman Filter (UKF) - Particle filter\n3. Risk Analysis: Assess probability of constraint violation: - Monte Carlo simulation - Rare event estimation - Safety verification\n4. Parameter Identification: Estimate parameters from noisy data: - Maximum likelihood - Bayesian inference - Sequential Monte Carlo\n5. Process Design: Design for robustness: - Worst-case analysis - Six Sigma methodology - Process capability studies"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nRecommended Methods: - Euler-Maruyama: Simple, robust, dt ~ 0.01-0.1 s - Milstein: Higher order, dt ~ 0.001-0.01 s - SRK: Even higher order, more cost\nMonte Carlo Ensemble: Run N = 100-10,000 simulations to characterize: - Mean trajectory: E[X(t)] - Variance: Var[X(t)] - Confidence bands: μ ± 2σ - Probability distributions\nNoise Structure: - Type: ADDITIVE (state-independent) - Dimension: nw = 3 (three Wiener processes) - Correlation: DIAGONAL (independent noise sources)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#comparison-with-deterministic",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#comparison-with-deterministic",
    "title": "",
    "section": "Comparison with Deterministic",
    "text": "Comparison with Deterministic\nDeterministic: - Single trajectory - Perfect prediction - Nominal design\nStochastic: - Ensemble of trajectories - Probabilistic prediction - Robust design\nWhen Stochastic is Necessary: - Real process has significant noise - Robust control needed - Risk assessment required - Parameter uncertainty significant"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nAdditive noise only (not multiplicative)\nConstant noise intensity (not state-dependent)\nIndependent noise sources (no correlation)\nNo jumps (only continuous Brownian paths)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nMultiplicative noise: g(x) = diag(σ_A·C_A, σ_B·C_B, σ_T·T)\nCorrelated noise: Full covariance matrix\nJump diffusion: Add Poisson jumps\nParameter uncertainty: Random walk parameters"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nContinuousBatchReactor : Deterministic version OrnsteinUhlenbeck : Mean-reverting stochastic process GeometricBrownianMotion : Multiplicative noise example"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_signal_to_noise_ratio\nCompute signal-to-noise ratio for each state.\n\n\ndefine_system\nDefine stochastic batch reactor dynamics.\n\n\nestimate_variance_growth\nEstimate variance growth for additive noise (approximate).\n\n\nget_noise_intensities\nGet current noise intensity parameters.\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ncompute_signal_to_noise_ratio\nsystems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.compute_signal_to_noise_ratio(\n    x,\n    t,\n)\nCompute signal-to-noise ratio for each state.\nSNR = |x| / (σ·√t)\nHigher SNR → noise less significant.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nCurrent state [C_A, C_B, T]\nrequired\n\n\nt\nfloat\nTime since start [s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nSNR for [C_A, C_B, T]\n\n\n\n\n\nNotes\nSNR &gt; 10: Noise negligible SNR ~ 1: Noise significant SNR &lt; 0.1: Noise dominates\n\n\nExamples\n&gt;&gt;&gt; reactor = ContinuousStochasticBatchReactor()\n&gt;&gt;&gt; x = np.array([0.5, 0.3, 360.0])\n&gt;&gt;&gt; snr = reactor.compute_signal_to_noise_ratio(x, t=10)\n&gt;&gt;&gt; print(f\"SNR: C_A={snr[0]:.1f}, C_B={snr[1]:.1f}, T={snr[2]:.1f}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.define_system(\n    k1_val=0.5,\n    k2_val=0.3,\n    E1_val=1000.0,\n    E2_val=1500.0,\n    alpha_val=0.1,\n    T_amb_val=300.0,\n    sigma_A=0.01,\n    sigma_B=0.01,\n    sigma_T=1.0,\n    C_A0=None,\n    T0=None,\n)\nDefine stochastic batch reactor dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk1_val\nfloat\nPre-exponential factor for A→B reaction [1/s]\n0.5\n\n\nk2_val\nfloat\nPre-exponential factor for B→C reaction [1/s]\n0.3\n\n\nE1_val\nfloat\nActivation energy for reaction 1 [K]\n1000.0\n\n\nE2_val\nfloat\nActivation energy for reaction 2 [K]\n1500.0\n\n\nalpha_val\nfloat\nHeat transfer coefficient [1/s]\n0.1\n\n\nT_amb_val\nfloat\nAmbient temperature [K]\n300.0\n\n\nsigma_A\nfloat\nConcentration noise intensity for A [mol/(L·√s)] - Typical: 0.001-0.1 mol/(L·√s) - Should be &lt;&lt; C_A0 for realistic noise - Rule of thumb: σ_A ~ 0.01·C_A0\n0.01\n\n\nsigma_B\nfloat\nConcentration noise intensity for B [mol/(L·√s)] - Same magnitude as σ_A typically - Represents mixing and kinetic uncertainty\n0.01\n\n\nsigma_T\nfloat\nTemperature noise intensity [K/√s] - Typical: 0.1-5.0 K/√s - More critical than concentration noise - Affects reaction rates exponentially - Rule of thumb: σ_T ~ 1 K/√s\n1.0\n\n\nC_A0\nOptional[float]\nInitial conditions for equilibrium setup\nNone\n\n\nT0\nOptional[float]\nInitial conditions for equilibrium setup\nNone\n\n\n\n\n\nNotes\nDrift (Deterministic Part): Identical to deterministic reactor: f(x, u) = [-r₁, r₁ - r₂, Q - α·(T - T_amb)]ᵀ\nDiffusion (Stochastic Part): Diagonal matrix (additive, independent noise): g(x, u) = diag(σ_A, σ_B, σ_T)\nThis gives three independent Wiener processes driving concentration and temperature fluctuations.\nNoise Intensity Guidelines:\nFor 1% relative noise at C_A0 = 1.0 mol/L over 1 second: σ_A ~ 0.01 mol/(L·√s)\nFor 1 K standard deviation over 1 second: σ_T ~ 1.0 K/√s\nPhysical Justification:\nAdditive noise models: - External disturbances (feed, ambient) - Measurement errors (sensors) - Control system imperfections - Unmodeled dynamics (lumped effects)\nAlternative: Multiplicative noise would be: g(x) = diag(σ_A·C_A, σ_B·C_B, σ_T·T)\nThis models relative errors scaling with state magnitude.\nValidation:\nCheck noise levels are reasonable: 1. Run deterministic + stochastic simulations 2. Compare final states 3. Coefficient of variation should be 5-20%: CV = std(C_B_final) / mean(C_B_final) 4. If CV &gt; 30%: Noise too large 5. If CV &lt; 1%: Noise negligible\n\n\n\nestimate_variance_growth\nsystems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.estimate_variance_growth(\n    t,\n)\nEstimate variance growth for additive noise (approximate).\nFor additive noise with independent sources: Var[X(t)] ≈ Var[X(0)] + diag(σ²)·t\nThis is exact for linear systems, approximate for nonlinear.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nTime [s]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nEstimated variance [Var(C_A), Var(C_B), Var(T)]\n\n\n\n\n\nNotes\nThis is a rough estimate. For accurate statistics, run Monte Carlo.\n\n\nExamples\n&gt;&gt;&gt; reactor = ContinuousStochasticBatchReactor(\n...     sigma_A=0.01, sigma_B=0.01, sigma_T=1.0\n... )\n&gt;&gt;&gt; var_100s = reactor.estimate_variance_growth(t=100)\n&gt;&gt;&gt; std_100s = np.sqrt(var_100s)\n&gt;&gt;&gt; print(f\"Estimated std after 100s: C_A={std_100s[0]:.3f}, \"\n...       f\"C_B={std_100s[1]:.3f}, T={std_100s[2]:.3f}\")\n\n\n\nget_noise_intensities\nsystems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.get_noise_intensities(\n)\nGet current noise intensity parameters.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with keys ‘sigma_A’, ‘sigma_B’, ‘sigma_T’\n\n\n\n\n\nExamples\n&gt;&gt;&gt; reactor = ContinuousStochasticBatchReactor(\n...     sigma_A=0.01, sigma_B=0.01, sigma_T=1.0\n... )\n&gt;&gt;&gt; noise = reactor.get_noise_intensities()\n&gt;&gt;&gt; print(f\"Temperature noise: {noise['sigma_T']} K/√s\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor.setup_equilibria(\n)\nSet up equilibrium points.\nNote: For stochastic systems, “equilibrium” refers to deterministic part only. Actual trajectories fluctuate around this point."
  },
  {
    "objectID": "api/types.trajectories.ControlSequence.html",
    "href": "api/types.trajectories.ControlSequence.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.ControlSequence.html#examples",
    "href": "api/types.trajectories.ControlSequence.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Zero control\n&gt;&gt;&gt; u_seq: ControlSequence = np.zeros((100, 1))\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Sinusoidal control\n&gt;&gt;&gt; t = np.linspace(0, 10, 100)\n&gt;&gt;&gt; u_seq: ControlSequence = np.sin(t).reshape(-1, 1)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # MPC generates control sequence\n&gt;&gt;&gt; u_optimal: ControlSequence = mpc.solve(x0, horizon=20)\n&gt;&gt;&gt; print(u_optimal.shape)  # (20, nu)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Feedback control sequence (computed online)\n&gt;&gt;&gt; trajectory = [x0]\n&gt;&gt;&gt; controls = []\n&gt;&gt;&gt; x = x0\n&gt;&gt;&gt; for k in range(100):\n...     u = controller(x)  # Feedback policy\n...     controls.append(u)\n...     x = system.step(x, u)\n...     trajectory.append(x)\n&gt;&gt;&gt; u_seq: ControlSequence = np.array(controls)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Batched control for multiple systems\n&gt;&gt;&gt; u_batch: ControlSequence = np.random.randn(100, 50, 2)  # 50 systems"
  },
  {
    "objectID": "api/types.learning.TrainingResult.html",
    "href": "api/types.learning.TrainingResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.learning.TrainingResult.html#fields",
    "href": "api/types.learning.TrainingResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nfinal_loss : float Final training loss best_loss : float Best loss achieved during training loss_history : List[float] Loss value per epoch validation_loss : Optional[float] Validation set loss (if validation data provided) training_time : float Total training time in seconds epochs_trained : int Number of epochs completed early_stopped : bool Whether early stopping was triggered model_state : Optional[Dict] Saved model parameters/weights"
  },
  {
    "objectID": "api/types.learning.TrainingResult.html#examples",
    "href": "api/types.learning.TrainingResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Train neural ODE dynamics model\n&gt;&gt;&gt; result: TrainingResult = train_neural_ode(\n...     model, data, epochs=100, learning_rate=1e-3\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"Training complete:\")\n&gt;&gt;&gt; print(f\"  Final loss: {result['final_loss']:.3e}\")\n&gt;&gt;&gt; print(f\"  Best loss: {result['best_loss']:.3e}\")\n&gt;&gt;&gt; print(f\"  Time: {result['training_time']:.1f}s\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot learning curve\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(result['loss_history'])\n&gt;&gt;&gt; plt.xlabel('Epoch')\n&gt;&gt;&gt; plt.ylabel('Loss')\n&gt;&gt;&gt; plt.yscale('log')\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['early_stopped']:\n...     print(\"Training stopped early (convergence reached)\")"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nState-space form: dx = v·dt dv = u·dt + σ·dW\nMatrix form: dX = (A·X + B·u)·dt + G·dW\nwhere: X = [x, v]ᵀ: Position and velocity A = [0 1]: Drift matrix (double integrator) [0 0] B = [0]: Control input matrix [1] G = [0]: Noise input matrix (velocity noise only) [σ] u: Control force W(t): Standard Wiener process"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nNewton’s Second Law with Random Forces:\nFor unit mass: F = ma a = u + w(t)\nwhere u is applied force and w(t) is random disturbance.\nState Variables: - x: Position [m] (unbounded) - v: Velocity [m/s] (unbounded)\nControl: - u: Applied force [m/s²] (acceleration)\nNoise: - σ: Force noise intensity [m/(s²·√s)] - Enters velocity equation (Newton’s law)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nLinearity: Linear drift (A·X + B·u) enables exact solution.\nAdditive Noise: Constant diffusion G (state-independent).\nDouble Integration: Control u → velocity v → position x (two integrations).\nMarginally Stable: Eigenvalues: {0, 0} (poles at origin). - Not asymptotically stable - Requires feedback for regulation\nNon-Stationary: Variance grows unboundedly without control.\nGaussian: Linear dynamics preserve Gaussianity."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nExact Solution (u constant):\nPosition: x(t) = x₀ + v₀·t + (1/2)·u·t² + ∫₀ᵗ σ·(t-s)·dW(s)\nVelocity: v(t) = v₀ + u·t + σ·W(t)\nMoments: Mean: E[x(t)] = x₀ + v₀·t + (1/2)·u·t² E[v(t)] = v₀ + u·t\nVariance: Var[x(t)] = σ²·t³/3 Var[v(t)] = σ²·t\nCovariance: Cov[x(t), v(t)] = σ²·t²/2\nDistribution: [x(t)] [E[x]] σ²·[t³/3 t²/2] [v(t)] ~ N([E[v]], [t²/2 t ])\nVariance Growth: - Position: O(t³) - very fast! - Velocity: O(t) - moderate - Correlation: O(t²)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nNoise Intensity σ: - Units: [m/(s²·√s)] = [m/s^(3/2)] - Controls disturbance force magnitude - Typical: 0.01-1.0 depending on application\nRMS Values: After time t: - Position RMS: σ·t^(3/2)/√3 - Velocity RMS: σ·√t\nWhy Position Variance Grows Faster: Noise on velocity integrates to position: - Small velocity errors accumulate - Integration amplifies uncertainty - Requires active control to bound"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X = [x, v] ∈ ℝ² - Unbounded (can take any real values) - No equilibrium without control - Non-stationary (variance grows)\nControl: u ∈ ℝ - Force/acceleration input - Can be state feedback: u = u(x, v)\nNoise: w ∈ ℝ - Single Wiener process - Enters velocity equation only - G = [0, σ]ᵀ"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nNoise intensity [m/(s²·√s)] - Controls disturbance magnitude - Typical: 0.01-1.0 - Larger σ → more uncertainty\n0.1\n\n\nm\nfloat\nMass [kg] (optional, typically normalized to 1) - Can include for dimensional analysis - Usually set to 1 (unit mass)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: LINEAR\nNoise Type: ADDITIVE (constant)\nSDE Type: Itô\nNoise Dimension: nw = 1\nStationary: No (open-loop)\nGaussian: Yes (linear dynamics)\nControllable: Yes (completely)\nObservable: Depends on measurement"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. LQG Control: Canonical benchmark for Linear-Quadratic-Gaussian: - Separation principle demonstration - Kalman filter + LQR combination - Optimal for quadratic cost\n2. Kalman Filtering: Test state estimation algorithms: - Position measurement → estimate velocity - Optimal for Gaussian noise - Benchmark filter performance\n3. Robotics: - UAV position control (per axis) - Robot manipulator (per joint) - Mobile robot navigation\n4. Aerospace: - Spacecraft position control - Missile guidance - Aircraft lateral control\n5. Economics: - Capital accumulation models - Inventory control - Policy design under uncertainty"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nExact Discretization (Recommended): Use closed-form discrete-time model: X[k+1] = Φ·X[k] + Γ·u + w_d\nNo discretization error, preserves all properties.\nSDE Integration: - Euler-Maruyama: Simple, O(√Δt) strong convergence - Milstein: Same as Euler for additive noise - Framework solvers: All work well (linear, non-stiff)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#lqg-control-design",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#lqg-control-design",
    "title": "",
    "section": "LQG Control Design",
    "text": "LQG Control Design\nCost Function: J = E[∫ (Xᵀ·Q·X + u·R·u)·dt]\nOptimal Control: u* = -K·X̂\nwhere K from LQR, X̂ from Kalman filter.\nSeparation Principle: Design independently: - LQR gain K (assume perfect state) - Kalman gain L (estimate state) - Combine: u = -K·X̂"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#comparison-with-deterministic",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#comparison-with-deterministic",
    "title": "",
    "section": "Comparison with Deterministic",
    "text": "Comparison with Deterministic\nDeterministic: - ẍ = u (no noise) - Perfect control possible - Exact regulation\nStochastic: - ẍ = u + w (noise) - Minimum variance limit - Probabilistic regulation\nCritical Difference: Cannot eliminate noise effect - fundamental limit on achievable performance."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nNo damping (purely integrating)\nLinear (no nonlinear effects)\nAdditive noise only\nSingle control input\nNo constraints"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nAdd damping: -b·v term\nNonlinear: u·v coupling\nMultiplicative noise\nConstraints: |x| ≤ x_max\nHigher dimensions: 2D, 3D"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#examples",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nBasic double integrator:\n&gt;&gt;&gt; # Standard configuration\n&gt;&gt;&gt; system = StochasticDoubleIntegrator(sigma=0.1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check properties\n&gt;&gt;&gt; print(f\"Linear system: {system.is_linear()}\")  # True\n&gt;&gt;&gt; print(f\"Additive noise: {system.is_additive_noise()}\")  # True\n&gt;&gt;&gt; print(f\"State dimension: {system.nx}\")  # 2\nEvaluate dynamics:\n&gt;&gt;&gt; # At rest with unit force\n&gt;&gt;&gt; x = np.array([0.0, 0.0])\n&gt;&gt;&gt; u = np.array([1.0])\n&gt;&gt;&gt; drift = system.drift(x, u)  # [0, 1]\n&gt;&gt;&gt; diffusion = system.diffusion(x, u)  # [[0], [0.1]]\nDifferent noise levels:\n&gt;&gt;&gt; # Low noise (precise environment)\n&gt;&gt;&gt; low_noise = StochasticDoubleIntegrator(sigma=0.01)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # High noise (harsh environment)\n&gt;&gt;&gt; high_noise = StochasticDoubleIntegrator(sigma=1.0)\nSimulation:\n&gt;&gt;&gt; # Free motion with noise (u=0)\n&gt;&gt;&gt; x0 = np.array([1.0, 0.0])  # Start at x=1, v=0\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,  # Zero control\n...     t_span=(0, 10),\n...     method='euler-maruyama',\n...     dt=0.01\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Variance should grow\n&gt;&gt;&gt; positions = result['y'][0, :]\n&gt;&gt;&gt; velocities = result['y'][1, :]\n&gt;&gt;&gt; print(f\"Position variance: {np.var(positions):.3f}\")"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDoubleIntegrator : Deterministic version OrnsteinUhlenbeck : With damping (stable)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.StochasticDoubleIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine stochastic double integrator dynamics.\n\n\nget_position_std\nGet analytical position standard deviation at time t.\n\n\nget_variance_at_time\nGet analytical variance matrix at time t (open-loop, u=0, X₀=0).\n\n\nget_velocity_std\nGet analytical velocity standard deviation at time t.\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.StochasticDoubleIntegrator.define_system(\n    sigma=0.1,\n    m=1.0,\n)\nDefine stochastic double integrator dynamics.\nSets up linear SDE: dx = v·dt dv = u·dt + σ·dW\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nNoise intensity [m/(s²·√s)] - Controls disturbance force magnitude - Typical: 0.01-1.0 - Larger σ → more uncertainty\n0.1\n\n\nm\nfloat\nMass [kg] (optional, typically 1) - Usually normalized to unit mass - Can include for dimensional analysis\n1.0\n\n\n\n\n\nNotes\nSystem Structure:\nLinear drift: A = [0 1] (standard double integrator) [0 0]\nControl matrix: B = [0] (force affects acceleration) [1/m]\nNoise matrix: G = [0] (noise on velocity only) [σ]\nEigenvalues: λ = {0, 0} - double pole at origin (marginally stable).\nControllability: rank[B, A·B] = 2 - completely controllable.\nObservability: If measuring x: rank[C; C·A] = 2 - observable If measuring v: NOT observable (x decoupled)\nNoise Placement: Physically correct: Noise on velocity (forces cause accelerations).\nAlternative (wrong): G = [σ, 0]ᵀ would be position noise, violating Newton’s law.\nVariance Growth: Without control: - Var[x(t)] = σ²·t³/3 (cubic!) - Var[v(t)] = σ²·t (linear)\nRequires feedback to stabilize.\nParameter Scaling:\nFor spacecraft (SI units): - Position: meters - Velocity: m/s - Force: Newtons (= kg·m/s² = m/s² for m=1) - σ: m/s^(3/2)\nFor normalized units: - Set m = 1 (dimensionless) - Position, velocity in natural units - Force = acceleration\n\n\nExamples\n&gt;&gt;&gt; # Standard unit mass system\n&gt;&gt;&gt; system = StochasticDoubleIntegrator(sigma=0.1, m=1.0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Spacecraft (1000 kg)\n&gt;&gt;&gt; spacecraft = StochasticDoubleIntegrator(\n...     sigma=0.01,  # Small disturbances\n...     m=1000.0\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # High noise environment\n&gt;&gt;&gt; harsh = StochasticDoubleIntegrator(sigma=1.0, m=1.0)\n\n\n\nget_position_std\nsystems.builtin.stochastic.continuous.StochasticDoubleIntegrator.get_position_std(\n    t,\n)\nGet analytical position standard deviation at time t.\nσ_x(t) = σ·t^(3/2)/√3\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nTime [s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nPosition standard deviation\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = StochasticDoubleIntegrator(sigma=0.1)\n&gt;&gt;&gt; std_10s = system.get_position_std(t=10.0)\n&gt;&gt;&gt; print(f\"Position std after 10s: {std_10s:.3f} m\")\n\n\n\nget_variance_at_time\nsystems.builtin.stochastic.continuous.StochasticDoubleIntegrator.get_variance_at_time(\n    t,\n)\nGet analytical variance matrix at time t (open-loop, u=0, X₀=0).\nReturns 2×2 covariance matrix.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nTime [s]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nCovariance matrix [[Var(x), Cov(x,v)], [Cov(x,v), Var(v)]]\n\n\n\n\n\nNotes\nFor open-loop (u=0) starting from origin: Var[x] = σ²·t³/3 Var[v] = σ²·t Cov[x,v] = σ²·t²/2\n\n\nExamples\n&gt;&gt;&gt; system = StochasticDoubleIntegrator(sigma=0.1)\n&gt;&gt;&gt; Sigma = system.get_variance_at_time(t=10.0)\n&gt;&gt;&gt; print(f\"Position variance: {Sigma[0,0]:.2f}\")\n&gt;&gt;&gt; print(f\"Velocity variance: {Sigma[1,1]:.2f}\")\n\n\n\nget_velocity_std\nsystems.builtin.stochastic.continuous.StochasticDoubleIntegrator.get_velocity_std(\n    t,\n)\nGet analytical velocity standard deviation at time t.\nσ_v(t) = σ·√t\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nfloat\nTime [s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nVelocity standard deviation\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = StochasticDoubleIntegrator(sigma=0.1)\n&gt;&gt;&gt; std_10s = system.get_velocity_std(t=10.0)\n&gt;&gt;&gt; print(f\"Velocity std after 10s: {std_10s:.3f} m/s\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.continuous.StochasticDoubleIntegrator.setup_equilibria(\n)\nSet up equilibrium points.\nFor open-loop double integrator, only equilibrium is origin with zero control. System is marginally stable (not asymptotically)."
  },
  {
    "objectID": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html",
    "href": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#parameters",
    "href": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nContinuous-time system to integrate (controlled or autonomous)\nrequired\n\n\ndt\nOptional[ScalarLike]\nTime step size\nNone\n\n\nstep_mode\nStepMode\nFIXED or ADAPTIVE stepping mode\nStepMode.ADAPTIVE\n\n\nbackend\nstr\nMust be ‘torch’ for this integrator\n'torch'\n\n\nmethod\nstr\nSolver method. Options: ‘dopri5’, ‘dopri8’, ‘adams’, ‘bosh3’, ‘euler’, ‘midpoint’, ‘rk4’, ‘explicit_adams’, ‘implicit_adams’. Default: ‘dopri5’\n'dopri5'\n\n\nadjoint\nbool\nUse adjoint method for memory-efficient backpropagation. Default: False Note: Adjoint method requires the ODE function to be an nn.Module. Only use adjoint=True for Neural ODE applications where the system is a neural network. For regular dynamical systems, use adjoint=False.\nFalse\n\n\n**options\n\nAdditional options including rtol, atol, max_steps\n{}"
  },
  {
    "objectID": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#available-methods",
    "href": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#available-methods",
    "title": "",
    "section": "Available Methods",
    "text": "Available Methods\nAdaptive (Recommended): - dopri5: Dormand-Prince 5(4) - general purpose [DEFAULT] - dopri8: Dormand-Prince 8 - high accuracy - bosh3: Bogacki-Shampine 3(2) - lower accuracy - adaptive_heun: Adaptive Heun method - fehlberg2: Fehlberg method\nFixed-Step: - euler: Forward Euler (1st order) - midpoint: Midpoint method (2nd order) - rk4: Classic Runge-Kutta 4 (4th order)\nMultistep: - explicit_adams: Explicit Adams method - implicit_adams: Implicit Adams method - fixed_adams: Fixed-step Adams method"
  },
  {
    "objectID": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#examples",
    "href": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; from torchdiffeq_integrator import TorchDiffEqIntegrator\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Regular controlled dynamical system (adjoint=False)\n&gt;&gt;&gt; integrator = TorchDiffEqIntegrator(\n...     system,\n...     dt=0.01,\n...     backend='torch',\n...     method='dopri5',\n...     adjoint=False  # Default for regular systems\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; x0 = torch.tensor([1.0, 0.0])\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0,\n...     lambda t, x: torch.zeros(1),\n...     (0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Success: {result['success']}\")\n&gt;&gt;&gt; print(f\"Steps: {result['nsteps']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = TorchDiffEqIntegrator(autonomous_system, backend='torch')\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=torch.tensor([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Neural ODE (adjoint=True for memory efficiency)\n&gt;&gt;&gt; class NeuralODE(torch.nn.Module):\n...     def __init__(self):\n...         super().__init__()\n...         self.net = torch.nn.Sequential(\n...             torch.nn.Linear(2, 50),\n...             torch.nn.Tanh(),\n...             torch.nn.Linear(50, 2)\n...         )\n...     def forward(self, t, x):\n...         return self.net(x)\n&gt;&gt;&gt;\n&gt;&gt;&gt; neural_ode = NeuralODE()\n&gt;&gt;&gt; integrator_neural = TorchDiffEqIntegrator(\n...     neural_ode,\n...     backend='torch',\n...     method='dopri5',\n...     adjoint=True  # Memory-efficient for neural networks\n... )"
  },
  {
    "objectID": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#attributes",
    "href": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nname\nReturn the name of the integrator."
  },
  {
    "objectID": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#methods",
    "href": "api/systems.base.numerical_integration.TorchDiffEqIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndisable_adjoint\nDisable adjoint method (use standard backpropagation).\n\n\nenable_adjoint\nEnable adjoint method for memory-efficient backpropagation.\n\n\nintegrate\nIntegrate over time interval with control policy.\n\n\nintegrate_with_gradient\nIntegrate and compute gradients w.r.t. initial conditions.\n\n\nstep\nTake one integration step: x(t) → x(t + dt).\n\n\nto_device\nMove system parameters to specified device (if applicable).\n\n\n\n\ndisable_adjoint\nsystems.base.numerical_integration.TorchDiffEqIntegrator.disable_adjoint()\nDisable adjoint method (use standard backpropagation).\n\nExamples\n&gt;&gt;&gt; integrator.disable_adjoint()\n&gt;&gt;&gt; assert integrator.use_adjoint == False\n\n\n\nenable_adjoint\nsystems.base.numerical_integration.TorchDiffEqIntegrator.enable_adjoint()\nEnable adjoint method for memory-efficient backpropagation.\n\nNotes\nAdjoint method trades computation for memory - useful for Neural ODEs with many steps. Requires system to be an nn.Module.\n\n\nExamples\n&gt;&gt;&gt; integrator.enable_adjoint()\n&gt;&gt;&gt; assert integrator.use_adjoint == True\n\n\n\nintegrate\nsystems.base.numerical_integration.TorchDiffEqIntegrator.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n)\nIntegrate over time interval with control policy.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable[[ScalarLike, StateVector], Optional[ControlVector]]\nControl policy: (t, x) → u (or None for autonomous systems)\nrequired\n\n\nt_span\nTimeSpan\nIntegration interval (t_start, t_end)\nrequired\n\n\nt_eval\nOptional[TimePoints]\nSpecific times at which to store solution\nNone\n\n\ndense_output\nbool\nIf True, return dense interpolated solution (not supported by torchdiffeq)\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nTypedDict containing: - t: Time points (T,) - x: State trajectory (T, nx) - success: Whether integration succeeded - message: Status message - nfev: Number of function evaluations - nsteps: Number of steps taken - integration_time: Computation time (seconds) - solver: Integrator name\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Controlled system\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=torch.tensor([1.0, 0.0]),\n...     u_func=lambda t, x: torch.tensor([0.5]),\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Success: {result['success']}\")\n&gt;&gt;&gt; print(f\"Final state: {result['x'][-1]}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=torch.tensor([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Evaluate at specific times\n&gt;&gt;&gt; t_eval = torch.linspace(0, 10, 1001)\n&gt;&gt;&gt; result = integrator.integrate(x0, u_func, (0, 10), t_eval=t_eval)\n&gt;&gt;&gt; assert result[\"t\"].shape == (1001,)\n\n\n\nintegrate_with_gradient\nsystems.base.numerical_integration.TorchDiffEqIntegrator.integrate_with_gradient(\n    x0,\n    u_func,\n    t_span,\n    loss_fn,\n    t_eval=None,\n)\nIntegrate and compute gradients w.r.t. initial conditions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (requires_grad=True for gradients)\nrequired\n\n\nu_func\nCallable[[ScalarLike, StateVector], Optional[ControlVector]]\nControl policy (or None for autonomous)\nrequired\n\n\nt_span\nTimeSpan\nTime span (t_start, t_end)\nrequired\n\n\nloss_fn\nCallable[[IntegrationResult], torch.Tensor]\nLoss function taking IntegrationResult\nrequired\n\n\nt_eval\nOptional[TimePoints]\nEvaluation times\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(loss_value: float, gradient_wrt_x0: StateVector)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Define loss (e.g., final state error)\n&gt;&gt;&gt; def loss_fn(result):\n...     x_final = result[\"x\"][-1]\n...     x_target = torch.tensor([1.0, 0.0])\n...     return torch.sum((x_final - x_target)**2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute loss and gradient\n&gt;&gt;&gt; x0 = torch.tensor([0.0, 0.0], requires_grad=True)\n&gt;&gt;&gt; loss, grad = integrator.integrate_with_gradient(\n...     x0=x0,\n...     u_func=lambda t, x: torch.zeros(1),\n...     t_span=(0.0, 10.0),\n...     loss_fn=loss_fn\n... )\n&gt;&gt;&gt; print(f\"Loss: {loss:.4f}\")\n&gt;&gt;&gt; print(f\"Gradient: {grad}\")\n\n\n\nstep\nsystems.base.numerical_integration.TorchDiffEqIntegrator.step(\n    x,\n    u=None,\n    dt=None,\n)\nTake one integration step: x(t) → x(t + dt).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,) or (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input (nu,) or (batch, nu), or None for autonomous systems\nNone\n\n\ndt\nOptional[ScalarLike]\nStep size (uses self.dt if None)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x(t + dt)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Controlled system\n&gt;&gt;&gt; x_next = integrator.step(\n...     x=torch.tensor([1.0, 0.0]),\n...     u=torch.tensor([0.5])\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; x_next = integrator.step(\n...     x=torch.tensor([1.0, 0.0]),\n...     u=None\n... )\n\n\n\nto_device\nsystems.base.numerical_integration.TorchDiffEqIntegrator.to_device(device)\nMove system parameters to specified device (if applicable).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndevice\nstr\nDevice identifier (‘cpu’, ‘cuda’, ‘cuda:0’, etc.)\nrequired\n\n\n\n\n\nNotes\nThis only works if the system is a PyTorch nn.Module. For regular dynamical systems, this is a no-op.\n\n\nExamples\n&gt;&gt;&gt; # For Neural ODE systems\n&gt;&gt;&gt; integrator.to_device('cuda:0')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # For regular systems (no effect)\n&gt;&gt;&gt; integrator.to_device('cpu')"
  },
  {
    "objectID": "api/types.backends.ConvergenceType.html",
    "href": "api/types.backends.ConvergenceType.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\ntypes.backends.ConvergenceType\ntypes.backends.ConvergenceType()\nSDE convergence type for numerical integration.\nTypes: - ‘strong’: Pathwise/strong convergence * Individual sample paths converge * E[|X_numerical - X_true|] → 0 * Needed for: Filtering, control synthesis, single trajectory accuracy * More expensive to achieve\n\n‘weak’: Weak convergence\nDistributions/moments converge\nE[φ(X_numerical)] → E[φ(X_true)] for test functions φ\nNeeded for: Monte Carlo, statistics, ensemble behavior\nEasier to achieve (higher order possible)\n\nOrder Comparison: - Euler-Maruyama: Strong order 0.5, weak order 1.0 - Milstein: Strong order 1.0 - SRA1: Weak order 2.0"
  },
  {
    "objectID": "api/types.backends.SDEIntegratorConfig.html",
    "href": "api/types.backends.SDEIntegratorConfig.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.SDEIntegratorConfig.html#attributes",
    "href": "api/types.backends.SDEIntegratorConfig.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmethod\nSDEIntegrationMethod\nSDE integration algorithm\n\n\ndt\nfloat\nTime step (fixed-step methods)\n\n\nconvergence_type\nConvergenceType\nStrong (pathwise) or weak (distributional)\n\n\nbackend\nBackend\nComputational backend\n\n\nseed\nOptional[int]\nRandom seed for reproducibility\n\n\nadaptive\nbool\nUse adaptive stepping (if available)"
  },
  {
    "objectID": "api/types.backends.SDEIntegratorConfig.html#examples",
    "href": "api/types.backends.SDEIntegratorConfig.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Basic configuration\n&gt;&gt;&gt; config: SDEIntegratorConfig = {\n...     'method': 'euler',\n...     'dt': 0.01,\n...     'convergence_type': 'strong',\n...     'backend': 'numpy'\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # High-accuracy additive noise\n&gt;&gt;&gt; config_accurate: SDEIntegratorConfig = {\n...     'method': 'SRIW1',\n...     'dt': 0.001,\n...     'convergence_type': 'strong',\n...     'backend': 'numpy',\n...     'seed': 42\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Monte Carlo simulation\n&gt;&gt;&gt; config_mc: SDEIntegratorConfig = {\n...     'method': 'SEA',\n...     'dt': 0.01,\n...     'convergence_type': 'weak',\n...     'backend': 'jax',\n... }"
  },
  {
    "objectID": "api/types.core.GainMatrix.html",
    "href": "api/types.core.GainMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.GainMatrix.html#examples",
    "href": "api/types.core.GainMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # LQR feedback gain\n&gt;&gt;&gt; K_lqr: GainMatrix = np.array([[1.0, 0.5]])  # (nu=1, nx=2)\n&gt;&gt;&gt; u = -K_lqr @ x\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Kalman gain\n&gt;&gt;&gt; K_kalman: GainMatrix = np.array([[0.1], [0.2]])  # (nx=2, ny=1)\n&gt;&gt;&gt; innovation = y - C @ x_hat\n&gt;&gt;&gt; x_hat_update = x_hat + K_kalman @ innovation"
  },
  {
    "objectID": "api/types.trajectories.TimeSpan.html",
    "href": "api/types.trajectories.TimeSpan.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.TimeSpan.html#examples",
    "href": "api/types.trajectories.TimeSpan.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Standard interval [0, T]\n&gt;&gt;&gt; t_span: TimeSpan = (0.0, 10.0)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Non-zero start time\n&gt;&gt;&gt; t_span: TimeSpan = (5.0, 15.0)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Short interval for testing\n&gt;&gt;&gt; t_span: TimeSpan = (0.0, 0.1)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Use in integration\n&gt;&gt;&gt; from scipy.integrate import solve_ivp\n&gt;&gt;&gt; result = solve_ivp(\n...     fun=dynamics,\n...     t_span=t_span,\n...     y0=x0,\n...     method='RK45'\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Extract t_eval from t_span\n&gt;&gt;&gt; t_start, t_end = t_span\n&gt;&gt;&gt; t_eval: TimePoints = np.linspace(t_start, t_end, 1000)"
  },
  {
    "objectID": "api/types.control_classical.ObservabilityInfo.html",
    "href": "api/types.control_classical.ObservabilityInfo.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.ObservabilityInfo.html#fields",
    "href": "api/types.control_classical.ObservabilityInfo.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nobservability_matrix : ObservabilityMatrix O = [C; CA; CA²; …; CAⁿ⁻¹] of shape (nx*ny, nx) rank : int Rank of observability matrix is_observable : bool True if rank == nx (full rank) unobservable_modes : Optional[np.ndarray] Eigenvalues of unobservable subsystem (if any)"
  },
  {
    "objectID": "api/types.control_classical.ObservabilityInfo.html#examples",
    "href": "api/types.control_classical.ObservabilityInfo.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position only\n&gt;&gt;&gt;\n&gt;&gt;&gt; info: ObservabilityInfo = analyze_observability(A, C)\n&gt;&gt;&gt; print(info['is_observable'])  # True\n&gt;&gt;&gt; print(info['rank'])  # 2\n&gt;&gt;&gt; print(info['observability_matrix'].shape)  # (2, 2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Unobservable system\n&gt;&gt;&gt; C_bad = np.array([[1, 1]])  # Can't distinguish states\n&gt;&gt;&gt; A_diag = np.array([[1, 0], [0, 2]])\n&gt;&gt;&gt; info: ObservabilityInfo = analyze_observability(A_diag, C_bad)\n&gt;&gt;&gt; print(info['is_observable'])  # False"
  },
  {
    "objectID": "api/types.control_classical.StabilityInfo.html",
    "href": "api/types.control_classical.StabilityInfo.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.StabilityInfo.html#fields",
    "href": "api/types.control_classical.StabilityInfo.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\neigenvalues : np.ndarray Eigenvalues of system matrix (complex) magnitudes : np.ndarray Absolute values |λ| of eigenvalues max_magnitude : float Maximum |λ| (spectral radius) spectral_radius : float Same as max_magnitude (discrete systems) is_stable : bool True if system is asymptotically stable is_marginally_stable : bool True if max|λ| ≈ 1 or Re(λ) ≈ 0 is_unstable : bool True if any |λ| &gt; 1 or Re(λ) &gt; 0"
  },
  {
    "objectID": "api/types.control_classical.StabilityInfo.html#examples",
    "href": "api/types.control_classical.StabilityInfo.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Continuous system\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; stability: StabilityInfo = analyze_stability(A, system_type='continuous')\n&gt;&gt;&gt; print(stability['is_stable'])  # True\n&gt;&gt;&gt; print(stability['eigenvalues'])  # [-1, -2]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discrete system\n&gt;&gt;&gt; Ad = np.array([[0.9, 0.1], [0, 0.8]])\n&gt;&gt;&gt; stability: StabilityInfo = analyze_stability(Ad, system_type='discrete')\n&gt;&gt;&gt; print(stability['is_stable'])  # True (both |λ| &lt; 1)\n&gt;&gt;&gt; print(stability['spectral_radius'])  # 0.9\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Unstable system\n&gt;&gt;&gt; A_unstable = np.array([[1, 1], [0, 1]])\n&gt;&gt;&gt; stability: StabilityInfo = analyze_stability(A_unstable, system_type='continuous')\n&gt;&gt;&gt; print(stability['is_unstable'])  # True"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_available_methods.html",
    "href": "api/systems.base.numerical_integration.get_available_methods.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_available_methods.html#parameters",
    "href": "api/systems.base.numerical_integration.get_available_methods.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\nbackend : Backend, default='numpy'\n    Backend to query: 'numpy', 'torch', or 'jax'\nmethod_type : str, default='all'\n    Filter by method type:\n    - 'all': All methods (default)\n    - 'deterministic': Only ODE methods\n    - 'stochastic': Only SDE methods\n    - 'fixed_step': Only fixed-step methods (both ODE and SDE)\n    - 'adaptive': Only adaptive methods (both ODE and SDE)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_available_methods.html#returns",
    "href": "api/systems.base.numerical_integration.get_available_methods.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\ndict\n    Dictionary with method categories as keys:\n\n    - **deterministic_fixed_step** : list of str\n        Fixed-step ODE methods (euler, rk4, heun, midpoint)\n\n    - **deterministic_adaptive** : list of str\n        Adaptive ODE methods (RK45, LSODA, dopri5, tsit5, etc.)\n\n    - **sde_fixed_step** : list of str\n        Fixed-step SDE methods (EM, euler_maruyama, milstein, etc.)\n\n    - **sde_adaptive** : list of str\n        Adaptive SDE methods (LambaEM, AutoEM, adaptive_heun)\n\n    - **canonical_aliases** : list of str\n        User-friendly canonical names that work on all backends\n        (euler_maruyama, milstein, rk45, rk23, etc.)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_available_methods.html#method-availability",
    "href": "api/systems.base.numerical_integration.get_available_methods.html#method-availability",
    "title": "",
    "section": "Method Availability",
    "text": "Method Availability\nActual availability depends on installed packages:\n\n- **NumPy backend**:\n  - Requires: scipy (always available)\n  - Optional: diffeqpy (Julia integration, enables high-accuracy SDE solvers)\n  - Without diffeqpy: Only scipy methods + manual implementations\n\n- **PyTorch backend**:\n  - Requires: torch (for basic functionality)\n  - Optional: torchdiffeq (ODE solvers), torchsde (SDE solvers)\n  - Without packages: Only manual implementations (euler, rk4, heun)\n\n- **JAX backend**:\n  - Requires: jax, jaxlib\n  - Optional: diffrax (comprehensive ODE/SDE solvers)\n  - Without diffrax: Only manual implementations\n\nThis function returns ALL methods that COULD be available, not just\nthose currently installed. Use validate_method() to check if a specific\nmethod is actually available."
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_available_methods.html#examples",
    "href": "api/systems.base.numerical_integration.get_available_methods.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n**Get all methods for PyTorch:**\n\n&gt;&gt;&gt; methods = get_available_methods('torch', method_type='all')\n&gt;&gt;&gt; print(methods.keys())\ndict_keys(['deterministic_fixed_step', 'deterministic_adaptive',\n           'sde_fixed_step', 'sde_adaptive', 'canonical_aliases'])\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(methods['sde_fixed_step'])\n['euler', 'milstein', 'srk', 'midpoint']\n\n**Get only stochastic methods:**\n\n&gt;&gt;&gt; sde_methods = get_available_methods('jax', method_type='stochastic')\n&gt;&gt;&gt; print(sde_methods['sde_fixed_step'])\n['Euler', 'EulerHeun', 'Heun', 'ItoMilstein', 'StratonovichMilstein',\n 'SEA', 'SHARK', 'SRA1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(sde_methods['canonical_aliases'])\n['euler_maruyama', 'milstein', 'rk45', 'rk23', 'tsit5']\n\n**Get only fixed-step methods (both ODE and SDE):**\n\n&gt;&gt;&gt; fixed = get_available_methods('numpy', method_type='fixed_step')\n&gt;&gt;&gt; print(fixed['deterministic_fixed_step'])\n['euler', 'midpoint', 'rk4', 'heun']\n&gt;&gt;&gt; print(fixed['sde_fixed_step'])\n['EM', 'EulerHeun', 'SRIW1', 'SRIW2', 'SRA1', 'SRA3', 'RKMil', 'ImplicitEM']\n\n**Compare backends:**\n\n&gt;&gt;&gt; for backend in ['numpy', 'torch', 'jax']:\n...     methods = get_available_methods(backend, method_type='stochastic')\n...     n_sde = len(methods['sde_fixed_step']) + len(methods['sde_adaptive'])\n...     print(f\"{backend:6s}: {n_sde} SDE methods\")\nnumpy : 10 SDE methods\ntorch : 6 SDE methods\njax   : 9 SDE methods\n\n**Discover canonical aliases:**\n\n&gt;&gt;&gt; methods = get_available_methods('torch')\n&gt;&gt;&gt; print(\"Portable canonical names:\")\n&gt;&gt;&gt; for alias in methods['canonical_aliases']:\n...     print(f\"  - {alias}\")\nPortable canonical names:\n  - euler_maruyama\n  - milstein\n  - rk45\n  - rk23\n\n**Filter and format for user display:**\n\n&gt;&gt;&gt; methods = get_available_methods('numpy', method_type='deterministic')\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(\"Fixed-step methods:\")\n&gt;&gt;&gt; for method in sorted(methods['deterministic_fixed_step']):\n...     print(f\"  - {method}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(\"\nAdaptive methods:“) &gt;&gt;&gt; for method in sorted(methods[‘deterministic_adaptive’]): … print(f” - {method}“)\n**Usage in DiscretizedSystem.get_available_methods():**\n\n&gt;&gt;&gt; # Delegate to this utility function\n&gt;&gt;&gt; @staticmethod\n&gt;&gt;&gt; def get_available_methods(*args, **kwargs):\n...     from cdesym.systems.base.numerical_integration.method_registry import (\n...         get_available_methods as _get_available_methods\n...     )\n...     return _get_available_methods(*args, **kwargs)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_available_methods.html#notes",
    "href": "api/systems.base.numerical_integration.get_available_methods.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n- Returns potential methods, not necessarily installed/working\n- Manual implementations (euler, rk4, heun) work on all backends\n- Some method names appear in multiple categories due to backend conventions\n- Canonical aliases provide portable names across backends\n- Filter results by method_type to reduce information overload"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_available_methods.html#see-also",
    "href": "api/systems.base.numerical_integration.get_available_methods.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nvalidate_method : Check if specific method is actually available\nnormalize_method_name : Convert canonical to backend-specific names\nBACKEND_METHODS : Complete set of methods per backend"
  },
  {
    "objectID": "api/control.design_lqg.html",
    "href": "api/control.design_lqg.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.design_lqg.html#examples",
    "href": "api/control.design_lqg.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Design LQG controller\n&gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.9]])\n&gt;&gt;&gt; B = np.array([[0], [0.1]])\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position\n&gt;&gt;&gt;\n&gt;&gt;&gt; # LQR weights\n&gt;&gt;&gt; Q_state = np.diag([10, 1])\n&gt;&gt;&gt; R_control = np.array([[0.1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Noise covariances\n&gt;&gt;&gt; Q_process = 0.01 * np.eye(2)\n&gt;&gt;&gt; R_measurement = np.array([[0.1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = design_lqg(\n...     A, B, C,\n...     Q_state, R_control,\n...     Q_process, R_measurement,\n...     system_type='discrete'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; K = result['controller_gain']\n&gt;&gt;&gt; L = result['estimator_gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Implementation\n&gt;&gt;&gt; x_hat = np.zeros(2)\n&gt;&gt;&gt; for k in range(N):\n...     # Control\n...     u = -K @ x_hat\n...\n...     # Estimation\n...     x_hat_pred = A @ x_hat + B @ u\n...     innovation = y[k] - C @ x_hat_pred\n...     x_hat = x_hat_pred + L @ innovation"
  },
  {
    "objectID": "api/control.design_lqg.html#notes",
    "href": "api/control.design_lqg.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nSeparation principle: LQR and Kalman can be designed independently\nLQG is optimal for linear systems with Gaussian noise\nClosed-loop has eigenvalues of both controller and estimator\nController must stabilize system\nEstimator must converge faster than controller for good performance\nTrade-off: Lower Q_process/R_measurement → more aggressive estimator"
  },
  {
    "objectID": "api/types.control_advanced.LMIResult.html",
    "href": "api/types.control_advanced.LMIResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_advanced.LMIResult.html#fields",
    "href": "api/types.control_advanced.LMIResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ndecision_variables : Dict[str, ArrayLike] Solved matrix variables (P, Y, etc.) objective_value : float Optimal objective function value feasible : bool Whether LMI constraints are feasible solver : str Solver used (‘cvxpy’, ‘mosek’, ‘sedumi’, etc.) solve_time : float Computation time in seconds condition_number : float Condition number of solution (numerical health)"
  },
  {
    "objectID": "api/types.control_advanced.LMIResult.html#examples",
    "href": "api/types.control_advanced.LMIResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Lyapunov stability LMI: find P &gt; 0 s.t. A'P + PA &lt; 0\n&gt;&gt;&gt; import cvxpy as cp\n&gt;&gt;&gt; P = cp.Variable((2, 2), symmetric=True)\n&gt;&gt;&gt; constraints = [\n...     P &gt;&gt; 0,  # P positive definite\n...     A.T @ P + P @ A &lt;&lt; 0  # Lyapunov inequality\n... ]\n&gt;&gt;&gt; problem = cp.Problem(cp.Minimize(0), constraints)\n&gt;&gt;&gt; problem.solve()\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: LMIResult = {\n...     'decision_variables': {'P': P.value},\n...     'objective_value': problem.value,\n...     'feasible': problem.status == 'optimal',\n...     'solver': 'cvxpy',\n...     'solve_time': problem.solver_stats.solve_time,\n...     'condition_number': np.linalg.cond(P.value),\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['feasible']:\n...     P_lyap = result['decision_variables']['P']\n...     print(\"System is stable\")"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#discrete-time-stochastic-dynamics",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#discrete-time-stochastic-dynamics",
    "title": "",
    "section": "Discrete-Time Stochastic Dynamics",
    "text": "Discrete-Time Stochastic Dynamics\nExact discretization with zero-order hold:\nx[k+1] = x[k] + v[k]·Δt + (1/2)·u[k]·Δt²\nv[k+1] = v[k] + u[k]·Δt\nWith process noise: x[k+1] = x[k] + v[k]·Δt + (1/2)·u[k]·Δt² + w_x[k] v[k+1] = v[k] + u[k]·Δt + w_v[k]\nMatrix Form: X[k+1] = Φ·X[k] + Γ·u[k] + w[k]\nwhere: X = [x, v]ᵀ\nΦ = [1  Δt]  (exact discrete-time dynamics)\n    [0   1]\n\nΓ = [Δt²/2]  (exact zero-order hold)\n    [Δt   ]\n\nw ~ N(0, Q)  (correlated process noise)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nDiscrete-Time Dynamics:\nPosition update: x[k+1] = x[k] + v[k]·Δt + (1/2)·u[k]·Δt²\nTerms: 1. x[k]: Current position (persistence) 2. v[k]·Δt: Displacement from velocity (integration) 3. (1/2)·u[k]·Δt²: Displacement from acceleration (double integration)\nThis is exact kinematics for constant acceleration over [k·Δt, (k+1)·Δt].\nVelocity update: v[k+1] = v[k] + u[k]·Δt\nExact integration of constant acceleration.\nProcess Noise:\nRepresents disturbances accumulated over sampling interval: - w_x[k]: Position error (from integrated velocity noise) - w_v[k]: Velocity error (from force disturbances)\nCovariance Structure:\nFrom continuous noise σ [m/(s²·√s)]: Q = σ²·[Δt³/3 Δt²/2] [Δt²/2 Δt ]\nNon-diagonal! Position and velocity errors correlated."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nExact Discretization: No discretization error in deterministic part (kinematic equations exact).\nLinear Dynamics: Enables analytical Riccati solutions, optimal Kalman filter.\nControllability: Completely controllable: rank[Γ, Φ·Γ] = 2\nObservability: Depends on measurement: - C = [1, 0]: Position only (observable) - C = [0, 1]: Velocity only (NOT observable) - C = I: Both (trivially observable)\nMarginal Stability: Eigenvalues: z = {1, 1} (on unit circle) - Not asymptotically stable (need feedback) - Not unstable (doesn’t diverge)\nNon-Stationary (Open-Loop): Variance grows with k (no equilibrium without control)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nState Transition Matrix: Φ = [1 Δt] [0 1]\nEigenvalues: λ = 1 (double) Eigenvector: [1, 0]ᵀ (position mode)\nControllability Matrix: C_ctrl = [Γ, Φ·Γ] = [Δt²/2 Δt³/2] [Δt Δt² ]\nrank = 2 (fully controllable)\nObservability Matrix (C = [1,0]): O = [C ] = [1 0 ] [C·Φ ] [1 Δt]\nrank = 2 (observable from position)\nProcess Noise Covariance:\nExact from continuous: Q = σ²·[Δt³/3 Δt²/2] [Δt²/2 Δt ]\nProperties: - Positive definite (if σ &gt; 0) - Symmetric (by construction) - Scales with Δt (smaller Δt → smaller Q)\nDiscrete Riccati Equation:\nFor LQR, DARE: P = Q_cost + Φᵀ·P·Φ - Φᵀ·P·Γ·(R + Γᵀ·P·Γ)⁻¹·Γᵀ·P·Φ\nFor Kalman, dual DARE: Σ = Q_noise + Φ·Σ·Φᵀ - Φ·Σ·Cᵀ·(R_meas + C·Σ·Cᵀ)⁻¹·C·Σ·Φᵀ"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nSampling Period Δt: - Sets digital control rate - Affects noise accumulation (Q ∝ Δt) - Determines controllability region - Trade-off: Fast sampling vs computation\nProcess Noise Intensity σ: - From continuous: σ [m/(s²·√s)] - Creates discrete Q via integration - Physical: Force disturbances, model uncertainty\nWhy Position Variance Larger:\nQ₁₁/Q₂₂ = Δt²/3\nFor Δt = 0.1 s: Q₁₁/Q₂₂ = 0.01/3 ≈ 0.0033\nVelocity noise integrates twice to position → amplification."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X[k] = [x[k], v[k]] ∈ ℝ² - x: Position [m] (unbounded) - v: Velocity [m/s] (unbounded)\nControl: u[k] ∈ ℝ - Acceleration command [m/s²] - Zero-order hold between samples\nNoise: w[k] = [w_x[k], w_v[k]] ~ N(0, Q) - Correlated Gaussian white noise - Accumulated over sampling interval"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nContinuous noise intensity [m/(s²·√s)] - Determines discrete Q via integration - Typical: 0.01-1.0\n0.1\n\n\ndt\nfloat\nSampling period [s] - Critical design parameter - Typical: 0.001-1.0 depending on application - Affects both dynamics and noise\n0.1\n\n\nm\nfloat\nMass [kg] (optional, typically normalized to 1)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: LINEAR\nNoise Type: ADDITIVE (constant)\nDiscrete: Yes (native discrete-time)\nNoise Dimension: nw = 2 (position and velocity)\nStationary: No (open-loop)\nGaussian: Yes (linear preserves Gaussianity)\nExact Discretization: Yes (no error)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Digital LQG Control: - Discrete DARE for optimal gain - Discrete Kalman filter for estimation - Real-time implementation\n2. Embedded Control: - Microcontroller implementation - Fixed-point arithmetic - Real-time constraints\n3. Discrete Kalman Filter: - Standard benchmark for testing - Numerical stability analysis - Joseph form, square-root filters\n4. Model Predictive Control: - Discrete-time optimization - Constraint handling - Receding horizon\n5. Reinforcement Learning: - Model-based RL (forward dynamics) - Discrete state-action updates - LQR as baseline\n6. Motion Control: - CNC machines - Robotics - Hard disk drives - Satellite control"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nDirect Evaluation: No integration needed - direct update: X[k+1] = Φ·X[k] + Γ·u[k] + w[k]\nwhere w[k] ~ N(0, Q) sampled directly.\nEfficiency: - Matrix multiplication (fast) - No time-stepping error - No stability issues - Vectorizable for batch"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#discrete-kalman-filter-example",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#discrete-kalman-filter-example",
    "title": "",
    "section": "Discrete Kalman Filter Example",
    "text": "Discrete Kalman Filter Example\nStandard implementation:\n# Initialize\nX_hat = np.zeros(2)\nP = np.eye(2)\n\nfor k in range(N):\n    # Prediction\n    X_pred = Phi @ X_hat + Gamma * u[k]\n    P_pred = Phi @ P @ Phi.T + Q\n\n    # Update (if measurement available)\n    if y[k] is not None:\n        C = np.array([[1, 0]])  # Position measurement\n        S = C @ P_pred @ C.T + R_meas\n        K = P_pred @ C.T / S\n\n        X_hat = X_pred + K * (y[k] - C @ X_pred)\n        P = (np.eye(2) - K @ C) @ P_pred\n    else:\n        X_hat = X_pred\n        P = P_pred"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#comparison-with-continuous",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#comparison-with-continuous",
    "title": "",
    "section": "Comparison with Continuous",
    "text": "Comparison with Continuous\nContinuous: - Continuous-time Riccati (differential) - Kalman-Bucy filter (continuous) - Theoretical foundation\nDiscrete: - Discrete-time Riccati (algebraic) - Discrete Kalman filter (recursive) - Practical implementation\nConversion: - Φ = exp(A·Δt) exactly - Q from integration exactly - No approximation needed"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nLinear only (no nonlinearity)\nConstant parameters (no time-variation)\nGaussian noise (no heavy tails)\nNo constraints (in base formulation)\nNo delays (zero computation time assumed)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nAdd damping: Φ₂₂ = (1 - b·Δt)\nNonlinear: u·v coupling\nConstraints: |x| ≤ x_max\nDelays: Measurement delay d steps\nMulti-rate: Different sampling for sensors/actuators"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine discrete stochastic double integrator dynamics.\n\n\nget_control_matrix\nGet exact control input matrix Γ (zero-order hold).\n\n\nget_discrete_eigenvalues\nGet eigenvalues of discrete-time system (open-loop).\n\n\nget_process_noise_covariance\nGet exact process noise covariance Q.\n\n\nget_state_transition_matrix\nGet exact state transition matrix Φ.\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.define_system(\n    sigma=0.1,\n    dt=0.1,\n    m=1.0,\n    noise_on_position=False,\n)\nDefine discrete stochastic double integrator dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nContinuous noise intensity [m/(s²·√s)] - Determines discrete Q matrix - Typical: 0.01-1.0\n0.1\n\n\ndt\nfloat\nSampling period [s] - Critical parameter (affects dynamics and noise) - Typical: 0.001-1.0 - Choose based on bandwidth requirements\n0.1\n\n\nm\nfloat\nMass [kg] (typically normalized to 1)\n1.0\n\n\nnoise_on_position\nbool\nIf True, add independent position noise (less physical) If False, only velocity noise (physical)\nFalse\n\n\n\n\n\nNotes\nExact Discretization:\nState transition (exact): Φ = [1 Δt] (from exp(A·Δt)) [0 1]\nControl input (exact for zero-order hold): Γ = [Δt²/2] [Δt ]\nProcess Noise Covariance:\nFrom continuous noise σ integrated over Δt: Q = σ²·[Δt³/3 Δt²/2] [Δt²/2 Δt ]\nThis is exact integration of Wiener process.\nStructure: - Q₁₁ ∝ Δt³: Position noise (from double integration) - Q₂₂ ∝ Δt: Velocity noise (from single integration) - Q₁₂ ∝ Δt²: Correlation (from integration)\nScaling: Smaller Δt: - Φ closer to identity (less change per step) - Γ smaller (less control authority per step) - Q smaller (less noise per step) - Need more steps for same motion\nPhysical Validity:\nStandard: Noise on velocity only (force disturbances) - Physically motivated (Newton’s law) - Q from integration exact\nOptional: Add position noise (model uncertainty) - Less physical but accounts for unmodeled effects - Increases Q₁₁ independently\nSampling Rate Selection:\nFor desired closed-loop bandwidth ω_cl: Δt &lt; 1/(10·ω_cl)\nExample: ω_cl = 10 rad/s → Δt &lt; 0.01 s (100 Hz minimum)\nEigenvalues:\nOpen-loop: z = {1, 1} (unit circle) Closed-loop (with LQR): Inside unit circle (stable)\n\n\nExamples\n&gt;&gt;&gt; # Fast servo (100 Hz)\n&gt;&gt;&gt; fast = DiscreteStochasticDoubleIntegrator(\n...     sigma=0.1,\n...     dt=0.01\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Medium rate (20 Hz)\n&gt;&gt;&gt; medium = DiscreteStochasticDoubleIntegrator(\n...     sigma=0.1,\n...     dt=0.05\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check noise covariance scaling\n&gt;&gt;&gt; Q_fast = fast.get_process_noise_covariance()\n&gt;&gt;&gt; Q_medium = medium.get_process_noise_covariance()\n&gt;&gt;&gt; print(f\"Ratio Q₂₂: {Q_medium[1,1] / Q_fast[1,1]:.1f}\")  # = dt_ratio\n\n\n\nget_control_matrix\nsystems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.get_control_matrix(\n)\n    Get exact control input matrix Γ (zero-order hold).\n\nReturns\n    np.ndarray\n        Γ = [Δt²/2]\n            [Δt   ]\n\n\nExamples\n    &gt;&gt;&gt; system = DiscreteStochasticDoubleIntegrator(dt=0.1)\n    &gt;&gt;&gt; Gamma = system.get_control_matrix()\n    &gt;&gt;&gt; print(f\"Γ:\n{Gamma}“)\n\n\n\nget_discrete_eigenvalues\nsystems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.get_discrete_eigenvalues(\n)\nGet eigenvalues of discrete-time system (open-loop).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nEigenvalues (both equal to 1)\n\n\n\n\n\nNotes\nMarginally stable: On unit circle boundary.\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteStochasticDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; eigs = system.get_discrete_eigenvalues()\n&gt;&gt;&gt; print(f\"Eigenvalues: {eigs}\")  # [1, 1]\n&gt;&gt;&gt; print(f\"On unit circle: {np.allclose(np.abs(eigs), 1)}\")\n\n\n\nget_process_noise_covariance\nsystems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.get_process_noise_covariance(\n)\n    Get exact process noise covariance Q.\n\n    From continuous noise σ integrated over Δt:\n        Q = σ²·[Δt³/3   Δt²/2]\n                [Δt²/2   Δt   ]\n\nReturns\n    np.ndarray\n        Process noise covariance Q (2×2)\n\n\nExamples\n    &gt;&gt;&gt; system = DiscreteStochasticDoubleIntegrator(sigma=0.1, dt=0.1)\n    &gt;&gt;&gt; Q = system.get_process_noise_covariance()\n    &gt;&gt;&gt; print(f\"Q:\n{Q}“) &gt;&gt;&gt; print(f”Q₁₁/Q₂₂ = {Q[0,0]/Q[1,1]:.4f} (should be Δt²/3)“)\n\n\n\nget_state_transition_matrix\nsystems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.get_state_transition_matrix(\n)\n    Get exact state transition matrix Φ.\n\nReturns\n    np.ndarray\n        Φ = [1  Δt]\n            [0   1]\n\n\nExamples\n    &gt;&gt;&gt; system = DiscreteStochasticDoubleIntegrator(dt=0.1)\n    &gt;&gt;&gt; Phi = system.get_state_transition_matrix()\n    &gt;&gt;&gt; print(f\"Φ:\n{Phi}“)\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator.setup_equilibria(\n)\nSet up equilibrium points.\nOrigin is only equilibrium (marginally stable without control)."
  },
  {
    "objectID": "api/types.symbolic.SymbolicExpression.html",
    "href": "api/types.symbolic.SymbolicExpression.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.symbolic.SymbolicExpression.html#examples",
    "href": "api/types.symbolic.SymbolicExpression.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; import sympy as sp\n&gt;&gt;&gt; x, u = sp.symbols('x u')\n&gt;&gt;&gt; expr: SymbolicExpression = x**2 + sp.sin(u)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Differentiate\n&gt;&gt;&gt; dexpr_dx = sp.diff(expr, x)  # 2*x\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Evaluate\n&gt;&gt;&gt; result = expr.subs({x: 1.0, u: 0.0})  # 1.0\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Simplify\n&gt;&gt;&gt; simplified: SymbolicExpression = sp.simplify(expr)"
  },
  {
    "objectID": "api/types.backends.validate_device.html",
    "href": "api/types.backends.validate_device.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.validate_device.html#parameters",
    "href": "api/types.backends.validate_device.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndevice\nstr\nDevice identifier\nrequired\n\n\nbackend\nBackend\nBackend being used\nrequired"
  },
  {
    "objectID": "api/types.backends.validate_device.html#returns",
    "href": "api/types.backends.validate_device.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDevice\nValidated device"
  },
  {
    "objectID": "api/types.backends.validate_device.html#raises",
    "href": "api/types.backends.validate_device.html#raises",
    "title": "",
    "section": "Raises",
    "text": "Raises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf device incompatible with backend"
  },
  {
    "objectID": "api/types.backends.validate_device.html#examples",
    "href": "api/types.backends.validate_device.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; validate_device('cuda', 'torch')\n'cuda'\n&gt;&gt;&gt; validate_device('cuda', 'numpy')  # ValueError - NumPy is CPU-only"
  },
  {
    "objectID": "api/visualization.ControlPlotter.html",
    "href": "api/visualization.ControlPlotter.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/visualization.ControlPlotter.html#attributes",
    "href": "api/visualization.ControlPlotter.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbackend\nBackend\nDefault computational backend for array conversion\n\n\ndefault_theme\nstr\nDefault plot theme to apply"
  },
  {
    "objectID": "api/visualization.ControlPlotter.html#examples",
    "href": "api/visualization.ControlPlotter.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nEigenvalue stability map:\n&gt;&gt;&gt; plotter = ControlPlotter()\n&gt;&gt;&gt; result = system.design_lqr(Q, R)\n&gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n...     result['closed_loop_eigenvalues'],\n...     system_type='continuous',\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\nCompare LQR gains:\n&gt;&gt;&gt; gains = {\n...     'Light Q': K1,\n...     'Heavy Q': K2,\n... }\n&gt;&gt;&gt; fig = plotter.plot_gain_comparison(\n...     gains,\n...     color_scheme='colorblind_safe',\n...     theme='dark'\n... )"
  },
  {
    "objectID": "api/visualization.ControlPlotter.html#methods",
    "href": "api/visualization.ControlPlotter.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nlist_available_color_schemes\nList available color schemes.\n\n\nlist_available_themes\nList available plot themes.\n\n\nplot_controllability_gramian\nVisualize controllability Gramian as heatmap.\n\n\nplot_eigenvalue_map\nPlot eigenvalues with stability region.\n\n\nplot_frequency_response\nPlot frequency response (Bode plot).\n\n\nplot_gain_comparison\nCompare feedback gains across different designs.\n\n\nplot_impulse_response\nPlot impulse response with performance metrics.\n\n\nplot_nyquist\nPlot Nyquist diagram.\n\n\nplot_observability_gramian\nVisualize observability Gramian as heatmap.\n\n\nplot_riccati_convergence\nPlot Riccati equation solver convergence.\n\n\nplot_root_locus\nPlot root locus (pole migration as gain varies).\n\n\nplot_step_response\nPlot step response with performance metrics.\n\n\n\n\nlist_available_color_schemes\nvisualization.ControlPlotter.list_available_color_schemes()\nList available color schemes.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nAvailable color scheme names\n\n\n\n\n\nExamples\n&gt;&gt;&gt; schemes = ControlPlotter.list_available_color_schemes()\n&gt;&gt;&gt; print(schemes)\n['plotly', 'd3', 'colorblind_safe', 'tableau', ...]\n\n\n\nlist_available_themes\nvisualization.ControlPlotter.list_available_themes()\nList available plot themes.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nAvailable theme names\n\n\n\n\n\nExamples\n&gt;&gt;&gt; themes = ControlPlotter.list_available_themes()\n&gt;&gt;&gt; print(themes)\n['default', 'publication', 'dark', 'presentation']\n\n\n\nplot_controllability_gramian\nvisualization.ControlPlotter.plot_controllability_gramian(\n    W_c,\n    state_names=None,\n    title='Controllability Gramian',\n    theme=None,\n    **kwargs,\n)\nVisualize controllability Gramian as heatmap.\nShows coupling between states for controllability analysis.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nW_c\nnp.ndarray\nControllability Gramian, shape (nx, nx) Symmetric positive semi-definite matrix\nrequired\n\n\nstate_names\nOptional[List[str]]\nNames for states\nNone\n\n\ntitle\nstr\nPlot title\n'Controllability Gramian'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nGramian heatmap\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compute controllability Gramian\n&gt;&gt;&gt; from scipy.linalg import solve_continuous_lyapunov\n&gt;&gt;&gt; W_c = solve_continuous_lyapunov(A, -B @ B.T)\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_controllability_gramian(\n...     W_c,\n...     state_names=['Position', 'Velocity'],\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n\n\nNotes\n\nDiagonal elements: controllability of individual states\nOff-diagonal: coupling between states\nSmall eigenvalues → difficult to control\nCan also visualize observability Gramian W_o\n\n\n\n\nplot_eigenvalue_map\nvisualization.ControlPlotter.plot_eigenvalue_map(\n    eigenvalues,\n    system_type='continuous',\n    labels=None,\n    title='Eigenvalue Map',\n    show_stability_margin=True,\n    show_stability_region=True,\n    color_scheme='plotly',\n    theme=None,\n    **kwargs,\n)\nPlot eigenvalues with stability region.\nCreates complex plane plot showing eigenvalue locations with stability region highlighted. Supports multiple eigenvalue sets for comparative analysis.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\neigenvalues\nUnion[np.ndarray, Dict[str, np.ndarray]]\nComplex eigenvalues in one of two formats: Format 1: Single array Shape (n,) - single set of eigenvalues Use with labels parameter for individual point labels Format 2: Dictionary (recommended for multiple sets) Dict mapping set names to eigenvalue arrays Example: {‘Open-loop’: eigs_ol, ‘Closed-loop’: eigs_cl} Each array: shape (n_eigs,)\nrequired\n\n\nsystem_type\nstr\nSystem type determining stability criterion: - ‘continuous’: Re(λ) &lt; 0 (left half-plane stable) - ‘discrete’: |λ| &lt; 1 (inside unit circle stable)\n'continuous'\n\n\nlabels\nOptional[Union[List[str], str]]\nLabels for eigenvalues (only used if eigenvalues is array): - List[str]: Individual label per eigenvalue, length must match - str: Single label for entire set - None: Default to “Eigenvalues” Ignored if eigenvalues is Dict (uses dict keys instead)\nNone\n\n\ntitle\nstr\nPlot title\n'Eigenvalue Map'\n\n\nshow_stability_margin\nbool\nIf True, annotate stability margin (distance to boundary) - Continuous: margin = -max(Re(λ)) - Discrete: margin = 1 - max(|λ|)\nTrue\n\n\nshow_stability_region\nbool\nIf True, shade stability region - Continuous: shade left half-plane (green) - Discrete: draw unit circle\nTrue\n\n\ncolor_scheme\nstr\nColor scheme for eigenvalue sets Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, etc. Used when plotting multiple sets (dict format)\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional customization arguments - marker_size : int - Size of eigenvalue markers (default: 12) - show_grid : bool - Show grid lines (default: True)\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nInteractive eigenvalue map with stability region\n\n\n\n\n\nExamples\nSingle set of eigenvalues:\n&gt;&gt;&gt; lqr = system.design_lqr(Q, R)\n&gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n...     lqr['closed_loop_eigenvalues'],\n...     system_type='continuous',\n...     labels='Closed-loop (LQR)',\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\nMultiple sets using dictionary (recommended):\n&gt;&gt;&gt; eigenvalue_sets = {\n...     'Open-loop': eigs_open,\n...     'Closed-loop (LQR)': eigs_lqr,\n...     'Closed-loop (H∞)': eigs_hinf,\n... }\n&gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n...     eigenvalue_sets,\n...     system_type='continuous',\n...     color_scheme='colorblind_safe',\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\nMultiple sets using concatenation + labels:\n&gt;&gt;&gt; eigs_all = np.concatenate([eigs_ol, eigs_cl])\n&gt;&gt;&gt; labels_all = (\n...     ['Open-loop'] * len(eigs_ol) + \n...     ['Closed-loop'] * len(eigs_cl)\n... )\n&gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n...     eigs_all,\n...     labels=labels_all,\n...     system_type='continuous'\n... )\nDiscrete system:\n&gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n...     discrete_lqr['closed_loop_eigenvalues'],\n...     system_type='discrete',\n...     theme='dark'\n... )\nCustom marker size and grid:\n&gt;&gt;&gt; fig = plotter.plot_eigenvalue_map(\n...     eigenvalue_sets,\n...     marker_size=15,\n...     show_grid=True\n... )\n\n\nNotes\nStability Criteria:\n\nContinuous systems: Stable if Re(λ) &lt; 0 for all eigenvalues (left half-plane of complex plane)\nDiscrete systems: Stable if |λ| &lt; 1 for all eigenvalues (inside unit circle)\n\nStability Margin:\nDistance from least stable eigenvalue to stability boundary:\n\nContinuous: margin = -max(Re(λ))\nPositive: stable with margin\nNegative: unstable\nLarger is better (more robustness)\nDiscrete: margin = 1 - max(|λ|)\nPositive: stable with margin\nNegative: unstable\nLarger is better\n\nVisual Encoding:\n\nStable region: Shaded green/highlighted\nUnstable region: Shaded red/unmarked\nStability boundary: Solid black line\nEigenvalues: Colored circles (one color per set)\nMargin: Annotated with arrow\n\nMultiple Sets:\nWhen comparing multiple designs: - Each set gets unique color from color_scheme - Legend shows which eigenvalues belong to which design - Useful for visualizing controller tuning effects\n\n\nSee Also\nplot_root_locus : Shows eigenvalue migration as gain varies plot_gain_comparison : Compare feedback gains\n\n\n\nplot_frequency_response\nvisualization.ControlPlotter.plot_frequency_response(\n    frequencies,\n    magnitude,\n    phase,\n    title='Frequency Response (Bode Plot)',\n    show_margins=True,\n    theme=None,\n    **kwargs,\n)\nPlot frequency response (Bode plot).\nCreates magnitude and phase plots vs frequency, with optional gain and phase margin annotations.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfrequencies\nnp.ndarray\nFrequency points in rad/s, shape (n_freq,)\nrequired\n\n\nmagnitude\nnp.ndarray\nMagnitude response in dB, shape (n_freq,)\nrequired\n\n\nphase\nnp.ndarray\nPhase response in degrees, shape (n_freq,)\nrequired\n\n\ntitle\nstr\nPlot title\n'Frequency Response (Bode Plot)'\n\n\nshow_margins\nbool\nIf True, annotate gain and phase margins\nTrue\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nBode plot with magnitude and phase subplots\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compute frequency response\n&gt;&gt;&gt; from scipy import signal\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Closed-loop transfer function\n&gt;&gt;&gt; A_cl = A - B @ K\n&gt;&gt;&gt; sys = signal.StateSpace(A_cl, B, C, D)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Frequency response\n&gt;&gt;&gt; w = np.logspace(-2, 2, 1000)  # rad/s\n&gt;&gt;&gt; w, H = signal.freqresp(sys, w)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert to dB and degrees\n&gt;&gt;&gt; mag_dB = 20 * np.log10(np.abs(H).flatten())\n&gt;&gt;&gt; phase_deg = np.angle(H, deg=True).flatten()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot with publication theme\n&gt;&gt;&gt; fig = plotter.plot_frequency_response(\n...     w, mag_dB, phase_deg,\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n\n\nNotes\n\nMagnitude in dB: 20*log10(|H(jω)|)\nPhase in degrees: ∠H(jω)\nGain margin: Amount gain can increase before instability\nPhase margin: Amount phase can decrease before instability\nCrossover frequencies automatically detected\n\n\n\n\nplot_gain_comparison\nvisualization.ControlPlotter.plot_gain_comparison(\n    gains,\n    labels=None,\n    title='Feedback Gain Comparison',\n    color_scheme='plotly',\n    theme=None,\n    **kwargs,\n)\nCompare feedback gains across different designs.\nCreates grouped bar chart or heatmap showing gain values for different control designs.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngains\nDict[str, np.ndarray]\nDictionary mapping design names to gain matrices Each gain: (nu, nx) array\nrequired\n\n\nlabels\nOptional[List[str]]\nLabels for gain entries (state names) If None, uses generic labels\nNone\n\n\ntitle\nstr\nPlot title\n'Feedback Gain Comparison'\n\n\ncolor_scheme\nstr\nColor scheme name for bar charts Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, etc. Default: ‘plotly’\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nGain comparison plot\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compare different Q weights with colorblind-safe colors\n&gt;&gt;&gt; gains = {\n...     'Q=10*I': system.design_lqr(10*np.eye(2), R)['gain'],\n...     'Q=100*I': system.design_lqr(100*np.eye(2), R)['gain'],\n...     'Q=1000*I': system.design_lqr(1000*np.eye(2), R)['gain'],\n... }\n&gt;&gt;&gt; fig = plotter.plot_gain_comparison(\n...     gains,\n...     color_scheme='colorblind_safe',\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With state labels\n&gt;&gt;&gt; fig = plotter.plot_gain_comparison(\n...     gains,\n...     labels=['Position', 'Velocity'],\n...     theme='dark'\n... )\n\n\nNotes\n\nEach design shown as separate bar group\nUseful for parameter studies\nShows effect of Q/R tuning on gains\n\n\n\n\nplot_impulse_response\nvisualization.ControlPlotter.plot_impulse_response(\n    t,\n    y,\n    show_metrics=True,\n    title='Impulse Response',\n    theme=None,\n    **kwargs,\n)\nPlot impulse response with performance metrics.\nShows closed-loop impulse response (response to Dirac delta input) with annotations for peak, decay rate, and settling characteristics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nnp.ndarray\nTime points, shape (T,)\nrequired\n\n\ny\nnp.ndarray\nOutput response, shape (T,) or (T, ny)\nrequired\n\n\nshow_metrics\nbool\nIf True, annotate performance metrics\nTrue\n\n\ntitle\nstr\nPlot title\n'Impulse Response'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nImpulse response plot with metrics\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Simulate closed-loop impulse response\n&gt;&gt;&gt; # For continuous systems: y(t) = C @ expm(A_cl*t) @ B\n&gt;&gt;&gt; from scipy.linalg import expm\n&gt;&gt;&gt; A_cl = A - B @ K\n&gt;&gt;&gt; t = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; y = np.array([C @ expm(A_cl * t_i) @ B for t_i in t]).flatten()\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_impulse_response(\n...     t, y,\n...     show_metrics=True,\n...     theme='publication'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # For discrete systems: simulate with impulse at k=0\n&gt;&gt;&gt; x = np.zeros(nx)\n&gt;&gt;&gt; y_discrete = []\n&gt;&gt;&gt; for k in range(N):\n...     u_k = 1.0 if k == 0 else 0.0  # Impulse at k=0\n...     y_discrete.append(C @ x)\n...     x = A_cl @ x + B * u_k\n&gt;&gt;&gt; fig = plotter.plot_impulse_response(t_discrete, np.array(y_discrete))\n\n\nNotes\n\nPeak value: Maximum absolute response\nPeak time: Time to peak\nDecay rate: Exponential decay constant (if applicable)\nSettling time: Time to settle within 2% of zero\nEnergy: Integral of squared response (L2 norm)\n\n\n\n\nplot_nyquist\nvisualization.ControlPlotter.plot_nyquist(\n    real,\n    imag,\n    frequencies=None,\n    title='Nyquist Plot',\n    show_critical_point=True,\n    theme=None,\n    **kwargs,\n)\nPlot Nyquist diagram.\nShows frequency response in complex plane, useful for stability analysis via Nyquist stability criterion.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nreal\nnp.ndarray\nReal part of frequency response, shape (n_freq,)\nrequired\n\n\nimag\nnp.ndarray\nImaginary part of frequency response, shape (n_freq,)\nrequired\n\n\nfrequencies\nOptional[np.ndarray]\nFrequency points in rad/s (for hover info)\nNone\n\n\ntitle\nstr\nPlot title\n'Nyquist Plot'\n\n\nshow_critical_point\nbool\nIf True, mark critical point (-1, 0j)\nTrue\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nNyquist plot\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compute open-loop frequency response\n&gt;&gt;&gt; from scipy import signal\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Open-loop system: G(s) = C(sI - A)^(-1)B\n&gt;&gt;&gt; sys_ol = signal.StateSpace(A, B, C, D)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Frequency response\n&gt;&gt;&gt; w = np.logspace(-2, 2, 1000)\n&gt;&gt;&gt; w, H = signal.freqresp(sys_ol, w)\n&gt;&gt;&gt; H = H.flatten()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot Nyquist with dark theme\n&gt;&gt;&gt; fig = plotter.plot_nyquist(\n...     np.real(H), np.imag(H), frequencies=w,\n...     theme='dark'\n... )\n&gt;&gt;&gt; fig.show()\n\n\nNotes\n\nNyquist plot: H(jω) in complex plane as ω varies\nCritical point: (-1, 0j)\nStability: Number of encirclements of (-1, 0j) determines stability\nGain margin: Distance from curve to (-1, 0j)\nPhase margin: Angle from curve to (-1, 0j)\n\n\n\n\nplot_observability_gramian\nvisualization.ControlPlotter.plot_observability_gramian(\n    W_o,\n    state_names=None,\n    title='Observability Gramian',\n    theme=None,\n    **kwargs,\n)\nVisualize observability Gramian as heatmap.\nShows coupling between states for observability analysis.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nW_o\nnp.ndarray\nObservability Gramian, shape (nx, nx)\nrequired\n\n\nstate_names\nOptional[List[str]]\nNames for states\nNone\n\n\ntitle\nstr\nPlot title\n'Observability Gramian'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nGramian heatmap\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compute observability Gramian\n&gt;&gt;&gt; from scipy.linalg import solve_continuous_lyapunov\n&gt;&gt;&gt; W_o = solve_continuous_lyapunov(A.T, -C.T @ C)\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_observability_gramian(\n...     W_o,\n...     theme='publication'\n... )\n\n\n\nplot_riccati_convergence\nvisualization.ControlPlotter.plot_riccati_convergence(\n    P_history,\n    title='Riccati Equation Convergence',\n    theme=None,\n    **kwargs,\n)\nPlot Riccati equation solver convergence.\nShows how Riccati matrix P converges during iterative solution.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nP_history\nList[np.ndarray]\nList of P matrices at each iteration Each P: (nx, nx) array\nrequired\n\n\ntitle\nstr\nPlot title\n'Riccati Equation Convergence'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nConvergence plot\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # During iterative Riccati solving\n&gt;&gt;&gt; P_history = []\n&gt;&gt;&gt; P = np.eye(nx)\n&gt;&gt;&gt; for iter in range(100):\n...     P = riccati_iteration(P, A, B, Q, R)\n...     P_history.append(P.copy())\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_riccati_convergence(\n...     P_history,\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n\n\nNotes\n\nPlots Frobenius norm vs iteration\nShows convergence rate\nUseful for debugging custom solvers\n\n\n\n\nplot_root_locus\nvisualization.ControlPlotter.plot_root_locus(\n    root_locus_data,\n    title='Root Locus',\n    show_grid=True,\n    system_type='continuous',\n    color_scheme='plotly',\n    theme=None,\n    **kwargs,\n)\nPlot root locus (pole migration as gain varies).\nShows how closed-loop poles move in complex plane as control gain varies from 0 to infinity.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nroot_locus_data\nDict[str, np.ndarray]\nDictionary with: - ‘gains’: Array of gain values, shape (n_gains,) - ‘poles’: Array of poles, shape (n_gains, n_poles) - Optional ‘zeros’: Open-loop zeros\nrequired\n\n\ntitle\nstr\nPlot title\n'Root Locus'\n\n\nshow_grid\nbool\nIf True, show stability grid\nTrue\n\n\nsystem_type\nstr\n‘continuous’ or ‘discrete’ (affects stability region)\n'continuous'\n\n\ncolor_scheme\nstr\nColor scheme for pole branches Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, etc. Default: ‘plotly’\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nRoot locus plot\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compute root locus for LQR as Q varies\n&gt;&gt;&gt; from scipy import signal\n&gt;&gt;&gt;\n&gt;&gt;&gt; gains = np.logspace(-1, 3, 50)  # Q weight values\n&gt;&gt;&gt; poles_list = []\n&gt;&gt;&gt;\n&gt;&gt;&gt; for q in gains:\n...     lqr = system.design_lqr(q * np.eye(nx), R)\n...     poles_list.append(lqr['closed_loop_eigenvalues'])\n&gt;&gt;&gt;\n&gt;&gt;&gt; root_locus_data = {\n...     'gains': gains,\n...     'poles': np.array(poles_list)\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_root_locus(\n...     root_locus_data,\n...     system_type='continuous',\n...     color_scheme='colorblind_safe',\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n\n\nNotes\n\nEach branch shows one pole’s trajectory\nStarts at open-loop pole (K=0)\nEnds at zero or infinity (K→∞)\nStability: poles must stay in stable region\nContinuous: left half-plane (Re &lt; 0)\nDiscrete: inside unit circle (|z| &lt; 1)\n\n\n\n\nplot_step_response\nvisualization.ControlPlotter.plot_step_response(\n    t,\n    y,\n    reference=1.0,\n    show_metrics=True,\n    title='Step Response',\n    theme=None,\n    **kwargs,\n)\nPlot step response with performance metrics.\nShows closed-loop step response with annotations for rise time, settling time, overshoot, etc.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nnp.ndarray\nTime points, shape (T,)\nrequired\n\n\ny\nnp.ndarray\nOutput response, shape (T,) or (T, ny)\nrequired\n\n\nreference\nfloat\nReference value (step height)\n1.0\n\n\nshow_metrics\nbool\nIf True, annotate performance metrics\nTrue\n\n\ntitle\nstr\nPlot title\n'Step Response'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nStep response plot with metrics\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Simulate closed-loop step response\n&gt;&gt;&gt; A_cl = A - B @ K  # Closed-loop A matrix\n&gt;&gt;&gt; result = system.integrate(x0, u=None, A_override=A_cl, t_span=(0, 10))\n&gt;&gt;&gt; y = result['x'][:, 0]  # First state\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_step_response(\n...     result['t'],\n...     y,\n...     reference=1.0,\n...     show_metrics=True,\n...     theme='publication'\n... )\n\n\nNotes\n\nRise time: 10% to 90% of final value\nSettling time: Within 2% of final value\nOvershoot: Peak value above reference\nSteady-state error: Final value vs reference"
  },
  {
    "objectID": "api/control.design_lqr.html",
    "href": "api/control.design_lqr.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.design_lqr.html#parameters",
    "href": "api/control.design_lqr.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\nStateMatrix\nState matrix (nx, nx)\nrequired\n\n\nB\nInputMatrix\nInput matrix (nx, nu)\nrequired\n\n\nQ\nStateMatrix\nState cost matrix (nx, nx), must be positive semi-definite (Q ≥ 0)\nrequired\n\n\nR\nInputMatrix\nControl cost matrix (nu, nu), must be positive definite (R &gt; 0)\nrequired\n\n\nN\nOptional[InputMatrix]\nCross-coupling matrix (nx, nu), optional. Default is zero. Allows for non-quadratic objectives.\nNone\n\n\nsystem_type\nstr\n‘continuous’ or ‘discrete’, default ‘discrete’\n'discrete'\n\n\nbackend\nBackend\nComputational backend (‘numpy’, ‘torch’, ‘jax’), default ‘numpy’\n'numpy'"
  },
  {
    "objectID": "api/control.design_lqr.html#returns",
    "href": "api/control.design_lqr.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nLQRResult\nDictionary containing: - gain: Optimal feedback gain K (nu, nx) - cost_to_go: Riccati solution P (nx, nx) - controller_eigenvalues: Eigenvalues of (A - BK) - stability_margin: Distance from stability boundary * Continuous: -max(Re(λ)) (positive = stable) * Discrete: 1 - max(|λ|) (positive = stable)"
  },
  {
    "objectID": "api/control.design_lqr.html#raises",
    "href": "api/control.design_lqr.html#raises",
    "title": "",
    "section": "Raises",
    "text": "Raises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf matrices have incompatible shapes or invalid system_type\n\n\n\nLinAlgError\nIf Riccati equation has no solution (system may be unstabilizable)"
  },
  {
    "objectID": "api/control.design_lqr.html#examples",
    "href": "api/control.design_lqr.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nContinuous-time double integrator:\n&gt;&gt;&gt; A = np.array([[0, 1], [0, 0]])\n&gt;&gt;&gt; B = np.array([[0], [1]])\n&gt;&gt;&gt; Q = np.diag([10, 1])  # Penalize position more\n&gt;&gt;&gt; R = np.array([[0.1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = design_lqr(A, B, Q, R, system_type='continuous')\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt; print(f\"Gain: {K}\")\n&gt;&gt;&gt; print(f\"Stable: {result['stability_margin'] &gt; 0}\")\nDiscrete-time system:\n&gt;&gt;&gt; Ad = np.array([[1, 0.1], [0, 1]])\n&gt;&gt;&gt; Bd = np.array([[0.005], [0.1]])\n&gt;&gt;&gt; Q = np.diag([10, 1])\n&gt;&gt;&gt; R = np.array([[0.1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = design_lqr(Ad, Bd, Q, R, system_type='discrete')\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply control in simulation\n&gt;&gt;&gt; x = np.array([1.0, 0.0])\n&gt;&gt;&gt; for k in range(100):\n...     u = -K @ x\n...     x = Ad @ x + Bd @ u\nWith cross-coupling term:\n&gt;&gt;&gt; N = np.array([[0.5], [0.1]])\n&gt;&gt;&gt; result = design_lqr(A, B, Q, R, N=N, system_type='continuous')\nUsing PyTorch backend:\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; A_torch = torch.tensor(A, dtype=torch.float64)\n&gt;&gt;&gt; B_torch = torch.tensor(B, dtype=torch.float64)\n&gt;&gt;&gt; Q_torch = torch.tensor(Q, dtype=torch.float64)\n&gt;&gt;&gt; R_torch = torch.tensor(R, dtype=torch.float64)\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = design_lqr(\n...     A_torch, B_torch, Q_torch, R_torch,\n...     system_type='continuous',\n...     backend='torch'\n... )\n&gt;&gt;&gt; K = result['gain']  # Returns torch.Tensor"
  },
  {
    "objectID": "api/control.design_lqr.html#notes",
    "href": "api/control.design_lqr.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nControllability Requirements: - Full controllability: (A, B) must be controllable for arbitrary pole placement - Stabilizability: Unstable modes must be controllable (weaker, sufficient for LQR)\nCost Matrix Requirements: - Q must be positive semi-definite (all eigenvalues ≥ 0) - R must be positive definite (all eigenvalues &gt; 0) - (Q, A) should be detectable for finite-horizon convergence\nStability: - Continuous: Closed-loop stable if all Re(λ) &lt; 0 (left half-plane) - Discrete: Closed-loop stable if all |λ| &lt; 1 (inside unit circle) - stability_margin &gt; 0 indicates asymptotic stability\nCross-Coupling Term N: - Allows non-standard quadratic costs - Useful for systems with control-state coupling - Set to None (default) for standard LQR\nNumerical Considerations: - Uses scipy’s solve_continuous_are / solve_discrete_are - Numerical issues may arise for ill-conditioned systems - Consider scaling states/controls for better conditioning"
  },
  {
    "objectID": "api/control.design_lqr.html#see-also",
    "href": "api/control.design_lqr.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\ndesign_kalman_filter : Optimal state estimator (dual to LQR) design_lqg : Combined LQR + Kalman filter analyze_controllability : Test controllability of (A, B) analyze_stability : Analyze closed-loop stability"
  },
  {
    "objectID": "api/types.protocols.ContinuousSystemProtocol.html",
    "href": "api/types.protocols.ContinuousSystemProtocol.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.protocols.ContinuousSystemProtocol.html#implementations",
    "href": "api/types.protocols.ContinuousSystemProtocol.html#implementations",
    "title": "",
    "section": "Implementations",
    "text": "Implementations\n\nContinuousSymbolicSystem\nContinuousStochasticSystem\nNeuralODE (future)"
  },
  {
    "objectID": "api/types.protocols.ContinuousSystemProtocol.html#use-cases",
    "href": "api/types.protocols.ContinuousSystemProtocol.html#use-cases",
    "title": "",
    "section": "Use Cases",
    "text": "Use Cases\n\nTrajectory optimization\nSafety verification\nReachability analysis\nDiscretization utilities"
  },
  {
    "objectID": "api/types.protocols.ContinuousSystemProtocol.html#examples",
    "href": "api/types.protocols.ContinuousSystemProtocol.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; def discretize_any(\n...     system: ContinuousSystemProtocol,\n...     dt: float\n... ) -&gt; DiscretizedSystem:\n...     '''Discretize any continuous system.'''\n...     return DiscretizedSystem(system, dt, method='rk4')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Works with any continuous system:\n&gt;&gt;&gt; discrete1 = discretize_any(ContinuousSymbolicSystem(...), dt=0.01)\n&gt;&gt;&gt; discrete2 = discretize_any(ContinuousStochasticSystem(...), dt=0.01)"
  },
  {
    "objectID": "api/types.protocols.ContinuousSystemProtocol.html#attributes",
    "href": "api/types.protocols.ContinuousSystemProtocol.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nnu\nNumber of control inputs\n\n\nnx\nNumber of state variables"
  },
  {
    "objectID": "api/types.protocols.ContinuousSystemProtocol.html#methods",
    "href": "api/types.protocols.ContinuousSystemProtocol.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nintegrate\nNumerically integrate continuous system.\n\n\n\n\nintegrate\ntypes.protocols.ContinuousSystemProtocol.integrate(\n    x0,\n    u,\n    t_span,\n    method='RK45',\n    **kwargs,\n)\nNumerically integrate continuous system.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state\nrequired\n\n\nu\nUnion[ControlVector, Callable, None]\nControl input\nrequired\n\n\nt_span\nTimeSpan\nIntegration interval (t_start, t_end)\nrequired\n\n\nmethod\nstr\nIntegration method\n'RK45'\n\n\n**kwargs\n\nAdditional integrator options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nIntegration result with trajectory data"
  },
  {
    "objectID": "api/types.backends.IntegrationMethod.html",
    "href": "api/types.backends.IntegrationMethod.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\ntypes.backends.IntegrationMethod\ntypes.backends.IntegrationMethod\nIntegration method for continuous-time systems (ODEs)."
  },
  {
    "objectID": "api/systems.base.utils.EquilibriumHandler.html",
    "href": "api/systems.base.utils.EquilibriumHandler.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.EquilibriumHandler.html#attributes",
    "href": "api/systems.base.utils.EquilibriumHandler.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nnu\nNumber of controls\n\n\nnx\nNumber of states"
  },
  {
    "objectID": "api/systems.base.utils.EquilibriumHandler.html#methods",
    "href": "api/systems.base.utils.EquilibriumHandler.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nadd\nAdd named equilibrium point.\n\n\nget_both\nGet both state and control equilibria\n\n\nget_metadata\nGet metadata for equilibrium\n\n\nget_u\nGet equilibrium control in specified backend\n\n\nget_x\nGet equilibrium state in specified backend\n\n\nlist_names\nList all equilibrium names\n\n\nset_default\nSet default equilibrium\n\n\n\n\nadd\nsystems.base.utils.EquilibriumHandler.add(\n    name,\n    x_eq,\n    u_eq,\n    verify_fn=None,\n    tol=1e-06,\n    **metadata,\n)\nAdd named equilibrium point.\nArgs: name: Equilibrium name x_eq: Equilibrium state u_eq: Equilibrium control verify_fn: Optional function(x, u) -&gt; dx to verify equilibrium tol: Tolerance for verification **metadata: Additional info (stability, description, etc.)\n\n\nget_both\nsystems.base.utils.EquilibriumHandler.get_both(name=None, backend='numpy')\nGet both state and control equilibria\n\n\nget_metadata\nsystems.base.utils.EquilibriumHandler.get_metadata(name=None)\nGet metadata for equilibrium\n\n\nget_u\nsystems.base.utils.EquilibriumHandler.get_u(name=None, backend='numpy')\nGet equilibrium control in specified backend\n\n\nget_x\nsystems.base.utils.EquilibriumHandler.get_x(name=None, backend='numpy')\nGet equilibrium state in specified backend\n\n\nlist_names\nsystems.base.utils.EquilibriumHandler.list_names()\nList all equilibrium names\n\n\nset_default\nsystems.base.utils.EquilibriumHandler.set_default(name)\nSet default equilibrium"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA simplified model of a VTOL aircraft (helicopter, drone) constrained to move in a vertical plane.\nThe aircraft has: - Two thrust actuators (left and right, or front and back) - Ability to rotate (pitch) and translate (x, y) - Gravity acting downward - Thrust-vectoring through body rotation\nKey feature: Underactuated with 2 inputs controlling 3 degrees of freedom. Must use rotation (θ) to control horizontal motion (x)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html#coordinate-frame",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html#coordinate-frame",
    "title": "",
    "section": "Coordinate Frame:",
    "text": "Coordinate Frame:\nThis implementation uses body-fixed velocity coordinates, which is common in aircraft dynamics: - Position (x, y): In inertial (world) frame - Velocities (ẋ, ẏ): In body frame (rotates with aircraft) - Angle θ: Pitch angle in inertial frame"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, y, θ, ẋ, ẏ, θ̇] Position coordinates (inertial frame): - x: Horizontal position [m] (positive right) - y: Vertical position [m] (positive up) - θ (theta): Pitch angle [rad] * θ = 0: level (horizontal orientation) * θ &gt; 0: nose up (pitched back) * θ &lt; 0: nose down (pitched forward)\nVelocity coordinates (body frame):\n- ẋ (x_dot): Velocity in body x-direction [m/s]\n- ẏ (y_dot): Velocity in body y-direction [m/s]\n- θ̇ (theta_dot): Angular velocity [rad/s]\nControl: u = [u₁, u₂] - u₁: Left/front thrust [N] - u₂: Right/back thrust [N] Both must be non-negative in physical systems (thrust-only)\nOutput: y = [x, y, θ] - Measures position and orientation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe PVTOL dynamics in body frame are:\nẍ_body = ẏ·θ̇ - g·sin(θ)\nÿ_body = -ẋ·θ̇ - g·cos(θ) + (u₁ + u₂)/m\nθ̈ = d/I · (u₁ - u₂)\nHorizontal acceleration (ẍ_body): - ẏ·θ̇: Centrifugal effect from rotation - -g·sin(θ): Gravity component in body x-direction - Controlled indirectly through angle θ\nVertical acceleration (ÿ_body): - -ẋ·θ̇: Coriolis effect from rotation - -g·cos(θ): Gravity component in body y-direction - (u₁ + u₂)/m: Total thrust divided by mass\nAngular acceleration (θ̈): - d/I · (u₁ - u₂): Torque from differential thrust - d: Distance from center of mass to thrusters - I: Moment of inertia"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nlength : float, default=0.25 Half-distance between thrusters [m]. Also interpreted as distance from center of mass to each thruster. Larger L → more control authority for rotation (more torque per thrust difference). mass : float, default=4.0 Total mass of aircraft [kg]. Larger mass → slower acceleration response, more thrust needed to hover. inertia : float, default=0.0475 Moment of inertia about center of mass [kg·m²]. Larger I → slower rotational response. gravity : float, default=9.8 Gravitational acceleration [m/s²]. dist : float, default=0.25 Lever arm for torque generation [m]. Often equals length. Determines θ̈ = (dist/inertia)·(u₁ - u₂)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nHovering (level flight): x_eq = [x, y, 0, 0, 0, 0] (any position, level, stationary) u_eq = [mg/2, mg/2] (equal thrust, each supporting half weight)\nAt hover: - Total thrust balances gravity: u₁ + u₂ = mg - Differential thrust is zero: u₁ - u₂ = 0 - No rotation: θ = 0\nTilted hover (advanced): For x_eq = [x, y, θ*, 0, 0, 0] with θ* ≠ 0: Requires different thrust distribution to maintain position"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PVTOL.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.PVTOL.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nSymbolicQuadrotor2D : Similar flying vehicle, different parameterization CartPole : Another underactuated system Manipulator2Link : Multi-body system with coupling"
  },
  {
    "objectID": "api/types.reachability.CBFResult.html",
    "href": "api/types.reachability.CBFResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.reachability.CBFResult.html#fields",
    "href": "api/types.reachability.CBFResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nsafe_control : ControlVector Safety-filtered control u_safe barrier_value : float B(x) at current state barrier_derivative : float dB/dt or ΔB under current dynamics constraint_active : bool True if safety constraint is active nominal_control : ControlVector Original desired control u_nom modification_magnitude : float ||u_safe - u_nom|| control modification"
  },
  {
    "objectID": "api/types.reachability.CBFResult.html#examples",
    "href": "api/types.reachability.CBFResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Define barrier function (distance to obstacle)\n&gt;&gt;&gt; obstacle_center = np.array([5, 5])\n&gt;&gt;&gt; obstacle_radius = 2.0\n&gt;&gt;&gt; B = lambda x: np.linalg.norm(x - obstacle_center)**2 - obstacle_radius**2\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create CBF controller\n&gt;&gt;&gt; cbf = ControlBarrierFunction(barrier=B, system=robot, gamma=1.0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Filter control at each step\n&gt;&gt;&gt; x = np.array([4, 3])\n&gt;&gt;&gt; u_desired = np.array([1, 1])  # Nominal control (move toward obstacle)\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: CBFResult = cbf.filter_control(x, u_desired)\n&gt;&gt;&gt;\n&gt;&gt;&gt; u_safe = result['safe_control']\n&gt;&gt;&gt; print(f\"Barrier value: {result['barrier_value']:.3f}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['constraint_active']:\n...     print(\"Safety filter active!\")\n...     print(f\"Control modified by: {result['modification_magnitude']:.3f}\")\n... else:\n...     print(\"Nominal control is safe\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply safe control\n&gt;&gt;&gt; x_next = robot.step(x, u_safe)"
  },
  {
    "objectID": "api/visualization.PlotThemes.html",
    "href": "api/visualization.PlotThemes.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/visualization.PlotThemes.html#attributes",
    "href": "api/visualization.PlotThemes.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nDEFAULT\ndict\nStandard Plotly white theme\n\n\nPUBLICATION\ndict\nPublication-ready styling (clean, high-contrast)\n\n\nDARK\ndict\nDark mode theme\n\n\nPRESENTATION\ndict\nLarge fonts and high contrast for presentations"
  },
  {
    "objectID": "api/visualization.PlotThemes.html#examples",
    "href": "api/visualization.PlotThemes.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Apply theme to figure\n&gt;&gt;&gt; fig = plotter.plot_trajectory(t, x)\n&gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme='publication')\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom theme\n&gt;&gt;&gt; custom = PlotThemes.DEFAULT.copy()\n&gt;&gt;&gt; custom['font_size'] = 16\n&gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme=custom)"
  },
  {
    "objectID": "api/visualization.PlotThemes.html#methods",
    "href": "api/visualization.PlotThemes.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\napply_theme\nApply complete theme to Plotly figure.\n\n\nget_line_styles\nGet available line dash patterns.\n\n\n\n\napply_theme\nvisualization.PlotThemes.apply_theme(fig, theme='default')\nApply complete theme to Plotly figure.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfig\ngo.Figure\nPlotly figure to style\nrequired\n\n\ntheme\nstr or dict\nTheme name (‘default’, ‘publication’, ‘dark’, ‘presentation’) or custom theme dictionary\n'default'\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nStyled figure\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Apply publication theme\n&gt;&gt;&gt; fig = plotter.plot_trajectory(t, x)\n&gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme='publication')\n&gt;&gt;&gt; fig.write_html('figure.html')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom theme\n&gt;&gt;&gt; custom = {\n...     'template': 'plotly_white',\n...     'font_family': 'Helvetica',\n...     'font_size': 16,\n... }\n&gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme=custom)\n\n\n\nget_line_styles\nvisualization.PlotThemes.get_line_styles()\nGet available line dash patterns.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nList of Plotly line dash patterns\n\n\n\n\n\nExamples\n&gt;&gt;&gt; styles = PlotThemes.get_line_styles()\n&gt;&gt;&gt; print(styles)\n['solid', 'dot', 'dash', 'longdash', 'dashdot', 'longdashdot']"
  },
  {
    "objectID": "api/types.symbolic.SymbolicMatrix.html",
    "href": "api/types.symbolic.SymbolicMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.symbolic.SymbolicMatrix.html#examples",
    "href": "api/types.symbolic.SymbolicMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; import sympy as sp\n&gt;&gt;&gt; x1, x2 = sp.symbols('x1 x2')\n&gt;&gt;&gt; u = sp.symbols('u')\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Dynamics: dx/dt = f(x, u)\n&gt;&gt;&gt; f: SymbolicMatrix = sp.Matrix([\n...     x2,\n...     -x1 + u\n... ])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Jacobian\n&gt;&gt;&gt; A = f.jacobian([x1, x2])  # 2x2 matrix\n&gt;&gt;&gt; print(A)\n&gt;&gt;&gt; # Matrix([[0, 1], [-1, 0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Access elements\n&gt;&gt;&gt; f[0]  # x2\n&gt;&gt;&gt; f[1]  # -x1 + u"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nFull Langevin equation (position + velocity):\ndx = v·dt\ndv = -(γ/m)·v·dt + (F/m)·dt + √(2·k_B·T/m)·dW\nwhere: - x: Position [m] - v: Velocity [m/s] - m: Particle mass [kg] - γ: Friction coefficient [kg/s] - F: External force (control, potential gradient) [N] - k_B: Boltzmann constant = 1.380649×10⁻²³ J/K - T: Temperature [K] - W: Standard Wiener process\nThis is OU Process for Velocity: Velocity component is Ornstein-Uhlenbeck process."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nNewton’s Law with Fluctuations:\nm·dv/dt = F_total = F_external - γ·v + F_random\nComponents: 1. F_external: Applied force (gravity, fields, control) 2. -γ·v: Friction (Stokes drag, dissipation) 3. F_random: Thermal fluctuations (molecular collisions)\nFriction: For sphere in fluid (Stokes’ law): γ = 6π·η·r\nwhere η is viscosity, r is radius.\nThermal Noise: Fluctuation-dissipation theorem: ⟨F_random(t)·F_random(s)⟩ = 2·γ·k_B·T·δ(t-s)\nWhite noise with intensity √(2·γ·k_B·T).\nTemperature: Sets equilibrium energy scale: ⟨(1/2)·m·v²⟩ = (1/2)·k_B·T (equipartition)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nFluctuation-Dissipation: Friction γ and noise intensity related by temperature. Cannot choose independently!\nThermal Equilibrium: Velocity distribution: Maxwell-Boltzmann p(v) ∝ exp(-m·v²/2k_B·T)\nTwo Time Scales: - Fast: Velocity relaxation τ_v = m/γ - Slow: Position diffusion (no natural scale)\nMarkov Property: Future depends only on current (x, v), not history.\nErgodicity: Long trajectory → Boltzmann distribution."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nVelocity (OU Process):\nFor F = 0 (free particle): Mean: E[v(t)] = v₀·exp(-γ·t/m) Variance: Var[v(t)] = (k_B·T/m)·(1 - exp(-2γ·t/m))\nAsymptotic: Var[v(∞)] = k_B·T/m (equipartition)\nPosition (Diffusion):\nMean: E[x(t)] = x₀ + (m/γ)·v₀·(1 - exp(-γ·t/m)) Variance: Var[x(t)] = 2·D·t - 2·D·(m/γ)·(1 - exp(-γ·t/m))\nLong time: Var[x] ≈ 2·D·t (Einstein diffusion)\nDiffusion Coefficient: D = k_B·T/γ (Einstein relation)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nMass m: - Particle inertia - Heavier → slower velocity changes - Time scale: m/γ\nFriction γ: - Energy dissipation rate - Larger → faster equilibration - From Stokes: γ = 6π·η·r\nTemperature T: - Thermal energy reservoir - Higher T → larger fluctuations - Sets equilibrium distribution\nBoltzmann k_B: - Fundamental constant - Connects microscopic and macroscopic - Value: 1.380649×10⁻²³ J/K"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X = [x, v] ∈ ℝ² - x: Position (unbounded, diffuses) - v: Velocity (Boltzmann distributed at equilibrium)\nControl: u = F/m ∈ ℝ (optional) - Acceleration input - Can be potential gradient: -∇U/m\nNoise: w ∈ ℝ - Single Wiener process - Enters velocity equation (thermal fluctuations)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nm\nfloat\nParticle mass [kg] - Colloidal particle: ~10⁻¹⁵ kg - Protein: ~10⁻²⁰ kg - Affects time scale m/γ\n1e-15\n\n\ngamma\nfloat\nFriction coefficient [kg/s] - From Stokes: 6π·η·r - Water, 1μm sphere: ~10⁻⁸ kg/s\n1e-8\n\n\nT\nfloat\nTemperature [K] - Room temperature: 300 K - Physiological: 310 K - Sets thermal energy k_B·T\n300.0\n\n\nk_B\nfloat\nBoltzmann constant [J/K] - Fundamental constant (fixed)\n1.380649e-23"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: LINEAR (no external force)\nNoise Type: ADDITIVE (constant)\nSDE Type: Itô\nNoise Dimension: nw = 1\nStationary: Velocity (yes), Position (no)\nErgodic: Yes (for velocity distribution)\nPhysical: Yes (fluctuation-dissipation satisfied)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Molecular Dynamics: - Thermostat (constant T simulations) - Protein folding simulations - Material properties\n2. Bayesian Sampling: - Langevin MCMC - Posterior sampling - Optimization with noise\n3. Colloidal Physics: - Optical tweezers experiments - Rheology measurements - Single-molecule biophysics\n4. Machine Learning: - Stochastic gradient Langevin dynamics - Bayesian neural networks - Exploration in RL\n5. Statistical Mechanics: - Equilibrium sampling - Free energy calculations - Rare event simulation"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nTime Step Selection:\nMust resolve velocity relaxation: Δt &lt; m/γ (typically 0.1·m/γ)\nFor colloidal particle (m/γ ~ 10⁻⁷ s): Δt ~ 10⁻⁸ s\nOverdamped Approximation:\nIf observation time &gt;&gt; m/γ, use: dx = (F/γ)·dt + √(2·D)·dW\nMuch larger Δt possible (no velocity constraint)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#validation",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#validation",
    "title": "",
    "section": "Validation",
    "text": "Validation\nPhysical Checks:\n\nEquipartition: Var[v] = k_B·T/m (after equilibration)\nEinstein Relation: D_measured = Var[x]/2t should equal k_B·T/γ\nMaxwell-Boltzmann: Velocity histogram should be Gaussian with variance k_B·T/m\nAutocorrelation: ⟨v(0)·v(t)⟩ = (k_B·T/m)·exp(-γ·t/m)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#comparison-with-other-models",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#comparison-with-other-models",
    "title": "",
    "section": "Comparison with Other Models",
    "text": "Comparison with Other Models\nvs. Brownian Motion: - BM: Position only, no velocity - Langevin: Position + velocity (more complete)\nvs. Ornstein-Uhlenbeck: - OU: Velocity equation only - Langevin: Position + velocity\nvs. Stochastic Double Integrator: - DI: No friction (conservative) - Langevin: With friction (dissipative, equilibrium)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nLinear (no potential in base class)\n1D space (extend to 3D for realism)\nConstant γ, T (no hydrodynamic interactions)\nAdditive noise (no multiplicative)\nMarkov (memoryless, no viscoelasticity)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nPotential: Add U(x) via control F = -∇U\n3D: Three spatial dimensions\nGeneralized Langevin: Memory kernel (viscoelasticity)\nActive particles: Self-propulsion\nHydrodynamic interactions: Many-body γ_ij"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nOrnsteinUhlenbeck : Velocity-only version StochasticDoubleIntegrator : No friction version"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.LangevinDynamics.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncheck_fluctuation_dissipation\nVerify fluctuation-dissipation theorem is satisfied.\n\n\ndefine_system\nDefine Langevin dynamics (position + velocity with thermal noise).\n\n\nget_diffusion_coefficient\nGet diffusion coefficient D = k_B·T/γ (Einstein relation).\n\n\nget_relaxation_time\nGet velocity relaxation time τ_v = m/γ.\n\n\nget_thermal_velocity_std\nGet thermal velocity standard deviation from equipartition.\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ncheck_fluctuation_dissipation\nsystems.builtin.stochastic.continuous.LangevinDynamics.check_fluctuation_dissipation(\n)\nVerify fluctuation-dissipation theorem is satisfied.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nExpected vs implemented noise intensity\n\n\n\n\n\nExamples\n&gt;&gt;&gt; langevin = LangevinDynamics()\n&gt;&gt;&gt; check = langevin.check_fluctuation_dissipation()\n&gt;&gt;&gt; print(f\"FDT satisfied: {check}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.LangevinDynamics.define_system(\n    m=1e-15,\n    gamma=1e-08,\n    T=300.0,\n    k_B=1.380649e-23,\n)\nDefine Langevin dynamics (position + velocity with thermal noise).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nm\nfloat\nParticle mass [kg] - Colloidal particle: ~10⁻¹⁵ kg - Protein: ~10⁻²⁰ kg - Determines time scale m/γ\n1e-15\n\n\ngamma\nfloat\nFriction coefficient [kg/s] - From Stokes: γ = 6π·η·r - Water, 1μm sphere: ~10⁻⁸ kg/s - Controls relaxation rate\n1e-8\n\n\nT\nfloat\nTemperature [K] - Room temperature: 300 K - Physiological: 310 K - Sets thermal energy k_B·T\n300.0\n\n\nk_B\nfloat\nBoltzmann constant [J/K] - Physical constant (don’t change)\n1.380649e-23\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf m, gamma, T, or k_B are non-positive\n\n\n\n\n\nNotes\nFluctuation-Dissipation:\nNoise intensity MUST be: σ = √(2·γ·k_B·T/m)\nThis is not a free parameter! Determined by γ, T.\nTime Scales:\nVelocity relaxation: τ_v = m/γ - Fast equilibration of velocity - After ~5·τ_v: Velocity is Maxwellian\nPosition diffusion: No characteristic time - Variance grows linearly: 2·D·t - Diffusion coefficient: D = k_B·T/γ\nRegime Classification:\nUnderdamped: m/γ &gt;&gt; observation time - Ballistic short-time: ⟨x²⟩ ~ t² (free flight) - Diffusive long-time: ⟨x²⟩ ~ t (Brownian)\nOverdamped: m/γ &lt;&lt; observation time - Pure diffusion: ⟨x²⟩ ~ t always - Can use simplified equation (position only)\nPhysical Examples:\nColloidal particle (1 μm, water, 300 K): - m ~ 10⁻¹⁵ kg - γ ~ 10⁻⁸ kg/s - τ_v ~ 10⁻⁷ s (100 ns) - D ~ 4×10⁻¹³ m²/s\nProtein in water: - m ~ 10⁻²⁰ kg - γ ~ 10⁻¹¹ kg/s - τ_v ~ 10⁻⁹ s (1 ns) - D ~ 10⁻¹¹ m²/s\nValidation:\nCheck equilibrium properties: 1. Velocity variance: k_B·T/m 2. Diffusion coefficient: k_B·T/γ 3. Velocity autocorrelation: exp(-γ·t/m)\n\n\n\nget_diffusion_coefficient\nsystems.builtin.stochastic.continuous.LangevinDynamics.get_diffusion_coefficient(\n)\nGet diffusion coefficient D = k_B·T/γ (Einstein relation).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDiffusion coefficient [m²/s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; langevin = LangevinDynamics(gamma=1e-8, T=300)\n&gt;&gt;&gt; D = langevin.get_diffusion_coefficient()\n&gt;&gt;&gt; print(f\"Diffusion: {D:.3e} m²/s\")\n\n\n\nget_relaxation_time\nsystems.builtin.stochastic.continuous.LangevinDynamics.get_relaxation_time()\nGet velocity relaxation time τ_v = m/γ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nRelaxation time [s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; langevin = LangevinDynamics(m=1e-15, gamma=1e-8)\n&gt;&gt;&gt; tau = langevin.get_relaxation_time()\n&gt;&gt;&gt; print(f\"Relaxation: {tau:.3e} s\")\n\n\n\nget_thermal_velocity_std\nsystems.builtin.stochastic.continuous.LangevinDynamics.get_thermal_velocity_std(\n)\nGet thermal velocity standard deviation from equipartition.\nσ_v = √(k_B·T/m)\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nThermal velocity std [m/s]\n\n\n\n\n\nNotes\nFrom equipartition: ⟨(1/2)·m·v²⟩ = (1/2)·k_B·T\n\n\nExamples\n&gt;&gt;&gt; langevin = LangevinDynamics(m=1e-15, T=300)\n&gt;&gt;&gt; sigma_v = langevin.get_thermal_velocity_std()\n&gt;&gt;&gt; print(f\"Thermal velocity: {sigma_v:.3e} m/s\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.continuous.LangevinDynamics.setup_equilibria()\nSet up equilibrium points.\nFor free Langevin (u=0), equilibrium is origin with thermal velocity."
  },
  {
    "objectID": "api/types.control_advanced.MHEResult.html",
    "href": "api/types.control_advanced.MHEResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_advanced.MHEResult.html#fields",
    "href": "api/types.control_advanced.MHEResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nstate_estimate : StateVector Current optimal state estimate x̂[k] (nx,) covariance_estimate : CovarianceMatrix Estimated covariance P̂[k] (nx, nx) state_trajectory : StateTrajectory Estimated trajectory over horizon (N, nx) cost : float Estimation objective value success : bool Whether optimization succeeded solve_time : float Computation time in seconds innovation_sequence : OutputSequence Measurement residuals y - Cx̂ (N, ny)"
  },
  {
    "objectID": "api/types.control_advanced.MHEResult.html#examples",
    "href": "api/types.control_advanced.MHEResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Setup MHE\n&gt;&gt;&gt; mhe = MovingHorizonEstimator(\n...     system, horizon=10, Q_process=0.01*np.eye(2), R_meas=0.1*np.eye(1)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update with new measurement\n&gt;&gt;&gt; y_meas = np.array([1.2])\n&gt;&gt;&gt; u_applied = np.array([0.5])\n&gt;&gt;&gt; result: MHEResult = mhe.update(y_meas, u_applied)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use state estimate\n&gt;&gt;&gt; x_hat = result['state_estimate']\n&gt;&gt;&gt; P_hat = result['covariance_estimate']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check innovation\n&gt;&gt;&gt; innovations = result['innovation_sequence']\n&gt;&gt;&gt; innovation_norm = np.linalg.norm(innovations[-1])"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA continuous flow reactor where reactant A converts to product B in an exothermic reaction. The CSTR is one of the most studied nonlinear systems in chemical engineering, exhibiting rich dynamics including: - Multiple steady states (multiplicity) - Sustained oscillations (limit cycles) - Bifurcations and hysteresis - Thermal runaway behavior\nUnlike batch reactors, CSTRs operate continuously with: - Continuous feed stream entering at Cₐ,feed, T_feed - Continuous product stream leaving at reactor conditions - Perfect mixing assumption (uniform concentration and temperature) - External cooling/heating via jacket\nThe CSTR represents a fundamental model in: - Process control (benchmark nonlinear system) - Nonlinear dynamics (canonical example of multiplicity) - Chemical reaction engineering (industrial reactor design) - Bifurcation theory (illustrates saddle-node, Hopf bifurcations)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [Cₐ, T] Concentration state: - Cₐ: Concentration of reactant A in reactor [mol/L] * Governed by material balance: in - out - reaction * 0 ≤ Cₐ ≤ Cₐ,feed (bounded by feed concentration) * Low Cₐ → high conversion (desired but challenging to control) * High Cₐ → low conversion (safe but inefficient)\nTemperature state:\n- T: Reactor temperature [K]\n  * Governed by energy balance: in - out + generation - removal\n  * Typically T &gt; T_feed for exothermic reactions\n  * Exhibits strong nonlinear coupling with concentration\n  * Critical for safety (runaway prevention)\n  * Small changes can cause large rate changes (Arrhenius)\nControl: u = [T_jacket] - T_jacket: Cooling jacket temperature [K] * Primary manipulated variable for temperature control * Affects heat removal rate via UA·(T - T_jacket) * Typically T_jacket &lt; T (cooling mode) * Can be T_jacket &gt; T (heating mode for startup/cold days) * Physical constraints: chiller/heater capacity limits * Rate constraints: jacket dynamics (not modeled here)\nOutput: y = [Cₐ, T] - Full state measurement (common in modern plants) - In practice: * Cₐ: Online analyzer (GC, HPLC, NIR spectroscopy) * T: Thermocouple or RTD (fast, reliable) * Both have measurement noise and potential delays"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe continuous-time CSTR dynamics are:\ndCₐ/dt = (F/V)·(Cₐ,feed - Cₐ) - r\ndT/dt = (F/V)·(T_feed - T) + (-ΔH/ρCₚ)·r + UA/(VρCₚ)·(T_jacket - T)\nReaction Rate (Arrhenius kinetics): r = k₀·Cₐ·exp(-E/T) [mol/(L·s)]\nwhere: - k₀: Pre-exponential factor [1/s] * Collision frequency in Arrhenius equation * Typical range: 10⁶-10¹² for liquid-phase reactions * Material and reaction-specific constant - E: Activation energy [K] (dimensionless Eₐ/R) * Energy barrier for reaction to occur * Typical range: 5,000-15,000 K for Eₐ/R * Higher E → more temperature-sensitive reaction * Physical activation energy Eₐ typically 40-120 kJ/mol - exp(-E/T): Arrhenius temperature dependence * Exponential sensitivity creates strong nonlinearity * 10°C change can double/triple reaction rate * Source of multiple steady states and instability\nPhysical Interpretation of Each Term:\nMaterial Balance (dCₐ/dt): 1. (F/V)·(Cₐ,feed - Cₐ): Convective in/out - F/V = 1/τ: Inverse residence time [1/s] - τ = V/F: Average time molecule spends in reactor [s] - Positive when Cₐ &lt; Cₐ,feed (dilution effect) - Acts as “restoring force” toward feed concentration - Time scale: τ (seconds to minutes)\n\n-r: Consumption by reaction\n\nAlways negative (reactant consumed)\nExponentially increases with temperature\nDepends on current concentration (first-order)\nTime scale: 1/k (fast at high T, slow at low T)\n\n\nAt steady state: inflow rate = outflow rate + reaction rate\nEnergy Balance (dT/dt): 1. (F/V)·(T_feed - T): Convective heat in/out - Negative when T &gt; T_feed (typical for exothermic) - Same time scale as material balance (1/τ) - Acts as “restoring force” toward feed temperature\n\n(-ΔH/ρCₚ)·r: Heat generation from reaction\n\nPositive for exothermic reaction (ΔH &lt; 0)\nCouples concentration to temperature\nCreates positive feedback: higher T → faster r → more heat\nThis term causes thermal runaway if unchecked\nMagnitude: |ΔH|/(ρCₚ) is adiabatic temperature rise per mol/L\n\nUA/(VρCₚ)·(T_jacket - T): Heat removal via jacket\n\nNegative when T &gt; T_jacket (cooling)\nOnly term controlled by manipulated variable\nUA: Overall heat transfer coefficient × area [J/(s·K)]\nLarger UA → better temperature control\nTime scale: VρCₚ/UA (thermal time constant)\n\n\nAt steady state: heat in + heat generated = heat out + heat removed\nNonlinear Coupling and Feedback:\nThe CSTR exhibits strong positive feedback that can lead to instability:\n\nThermal Feedback Loop (Runaway Mechanism): T ↑ → r ↑ (Arrhenius) → heat generation ↑ → T ↑ (positive feedback)\nThis loop is stabilized by:\n\nConvective cooling: higher T → more heat removal to feed\nJacket cooling: higher T → more heat removal via jacket\nReactant depletion: higher r → lower Cₐ → lower r (negative feedback)\n\nMaterial-Thermal Coupling:\n\nHigh T → fast reaction → low Cₐ (depletion)\nLow Cₐ → slow reaction → less heat generation → lower T\nThis coupling creates multiple possible steady states\n\nCompetition Between Time Scales:\n\nResidence time τ = V/F (convective transport)\nReaction time 1/k (chemical kinetics)\nThermal time VρCₚ/UA (heat transfer)\nRelative magnitudes determine stability and multiplicity"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nF : float, default=100.0 Volumetric flow rate [L/s] - Controls residence time τ = V/F - Higher F → shorter τ → lower conversion but more stable - Lower F → longer τ → higher conversion but less stable - Typical range: 10-1000 L/s depending on reactor size - Often kept constant (set by upstream/downstream constraints)\nV : float, default=100.0 Reactor volume [L] - Combined with F to give residence time τ - Larger V → more material holdup → slower dynamics - Typical range: 100-10,000 L for industrial reactors - Design parameter (fixed once reactor is built)\nC_A_feed : float, default=1.0 Feed concentration [mol/L] - Upper bound for reactor concentration - Higher feed → more product but more heat generation - Typical range: 0.1-10 mol/L - Often a disturbance variable (feed composition changes)\nT_feed : float, default=350.0 Feed temperature [K] - Inlet stream temperature - Typical range: 280-360 K (ambient to pre-heated) - Can be manipulated for control but usually fixed - Feed pre-heating can improve conversion but reduces stability margin\nk0 : float, default=7.2e10 Pre-exponential factor [1/s] - Arrhenius equation parameter - Determines reaction speed at given temperature - Typical range: 10⁶-10¹² for liquid phase - Reaction and catalyst specific - Obtained from kinetic experiments or literature\nE : float, default=8750.0 Activation energy [K] (actually Eₐ/R, dimensionless) - Energy barrier for reaction to occur - Higher E → more temperature-sensitive - Typical range: 5,000-15,000 K for Eₐ/R - Physical Eₐ typically 40-120 kJ/mol - Key parameter determining multiplicity region - Strong influence on stability\ndelta_H : float, default=-5e4 Heat of reaction [J/mol] - Energy released (negative) or absorbed (positive) per mole reacted - Negative = exothermic (releases heat) - most common case - Positive = endothermic (absorbs heat) - rare, simpler control - Typical for exothermic: -20,000 to -200,000 J/mol - Magnitude determines thermal coupling strength - Larger |ΔH| → stronger feedback → more multiplicity/instability\nrho : float, default=1000.0 Density [kg/L] - Fluid density (assumed constant) - Typical for aqueous solutions: 900-1,100 kg/L - Affects thermal mass (heat capacity of reactor contents)\nCp : float, default=0.239 Specific heat capacity [J/(kg·K)] - Heat required to raise 1 kg by 1 K - Typical for aqueous: 0.2-0.5 J/(kg·K) - Note: Using J/(kg·K) not kJ/(kg·K), hence small value - Combined with ρ gives volumetric heat capacity ρCₚ - Higher Cₚ → larger thermal inertia → slower temperature changes\nUA : float, default=5e4 Overall heat transfer coefficient × area [J/(s·K)] - Lumped parameter combining: * Jacket-side film coefficient * Wall thermal conductivity * Reactor-side film coefficient * Heat transfer area - Typical range: 10³-10⁵ J/(s·K) - Higher UA → better temperature control, faster cooling - Limited by physical design (jacket size, flow rate, area) - Critical parameter for preventing runaway"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#equilibria-and-multiple-steady-states",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#equilibria-and-multiple-steady-states",
    "title": "",
    "section": "Equilibria and Multiple Steady States:",
    "text": "Equilibria and Multiple Steady States:\nThe Hallmark of CSTR Dynamics\nThe CSTR is famous for exhibiting multiple steady states - a phenomenon called multiplicity. For a given set of operating conditions (feed conditions and jacket temperature), the reactor can have:\n\nOne steady state (unique solution)\nThree steady states (two stable, one unstable)\nFive steady states (rare, special parameter combinations)\n\nThree Steady State Scenario (most common interesting case):\n\nLow-Conversion State (Stable):\n\nLow temperature (T ≈ T_feed + 10-30 K)\nHigh reactant concentration (Cₐ ≈ 0.7-0.9·Cₐ,feed)\nSlow reaction rate (low k·exp(-E/T))\nHeat generation &lt; Heat removal capacity\nBasin of attraction: States with low initial temperature\nCharacteristics:\n\nEasy to start up (cold startup naturally goes here)\nSafe and stable\nEconomically poor (low conversion, wasted reactant)\nEasy to control (large stability margins)\n\n\nIntermediate State (Unstable):\n\nModerate temperature\nModerate concentration\nSaddle point in phase space\nNot physically realizable (unstable equilibrium)\nActs as separatrix between basins of attraction\nPhysical meaning: Transition point where thermal generation rate exactly balances heat removal rate, but balance is unstable\n\nHigh-Conversion State (Stable):\n\nHigh temperature (T ≈ T_feed + 50-100 K)\nLow reactant concentration (Cₐ ≈ 0.05-0.3·Cₐ,feed)\nFast reaction rate (high k·exp(-E/T))\nLarge heat generation balanced by cooling\nBasin of attraction: States with high initial temperature\nCharacteristics:\n\nDesired operating point (high conversion = high profit)\nRequires good startup procedure (must cross unstable intermediate)\nRisk of runaway if cooling fails\nSmaller stability margins (closer to instability boundary)\nMore challenging to control (strong nonlinearity)\n\n\n\nPhysical Intuition for Multiple Steady States:\nImagine heat generation curve vs heat removal curve: - Heat generation: S-shaped (Arrhenius kinetics) * Low T: generation small (slow reaction) * Medium T: generation increases rapidly (exponential activation) * High T: generation levels off (reactant depletion)\n\nHeat removal: Linear in T (jacket cooling)\n\nStraight line: q_removal = UA·(T - T_jacket)/VρCₚ\nPlus convective: (F/V)·(T - T_feed)\n\n\nIntersections of these curves = steady states: - If removal line is steep (large UA): unique high-conversion state - If removal line is shallow (small UA): can have 3 intersections - As T_jacket varies: intersections appear/disappear (bifurcations)\nStability of Steady States:\nLinear stability analysis (eigenvalues of Jacobian): - Stable: Both eigenvalues have negative real parts (LHP) * Perturbations decay back to steady state * Can operate here sustainably - Unstable: At least one eigenvalue has positive real part (RHP) * Perturbations grow exponentially * Cannot operate here (physically unrealizable)\nFor CSTR: - Low-conversion state: Typically stable - Intermediate state: Always unstable (saddle point) - High-conversion state: Stable if cooling is adequate\nBifurcations (Qualitative changes in behavior):\n\nSaddle-Node Bifurcation (Fold): As T_jacket decreases (more cooling):\n\nInitially: Only low-conversion state exists\nAt bifurcation point: Two new states appear (intermediate + high)\nFurther cooling: Three states coexist\nHysteresis: Different paths for heating vs cooling\n\nHopf Bifurcation (Oscillations): At certain parameters, high-conversion state can lose stability via Hopf bifurcation → sustained oscillations (limit cycle)\n\nTemperature and concentration oscillate periodically\nCan occur with insufficient cooling or long residence time\nIndicates poor controllability\n\n\nFinding Steady States:\nSteady states satisfy: dCₐ/dt = 0, dT/dt = 0\nThis gives two coupled nonlinear algebraic equations: 1. (F/V)·(Cₐ,feed - Cₐ) = k₀·Cₐ·exp(-E/T) 2. (F/V)·(T_feed - T) + (-ΔH/ρCₚ)·k₀·Cₐ·exp(-E/T) = -UA/(VρCₚ)·(T_jacket - T)\nSolution methods: - Numerical: Newton-Raphson, fsolve with multiple initial guesses - Graphical: Plot dCₐ/dt and dT/dt surfaces, find intersections - Continuation: Track solutions as parameters vary (AUTO, MATCONT)\nSee find_steady_states() method for implementation."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#control-objectives",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\n\nSetpoint Regulation (Most Common):\n\nMaintain reactor at high-conversion steady state\nReject disturbances (feed composition, flow rate, ambient temperature)\nControllers: PID, LQR, MPC\nChallenge: Strong nonlinearity, operate near instability\n\nStartup Control:\n\nTransition from low-conversion to high-conversion state\nMust cross unstable intermediate state (separatrix crossing)\nRequires aggressive transient cooling\nStrategies:\n\nBang-bang cooling (maximum jacket cooling)\nOptimal control (minimize time/energy)\nGain scheduling (change controller as state changes)\n\nRisk: Overshoot → runaway\n\nRunaway Prevention (Safety Critical):\n\nDetect incipient runaway conditions\nImplement emergency cooling/shutdown\nMonitor dT/dt (temperature rate of change)\nConstraint: T &lt; T_max (safety limit)\nLast resort: Emergency cooling, feed shutoff, depressurization\n\nEconomic Optimization:\n\nMaximize profit = revenue - costs\nRevenue: Product value = price × F × conversion\nCosts: Cooling energy, reactant waste, equipment wear\nOften operates close to instability boundary for maximum conversion\nTradeoff: Higher conversion (profit) vs safety margin (risk)\n\nDisturbance Rejection: Common disturbances:\n\nFeed concentration variations: Cₐ,feed(t)\nFeed temperature changes: T_feed(t)\nFlow rate fluctuations: F(t)\nAmbient temperature (affects jacket): T_ambient(t)\nCatalyst deactivation: k₀(t) decreases slowly"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#state-constraints",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\n\nNon-negativity: Cₐ ≥ 0\n\nConcentration cannot be negative (physical)\nRarely active (implies complete conversion)\n\nConcentration Bounds: 0 ≤ Cₐ ≤ Cₐ,feed\n\nCannot exceed feed (dilution + reaction only decrease)\nUpper bound active only if no reaction occurs\n\nTemperature Limits: T_min ≤ T ≤ T_max\n\nLower limit: Prevent solidification/freezing (≈ 280 K)\nUpper limit: Safety, prevent runaway (≈ 450-500 K)\nMaterial limits: polymer degradation, wall integrity\nMost critical constraint for safety\n\nJacket Temperature Limits: T_jacket,min ≤ T_jacket ≤ T_jacket,max\n\nChiller capacity: T_jacket,min ≈ 280 K\nHeater capacity: T_jacket,max ≈ 400 K\nRate limit: |dT_jacket/dt| ≤ rate_max (jacket dynamics)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#time-scales-and-dynamics",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#time-scales-and-dynamics",
    "title": "",
    "section": "Time Scales and Dynamics:",
    "text": "Time Scales and Dynamics:\nMultiple Time Scales make CSTR dynamics rich and challenging:\n\nFast Scale - Reaction: t_reaction = 1/k\n\nAt low T (350 K): t_reaction ≈ 10-100 s\nAt high T (400 K): t_reaction ≈ 0.1-1 s\nExponentially dependent on temperature\nCan be very fast at high conversion state\n\nMedium Scale - Residence Time: t_residence = τ = V/F\n\nTypical: 10-1000 s (seconds to minutes)\nTime for complete turnover of reactor contents\nNatural time scale for concentration changes\nDesign parameter\n\nSlow Scale - Thermal: t_thermal = VρCₚ/UA\n\nTypical: 100-10,000 s (minutes to hours)\nTime constant for temperature response\nLimited by heat transfer through jacket\nDesign parameter (limited by area, jacket design)\n\n\nStiffness: When time scales differ by orders of magnitude: - Fast reactions with slow heat transfer → stiff system - Requires implicit ODE solvers (Radau, BDF) - Small numerical errors in fast variables → large errors in slow variables"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#integration-recommendations",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#integration-recommendations",
    "title": "",
    "section": "Integration Recommendations:",
    "text": "Integration Recommendations:\nSolver Selection:\nFor most CSTR problems: - Moderate stiffness: RK45 (adaptive Runge-Kutta) works well - High stiffness: Use stiff solvers * scipy: Radau, BDF, LSODA (auto-switching) * Julia (DiffEqPy): Rosenbrock23, Rodas5\nTolerance Selection: - Standard simulation: rtol=1e-6, atol=1e-8 - High accuracy (optimization): rtol=1e-9, atol=1e-11 - Looser tolerances may miss important dynamics\nEvent Detection: For safety-critical applications, use event detection: - Detect T &gt; T_max (runaway) - Detect dT/dt &gt; threshold (incipient runaway) - Detect steady state (convergence)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#example-usage",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate CSTR with default parameters\ncstr = ContinuousCSTR(F=100.0, V=100.0)\nFind all steady states for given jacket temperature\nT_jacket_op = 350.0 steady_states = cstr.find_steady_states(T_jacket_op) print(f”Found {len(steady_states)} steady states:“) for i, (C_A, T) in enumerate(steady_states): … print(f” State {i+1}: Cₐ={C_A:.3f} mol/L, T={T:.1f} K”) … print(f” Conversion: {cstr.compute_conversion(C_A, 1.0)*100:.1f}%“)\nChoose high-conversion operating point\nif len(steady_states) &gt;= 2: … # High-conversion state (highest T, lowest Cₐ) … steady_states_sorted = sorted(steady_states, key=lambda x: x[1], reverse=True) … C_A_op, T_op = steady_states_sorted[0] … x_op = np.array([C_A_op, T_op]) … u_op = np.array([T_jacket_op]) … else: … # Use provided or default operating point … x_op = np.array([0.1, 390.0]) … u_op = np.array([350.0])\nVerify equilibrium\ndx = cstr(x_op, u_op) print(f”check: ||dx/dt|| = {np.linalg.norm(dx):.2e}“)\nLinearize at operating point\nA, B = cstr.linearize(x_op, u_op) eigenvalues = np.linalg.eigvals(A) print(f”eigenvalues: {eigenvalues}“) print(f”Stable: {np.all(np.real(eigenvalues) &lt; 0)}“)\nDesign LQR controller (emphasize temperature control)\nQ = np.diag([1.0, 100.0]) # Penalize temperature error heavily R = np.array([[1.0]]) lqr_result = cstr.control.design_lqr(A, B, Q, R, system_type=‘continuous’) K = lqr_result[‘gain’]\nSimulate with LQR control and disturbance\ndef lqr_controller(x, t): … # Add feed temperature disturbance at t=50s … if t &gt; 50: … # Disturbance increases effective T_feed by changing heat balance … # Compensate by reducing jacket temperature … disturbance_compensation = -2.0 … else: … disturbance_compensation = 0.0 … … u_fb = -K @ (x - x_op) + u_op … return u_fb + disturbance_compensation\nPerturb from equilibrium\nx0 = x_op + np.array([0.05, -5.0]) # Small perturbation\nresult = cstr.simulate( … x0=x0, … controller=lqr_controller, … t_span=(0, 200), … dt=0.1, … method=‘Radau’ # Stiff solver … )\nPlot results\nimport matplotlib.pyplot as plt fig, axes = plt.subplots(3, 1, figsize=(10, 8))\nConcentration\naxes[0].plot(result[‘time’], result[‘states’][:, 0]) axes[0].axhline(x_op[0], color=‘r’, linestyle=‘–’, label=‘Setpoint’) axes[0].set_ylabel(‘Cₐ [mol/L]’) axes[0].legend() axes[0].grid(True)\nTemperature\naxes[1].plot(result[‘time’], result[‘states’][:, 1]) axes[1].axhline(x_op[1], color=‘r’, linestyle=‘–’, label=‘Setpoint’) axes[1].set_ylabel(‘T [K]’) axes[1].legend() axes[1].grid(True)\nControl action\naxes[2].plot(result[‘time’], result[‘controls’][:, 0]) axes[2].axhline(u_op[0], color=‘r’, linestyle=‘–’, label=‘Nominal’) axes[2].set_ylabel(‘T_jacket [K]’) axes[2].set_xlabel(‘Time [s]’) axes[2].legend() axes[2].grid(True)\nplt.tight_layout() plt.show()\nStartup simulation: low → high conversion\nStart at low-conversion steady state\nif len(steady_states) &gt;= 3: … C_A_low, T_low = steady_states_sorted[-1] # Lowest temperature state … x_low = np.array([C_A_low, T_low]) … else: … x_low = np.array([0.9, 360.0])\ndef startup_controller(x, t): … ’‘’Aggressive cooling for startup, then switch to regulator’’’ … if t &lt; 100: … # Phase 1: Aggressive cooling to jump to high-conversion state … return np.array([330.0]) # Cold jacket … else: … # Phase 2: LQR regulation around high-conversion setpoint … return lqr_controller(x, t)\nresult_startup = cstr.simulate( … x0=x_low, … controller=startup_controller, … t_span=(0, 300), … dt=0.1, … method=‘Radau’ … )\nCheck if startup succeeded\nfinal_state = result_startup[‘states’][-1, :] distance = np.linalg.norm(final_state - x_op) print(f”result:“) print(f” Final state: Cₐ={final_state[0]:.3f}, T={final_state[1]:.1f}“) print(f” Distance to target: {distance:.3f}“) print(f” Success: {distance &lt; 5.0}“)\nPhase portrait (requires multiple simulations)\nShows basins of attraction for multiple steady states\nBifurcation diagram (vary T_jacket)\nT_jacket_range = np.linspace(320, 360, 20) bifurcation_data = {‘T_jacket’: [], ‘C_A’: [], ‘T’: [], ‘stable’: []}\nfor Tj in T_jacket_range: … states = cstr.find_steady_states(Tj) … for C_A, T in states: … # Check stability … A_local, _ = cstr.linearize(np.array([C_A, T]), np.array([Tj])) … eigs = np.linalg.eigvals(A_local) … is_stable = np.all(np.real(eigs) &lt; 0) … … bifurcation_data[‘T_jacket’].append(Tj) … bifurcation_data[‘C_A’].append(C_A) … bifurcation_data[‘T’].append(T) … bifurcation_data[‘stable’].append(is_stable)\nPlot bifurcation diagram\nplt.figure(figsize=(10, 6)) stable = np.array(bifurcation_data[‘stable’]) plt.plot( … np.array(bifurcation_data[‘T_jacket’])[stable], … np.array(bifurcation_data[‘T’])[stable], … ‘b-’, linewidth=2, label=‘Stable’ … ) plt.plot( … np.array(bifurcation_data[‘T_jacket’])[~stable], … np.array(bifurcation_data[‘T’])[~stable], … ‘r–’, linewidth=2, label=‘Unstable’ … ) plt.xlabel(‘Jacket Temperature [K]’) plt.ylabel(‘Reactor Temperature [K]’) plt.title(‘CSTR Bifurcation Diagram’) plt.legend() plt.grid(True) plt.show()"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#physical-insights",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nWhy Multiple Steady States Occur:\nThe interplay between heat generation (nonlinear, S-shaped) and heat removal (linear) creates the possibility of multiple intersections:\n\nLow T region:\n\nReaction slow (small exp(-E/T))\nGeneration curve starts flat\nRemoval line dominates → low-conversion stable\n\nMedium T region:\n\nReaction accelerates rapidly (exponential growth)\nGeneration curve steepens dramatically\nCan intersect removal line 3 times\n\nHigh T region:\n\nReaction very fast but Cₐ depleted\nGeneration curve plateaus (limited by Cₐ)\nRemoval continues linearly → high-conversion stable\n\n\nThermal Runaway Mechanism:\nPositive feedback loop if cooling insufficient: 1. Small T increase (disturbance or control action) 2. Reaction rate jumps (exponential Arrhenius) 3. More heat generated (exothermic) 4. Temperature rises further 5. Loop continues → runaway!\nStabilizing mechanisms: - Reactant depletion (limits generation at high T) - Jacket cooling (removes heat) - Feed cooling (convective heat removal)\nIndustrial Significance:\nCSTRs are ubiquitous in chemical industry: - Polymerization reactors - Pharmaceutical synthesis - Wastewater treatment (biological reactors) - Fermentation processes\nMultiple steady states have practical implications: - Startup: Complex procedure to reach desired state - Control: Must prevent unintended switching - Safety: Runaway risk at high-conversion state - Economics: Higher conversion → more profit but harder control\nControl Challenges:\n\nNonlinearity:\n\nLinear controllers (PID) may perform poorly\nGain scheduling or nonlinear control needed\nOperating point dependent behavior\n\nInstability risk:\n\nHigh-conversion state often close to instability\nSmall disturbances can cause large excursions\nNeed fast, aggressive control action\n\nConstraints:\n\nTemperature limits (safety)\nJacket temperature limits (physical)\nActuator saturation degrades performance\n\nMultiple states:\n\nSystem can “jump” between states\nHysteresis complicates control\nNeed to prevent unintended transitions\n\n\nDesign Considerations:\nFor industrial CSTR design: - Safety first: Adequate cooling capacity (large UA) - Residence time: Balance conversion vs stability (choose V/F) - Operating point: High conversion but safe margin from instability - Instrumentation: Fast, reliable temperature measurement - Emergency systems: Backup cooling, feed shutoff, pressure relief"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#comparison-with-other-reactors",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#comparison-with-other-reactors",
    "title": "",
    "section": "Comparison with Other Reactors:",
    "text": "Comparison with Other Reactors:\nCSTR vs Batch Reactor: - CSTR: Continuous operation, steady state, higher throughput - Batch: Transient operation, finite time, better for small volumes\nCSTR vs Plug Flow Reactor (PFR): - CSTR: Back-mixed, uniform concentration/temperature - PFR: No back-mixing, concentration/temperature gradients - PFR: Generally more efficient but harder to control\nCSTR vs Semi-Batch: - CSTR: Continuous in/out - Semi-batch: Batch with continuous feed, better heat management"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDiscreteCSTR : Discrete-time version for digital control ContinuousBatchReactor : Batch operation instead of continuous DiscreteBatchReactor : Discrete batch reactor"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#notes",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#notes",
    "title": "",
    "section": "Notes:",
    "text": "Notes:\nExtensions: More complex CSTR models can include: - Multiple reactions (A → B → C, parallel reactions) - Non-ideal mixing (RTD, compartment models) - Jacket dynamics (first-order lag in cooling) - Catalyst deactivation (slow time scale) - pH effects (additional state) - Gas-liquid reactions (mass transfer limitations)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#methods",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousCSTR.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_conversion\nCompute fractional conversion of reactant A.\n\n\ncompute_damkohler_number\nCompute Damköhler number Da = k·τ (reaction rate × residence time).\n\n\ncompute_residence_time\nCompute residence time τ = V/F.\n\n\ndefine_system\nDefine continuous-time CSTR dynamics.\n\n\nfind_steady_states\nFind all steady states for a given jacket temperature.\n\n\nsetup_equilibria\nSet up steady-state equilibrium if provided.\n\n\n\n\ncompute_conversion\nsystems.builtin.deterministic.continuous.ContinuousCSTR.compute_conversion(\n    C_A,\n    C_A_feed,\n)\nCompute fractional conversion of reactant A.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_A\nfloat\nCurrent reactor concentration [mol/L]\nrequired\n\n\nC_A_feed\nfloat\nFeed concentration [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nConversion fraction X_A = (C_A_feed - C_A) / C_A_feed\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = ContinuousCSTR()\n&gt;&gt;&gt; X = cstr.compute_conversion(C_A=0.1, C_A_feed=1.0)\n&gt;&gt;&gt; print(f\"Conversion: {X*100:.1f}%\")\nConversion: 90.0%\n\n\nNotes\nHigh conversion (X &gt; 0.9) typically corresponds to high-temperature steady state with fast kinetics and strong exothermic heat generation.\n\n\n\ncompute_damkohler_number\nsystems.builtin.deterministic.continuous.ContinuousCSTR.compute_damkohler_number(\n    T,\n)\nCompute Damköhler number Da = k·τ (reaction rate × residence time).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT\nfloat\nTemperature [K]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDamköhler number [dimensionless]\n\n\n\n\n\nNotes\nDamköhler number measures reaction rate relative to flow rate: - Da &lt;&lt; 1: Reaction slow, flow dominates, low conversion - Da &gt;&gt; 1: Reaction fast, kinetics dominate, high conversion - Da ≈ 1: Balanced, optimal efficiency\n\n\nExamples\n&gt;&gt;&gt; cstr = ContinuousCSTR()\n&gt;&gt;&gt; Da_low = cstr.compute_damkohler_number(T=350.0)\n&gt;&gt;&gt; Da_high = cstr.compute_damkohler_number(T=400.0)\n&gt;&gt;&gt; print(f\"Da(350K) = {Da_low:.2f}\")\n&gt;&gt;&gt; print(f\"Da(400K) = {Da_high:.2f}\")\n\n\n\ncompute_residence_time\nsystems.builtin.deterministic.continuous.ContinuousCSTR.compute_residence_time()\nCompute residence time τ = V/F.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nResidence time [s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = ContinuousCSTR(F=100.0, V=100.0)\n&gt;&gt;&gt; tau = cstr.compute_residence_time()\n&gt;&gt;&gt; print(f\"Residence time: {tau} s\")\nResidence time: 1.0 s\n\n\nNotes\nResidence time is the average time a molecule spends in the reactor. - Longer τ (smaller F): More conversion, less stable - Shorter τ (larger F): Less conversion, more stable\n\n\n\ndefine_system\nsystems.builtin.deterministic.continuous.ContinuousCSTR.define_system(\n    F_val=100.0,\n    V_val=100.0,\n    C_A_feed_val=1.0,\n    T_feed_val=350.0,\n    k0_val=72000000000.0,\n    E_val=8750.0,\n    delta_H_val=-50000.0,\n    rho_val=1000.0,\n    Cp_val=0.239,\n    UA_val=50000.0,\n    x_ss=None,\n    u_ss=None,\n)\nDefine continuous-time CSTR dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nF_val\nfloat\nVolumetric flow rate [L/s]\n100.0\n\n\nV_val\nfloat\nReactor volume [L]\n100.0\n\n\nC_A_feed_val\nfloat\nFeed concentration [mol/L]\n1.0\n\n\nT_feed_val\nfloat\nFeed temperature [K]\n350.0\n\n\nk0_val\nfloat\nPre-exponential factor [1/s]\n72000000000.0\n\n\nE_val\nfloat\nActivation energy [K] (dimensionless Eₐ/R)\n8750.0\n\n\ndelta_H_val\nfloat\nHeat of reaction [J/mol] (negative = exothermic)\n-50000.0\n\n\nrho_val\nfloat\nDensity [kg/L]\n1000.0\n\n\nCp_val\nfloat\nSpecific heat capacity [J/(kg·K)]\n0.239\n\n\nUA_val\nfloat\nOverall heat transfer coefficient × area [J/(s·K)]\n50000.0\n\n\nx_ss\nOptional[np.ndarray]\nSteady-state [Cₐ, T] for equilibrium setup\nNone\n\n\nu_ss\nOptional[np.ndarray]\nSteady-state [T_jacket] for equilibrium setup\nNone\n\n\n\n\n\n\nfind_steady_states\nsystems.builtin.deterministic.continuous.ContinuousCSTR.find_steady_states(\n    T_jacket,\n    T_range=(300.0, 500.0),\n    n_points=100,\n)\nFind all steady states for a given jacket temperature.\nUses multiple initial guesses across temperature range to find all solutions to the steady-state equations.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT_jacket\nfloat\nJacket temperature [K]\nrequired\n\n\nT_range\ntuple\nTemperature range to search (T_min, T_max) [K]\n(300.0, 500.0)\n\n\nn_points\nint\nNumber of initial guesses for root finding\n100\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist\nList of (C_A, T) steady state tuples\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = ContinuousCSTR()\n&gt;&gt;&gt; steady_states = cstr.find_steady_states(T_jacket=350.0)\n&gt;&gt;&gt; print(f\"Found {len(steady_states)} steady states\")\n&gt;&gt;&gt; for i, (C_A, T) in enumerate(steady_states):\n...     X = cstr.compute_conversion(C_A, 1.0)\n...     print(f\"  State {i+1}: Cₐ={C_A:.3f}, T={T:.1f}, X={X*100:.1f}%\")\n\n\nNotes\nThis method finds steady states by solving: dCₐ/dt = 0 (material balance) dT/dt = 0 (energy balance)\nFor CSTR, there can be 1, 2, or 3 steady states depending on parameters. This method attempts to find all of them by using many different initial guesses across the temperature range.\nFor production code, consider: - scipy.optimize.fsolve with multiple guesses - Continuation methods (AUTO, MATCONT) - Homotopy methods for guaranteed finding of all solutions\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.continuous.ContinuousCSTR.setup_equilibria()\nSet up steady-state equilibrium if provided.\n\nNotes\nCSTR can have multiple steady states! Only add user-provided equilibrium. Finding all equilibria requires solving nonlinear algebraic equations (see find_steady_states() method)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA quadrotor constrained to move in a 2D vertical plane with two rotors providing thrust. The system has: - 3 degrees of freedom: (x, y) position and pitch angle θ - 2 control inputs: thrust forces from left and right rotors - Underactuated: 3 DOF controlled by 2 inputs - Nonlinear coupling between rotation and translation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, y, θ, ẋ, ẏ, θ̇] Position coordinates: - x: Horizontal position [m] (positive right) - y: Vertical position [m] (positive up) - θ (theta): Pitch angle [rad] (positive counterclockwise) * θ = 0: level orientation\nVelocity coordinates:\n- ẋ (x_dot): Horizontal velocity [m/s]\n- ẏ (y_dot): Vertical velocity [m/s]\n- θ̇ (theta_dot): Angular velocity [rad/s]\nControl: u = [u₁, u₂] - u₁: Left rotor thrust [N] - u₂: Right rotor thrust [N] Both must be non-negative in physical systems (thrust-only)\nOutput: y = [x, y, θ] - Measures position and orientation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe equations of motion are: ẍ = -(u₁ + u₂)/m · sin(θ) ÿ = (u₁ + u₂)/m · cos(θ) - g θ̈ = L/I · (u₁ - u₂)\nPhysical interpretation: - Total thrust (u₁ + u₂) provides vertical lift and horizontal acceleration - Differential thrust (u₁ - u₂) creates torque for rotation - Gravity acts downward with acceleration g - Thrust direction rotates with pitch angle θ"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nlength : float, default=0.25 Half-distance between rotors [m]. Larger L → more control authority for rotation (more torque from differential thrust). mass : float, default=0.486 Total mass of quadrotor [kg]. Based on Crazyflie 2.0 specs. inertia : float, default=0.00383 Moment of inertia about center of mass [kg⋅m²]. gravity : float, default=9.81 Gravitational acceleration [m/s²]."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#equilibrium",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#equilibrium",
    "title": "",
    "section": "Equilibrium:",
    "text": "Equilibrium:\nHovering equilibrium (level flight): x_eq = [x, y, 0, 0, 0, 0] (any (x, y), level, stationary) u_eq = [mg/2, mg/2] (each rotor supports half the weight)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#default-physical-parameters",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#default-physical-parameters",
    "title": "",
    "section": "Default Physical Parameters:",
    "text": "Default Physical Parameters:\n\nMass: 0.025 kg (25 grams)\nLength: 0.046 m (rotor arm)\nInertia: 0.00383 kg⋅m²\nGravity: 9.81 m/s²"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2D.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nSymbolicQuadrotor2DState : Full-state observation variant PVTOL : Similar dynamics but different parameterization CartPole : Another underactuated 2D system"
  },
  {
    "objectID": "api/types.core.OutputFunction.html",
    "href": "api/types.core.OutputFunction.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.OutputFunction.html#parameters",
    "href": "api/types.core.OutputFunction.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState (nx,)\nrequired"
  },
  {
    "objectID": "api/types.core.OutputFunction.html#returns",
    "href": "api/types.core.OutputFunction.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOutputVector\nOutput (ny,)"
  },
  {
    "objectID": "api/types.core.OutputFunction.html#examples",
    "href": "api/types.core.OutputFunction.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Full state observation\n&gt;&gt;&gt; def h_full(x: StateVector) -&gt; OutputVector:\n...     return x  # y = x\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Partial observation (position only)\n&gt;&gt;&gt; def h_partial(x: StateVector) -&gt; OutputVector:\n...     return x[0:2]  # First two states\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Nonlinear observation\n&gt;&gt;&gt; def h_nonlinear(x: StateVector) -&gt; OutputVector:\n...     return np.array([np.linalg.norm(x)])  # Distance from origin"
  },
  {
    "objectID": "api/types.control_classical.LuenbergerObserverResult.html",
    "href": "api/types.control_classical.LuenbergerObserverResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.LuenbergerObserverResult.html#fields",
    "href": "api/types.control_classical.LuenbergerObserverResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ngain : GainMatrix Observer gain L (nx, ny) desired_poles : np.ndarray Desired observer eigenvalues achieved_poles : np.ndarray Actual eigenvalues of (A - LC) is_observable : bool System must be observable for arbitrary placement"
  },
  {
    "objectID": "api/types.control_classical.LuenbergerObserverResult.html#examples",
    "href": "api/types.control_classical.LuenbergerObserverResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Place observer poles faster than controller\n&gt;&gt;&gt; desired_poles = np.array([-10, -12])\n&gt;&gt;&gt; result: LuenbergerObserverResult = design_observer(A, C, desired_poles)\n&gt;&gt;&gt;\n&gt;&gt;&gt; L = result['gain']\n&gt;&gt;&gt; print(result['is_observable'])  # True\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Observer-based control\n&gt;&gt;&gt; x_hat = np.zeros(2)\n&gt;&gt;&gt; for k in range(N):\n...     u = -K @ x_hat  # Control law\n...     y_meas = C @ x_true + noise\n...\n...     # Observer update\n...     x_hat_dot = A @ x_hat + B @ u + L @ (y_meas - C @ x_hat)\n...     x_hat = x_hat + dt * x_hat_dot  # Euler integration"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#physical-interpretation",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation:",
    "text": "Physical Interpretation:\nCould represent: - Flexible manipulator with multiple vibration modes - Actuator with nested control loops (each adding an order) - Academic test case for high-order integration"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#mathematical-formulation",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#mathematical-formulation",
    "title": "",
    "section": "Mathematical Formulation:",
    "text": "Mathematical Formulation:\nState: x = [q, q’, q’‘, q’’’, q⁽⁴⁾] where: - q: Position [m] - q’: Velocity [m/s] - q’‘: Acceleration [m/s²] - q’’’: Jerk [m/s³] - q⁽⁴⁾: Snap (fourth derivative) [m/s⁴]\nThe system evolves according to: q⁽⁵⁾ = f(q, q’, q’‘, q’’’, q⁽⁴⁾, u)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nq⁽⁵⁾ = -(k/m)q - c₁q’ - c₂q’’ - c₃q’’’ - 0.01q⁽⁴⁾ - g + u/m\nThis includes: - Stiffness term: -kq (like a spring) - Multiple damping terms at each derivative level - Gravity: -g - Control input: u/m"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm : float, default=1.0 Mass [kg] k : float, default=1.0 Stiffness coefficient [N/m] c1 : float, default=0.1 First-order damping (velocity damping) [N⋅s/m] c2 : float, default=0.05 Second-order damping (acceleration damping) [N⋅s³/m] c3 : float, default=0.01 Third-order damping (jerk damping) [N⋅s⁵/m] g : float, default=9.81 Gravitational acceleration [m/s²]"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [q, q’, q’‘, q’’’, q⁽⁴⁾] (5D) Control: u = [force] (1D) Output: y = [q, q’] (position and velocity)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#equilibrium",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#equilibrium",
    "title": "",
    "section": "Equilibrium:",
    "text": "Equilibrium:\nStatic equilibrium (balancing gravity): q_eq = -mg/k (compressed by gravity) All derivatives zero u_eq = mg (supporting weight)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.FifthOrderMechanicalSystem.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nSymbolicPendulum2ndOrder : More typical second-order system CoupledOscillatorSystem : More realistic multi-DOF system"
  },
  {
    "objectID": "api/types.learning.RLTrainingResult.html",
    "href": "api/types.learning.RLTrainingResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.learning.RLTrainingResult.html#fields",
    "href": "api/types.learning.RLTrainingResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nlearned_policy : Callable Trained policy π(s) → a episode_returns : List[float] Cumulative return per episode episode_lengths : List[int] Episode length (steps) per episode average_return : float Average return over last N episodes best_return : float Best episode return achieved total_timesteps : int Total environment steps training_time : float Training time in seconds converged : bool Whether training converged algorithm : str RL algorithm used (‘DQN’, ‘PPO’, ‘SAC’, ‘TD3’, etc.)"
  },
  {
    "objectID": "api/types.learning.RLTrainingResult.html#examples",
    "href": "api/types.learning.RLTrainingResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Train RL agent\n&gt;&gt;&gt; result: RLTrainingResult = train_rl_agent(\n...     env=pendulum_env,\n...     algorithm='SAC',\n...     episodes=1000,\n...     learning_rate=3e-4\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract policy\n&gt;&gt;&gt; policy = result['learned_policy']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Evaluate\n&gt;&gt;&gt; print(f\"Algorithm: {result['algorithm']}\")\n&gt;&gt;&gt; print(f\"Average return: {result['average_return']:.2f}\")\n&gt;&gt;&gt; print(f\"Best return: {result['best_return']:.2f}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot learning curve\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(result['episode_returns'])\n&gt;&gt;&gt; plt.xlabel('Episode')\n&gt;&gt;&gt; plt.ylabel('Return')\n&gt;&gt;&gt; plt.title('RL Training Progress')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Deploy policy\n&gt;&gt;&gt; state = env.reset()\n&gt;&gt;&gt; action = policy(state)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorFactory.html",
    "href": "api/systems.base.numerical_integration.IntegratorFactory.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorFactory.html#examples",
    "href": "api/systems.base.numerical_integration.IntegratorFactory.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Create integrator by backend and method\n&gt;&gt;&gt; integrator = IntegratorFactory.create(\n...     system,\n...     backend='numpy',\n...     method='LSODA'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Julia solver\n&gt;&gt;&gt; integrator = IntegratorFactory.create(\n...     system,\n...     backend='numpy',\n...     method='Tsit5'  # Capital T = Julia\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Automatic selection\n&gt;&gt;&gt; integrator = IntegratorFactory.auto(system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use case-specific\n&gt;&gt;&gt; integrator = IntegratorFactory.for_optimization(system)\n&gt;&gt;&gt; integrator = IntegratorFactory.for_production(system)\n&gt;&gt;&gt; integrator = IntegratorFactory.for_julia(system, algorithm='Vern9')"
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorFactory.html#methods",
    "href": "api/systems.base.numerical_integration.IntegratorFactory.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nauto\nAutomatically select best integrator for system.\n\n\ncreate\nCreate an integrator with specified backend and method.\n\n\nfor_educational\nCreate Euler fixed-step integrator.\n\n\nfor_julia\nCreate Julia-based integrator using DiffEqPy.\n\n\nfor_neural_ode\nCreate integrator for Neural ODE training.\n\n\nfor_optimization\nCreate integrator optimized for gradient-based optimization.\n\n\nfor_production\nCreate integrator for production use.\n\n\nfor_simple\nCreate simple RK4 fixed-step integrator.\n\n\nget_info\nGet information about a specific integrator configuration.\n\n\nlist_methods\nList available methods for each backend.\n\n\nrecommend\nGet recommended integrator configuration for a use case.\n\n\n\n\nauto\nsystems.base.numerical_integration.IntegratorFactory.auto(\n    system,\n    prefer_backend=None,\n    **options,\n)\nAutomatically select best integrator for system.\nSelection logic: 1. If JAX available and no backend preference → Diffrax (fast + accurate) 2. If PyTorch available and no backend preference → TorchDiffEq 3. Otherwise → Scipy (always available)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to integrate (controlled or autonomous)\nrequired\n\n\nprefer_backend\nOptional[str]\nPreferred backend if available\nNone\n\n\n**options\n\nAdditional options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nBest available integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; integrator = IntegratorFactory.auto(system)\n&gt;&gt;&gt; integrator = IntegratorFactory.auto(system, prefer_backend='jax')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Works with autonomous systems\n&gt;&gt;&gt; integrator = IntegratorFactory.auto(autonomous_system)\n\n\n\ncreate\nsystems.base.numerical_integration.IntegratorFactory.create(\n    system,\n    backend='numpy',\n    method=None,\n    dt=None,\n    step_mode=StepMode.ADAPTIVE,\n    **options,\n)\nCreate an integrator with specified backend and method.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to integrate (controlled or autonomous)\nrequired\n\n\nbackend\nstr\nBackend: ‘numpy’, ‘torch’, ‘jax’. Default: ‘numpy’\n'numpy'\n\n\nmethod\nOptional[str]\nSolver method. If None, uses backend default. - numpy: ‘LSODA’ (scipy, auto-stiffness) - numpy with capital: ‘Tsit5’ (Julia via DiffEqPy) - torch: ‘dopri5’ (general adaptive) - jax: ‘tsit5’ (general adaptive)\nNone\n\n\ndt\nOptional[ScalarLike]\nTime step (required for FIXED mode)\nNone\n\n\nstep_mode\nStepMode\nFIXED or ADAPTIVE stepping\nStepMode.ADAPTIVE\n\n\n**options\n\nAdditional integrator options (rtol, atol, etc.) Note: For JAX backend, ‘solver’ in options will be treated as ‘method’\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nConfigured integrator\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf backend/method combination is invalid\n\n\n\nImportError\nIf required package not installed\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Use defaults (scipy)\n&gt;&gt;&gt; integrator = IntegratorFactory.create(system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Julia solver\n&gt;&gt;&gt; integrator = IntegratorFactory.create(\n...     system, backend='numpy', method='Tsit5'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Specify JAX method (both calling styles work)\n&gt;&gt;&gt; integrator = IntegratorFactory.create(\n...     system, backend='jax', method='dopri5'\n... )\n&gt;&gt;&gt; # OR\n&gt;&gt;&gt; integrator = IntegratorFactory.create(\n...     system, backend='jax', solver='dopri5'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Fixed-step\n&gt;&gt;&gt; integrator = IntegratorFactory.create(\n...     system,\n...     backend='numpy',\n...     method='rk4',\n...     dt=0.01,\n...     step_mode=StepMode.FIXED\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = IntegratorFactory.create(autonomous_system)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n\n\n\nfor_educational\nsystems.base.numerical_integration.IntegratorFactory.for_educational(\n    system,\n    dt=0.01,\n    backend='numpy',\n    **options,\n)\nCreate Euler fixed-step integrator.\nSimplest method for learning and debugging.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to integrate (controlled or autonomous)\nrequired\n\n\ndt\nScalarLike\nTime step\n0.01\n\n\nbackend\nstr\nBackend to use\n'numpy'\n\n\n**options\n\nAdditional options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nEuler integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; integrator = IntegratorFactory.for_educational(system, dt=0.001)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = IntegratorFactory.for_educational(autonomous_system)\n\n\n\nfor_julia\nsystems.base.numerical_integration.IntegratorFactory.for_julia(\n    system,\n    algorithm='Tsit5',\n    **options,\n)\nCreate Julia-based integrator using DiffEqPy.\nProvides access to Julia’s extensive solver library.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to integrate (controlled or autonomous)\nrequired\n\n\nalgorithm\nstr\nJulia algorithm name. Default: ‘Tsit5’ Examples: ‘Vern9’, ‘Rosenbrock23’, ‘AutoTsit5(Rosenbrock23())’\n'Tsit5'\n\n\n**options\n\nAdditional options (reltol, abstol, etc.)\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nJulia-powered integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # High-accuracy solver\n&gt;&gt;&gt; integrator = IntegratorFactory.for_julia(system, algorithm='Vern9')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stiff system\n&gt;&gt;&gt; integrator = IntegratorFactory.for_julia(\n...     system, algorithm='Rosenbrock23'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = IntegratorFactory.for_julia(autonomous_system)\n\n\n\nfor_neural_ode\nsystems.base.numerical_integration.IntegratorFactory.for_neural_ode(\n    system,\n    use_adjoint=True,\n    **options,\n)\nCreate integrator for Neural ODE training.\nUses PyTorch with adjoint method for memory-efficient backpropagation.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nNeural ODE system (should be torch.nn.Module)\nrequired\n\n\nuse_adjoint\nbool\nUse adjoint method for backprop. Default: True\nTrue\n\n\n**options\n\nAdditional options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nNeural ODE integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; neural_ode = MyNeuralODE()  # torch.nn.Module\n&gt;&gt;&gt; integrator = IntegratorFactory.for_neural_ode(neural_ode)\n\n\n\nfor_optimization\nsystems.base.numerical_integration.IntegratorFactory.for_optimization(\n    system,\n    prefer_backend=None,\n    **options,\n)\nCreate integrator optimized for gradient-based optimization.\nPrefers JAX (Diffrax) for best performance with gradients. Falls back to PyTorch if JAX unavailable.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to integrate (controlled or autonomous)\nrequired\n\n\nprefer_backend\nOptional[str]\nForce specific backend (‘jax’ or ‘torch’)\nNone\n\n\n**options\n\nAdditional options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nOptimization-ready integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; integrator = IntegratorFactory.for_optimization(system)\n&gt;&gt;&gt; integrator = IntegratorFactory.for_optimization(system, prefer_backend='torch')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = IntegratorFactory.for_optimization(autonomous_system)\n\n\n\nfor_production\nsystems.base.numerical_integration.IntegratorFactory.for_production(\n    system,\n    use_julia=False,\n    **options,\n)\nCreate integrator for production use.\nUses scipy.LSODA (default) or Julia’s AutoTsit5 (if use_julia=True) with automatic stiffness detection. Most reliable choices.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to integrate (controlled or autonomous)\nrequired\n\n\nuse_julia\nbool\nIf True, use Julia’s AutoTsit5. Default: False (scipy)\nFalse\n\n\n**options\n\nAdditional options (rtol, atol, etc.)\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nProduction-grade integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Scipy (default)\n&gt;&gt;&gt; integrator = IntegratorFactory.for_production(\n...     system, rtol=1e-9, atol=1e-11\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Julia (if installed)\n&gt;&gt;&gt; integrator = IntegratorFactory.for_production(\n...     system, use_julia=True\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = IntegratorFactory.for_production(autonomous_system)\n\n\n\nfor_simple\nsystems.base.numerical_integration.IntegratorFactory.for_simple(\n    system,\n    dt=0.01,\n    backend='numpy',\n    **options,\n)\nCreate simple RK4 fixed-step integrator.\nGood for prototyping and educational purposes.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to integrate (controlled or autonomous)\nrequired\n\n\ndt\nScalarLike\nTime step\n0.01\n\n\nbackend\nstr\nBackend to use\n'numpy'\n\n\n**options\n\nAdditional options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegratorBase\nRK4 integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; integrator = IntegratorFactory.for_simple(system, dt=0.01)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = IntegratorFactory.for_simple(autonomous_system)\n\n\n\nget_info\nsystems.base.numerical_integration.IntegratorFactory.get_info(backend, method)\nGet information about a specific integrator configuration.\nDelegates to integrator-specific info functions where available.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nstr\nBackend name\nrequired\n\n\nmethod\nstr\nMethod name\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nInformation about the integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; info = IntegratorFactory.get_info('jax', 'tsit5')\n&gt;&gt;&gt; print(info['description'])\n'Excellent general purpose, JAX-optimized'\n&gt;&gt;&gt;\n&gt;&gt;&gt; info = IntegratorFactory.get_info('numpy', 'Tsit5')\n&gt;&gt;&gt; print(info['description'])\n'Excellent general-purpose solver with good efficiency'\n&gt;&gt;&gt;\n&gt;&gt;&gt; info = IntegratorFactory.get_info('numpy', 'Vern7')\n&gt;&gt;&gt; print(info['description'])  # Works even if not in hardcoded list!\n\n\n\nlist_methods\nsystems.base.numerical_integration.IntegratorFactory.list_methods(backend=None)\nList available methods for each backend.\nDelegates to method_registry for base methods, then adds Julia ODE methods.\n\n\nrecommend\nsystems.base.numerical_integration.IntegratorFactory.recommend(\n    use_case,\n    has_gpu=False,\n)\nGet recommended integrator configuration for a use case.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuse_case\nstr\nUse case: ‘production’, ‘optimization’, ‘neural_ode’, ‘simple’, ‘julia’, ‘educational’\nrequired\n\n\nhas_gpu\nbool\nWhether GPU is available\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nRecommended configuration with ‘backend’, ‘method’, ‘description’\n\n\n\n\n\nExamples\n&gt;&gt;&gt; rec = IntegratorFactory.recommend('optimization')\n&gt;&gt;&gt; print(rec['backend'], rec['method'])\n'jax' 'tsit5'\n&gt;&gt;&gt;\n&gt;&gt;&gt; rec = IntegratorFactory.recommend('production')\n&gt;&gt;&gt; print(rec['description'])"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nIdentical physics to SymbolicPendulum, but formulated as a second-order differential equation rather than a first-order state-space system."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [θ, θ̇] (same as first-order variant)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#dynamics-representation",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#dynamics-representation",
    "title": "",
    "section": "Dynamics Representation:",
    "text": "Dynamics Representation:\nSecond-order form: θ̈ = -(β/I)θ̇ + (g/l)sin(θ) + τ/I\nThe forward() method computes and returns ONLY the acceleration θ̈.\nState-space conversion (handled automatically): dx/dt = [θ̇ ] = [ θ̇ ] [θ̈ ] [f(θ, θ̇, τ)]\nThe GenericDiscreteTimeSystem integrator handles the conversion: 1. Calls forward(x, u) to get θ̈ 2. Integrates θ̈ to get θ̇{k+1} 3. Integrates θ̇ to get θ{k+1} 4. Returns x_{k+1} = [θ_{k+1}, θ̇_{k+1}]"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm, l, beta, g : Same as SymbolicPendulum"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#properties",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#properties",
    "title": "",
    "section": "Properties:",
    "text": "Properties:\norder : int = 2 Marks system as second-order (changes integration behavior) nq : int = 1 Number of generalized coordinates (just θ)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#notes",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#notes",
    "title": "",
    "section": "Notes:",
    "text": "Notes:\n\nforward() output shape is (1,) for scalar acceleration, NOT (2,)\nThe state x is still (2,) = [θ, θ̇]\nIntegrators automatically handle the state-space conversion\nCan use different integration methods for position vs velocity\nLinearization returns full 2×2 state-space matrices"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nSymbolicPendulum : First-order state-space formulation SymbolicQuadrotor2D : Another second-order system (3 accelerations)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA simplified model of a car or mobile robot that can move forward and rotate, but cannot move sideways (nonholonomic constraint).\nThe vehicle is modeled as a point with: - Position (x, y) in the plane - Heading angle θ - Forward velocity v (control input) - Angular velocity ω (control input)\nKey constraint: The vehicle must move in the direction it’s pointing (no lateral sliding). This is called a nonholonomic constraint."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#coordinate-frame",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#coordinate-frame",
    "title": "",
    "section": "Coordinate Frame:",
    "text": "Coordinate Frame:\n\nInertial frame: Fixed (x, y) coordinates\nBody frame: Moves and rotates with vehicle\nHeading θ: Angle from x-axis to vehicle’s forward direction"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, y, θ] - x: Horizontal position [m] - y: Vertical position [m] - θ (theta): Heading angle [rad] * θ = 0: pointing right (along +x axis) * θ = π/2: pointing up (along +y axis) * θ = π: pointing left * θ = 3π/2 or -π/2: pointing down\nControl: u = [v, ω] - v: Forward velocity [m/s] * v &gt; 0: move forward * v &lt; 0: move backward * v = 0: stopped - ω (omega): Angular velocity [rad/s] * ω &gt; 0: turn left (counterclockwise) * ω &lt; 0: turn right (clockwise) * ω = 0: straight motion\nOutput: y = [x, y, θ] - Full state observation (position and heading)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe kinematic equations (Dubins car model):\nẋ = v·cos(θ)\nẏ = v·sin(θ)\nθ̇ = ω\nPosition dynamics: - Vehicle moves in direction θ at speed v - cos(θ) and sin(θ) project velocity onto x and y axes - No motion perpendicular to heading (nonholonomic constraint)\nHeading dynamics: - Directly controlled by angular velocity ω - Independent of forward velocity (can rotate in place if v=0)\nPhysical interpretation: - The vehicle is like a bicycle: must point where it’s going - Cannot slide sideways (like a car on dry pavement) - Minimum turning radius determined by maximum ω/v ratio"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#turning-radius",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#turning-radius",
    "title": "",
    "section": "Turning Radius:",
    "text": "Turning Radius:\nWhen moving in a circle (v constant, ω constant): R = v/ω (radius of circular path)\n\nTighter turn: increase ω or decrease v\nLarger turn: decrease ω or increase v\nStraight line: ω = 0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nThis implementation has no physical parameters - it’s a pure kinematic model. Further modifications to this model may include: - Maximum speed v_max - Maximum angular velocity ω_max - Minimum turning radius R_min = v_max/ω_max"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nStationary at origin: x_eq = [0, 0, θ*] (any heading θ*) u_eq = [0, 0] (no velocity)\nNote: Equilibria form a manifold - any (x, y, θ*) with u = [0, 0]. The system is marginally stable (doesn’t return to equilibrium on its own)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.DubinsVehicle.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nPathTracking : Error dynamics for path following PVTOL : Flying vehicle with similar kinematics CartPole : Another nonholonomic system"
  },
  {
    "objectID": "api/systems.base.utils.LinearizationEngine.html",
    "href": "api/systems.base.utils.LinearizationEngine.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.LinearizationEngine.html#methods",
    "href": "api/systems.base.utils.LinearizationEngine.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_dynamics\nCompute linearized dynamics: A = ∂f/∂x, B = ∂f/∂u.\n\n\ncompute_symbolic\nCompute symbolic linearization A = ∂f/∂x, B = ∂f/∂u.\n\n\nget_stats\nGet performance statistics.\n\n\nreset_stats\nReset performance counters.\n\n\nverify_jacobians\nVerify symbolic Jacobians against automatic differentiation.\n\n\n\n\ncompute_dynamics\nsystems.base.utils.LinearizationEngine.compute_dynamics(x, u=None, backend=None)\nCompute linearized dynamics: A = ∂f/∂x, B = ∂f/∂u.\nAutomatically detects backend from input types. Supports both controlled (nu &gt; 0) and autonomous (nu = 0) systems.\nArgs: x: State at which to linearize u: Control at which to linearize (None for autonomous systems) backend: Backend selection (None = auto-detect)\nReturns: DeterministicLinearization Tuple of (A, B) Jacobian matrices: - A: StateMatrix (nx, nx) - state Jacobian ∂f/∂x - B: InputMatrix (nx, nu) - control Jacobian ∂f/∂u, or (nx, 0) if autonomous\nRaises: ValueError: If u is None for non-autonomous system\nExample: &gt;&gt;&gt; # Controlled system &gt;&gt;&gt; lin: DeterministicLinearization = engine.compute_dynamics(x, u) &gt;&gt;&gt; A, B = lin # Unpack Jacobians &gt;&gt;&gt; A.shape # (nx, nx) &gt;&gt;&gt; B.shape # (nx, nu) &gt;&gt;&gt; &gt;&gt;&gt; # Autonomous system (nu=0) &gt;&gt;&gt; A, B = engine.compute_dynamics(x_np) # u=None &gt;&gt;&gt; A.shape # (nx, nx) &gt;&gt;&gt; B.shape # (nx, 0) - empty but valid\n\n\ncompute_symbolic\nsystems.base.utils.LinearizationEngine.compute_symbolic(x_eq=None, u_eq=None)\nCompute symbolic linearization A = ∂f/∂x, B = ∂f/∂u.\nFor higher-order systems, constructs the full state-space linearization. For autonomous systems (nu=0), B is an empty matrix (nx, 0).\nArgs: x_eq: Equilibrium state (zeros if None) u_eq: Equilibrium control (zeros if None, empty if autonomous)\nReturns: Tuple of (A, B) symbolic matrices where: - A: (nx, nx) state Jacobian - B: (nx, nu) control Jacobian, or (nx, 0) if autonomous\nExample: &gt;&gt;&gt; # Controlled system &gt;&gt;&gt; A_sym, B_sym = engine.compute_symbolic( … x_eq=sp.Matrix([0, 0]), … u_eq=sp.Matrix([0]) … ) &gt;&gt;&gt; &gt;&gt;&gt; # Autonomous system &gt;&gt;&gt; A_sym, B_sym = engine.compute_symbolic( … x_eq=sp.Matrix([0, 0]) … ) # u_eq is None/empty for autonomous &gt;&gt;&gt; B_sym.shape # (2, 0)\n\n\nget_stats\nsystems.base.utils.LinearizationEngine.get_stats()\nGet performance statistics.\nReturns: Dict with call count, total time, and average time\n\n\nreset_stats\nsystems.base.utils.LinearizationEngine.reset_stats()\nReset performance counters.\n\n\nverify_jacobians\nsystems.base.utils.LinearizationEngine.verify_jacobians(\n    x,\n    u=None,\n    backend='torch',\n    tol=0.0001,\n)\nVerify symbolic Jacobians against automatic differentiation.\nUses autodiff to numerically compute Jacobians and compares against symbolic derivation. Requires autodiff backend (torch or jax).\nArgs: x: State at which to verify u: Control at which to verify (None for autonomous systems) backend: Backend for autodiff (‘torch’ or ‘jax’, not ‘numpy’) tol: Tolerance for considering Jacobians equal\nReturns: Dict with ‘A_match’, ‘B_match’ booleans and error magnitudes\nRaises: ValueError: If backend doesn’t support autodiff or u is None for non-autonomous\nExample: &gt;&gt;&gt; # Controlled system &gt;&gt;&gt; results = engine.verify_jacobians(x, u, backend=‘torch’, tol=1e-4) &gt;&gt;&gt; assert results[‘A_match’] is True &gt;&gt;&gt; assert results[‘B_match’] is True &gt;&gt;&gt; &gt;&gt;&gt; # Autonomous system &gt;&gt;&gt; results = engine.verify_jacobians(x, backend=‘torch’) # u=None &gt;&gt;&gt; assert results[‘A_match’] is True &gt;&gt;&gt; # B_match will be True trivially for empty matrix"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#difference-equation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#difference-equation",
    "title": "",
    "section": "Difference Equation",
    "text": "Difference Equation\nStandard ARMA(1,1) form: X[k] = φ·X[k-1] + w[k] + θ·w[k-1]\nWith control: X[k] = φ·X[k-1] + u[k] + w[k] + θ·w[k-1]\nwhere: - X[k]: Observed series (state) - φ: AR coefficient (persistence, -∞ &lt; φ &lt; ∞) - θ: MA coefficient (smoothing, -∞ &lt; θ &lt; ∞) - w[k]: White noise innovation ~ N(0, σ²) - u[k]: Control/external input\nState-Space Form (for simulation): Z[k] = [X[k], w[k-1]]ᵀ (augmented state)\nZ[k+1] = [φ  θ]·Z[k] + [1]·w[k+1]\n         [0  0]        [1]\nOutput: X[k] = [1, 0]·Z[k]"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nAR Component (φ): - Past observation influences current - φ &gt; 0: Positive persistence (typical) - φ &lt; 0: Alternation (rare) - Recursive: Memory of all past (exponentially weighted)\nMA Component (θ): - Past innovation influences current - θ &gt; 0: Smoothing (positive autocorrelation at lag 1) - θ &lt; 0: Overshoot (negative autocorrelation) - Finite: Only immediate past innovation matters\nCombined Effect: - AR provides long memory (slow decay) - MA adjusts short-term behavior (lag 1) - Together: More flexible than either alone\nWhy ARMA(1,1) is Popular:\nCan approximate: - AR(∞): Via MA(∞) representation - MA(∞): Via AR(∞) representation - Complex ACF: With just 3 parameters\nMore parsimonious than high-order AR or MA."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nStationarity: Requires |φ| &lt; 1 (from AR part).\nInvertibility: Requires |θ| &lt; 1 (from MA part).\nParsimony: 3 parameters (φ, θ, σ) provide flexibility of high-order models.\nAutocorrelation: - ρ(1): Affected by both φ and θ - ρ(h ≥ 2): Geometric decay at rate φ\nSpectral Density: Rational function (ratio of polynomials).\nMarkov (in Augmented State): State-space form is Markov in (X, w_prev)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nStationarity Condition: |φ| &lt; 1\nInvertibility Condition: |θ| &lt; 1\nVariance: Var[X] = σ²·(1 + 2θφ + θ²)/(1 - φ²)\nAutocorrelation: ρ(1) = (φ + θ)·(1 + θφ)/(1 + 2θφ + θ²) ρ(h) = φ·ρ(h-1) for h ≥ 2\nImpulse Response: ψ₀ = 1 ψ₁ = φ + θ ψⱼ = φ^(j-1)·(φ + θ) for j ≥ 2\nMA(∞) Representation: X[k] = Σψⱼ·w[k-j]\nCoefficients decay geometrically: ψⱼ ~ φ^j\nAR(∞) Representation: w[k] = Σπⱼ·X[k-j]\nCoefficients decay geometrically: πⱼ ~ θ^j (if |θ| &lt; 1)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nAR Coefficient φ: - Dimensionless - Fraction of past persisting - Typical: 0.3-0.9 (positive persistence)\nMA Coefficient θ: - Dimensionless - Weight on past shock - Typical: -0.5 to +0.5 - θ &gt; 0: Smoothing (positive lag-1 correlation) - θ &lt; 0: Overshoot (negative lag-1 correlation)\nInnovation Variance σ²: - Units: [state]² - Unpredictable component each period\nSpecial Cases:\nφ = 0.8, θ = 0: Pure AR(1) φ = 0, θ = -0.5: Pure MA(1) φ = 0.8, θ = -0.6: Typical ARMA(1,1)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nAugmented state: Z = [X, w_prev] ∈ ℝ² - X: Observed series - w_prev: Past innovation (latent)\nObservable state: X ∈ ℝ - What we actually measure\nControl: u ∈ ℝ (optional) - External input"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nphi\nfloat\nAR coefficient - Typical: 0.3-0.9 - Must satisfy |φ| &lt; 1 for stationarity\n0.7\n\n\ntheta\nfloat\nMA coefficient - Typical: -0.5 to +0.5 - Should satisfy |θ| &lt; 1 for invertibility\n0.3\n\n\nsigma\nfloat\nInnovation standard deviation - Must be positive - Sets scale of unpredictable component\n0.1\n\n\ndt\nfloat\nSampling period - Required for discrete system\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: LINEAR (ARMA)\nNoise Type: ADDITIVE (white noise)\nMarkov: In augmented state (X, w_prev)\nStationary: If |φ| &lt; 1\nInvertible: If |θ| &lt; 1\nGaussian: If w ~ N(0,σ²)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Economic Forecasting: - GDP growth - Inflation - Unemployment - Sales data\n2. Financial Time Series: - Asset returns - Interest rate spreads - Volume data\n3. Signal Processing: - Digital filter design - Prediction algorithms - Spectral estimation\n4. Engineering: - Vibration analysis - Quality control - Process monitoring\n5. Environmental: - Temperature series - Rainfall - Pollution levels"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nState-Space Implementation:\nAugment state with past innovation: Z[k+1] = F·Z[k] + G·w[k+1]\nwhere: Z = [X, w_prev]ᵀ F = [φ θ] [0 0] G = [1] [1]\nExtract: X[k] = Z[k][0]"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#forecasting",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#forecasting",
    "title": "",
    "section": "Forecasting",
    "text": "Forecasting\nOne-Step-Ahead: X̂[k+1|k] = φ·X[k] + θ·ε[k]\nwhere ε[k] = X[k] - X̂[k|k-1] is innovation.\nh-Step-Ahead: X̂[k+h|k] = φ^h·X[k] + θ·Σφ^(h-1-j)·ε[k-j]\nForecast variance increases with horizon."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#comparison-with-other-models",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#comparison-with-other-models",
    "title": "",
    "section": "Comparison with Other Models",
    "text": "Comparison with Other Models\nvs. AR(1): - AR(1): Only φ parameter - ARMA(1,1): Adds θ (more flexible) - Same asymptotic ACF (h → ∞) - Different ρ(1)\nvs. MA(1): - MA(1): Only θ parameter - ARMA(1,1): Adds φ (long memory)\nvs. AR(2): - AR(2): Two AR lags (4 parameters with σ, μ) - ARMA(1,1): One AR, one MA (3 parameters) - Often ARMA(1,1) more parsimonious\nvs. ARMA(p,q): - ARMA(1,1): Simplest non-trivial - Higher order: More flexible but more parameters - Start with ARMA(1,1), increase if needed"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nLinear only\nConstant parameters\nGaussian innovations (typically)\nStationary (no trends)\nLow order (1,1 may not suffice)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nARMA(p,q): Higher order\nARIMA: Integrated (for non-stationary)\nSARIMA: Seasonal patterns\nGARCH: Time-varying variance\nRegime-switching ARMA"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#examples",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nStandard ARMA(1,1):\n&gt;&gt;&gt; # Typical configuration\n&gt;&gt;&gt; arma = DiscreteARMA11(\n...     phi=0.7,    # Moderate persistence\n...     theta=0.3,  # Positive MA (smoothing)\n...     sigma=0.1,\n...     dt=1.0\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check stationarity and invertibility\n&gt;&gt;&gt; print(f\"|φ| &lt; 1: {abs(0.7) &lt; 1}\")  # Stationary\n&gt;&gt;&gt; print(f\"|θ| &lt; 1: {abs(0.3) &lt; 1}\")  # Invertible\nDifferent configurations:\n&gt;&gt;&gt; # High persistence, low MA\n&gt;&gt;&gt; high_ar = DiscreteARMA11(phi=0.9, theta=0.1, sigma=0.1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Moderate AR, negative MA (overshoot)\n&gt;&gt;&gt; negative_ma = DiscreteARMA11(phi=0.5, theta=-0.3, sigma=0.1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Balanced AR and MA\n&gt;&gt;&gt; balanced = DiscreteARMA11(phi=0.6, theta=0.4, sigma=0.1)\nSimulation:\n&gt;&gt;&gt; # Generate ARMA series\n&gt;&gt;&gt; z0 = np.array([0.0, 0.0])  # [X[0], w[-1]]\n&gt;&gt;&gt; u_seq = np.zeros((100, 1))\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = arma.simulate(z0, u_seq, n_steps=100)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract observed series (first component of augmented state)\n&gt;&gt;&gt; X_series = result['states'][:, 0]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute sample ACF\n&gt;&gt;&gt; from statsmodels.tsa.stattools import acf\n&gt;&gt;&gt; acf_values = acf(X_series, nlags=20)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDiscreteAR1 : Pure autoregressive (θ=0) DiscreteMA1 : Pure moving average (φ=0, future) DiscreteARMA : General ARMA(p,q) (future)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#references",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#references",
    "title": "",
    "section": "References",
    "text": "References\n.. [1] Box, G.E.P. & Jenkins, G.M. (1970). “Time Series Analysis: Forecasting and Control” .. [2] Hamilton, J.D. (1994). “Time Series Analysis” .. [3] Brockwell, P.J. & Davis, R.A. (2016). “Introduction to Time Series and Forecasting” .. [4] Shumway, R.H. & Stoffer, D.S. (2017). “Time Series Analysis and Its Applications”"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteARMA11.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine ARMA(1,1) process dynamics in state-space form.\n\n\nget_acf\nGet theoretical autocorrelation function.\n\n\nget_acf_lag1\nGet theoretical autocorrelation at lag 1.\n\n\nget_stationary_variance\nGet theoretical stationary variance of X.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteARMA11.define_system(\n    phi=0.7,\n    theta=0.3,\n    sigma=0.1,\n    dt=1.0,\n)\nDefine ARMA(1,1) process dynamics in state-space form.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nphi\nfloat\nAR coefficient (persistence) - Typical: 0.3-0.9 - Should satisfy |φ| &lt; 1 for stationarity - Similar to AR(1)\n0.7\n\n\ntheta\nfloat\nMA coefficient (smoothing) - Typical: -0.5 to +0.5 - Should satisfy |θ| &lt; 1 for invertibility - θ &gt; 0: Smoothing (common) - θ &lt; 0: Overshoot (less common)\n0.3\n\n\nsigma\nfloat\nInnovation standard deviation - Must be positive - Sets scale of unpredictable shocks\n0.1\n\n\ndt\nfloat\nSampling period - Required for discrete system\n1.0\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf sigma ≤ 0\n\n\n\nUserWarning\nIf |φ| ≥ 1 (non-stationary) If |θ| ≥ 1 (non-invertible)\n\n\n\n\n\nNotes\nStationarity: Requires |φ| &lt; 1 (from AR component). - φ = 1: Unit root (ARIMA needed) - |φ| &gt; 1: Explosive (unstable)\nInvertibility: Requires |θ| &lt; 1 (from MA component). - |θ| ≥ 1: Non-unique representation - Multiple ARMA models give same ACF - Estimation problems\nParameter Space: Valid region: |φ| &lt; 1 AND |θ| &lt; 1\nState-Space Formulation:\nTo simulate ARMA, augment state with past innovation: Z = [X, w_prev]ᵀ\nDynamics: Z[k+1] = F·Z[k] + G·w[k+1]\nwhere: F = [φ θ] [0 0]\nG = [1]\n    [1]\nWhy Augmented State? Cannot write X[k+1] = f(X[k]) alone because depends on w[k]. Need to track w[k] as auxiliary state.\nVariance (Stationary): Var[X] = σ²·(1 + 2θφ + θ²)/(1 - φ²)\nAutocorrelation: ρ(1) = (φ + θ)·(1 + θφ)/(1 + 2θφ + θ²) ρ(h) = φ·ρ(h-1) for h ≥ 2\nSpecial Cases:\nθ = 0: Reduces to AR(1) X[k] = φ·X[k-1] + w[k]\nφ = 0: Reduces to MA(1) X[k] = θ·w[k-1] + w[k]\nφ = -θ: Simplifies significantly X[k] = φ·(X[k-1] - w[k-1]) + w[k] (Differencing form)\nTypical Configurations:\nEconomic data: - φ = 0.6-0.9 (high persistence) - θ = 0.1-0.5 (moderate smoothing)\nFinancial returns: - φ = 0.0-0.3 (low persistence) - θ = -0.3-0.0 (slight overshoot or none)\nPhysical measurements: - φ = 0.5-0.8 (moderate persistence) - θ = 0.2-0.5 (smoothing from measurement)\n\n\nExamples\n&gt;&gt;&gt; # Standard economic series\n&gt;&gt;&gt; economic = DiscreteARMA11(\n...     phi=0.7,    # High persistence\n...     theta=0.3,  # Smoothing\n...     sigma=0.1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Financial returns (low persistence)\n&gt;&gt;&gt; returns = DiscreteARMA11(\n...     phi=0.1,     # Weak persistence\n...     theta=-0.2,  # Slight overshoot\n...     sigma=0.2\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Physical sensor (measurement smoothing)\n&gt;&gt;&gt; sensor = DiscreteARMA11(\n...     phi=0.6,\n...     theta=0.4,   # Strong smoothing\n...     sigma=0.05\n... )\n\n\n\nget_acf\nsystems.builtin.stochastic.discrete.DiscreteARMA11.get_acf(max_lag=20)\nGet theoretical autocorrelation function.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmax_lag\nint\nMaximum lag\n20\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nACF values [ρ(0), ρ(1), …, ρ(max_lag)]\n\n\n\n\n\nNotes\nρ(0) = 1 ρ(1) = (φ + θ)·(1 + θφ)/(1 + 2θφ + θ²) ρ(h) = φ·ρ(h-1) for h ≥ 2\nGeometric decay after lag 1.\n\n\nExamples\n&gt;&gt;&gt; arma = DiscreteARMA11(phi=0.7, theta=0.3, sigma=0.1)\n&gt;&gt;&gt; acf = arma.get_acf(max_lag=10)\n&gt;&gt;&gt; print(f\"ACF: {acf}\")\n\n\n\nget_acf_lag1\nsystems.builtin.stochastic.discrete.DiscreteARMA11.get_acf_lag1()\nGet theoretical autocorrelation at lag 1.\nρ(1) = (φ + θ)·(1 + θφ)/(1 + 2θφ + θ²)\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nLag-1 autocorrelation\n\n\n\n\n\nNotes\nThis is where ARMA differs from AR(1). For AR(1): ρ(1) = φ For ARMA(1,1): ρ(1) ≠ φ (MA effect)\n\n\nExamples\n&gt;&gt;&gt; arma = DiscreteARMA11(phi=0.7, theta=0.3, sigma=0.1)\n&gt;&gt;&gt; rho1 = arma.get_acf_lag1()\n&gt;&gt;&gt; print(f\"ρ(1) = {rho1:.3f}\")\n&gt;&gt;&gt; print(f\"Compare with φ = 0.7\")\n\n\n\nget_stationary_variance\nsystems.builtin.stochastic.discrete.DiscreteARMA11.get_stationary_variance()\nGet theoretical stationary variance of X.\nVar[X] = σ²·(1 + 2θφ + θ²)/(1 - φ²)\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nStationary variance\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf |φ| ≥ 1 (non-stationary)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; arma = DiscreteARMA11(phi=0.7, theta=0.3, sigma=0.1)\n&gt;&gt;&gt; var = arma.get_stationary_variance()\n&gt;&gt;&gt; print(f\"Stationary variance: {var:.4f}\")"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_method_info.html",
    "href": "api/systems.base.numerical_integration.get_method_info.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_method_info.html#parameters",
    "href": "api/systems.base.numerical_integration.get_method_info.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\nMethod name (canonical or backend-specific)\nrequired\n\n\nbackend\nBackend\nTarget backend\n'numpy'"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_method_info.html#returns",
    "href": "api/systems.base.numerical_integration.get_method_info.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with method information: - original_name : str - Method name as provided - normalized_name : str - Backend-specific normalized name - backend : str - Target backend - is_sde : bool - Whether method is for SDEs - is_fixed_step : bool - Whether method uses fixed time stepping - is_adaptive : bool - Whether method uses adaptive time stepping - is_available : bool - Whether method exists for backend - category : str - Method category (e.g., ‘deterministic_fixed_step’)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_method_info.html#examples",
    "href": "api/systems.base.numerical_integration.get_method_info.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; info = get_method_info('euler_maruyama', 'torch')\n&gt;&gt;&gt; print(info)\n{\n    'original_name': 'euler_maruyama',\n    'normalized_name': 'euler',\n    'backend': 'torch',\n    'is_sde': True,\n    'is_fixed_step': True,\n    'is_adaptive': False,\n    'is_available': True,\n    'category': 'sde_fixed_step'\n}"
  },
  {
    "objectID": "api/types.linearization.ContinuousStochasticLinearization.html",
    "href": "api/types.linearization.ContinuousStochasticLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.ContinuousStochasticLinearization.html#examples",
    "href": "api/types.linearization.ContinuousStochasticLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Ac, Bc, Gc = sde_system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; # Drift stability\n&gt;&gt;&gt; drift_stable = np.all(np.real(np.linalg.eigvals(Ac)) &lt; 0)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nThe harmonic oscillator models a mass attached to a spring and damper, subject to external force. The continuous-time dynamics are:\nm·ẍ + c·ẋ + k·x = F(t)\nDividing by mass and defining natural frequency ωₙ and damping ratio ζ:\nẍ + 2ζωₙ·ẋ + ωₙ²·x = u(t)\nwhere: ωₙ = √(k/m) [rad/s] : Natural (undamped) frequency ζ = c/(2√(km)) [-] : Damping ratio\nThe discrete-time version depends on the discretization method. This implementation provides several options:\nZero-Order Hold (ZOH) - Exact Discretization: The exact solution assuming piecewise-constant control. For underdamped systems (0 &lt; ζ &lt; 1), this gives:\nx[k+1] = e^(-ζωₙdt)·[x[k]·cos(ωd·dt) + v[k]·sin(ωd·dt)/ωd]\nv[k+1] = e^(-ζωₙdt)·[-x[k]·ωd·sin(ωd·dt) + v[k]·cos(ωd·dt)] + dt·u[k]\nwhere ωd = ωₙ√(1 - ζ²) is the damped natural frequency.\nTustin/Bilinear Transform: Preserves frequency response characteristics:\n(I - 0.5·dt·A)·x[k+1] = (I + 0.5·dt·A)·x[k] + 0.5·dt·B·(u[k] + u[k+1])\nThis is the standard method for designing discrete filters from continuous prototypes, as it maps the jω axis in s-plane to the unit circle in z-plane.\nForward Euler: Simple first-order approximation:\nx[k+1] = x[k] + dt·v[k]\nv[k+1] = v[k] + dt·(-ωₙ²·x[k] - 2ζωₙ·v[k] + u[k])\nBackward Euler: Implicit method with better stability for stiff systems."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] = [x[k], v[k]] Displacement state: - x: Position/displacement from equilibrium [m] * Can be positive or negative * Zero at equilibrium (spring relaxed) * Bounded for stable systems: |x| &lt; ∞ * Oscillates around zero for underdamped systems\nVelocity state:\n- v: Velocity [m/s]\n  * Rate of change of position\n  * Zero at equilibrium\n  * Phase-shifted 90° from position in steady-state oscillation\n  * Maximum at equilibrium crossing for underdamped\nControl: u[k] = [F[k]] - F: External force/acceleration [m/s²] or [N/kg] * Directly enters as acceleration term * Can be used to: - Excite oscillations (resonance testing) - Damp oscillations (active damping) - Track reference trajectories - Reject disturbances\nOutput: y[k] = [x[k]] or [x[k], v[k]] - Displacement-only measurement (most common): y[k] = x[k] Examples: LVDT, laser displacement, strain gauge - Full state measurement: y[k] = [x[k], v[k]] Examples: accelerometer integration, optical tracking"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#dynamics-general-form",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#dynamics-general-form",
    "title": "",
    "section": "Dynamics (General Form):",
    "text": "Dynamics (General Form):\nThe discrete dynamics can be written in state-space form:\nx[k+1] = Ad·x[k] + Bd·u[k]\nwhere the matrices Ad and Bd depend on the discretization method and system parameters (ωₙ, ζ, dt).\nPhysical Interpretation of Parameters:\nNatural Frequency ωₙ [rad/s]: - Frequency of oscillation without damping - Higher ωₙ → faster oscillations, stiffer spring - Related to spring constant: ωₙ = √(k/m) - Typical values: * Building structures: 0.1-10 rad/s * Vehicle suspensions: 5-50 rad/s * Machine tools: 100-1000 rad/s * MEMS devices: 10³-10⁶ rad/s\nDamping Ratio ζ [-]: - Dimensionless measure of energy dissipation - Controls how quickly oscillations decay - ζ = 0: Undamped (oscillates forever) - 0 &lt; ζ &lt; 1: Underdamped (oscillates with decay) - ζ = 1: Critically damped (fastest non-oscillatory) - ζ &gt; 1: Overdamped (slow return, no oscillation) - Typical values: * Air damping: ζ ≈ 0.01-0.1 * Automotive shocks: ζ ≈ 0.3-0.7 * Seismic isolators: ζ ≈ 0.1-0.3 * Critically damped instruments: ζ = 1.0\nRegime Classification:\n\nUnderdamped (0 &lt; ζ &lt; 1):\n\nOscillates with exponentially decaying amplitude\nDamped frequency: ωd = ωₙ√(1 - ζ²) &lt; ωₙ\nDecay rate: σ = ζωₙ\nPeriod: T = 2π/ωd\nEnvelope: A(t) = A₀·e^(-ζωₙt)\nMost common in practice\n\nCritically Damped (ζ = 1):\n\nFastest return to equilibrium without overshoot\nNo oscillation\nOptimal for instruments, door closers\nTwo equal real eigenvalues: λ = -ωₙ\n\nOverdamped (ζ &gt; 1):\n\nSlow return to equilibrium\nNo oscillation\nTwo distinct real eigenvalues\nExample: heavily damped pendulum in oil\n\nUndamped (ζ = 0):\n\nPure sinusoidal oscillation forever\nNo energy dissipation\nIdealization (never exact in reality)\nEigenvalues on imaginary axis: λ = ±jωₙ"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nomega_n : float, default=1.0 Natural frequency [rad/s] Must be positive: ωₙ &gt; 0 Controls oscillation speed Related to spring stiffness and mass\nzeta : float, default=0.1 Damping ratio [-] Must be non-negative: ζ ≥ 0 Controls energy dissipation ζ = 0: undamped, ζ &lt; 1: underdamped, ζ = 1: critical, ζ &gt; 1: overdamped\ndt : float, default=0.1 Sampling/discretization time step [s] Critical parameter affecting: - Accuracy of discrete approximation - Aliasing (must satisfy Nyquist: dt &lt; π/ωₙ) - Numerical stability (depends on method) - Control bandwidth\nGuidelines:\n- Nyquist: dt &lt; π/ωₙ (sample at least 2× per cycle)\n- Shannon: dt &lt; 1/(10·fₙ) for good reconstruction\n- Rule of thumb: 10-20 samples per period T = 2π/ωₙ\n- For ωₙ = 1 rad/s: dt ≈ 0.1-0.3 s\n- For ωₙ = 10 rad/s: dt ≈ 0.01-0.03 s\nmethod : str, default=‘zoh’ Discretization method: - ‘zoh’: Zero-order hold (exact, recommended for control) - ‘tustin’: Bilinear/trapezoidal (preserves frequency response) - ‘euler’: Forward Euler (simple, less accurate) - ‘backward_euler’: Backward Euler (more stable) - ‘matched’: Matched pole-zero (preserves poles)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nStable equilibrium at origin: x_eq = [0, 0] (rest position, spring relaxed) u_eq = 0 (no external force)\nStability depends on damping: - ζ &gt; 0: Asymptotically stable (returns to origin) - ζ = 0: Marginally stable (oscillates forever)\nEigenvalue Analysis:\nContinuous-time poles: λ = -ζωₙ ± jωₙ√(1 - ζ²) (for ζ &lt; 1)\nDiscrete-time poles (ZOH): z = e^(λdt) = e(-ζωₙdt)·e(±jωd·dt)\nStability requires |z| &lt; 1: |z| = e^(-ζωₙdt) &lt; 1 ⟹ ζωₙ &gt; 0\nThis is always satisfied for ζ &gt; 0 (damped systems).\nFor undamped (ζ = 0): |z| = 1 (marginally stable, poles on unit circle)\nForced Oscillation Equilibrium: For constant forcing u = u_ss: x_ss = u_ss/ωₙ² (static deflection) v_ss = 0\nThis represents a new equilibrium position where spring force balances the constant applied force."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#controllability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#controllability",
    "title": "",
    "section": "Controllability:",
    "text": "Controllability:\nThe discrete harmonic oscillator is COMPLETELY CONTROLLABLE for all discretization methods and parameter values (ωₙ &gt; 0).\nControllability Matrix: C = [Bd, Ad·Bd]\nPhysical Meaning: - Can move to any position with any velocity - Requires at most 2 time steps (for linear systems) - Energy required depends on desired state and time - Practical limits: actuator force, position/velocity bounds\nMinimum Energy Control: To reach target state x_target from origin in time T: u*(t) = B’·e^(A’(T-t))·[∫₀ᵀ e(At)·B·B’·e(A’t) dt]⁻¹·x_target\nThis gives the control that minimizes ∫ u² dt."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#observability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#observability",
    "title": "",
    "section": "Observability:",
    "text": "Observability:\nDisplacement-only measurement: y[k] = x[k] C = [1 0]\nObservability matrix:\nO = [C     ] = [1         0        ]\n    [C·Ad  ]   [Ad[0,0]   Ad[0,1]  ]\n\nFully observable for all parameter values.\nCan reconstruct velocity from position measurements over time.\nPhysical Interpretation: Velocity is estimated from position differences: v[k] ≈ (x[k+1] - x[k])/dt\nBetter estimates use multiple samples (Kalman filter, least squares).\nFull state measurement: y[k] = [x[k], v[k]] Trivially observable - direct measurement of all states."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#frequency-response",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#frequency-response",
    "title": "",
    "section": "Frequency Response:",
    "text": "Frequency Response:\nThe oscillator exhibits characteristic frequency-dependent behavior.\nContinuous-time transfer function: H(s) = 1/(s² + 2ζωₙs + ωₙ²)\nKey frequencies:\n\nNatural frequency ωₙ:\n\nResonance frequency for undamped system\nDetermines overall response speed\n\nDamped natural frequency ωd: ωd = ωₙ√(1 - ζ²) [rad/s]\n\nActual oscillation frequency for underdamped\nLower than ωₙ due to damping\n\nResonant peak frequency ωᵣ: ωᵣ = ωₙ√(1 - 2ζ²) [rad/s] (for ζ &lt; 1/√2)\n\nFrequency of maximum gain\nOnly exists for light damping\n\n\nMagnitude response: At resonance (ω = ωᵣ): |H(jωᵣ)| = 1/(2ζ√(1 - ζ²))\nFor small damping (ζ &lt;&lt; 1): |H(jωₙ)| ≈ 1/(2ζ) (quality factor Q = 1/(2ζ))\nPhase response: - Low frequency (ω &lt;&lt; ωₙ): φ ≈ 0° (in-phase) - Resonance (ω = ωₙ): φ = -90° (quadrature) - High frequency (ω &gt;&gt; ωₙ): φ → -180° (out-of-phase)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\nCommon control goals for harmonic oscillators:\n\nVibration Damping: Goal: Increase effective damping to reduce oscillations Methods:\n\nVelocity feedback: u = -k_d·v (adds damping)\nLQR with velocity penalty\nActive damping control Applications: building isolation, machine tools, aerospace\n\nResonance Tracking: Goal: Maintain oscillation at specific frequency and amplitude Methods:\n\nSinusoidal forcing at ωd\nPhase-locked loop Applications: clocks, oscillators, sensors\n\nPosition Regulation: Goal: Drive to desired position and hold Control: u = -K·[x - x_ref, v] Design: LQR, pole placement\nSetpoint Tracking: Goal: Follow time-varying reference position Control: u = -K·[x - x_ref(t), v - v_ref(t)] + u_ff(t) Feedforward: u_ff = ẍ_ref + 2ζωₙv_ref + ωₙ²x_ref\nDisturbance Rejection: Goal: Maintain position despite external forces Methods:\n\nHigh-gain feedback\nIntegral action\nDisturbance observer Applications: precision positioning, isolation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\nPhysical constraints that must be enforced:\n\nPosition limits: x_min ≤ x[k] ≤ x_max\n\nPhysical stops, workspace boundaries\nSpring compression/extension limits\nTypical: |x| ≤ 0.1 m for suspensions\n\nVelocity limits: |v[k]| ≤ v_max\n\nMaterial stress limits (fatigue)\nSafety considerations\nTypical: |v| ≤ 1 m/s for mechanical systems\n\nControl limits: |u[k]| ≤ u_max\n\nActuator force saturation\nPower constraints\nMost critical practical constraint\nTypical: |u| ≤ 10 m/s² for active systems\n\nFrequency limits (for tracking):\n\nCannot track above Nyquist frequency: f &lt; 1/(2dt)\nAnti-aliasing required for higher frequencies\nPractical limit: f &lt; 0.1/dt for good control"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\nStability:\nFor explicit methods (Euler), stability requires: dt &lt; 2/(ζωₙ + √(ζ²ωₙ² + ωₙ²))\nApproximately: dt &lt; 1/ωₙ for ζ small\nFor ZOH and Tustin, the discretization is always stable if the continuous system is stable (ζ &gt; 0).\nAccuracy: - ZOH: Exact for underdamped systems with constant control - Tustin: O(dt²) error, preserves frequency response - Euler: O(dt) error, can become unstable - Matched: Exact pole locations, approximate zeros\nAliasing: If excited at frequencies above Nyquist (π/dt), aliasing occurs. The response appears at lower frequencies: f_apparent = |f_actual - n·f_sample|\nPrevention: Use anti-aliasing filters before sampling.\nResonance Amplification: At resonance with small damping: Gain ≈ Q = 1/(2ζ)\nFor ζ = 0.01: Q = 50 (34 dB amplification!) This can cause: - Large displacements from small inputs - Control saturation - Numerical overflow if not handled"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#control-design-examples",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#control-design-examples",
    "title": "",
    "section": "Control Design Examples:",
    "text": "Control Design Examples:\n1. Damping Augmentation (Velocity Feedback): u[k] = -k_d·v[k]\nEffective damping: ζ_eff = ζ + k_d/(2ωₙ)\n\nChoose k_d to achieve desired damping:\n    k_d = 2ωₙ(ζ_desired - ζ)\n\nExample: ωₙ = 10 rad/s, ζ = 0.1, ζ_desired = 0.7\n    k_d = 2(10)(0.7 - 0.1) = 12\n2. LQR (Optimal State Feedback): Minimize: J = Σ (x’·Q·x + u’·R·u)\nTuning guidelines:\n- Large Q[0,0]: Penalize position error (stiff response)\n- Large Q[1,1]: Penalize velocity (add damping)\n- Large R: Penalize control effort (smooth, slow)\n\nExample:\n    Q = diag([100, 10])  # Care about position\n    R = 1\n    Result: Fast settling, moderate control\n3. Pole Placement: Desired continuous-time poles: s = -ζ_d·ωₙ_d ± jωₙ_d√(1 - ζ_d²)\nMap to discrete:\n    z = e^(s·dt)\n\nExample: ωₙ_d = 10, ζ_d = 0.7, dt = 0.01\n    s = -7 ± j7.14\n    z = 0.932 ± j0.069\n4. Notch Filter (Resonance Suppression): For systems with known resonance, add notch filter: H_notch(z) = (z² - 2cos(ω_notch·dt)z + 1)/(z² - 2r·cos(ω_notch·dt)z + r²)\nwhere r &lt; 1 controls notch width."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate underdamped oscillator with natural frequency 2π rad/s (1 Hz)\nsystem = DiscreteOscillator(omega_n=2*np.pi, zeta=0.1, dt=0.01)\nInitial condition: displaced 1m, at rest\nx0 = np.array([1.0, 0.0]) # [position, velocity]\nFree oscillation (no control)\nresult_free = system.simulate( … x0=x0, … u_sequence=None, … n_steps=500 … )\nPlot free oscillation\nimport matplotlib.pyplot as plt t = result_free[‘time_steps’] * system.dt fig, axes = plt.subplots(3, 1, figsize=(10, 8))\nPosition\naxes[0].plot(t, result_free[‘states’][:, 0]) axes[0].set_ylabel(‘Position [m]’) axes[0].grid() axes[0].set_title(‘Free Oscillation (Underdamped)’)\nVelocity\naxes[1].plot(t, result_free[‘states’][:, 1]) axes[1].set_ylabel(‘Velocity [m/s]’) axes[1].grid()\nPhase portrait\naxes[2].plot(result_free[‘states’][:, 0], result_free[‘states’][:, 1]) axes[2].set_xlabel(‘Position [m]’) axes[2].set_ylabel(‘Velocity [m/s]’) axes[2].grid() axes[2].set_title(‘Phase Portrait (Spiral to Origin)’)\nplt.tight_layout() plt.show()\nCompute theoretical decay envelope\nA0 = 1.0 # Initial amplitude envelope = A0 * np.exp(-system.zeta * system.omega_n * t)\nVerify decay rate\npeaks = result_free[‘states’][::int(np.pi/(system.omega_d * system.dt)), 0] print(f”Theoretical decay: {envelope[-1]:.4f}“) print(f”Simulated decay: {np.abs(peaks[-1]):.4f}“)\nDesign damping augmentation controller\nzeta_desired = 0.7 # Critical damping k_d = system.design_damping_controller(zeta_desired) print(f”Damping gain: k_d = {k_d:.2f}“)\ndef damping_controller(x, k): … return -k_d * x[1] # Velocity feedback only\nresult_damped = system.rollout(x0, damping_controller, n_steps=500)\nCompare settling times\nsettling_threshold = 0.02 * A0 # 2% criterion free_settling = np.where(np.abs(result_free[‘states’][:, 0]) &lt; settling_threshold)[0] damped_settling = np.where(np.abs(result_damped[‘states’][:, 0]) &lt; settling_threshold)[0]\nif len(free_settling) &gt; 0 and len(damped_settling) &gt; 0: … print(f”Free settling time: {free_settling[0] * system.dt:.2f} s”) … print(f”Damped settling time: {damped_settling[0] * system.dt:.2f} s”)\nResonance testing - sweep frequency\nfrequencies = np.logspace(-1, 1, 50) # 0.1 to 10 rad/s gains = [] phases = []\nfor omega in frequencies: … # Apply sinusoidal input … t_sim = np.arange(0, 20, system.dt) … u_sin = np.sin(omega * t_sim) … … result = system.simulate( … x0=np.zeros(2), … u_sequence=u_sin, … n_steps=len(t_sim) … ) … … # Measure steady-state amplitude and phase … x_ss = result[‘states’][-100:, 0] … u_ss = u_sin[-100:] … … # Compute gain (amplitude ratio) … gain = np.max(np.abs(x_ss)) / np.max(np.abs(u_ss)) … gains.append(gain) … … # Compute phase (via FFT) … X_fft = np.fft.fft(x_ss) … U_fft = np.fft.fft(u_ss) … phase = np.angle(X_fft[1]) - np.angle(U_fft[1]) … phases.append(np.rad2deg(phase))\nPlot Bode diagram\nfig, axes = plt.subplots(2, 1, figsize=(10, 8))\nMagnitude\naxes[0].semilogx(frequencies, 20*np.log10(gains), ‘b-’, label=‘Simulated’) axes[0].axvline(system.omega_n, color=‘r’, linestyle=‘–’, label=f’ωₙ = {system.omega_n:.2f}‘) axes[0].set_ylabel(’Magnitude [dB]’) axes[0].grid(which=‘both’) axes[0].legend() axes[0].set_title(‘Frequency Response (Bode Plot)’)\nPhase\naxes[1].semilogx(frequencies, phases, ‘b-’) axes[1].axvline(system.omega_n, color=‘r’, linestyle=‘–’) axes[1].axhline(-90, color=‘g’, linestyle=‘:’, label=‘-90° at resonance’) axes[1].set_xlabel(‘Frequency [rad/s]’) axes[1].set_ylabel(‘Phase [deg]’) axes[1].grid(which=‘both’) axes[1].legend()\nplt.tight_layout() plt.show()\nDesign LQR controller\nAd, Bd = system.linearize(np.zeros(2), np.zeros(1)) Q = np.diag([100.0, 1.0]) # Care more about position R = np.array([[1.0]]) lqr_result = system.control.design_lqr( … Ad, Bd, Q, R, system_type=‘discrete’ … ) K = lqr_result[‘gain’] print(f”LQR gain: K = {K}“)\nCheck closed-loop damping\nzeta_cl, omega_cl = system.compute_closed_loop_damping(K) print(f”Closed-loop damping: ζ = {zeta_cl:.3f}“) print(f”Closed-loop frequency: ω = {omega_cl:.2f} rad/s”)\nSimulate with LQR\ndef lqr_controller(x, k): … return -K @ x\nresult_lqr = system.rollout(x0, lqr_controller, n_steps=500)\nTracking example: follow sinusoidal reference\nomega_ref = 0.5 # Below resonance A_ref = 0.5 # Amplitude t_track = np.arange(0, 10, system.dt) x_ref = A_ref * np.sin(omega_ref * t_track) v_ref = A_ref * omega_ref * np.cos(omega_ref * t_track) a_ref = -A_ref * omega_ref**2 * np.sin(omega_ref * t_track)\ndef tracking_controller(x, k): … if k &gt;= len(x_ref): … return np.array([0.0]) … … # Feedforward + feedback … u_ff = a_ref[k] + 2system.zetasystem.omega_n*v_ref[k] + system.omega_n**2*x_ref[k] … u_fb = -K @ (x - np.array([x_ref[k], v_ref[k]])) … return u_fb + u_ff\nresult_track = system.rollout(np.zeros(2), tracking_controller, n_steps=len(t_track))\nPlot tracking performance\nplt.figure(figsize=(10, 6)) plt.plot(t_track, x_ref, ‘r–’, label=‘Reference’, linewidth=2) plt.plot(t_track, result_track[‘states’][:, 0], ‘b-’, label=‘Actual’) plt.xlabel(‘Time [s]’) plt.ylabel(‘Position [m]’) plt.legend() plt.grid() plt.title(‘Tracking Performance’) plt.show()\nCompute tracking error\nerror = result_track[‘states’][:, 0] - x_ref rms_error = np.sqrt(np.mean(error**2)) max_error = np.max(np.abs(error)) print(f”RMS tracking error: {rms_error:.4f} m”) print(f”Max tracking error: {max_error:.4f} m”)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nEnergy Considerations: The harmonic oscillator continuously exchanges energy between kinetic and potential forms:\nE_kinetic = 0.5·m·v²\nE_potential = 0.5·k·x²\nE_total = E_kinetic + E_potential\nFor undamped (ζ = 0): Total energy is conserved For damped (ζ &gt; 0): Energy decreases exponentially E(t) = E₀·e^(-2ζωₙt)\nPower dissipated by damping: P_damped = c·v² = 2mζωₙ·v²\nQuality Factor: The quality factor Q measures how underdamped the system is: Q = 1/(2ζ)\nHigh Q (low damping): - Sharp resonance peak - Long ringing time - Narrow bandwidth - Examples: tuning forks (Q ~ 1000), quartz crystals (Q ~ 10⁶)\nLow Q (high damping): - Broad response - Fast settling - Wide bandwidth - Examples: shock absorbers (Q ~ 1), damped doors (Q ~ 0.5)\nDecay Rate vs Oscillation Frequency: For underdamped systems, there’s a tradeoff: - Decay rate: σ = ζωₙ (controls settling time) - Oscillation frequency: ωd = ωₙ√(1 - ζ²)\nAs damping increases: - Decay rate increases (faster settling) - Oscillation frequency decreases - At critical damping: ωd = 0 (no oscillation)\nResonance Phenomenon: At resonance, even small periodic forces can produce large displacements. Examples: - Tacoma Narrows Bridge collapse (1940) - Wine glass shattering from sound - Building damage in earthquakes - Mechanical vibration failures\nPrevention strategies: - Avoid excitation near ωₙ - Increase damping (ζ &gt; 0.1 typically safe) - Use vibration isolators - Active control\nTime Scales: The system has characteristic time scales:\n\nNatural period: T = 2π/ωₙ\n\nTime for one complete oscillation (undamped)\n\nDamped period: Td = 2π/ωd\n\nActual oscillation period (underdamped)\nTd &gt; T (damping slows oscillation)\n\nTime constant: τ = 1/(ζωₙ)\n\nTime for amplitude to decay by factor e\nEnvelope decay: e^(-t/τ)\n\nSettling time (2% criterion): ts ≈ 4τ = 4/(ζωₙ)\n\nTime to reach 2% of steady-state\nOften used as design specification\n\n\nRelationship to Electrical Circuits: The RLC circuit is mathematically identical:\nL·d²q/dt² + R·dq/dt + (1/C)·q = V(t)\nAnalogies: Mechanical ↔︎ Electrical Position x ↔︎ Charge q Velocity v ↔︎ Current i Mass m ↔︎ Inductance L Damping c ↔︎ Resistance R Spring k ↔︎ 1/Capacitance\nThis enables unified analysis and design across domains."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n\nAliasing in high-frequency oscillators: If ωₙ &gt; π/dt (Nyquist), the discrete system appears slower. Fix: Increase sampling rate or add anti-aliasing filter.\nResonance amplification: Small disturbances at ωₙ cause large response for small ζ. Fix: Avoid excitation near ωₙ or increase damping.\nIncorrect damping ratio: Using damping coefficient c instead of ratio ζ. Remember: ζ = c/(2√(km)) is dimensionless.\nForgetting frequency shift: Damped frequency ωd ≠ ωₙ for ζ &gt; 0. Use: ωd = ωₙ√(1 - ζ²)\nNumerical instability with Euler: For stiff systems (large ωₙ or ζ), Euler requires tiny dt. Fix: Use ZOH, Tustin, or implicit methods.\nControl saturation near resonance: At resonance, control effort can be excessive. Fix: Use anti-windup, gain scheduling, or notch filters."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#extensions",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#extensions",
    "title": "",
    "section": "Extensions:",
    "text": "Extensions:\nThis basic oscillator can be extended to:\n\nNonlinear oscillator: Add nonlinear spring: k → k₁x + k₃x³ (Duffing oscillator) Creates amplitude-dependent frequency\nCoupled oscillators: Multiple masses connected by springs Normal modes and mode shapes\nParametric oscillator: Time-varying parameters: ωₙ(t) Can cause parametric resonance\nForced oscillator with multiple frequencies: Beat phenomena, combination tones\nWith Coulomb friction: Add dry friction: F_friction = μ·N·sign(v) Creates limit cycles\nNonlinear damping: Quadratic drag: F_drag = c·v² Common in aerodynamics"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDiscreteDoubleIntegrator : Undamped limit (ζ = 0, ωₙ = 0)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#attributes",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ndamped_period\nDamped period Td = 2π/ωd [s] (for underdamped only).\n\n\ndamping_coefficient\nDamping coefficient c = 2ζ√(km) [N·s/m].\n\n\nnatural_period\nNatural period T = 2π/ωₙ [s].\n\n\nomega_d\nDamped natural frequency [rad/s].\n\n\nomega_n\nNatural frequency [rad/s].\n\n\nquality_factor\nQuality factor Q = 1/(2ζ) [-].\n\n\nsettling_time\nSettling time (2% criterion) ts ≈ 4τ [s].\n\n\nspring_constant\nSpring constant k = m·ωₙ² [N/m].\n\n\ntime_constant\nTime constant τ = 1/(ζωₙ) [s].\n\n\nzeta\nDamping ratio [-]."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteOscillator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_closed_loop_damping\nCompute closed-loop damping ratio and natural frequency.\n\n\ncompute_eigenvalues\nCompute discrete-time eigenvalues.\n\n\ncompute_frequency_response\nCompute frequency response (Bode plot data).\n\n\ncompute_resonant_frequency\nCompute resonant peak frequency ωᵣ [rad/s].\n\n\ncompute_resonant_peak\nCompute resonant peak magnitude (gain at resonance).\n\n\ncompute_step_response_characteristics\nCompute step response characteristics.\n\n\ncompute_system_matrices\nCompute discrete-time state-space matrices Ad, Bd.\n\n\ndefine_system\nDefine discrete-time harmonic oscillator dynamics.\n\n\ndesign_damping_controller\nDesign velocity feedback gain to achieve desired damping ratio.\n\n\ndesign_stiffness_controller\nDesign position feedback gain to achieve desired natural frequency.\n\n\ngenerate_chirp_signal\nGenerate chirp (frequency sweep) signal for system identification.\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ncompute_closed_loop_damping\nsystems.builtin.deterministic.discrete.DiscreteOscillator.compute_closed_loop_damping(\n    K,\n)\nCompute closed-loop damping ratio and natural frequency.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nK\nnp.ndarray\nState feedback gain [k_p, k_d]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(zeta_cl, omega_cl) closed-loop damping and frequency\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; K = np.array([[50, 10]])\n&gt;&gt;&gt; zeta_cl, omega_cl = system.compute_closed_loop_damping(K)\n&gt;&gt;&gt; print(f\"Closed-loop: ζ = {zeta_cl:.3f}, ω = {omega_cl:.2f}\")\n\n\n\ncompute_eigenvalues\nsystems.builtin.deterministic.discrete.DiscreteOscillator.compute_eigenvalues()\nCompute discrete-time eigenvalues.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nComplex eigenvalues (2,)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; eigs = system.compute_eigenvalues()\n&gt;&gt;&gt; print(f\"Eigenvalues: {eigs}\")\n&gt;&gt;&gt; print(f\"Magnitude: {np.abs(eigs)}\")\n&gt;&gt;&gt; print(f\"Stable: {np.all(np.abs(eigs) &lt; 1)}\")\n\n\nNotes\nFor continuous-time poles s = -ζωₙ ± jωₙ√(1-ζ²), discrete poles are z = e^(s·dt).\nMagnitude |z| = e^(-ζωₙdt) determines stability: - |z| &lt; 1: Stable (decays) - |z| = 1: Marginally stable (ζ = 0) - |z| &gt; 1: Unstable (grows)\n\n\n\ncompute_frequency_response\nsystems.builtin.deterministic.discrete.DiscreteOscillator.compute_frequency_response(\n    frequencies,\n)\nCompute frequency response (Bode plot data).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfrequencies\nnp.ndarray\nFrequencies to evaluate [rad/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(magnitude_dB, phase_deg) where: - magnitude_dB: Magnitude in decibels - phase_deg: Phase in degrees\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; freqs = np.logspace(-1, 2, 100)\n&gt;&gt;&gt; mag_dB, phase_deg = system.compute_frequency_response(freqs)\n&gt;&gt;&gt;\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; fig, axes = plt.subplots(2, 1)\n&gt;&gt;&gt; axes[0].semilogx(freqs, mag_dB)\n&gt;&gt;&gt; axes[0].set_ylabel('Magnitude [dB]')\n&gt;&gt;&gt; axes[1].semilogx(freqs, phase_deg)\n&gt;&gt;&gt; axes[1].set_ylabel('Phase [deg]')\n&gt;&gt;&gt; axes[1].set_xlabel('Frequency [rad/s]')\n&gt;&gt;&gt; plt.show()\n\n\n\ncompute_resonant_frequency\nsystems.builtin.deterministic.discrete.DiscreteOscillator.compute_resonant_frequency(\n)\nCompute resonant peak frequency ωᵣ [rad/s].\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nResonant frequency (0 if ζ ≥ 1/√2)\n\n\n\n\n\nNotes\nFor ζ &lt; 1/√2: ωᵣ = ωₙ√(1 - 2ζ²)\nThe resonant frequency is where the magnitude response peaks. It’s lower than the natural frequency and only exists for lightly damped systems.\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; omega_r = system.compute_resonant_frequency()\n&gt;&gt;&gt; print(f\"Resonant frequency: {omega_r:.2f} rad/s\")\n&gt;&gt;&gt; print(f\"Natural frequency: {system.omega_n:.2f} rad/s\")\n\n\n\ncompute_resonant_peak\nsystems.builtin.deterministic.discrete.DiscreteOscillator.compute_resonant_peak(\n)\nCompute resonant peak magnitude (gain at resonance).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nPeak magnitude (infinity if ζ = 0)\n\n\n\n\n\nNotes\nAt resonance (ω = ωᵣ): |H(jωᵣ)| = 1/(2ζ√(1 - ζ²))\nFor small damping (ζ &lt;&lt; 1): |H(jωₙ)| ≈ Q = 1/(2ζ)\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.05, dt=0.01)\n&gt;&gt;&gt; peak = system.compute_resonant_peak()\n&gt;&gt;&gt; print(f\"Resonant peak: {peak:.1f} ({20*np.log10(peak):.1f} dB)\")\n&gt;&gt;&gt; print(f\"Quality factor: {system.quality_factor:.1f}\")\n\n\n\ncompute_step_response_characteristics\nsystems.builtin.deterministic.discrete.DiscreteOscillator.compute_step_response_characteristics(\n)\nCompute step response characteristics.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary containing: - ‘rise_time’: 10%-90% rise time [s] - ‘peak_time’: Time to first peak [s] - ‘overshoot’: Peak overshoot [%] - ‘settling_time’: 2% settling time [s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.3, dt=0.01)\n&gt;&gt;&gt; chars = system.compute_step_response_characteristics()\n&gt;&gt;&gt; for key, val in chars.items():\n...     print(f\"{key}: {val:.3f}\")\n\n\nNotes\nThese formulas are for underdamped systems (0 &lt; ζ &lt; 1). For critically/overdamped systems, some metrics don’t apply.\n\n\n\ncompute_system_matrices\nsystems.builtin.deterministic.discrete.DiscreteOscillator.compute_system_matrices(\n)\nCompute discrete-time state-space matrices Ad, Bd.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(Ad, Bd) where: - Ad: State transition matrix (2×2) - Bd: Control input matrix (2×1)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=2*np.pi, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; Ad, Bd = system.compute_system_matrices()\n&gt;&gt;&gt; print(f\"Ad =\\n{Ad}\")\n&gt;&gt;&gt; print(f\"Bd =\\n{Bd}\")\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteOscillator.define_system(\n    omega_n=1.0,\n    zeta=0.1,\n    dt=0.1,\n    method='zoh',\n    mass=1.0,\n    spring_constant=None,\n    damping_coefficient=None,\n)\nDefine discrete-time harmonic oscillator dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nomega_n\nfloat\nNatural frequency [rad/s], must be positive\n1.0\n\n\nzeta\nfloat\nDamping ratio [-], must be non-negative\n0.1\n\n\ndt\nfloat\nSampling time step [s]\n0.1\n\n\nmethod\nstr\nDiscretization method: - ‘zoh’: Zero-order hold (exact, recommended) - ‘tustin’: Bilinear/trapezoidal transform - ‘euler’: Forward Euler (simple) - ‘backward_euler’: Backward Euler (implicit) - ‘matched’: Matched pole-zero method\n'zoh'\n\n\nmass\nfloat\nSystem mass [kg] (only used with spring_constant/damping_coefficient)\n1.0\n\n\nspring_constant\nOptional[float]\nSpring constant k [N/m] (alternative to omega_n) If provided: omega_n = sqrt(k/m)\nNone\n\n\ndamping_coefficient\nOptional[float]\nDamping coefficient c [N·s/m] (alternative to zeta) If provided: zeta = c/(2sqrt(km))\nNone\n\n\n\n\n\n\ndesign_damping_controller\nsystems.builtin.deterministic.discrete.DiscreteOscillator.design_damping_controller(\n    zeta_desired,\n)\nDesign velocity feedback gain to achieve desired damping ratio.\nControl law: u[k] = -k_d·v[k]\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nzeta_desired\nfloat\nDesired closed-loop damping ratio\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nVelocity feedback gain k_d\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; k_d = system.design_damping_controller(zeta_desired=0.7)\n&gt;&gt;&gt; print(f\"Damping gain: k_d = {k_d:.2f}\")\n\n\nNotes\nThis adds damping without changing natural frequency (approximately). The effective damping becomes: ζ_eff ≈ ζ + k_d/(2ωₙ)\nSolving for k_d: k_d = 2ωₙ(ζ_desired - ζ)\n\n\n\ndesign_stiffness_controller\nsystems.builtin.deterministic.discrete.DiscreteOscillator.design_stiffness_controller(\n    omega_n_desired,\n)\nDesign position feedback gain to achieve desired natural frequency.\nControl law: u[k] = -k_p·x[k]\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nomega_n_desired\nfloat\nDesired closed-loop natural frequency [rad/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nPosition feedback gain k_p\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=5, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; k_p = system.design_stiffness_controller(omega_n_desired=10)\n&gt;&gt;&gt; print(f\"Stiffness gain: k_p = {k_p:.2f}\")\n\n\nNotes\nThis changes the effective natural frequency: ωₙ_eff = √(ωₙ² + k_p)\nSolving for k_p: k_p = ωₙ_desired² - ωₙ²\n\n\n\ngenerate_chirp_signal\nsystems.builtin.deterministic.discrete.DiscreteOscillator.generate_chirp_signal(\n    f_start,\n    f_end,\n    duration,\n    amplitude=1.0,\n)\nGenerate chirp (frequency sweep) signal for system identification.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nf_start\nfloat\nStarting frequency [Hz]\nrequired\n\n\nf_end\nfloat\nEnding frequency [Hz]\nrequired\n\n\nduration\nfloat\nSignal duration [s]\nrequired\n\n\namplitude\nfloat\nSignal amplitude\n1.0\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nChirp signal\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteOscillator(omega_n=10, zeta=0.1, dt=0.01)\n&gt;&gt;&gt; chirp = system.generate_chirp_signal(\n...     f_start=0.1,\n...     f_end=5.0,\n...     duration=10.0\n... )\n&gt;&gt;&gt; result = system.simulate(\n...     x0=np.zeros(2),\n...     u_sequence=chirp,\n...     n_steps=len(chirp)\n... )\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscreteOscillator.setup_equilibria()\nSet up equilibrium points.\nAdds the origin (rest position) as the stable equilibrium for damped systems."
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html",
    "href": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html#attributes",
    "href": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nt0\nScalarLike\nStart time\n\n\nt1\nScalarLike\nEnd time\n\n\ndW\nArrayLike\nBrownian increment for interval (t0, t1) Shape: (nw,) for the noise dimensions"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html#examples",
    "href": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Zero noise for deterministic testing\n&gt;&gt;&gt; dW = jnp.zeros(1)\n&gt;&gt;&gt; brownian = CustomBrownianPath(0.0, 0.01, dW)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom noise pattern\n&gt;&gt;&gt; dW = jnp.array([0.5])\n&gt;&gt;&gt; brownian = CustomBrownianPath(0.0, 0.01, dW)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html#methods",
    "href": "api/systems.base.numerical_integration.stochastic.CustomBrownianPath.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nevaluate\nEvaluate Brownian increment between t0 and t1.\n\n\n\n\nevaluate\nsystems.base.numerical_integration.stochastic.CustomBrownianPath.evaluate(\n    t0,\n    t1=None,\n    left=True,\n)\nEvaluate Brownian increment between t0 and t1.\nFor custom noise, we provide the exact increment for our interval. Diffrax will call this to get dW values.\nThis method must be JIT-compatible, so we use jnp.where() instead of Python if statements to avoid tracer boolean conversion errors.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt0\nScalarLike\nStart time of query\nrequired\n\n\nt1\nOptional[ScalarLike]\nEnd time of query (if None, return value at t0)\nNone\n\n\nleft\nbool\nWhether to use left or right limit\nTrue\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArray\nBrownian increment or value (JAX array for Diffrax compatibility)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegratorWithForce.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegratorWithForce.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegratorWithForce.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegratorWithForce.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine double integrator with force input.\n\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegratorWithForce.define_system(\n    dt=0.1,\n    mass=1.0,\n    method='zoh',\n)\nDefine double integrator with force input.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndt\nfloat\nSampling time [s]\n0.1\n\n\nmass\nfloat\nSystem mass [kg]\n1.0\n\n\nmethod\nstr\nDiscretization method\n'zoh'"
  },
  {
    "objectID": "api/types.trajectories.OutputSequence.html",
    "href": "api/types.trajectories.OutputSequence.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.OutputSequence.html#examples",
    "href": "api/types.trajectories.OutputSequence.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Simulate and observe\n&gt;&gt;&gt; trajectory: StateTrajectory = system.simulate(x0, u_seq, steps=100)\n&gt;&gt;&gt; observations: OutputSequence = system.observe(trajectory)\n&gt;&gt;&gt; print(observations.shape)  # (101, ny)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Noisy measurements\n&gt;&gt;&gt; y_clean: OutputSequence = C @ trajectory.T  # (ny, n_steps)\n&gt;&gt;&gt; y_noisy: OutputSequence = y_clean + np.random.randn(*y_clean.shape) * 0.1\n&gt;&gt;&gt; y_noisy = y_noisy.T  # (n_steps, ny)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Kalman filter with measurements\n&gt;&gt;&gt; x_estimates = []\n&gt;&gt;&gt; for k in range(len(observations)):\n...     y_k = observations[k]\n...     x_hat = kalman_filter.update(y_k, u_seq[k])\n...     x_estimates.append(x_hat)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # System identification dataset\n&gt;&gt;&gt; dataset = {\n...     'inputs': u_seq,      # (n_steps, nu)\n...     'outputs': y_seq,     # (n_steps, ny)\n...     'time': t_points,     # (n_steps,)\n... }"
  },
  {
    "objectID": "api/types.contraction.CCMResult.html",
    "href": "api/types.contraction.CCMResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.contraction.CCMResult.html#fields",
    "href": "api/types.contraction.CCMResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nfeedback_gain : GainMatrix State-dependent K(x) or constant K metric : ContractionMetric Contraction metric M(x) contraction_rate : ContractionRate Guaranteed contraction rate β metric_condition_number : ArrayLike Condition number κ(M(x)) over state space contraction_verified : bool LMI/SOS verification succeeded robustness_margin : float Margin in contraction condition geodesic_distance : Optional[Callable] Distance in M-metric: d_M(x₁, x₂)"
  },
  {
    "objectID": "api/types.contraction.CCMResult.html#examples",
    "href": "api/types.contraction.CCMResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Design CCM controller\n&gt;&gt;&gt; result: CCMResult = design_ccm_controller(\n...     system=pendulum,\n...     contraction_rate=0.5,\n...     method='SDP'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['contraction_verified']:\n...     K = result['feedback_gain']\n...     M = result['metric']\n...     beta = result['contraction_rate']\n...\n...     print(f\"CCM controller designed!\")\n...     print(f\"Contraction rate: {beta:.3f}\")\n...     print(f\"Robustness margin: {result['robustness_margin']:.3f}\")\n...\n...     # Apply controller\n...     def controller(x):\n...         if callable(K):\n...             return K(x)  # State-dependent\n...         else:\n...             return K @ x  # Constant\n...\n...     # Geodesic distance (if available)\n...     if 'geodesic_distance' in result:\n...         d_M = result['geodesic_distance']\n...         x1 = np.array([1.0, 0.5])\n...         x2 = np.array([0.5, 0.3])\n...         dist = d_M(x1, x2)\n...         print(f\"Distance in M-metric: {dist:.3f}\")"
  },
  {
    "objectID": "api/systems.base.utils.ObservationEngine.html",
    "href": "api/systems.base.utils.ObservationEngine.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.ObservationEngine.html#methods",
    "href": "api/systems.base.utils.ObservationEngine.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_jacobian\nCompute linearized observation: C = ∂h/∂x.\n\n\ncompute_symbolic\nCompute symbolic linearization C = ∂h/∂x.\n\n\nevaluate\nEvaluate output equation: y = h(x).\n\n\n\n\ncompute_jacobian\nsystems.base.utils.ObservationEngine.compute_jacobian(x, backend=None)\nCompute linearized observation: C = ∂h/∂x.\nIf no custom output function, returns identity matrix.\nArgs: x: State at which to linearize backend: Backend selection: - None: Auto-detect from input type (default) - ‘numpy’, ‘torch’, ‘jax’: Force specific backend - ‘default’: Use system’s default backend\nReturns: OutputMatrix C matrix (ny, nx) - output Jacobian (type matches backend)\nExample: &gt;&gt;&gt; C: OutputMatrix = engine.compute_jacobian(x, backend=‘numpy’) &gt;&gt;&gt; print(C.shape) # (ny, nx)\n\n\ncompute_symbolic\nsystems.base.utils.ObservationEngine.compute_symbolic(x_eq=None)\nCompute symbolic linearization C = ∂h/∂x.\nArgs: x_eq: Equilibrium state (zeros if None)\nReturns: C: Symbolic Jacobian matrix\nExample: &gt;&gt;&gt; C_sym = engine.compute_symbolic(x_eq=sp.Matrix([0, 0]))\n\n\nevaluate\nsystems.base.utils.ObservationEngine.evaluate(x, backend=None)\nEvaluate output equation: y = h(x).\nIf no custom output function is defined, returns the full state (identity).\nArgs: x: State vector backend: Backend selection: - None: Auto-detect from input type (default) - ‘numpy’, ‘torch’, ‘jax’: Force specific backend - ‘default’: Use system’s default backend\nReturns: Output vector (type matches backend)\nExample: &gt;&gt;&gt; y: OutputVector = engine.evaluate(x_numpy) # Auto-detect NumPy &gt;&gt;&gt; y: OutputVector = engine.evaluate(x_numpy, backend=‘torch’) # Convert to torch"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html",
    "href": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nDecay rate (positive = stable)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html#examples",
    "href": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; system = AutonomousLinearSystem(a=1.0)\n&gt;&gt;&gt; system.nu\n0\n&gt;&gt;&gt; dx = system(np.array([1.0]), u=None)  # -1*1 = -1"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html#methods",
    "href": "api/systems.builtin.deterministic.continuous.AutonomousLinearSystem.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine autonomous linear dynamics.\n\n\n\n\ndefine_system\nsystems.builtin.deterministic.continuous.AutonomousLinearSystem.define_system(\n    a=1.0,\n)\nDefine autonomous linear dynamics."
  },
  {
    "objectID": "api/types.linearization.ContinuousLinearization.html",
    "href": "api/types.linearization.ContinuousLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.ContinuousLinearization.html#examples",
    "href": "api/types.linearization.ContinuousLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Ac, Bc = continuous_system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; # Continuous-time stability: Re(λ) &lt; 0\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(Ac)\n&gt;&gt;&gt; is_stable = np.all(np.real(eigenvalues) &lt; 0)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nThe Hénon map was introduced by Michel Hénon (1976) as a simplified model for the Poincaré section of the Lorenz equations. It represents a generic quadratic area-contracting map that captures essential features of dissipative chaos.\nMathematical Form: The defining equations are remarkably simple:\nx[n+1] = 1 - a·x[n]² + y[n]\ny[n+1] = b·x[n]\nDespite this simplicity, the map exhibits: - Chaotic attractors (strange attractors) - Period-doubling cascades - Fractal basin boundaries - Sensitive dependence on initial conditions - Homoclinic bifurcations\nPhysical Interpretation: While originally a mathematical abstraction, the Hénon map can model: 1. Poincaré sections of 3D continuous flows 2. Population dynamics with two age classes 3. Chemical reactions with two coupled species 4. Economic models with production and capital 5. Fluid mixing and turbulence onset\nThe key feature is DISSIPATION: phase space volume contracts, leading to attractors (unlike conservative Hamiltonian systems).\nDissipation and Attractors: The Jacobian determinant is: det(J) = -b\nFor |b| &lt; 1, the map is area-contracting: - Phase space volume shrinks by factor |b| each iteration - Asymptotically, dynamics confined to attractor - Attractor has dimension &lt; 2 (fractal)\nThis contrasts with: - Logistic map (1D): Dimension 0 or 1 attractors - Standard map (conservative): No attractors, volume-preserving - Hénon map (2D dissipative): Dimension ~1.26 attractor (fractal!)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[n] = [x[n], y[n]] First coordinate: - x: “Position” or primary variable * Unbounded in principle: -∞ &lt; x &lt; ∞ * Typically confined to bounded region by attractor * For standard parameters: -1.5 &lt; x &lt; 1.5\nSecond coordinate:\n- y: \"Velocity\" or secondary variable\n  * Coupled to previous x value: y[n] = b·x[n-1]\n  * Acts as delayed feedback\n  * For standard parameters: -0.4 &lt; y &lt; 0.4\nPhase Space Structure: The (x, y) plane contains: - Attractors (where orbits converge) - Basins of attraction (initial conditions leading to each attractor) - Basin boundaries (separating different basins) - Saddle points and unstable manifolds\nControl: u[n] (optional, for controlled Hénon map) - Can represent: * Perturbation to x dynamics: x[n+1] = 1 - a·x[n]² + y[n] + u[n] * External forcing or feedback control * Stabilization of unstable periodic orbits - Standard map: u = 0 (autonomous)\nOutput: y[n] = [x[n], y[n]] - Full state measurement (both coordinates) - In practice, may observe only x (partial observation) - Time-delay embedding can reconstruct attractor from x alone"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#dynamics",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe Hénon map is defined by:\nx[n+1] = 1 - a·x[n]² + y[n]\ny[n+1] = b·x[n]\nKey Mathematical Properties:\n\nQuadratic nonlinearity:\n\nThe x² term creates folding in phase space\nEnables period-doubling and chaos\nSimplest polynomial map with strange attractor\n\nArea contraction (dissipation): Jacobian: J = | -2ax 1 | | b 0 |\ndet(J) = -b (constant, independent of state!)\nFor |b| &lt; 1:\n\nArea contracts by factor |b| per iteration\nVolume of phase space → 0 as n → ∞\nDynamics attracted to lower-dimensional set\n\nInvertibility: The map has a unique inverse (for b ≠ 0):\nx[n] = y[n+1]/b y[n] = x[n+1] - 1 + a·(y[n+1]/b)²\nThis allows backward iteration (unlike logistic map).\nTime-reversal symmetry (special case): For b = -1, map is time-reversible (area-preserving) This is the limit connecting to Hamiltonian systems."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\na : float, default=1.4 Nonlinearity parameter (controls folding strength)\n**Physical Meaning:**\n- Controls strength of quadratic nonlinearity\n- Larger |a| → stronger folding\n- Determines attractor complexity\n\n**Parameter Regimes:**\n\n**a = 0:**\n- Linear map: x[n+1] = 1 + y[n], y[n+1] = b·x[n]\n- Simple dynamics, no chaos\n- All orbits converge or diverge simply\n\n**0 &lt; a &lt; 0.368:**\n- Stable fixed point\n- All trajectories converge to single point\n- No oscillations or complexity\n\n**a ≈ 0.368:**\n- Flip bifurcation (period-doubling)\n- Fixed point becomes unstable\n- Period-2 orbit appears\n\n**0.368 &lt; a &lt; 1.06:**\n- Periodic attractors (period-2, 4, 8, ...)\n- Period-doubling cascade\n- Feigenbaum scaling (universal constants)\n- Resembles logistic map behavior\n\n**a ≈ 1.06:**\n- Onset of chaos\n- Accumulation point of period-doubling cascade\n- Transition from periodic to chaotic\n\n**1.06 &lt; a &lt; 1.4:**\n- Chaotic attractor (strange attractor)\n- Positive Lyapunov exponent\n- Fractal structure\n- Sensitive dependence on initial conditions\n\n**a = 1.4 (canonical value):**\n- Classic Hénon attractor\n- Well-studied strange attractor\n- Fractal dimension ≈ 1.26\n- Hausdorff dimension ≈ 1.261\n- Correlation dimension ≈ 1.25\n\n**a &gt; 1.4:**\n- Attractor may fragment or disappear\n- Escape to infinity possible\n- Multiple attractors may coexist\n- Complex basin boundaries\n\n**a &gt;&gt; 1:**\n- Most orbits escape to infinity\n- Bounded attractors rare\n- Chaotic scattering regime\nb : float, default=0.3 Dissipation parameter (controls area contraction)\n**Physical Meaning:**\n- Controls phase space volume contraction rate\n- |det(J)| = |b| = volume contraction factor\n- Larger |b| → slower contraction, less dissipation\n- Smaller |b| → faster contraction, more dissipation\n\n**Special Values:**\n\n**b = 0:**\n- Extreme dissipation (collapse to 1D)\n- y coordinate decouples: y[n+1] = 0\n- Effectively becomes 1D logistic-like map\n- Loses 2D structure\n\n**0 &lt; b &lt; 1:**\n- Standard dissipative regime\n- Area-contracting (det(J) &lt; 1)\n- Attractors exist (typical case)\n- b = 0.3 is canonical value\n\n**b = 1:**\n- Borderline case (area-preserving)\n- Conservative limit\n- No attractors (like Standard Map)\n- Unlikely for physical dissipative systems\n\n**b = -1:**\n- Area-preserving AND time-reversible\n- Special mathematical interest\n- Connects to Hamiltonian dynamics\n- Not typical for dissipative systems\n\n**-1 &lt; b &lt; 0:**\n- Orientation-reversing\n- Still dissipative (|b| &lt; 1)\n- Can have strange attractors\n- Less commonly studied\n\n**|b| &gt; 1:**\n- Area-expanding\n- No bounded attractors\n- Orbits typically escape\n- Not physical for dissipative systems\ndt : float, default=1.0 Time step between iterations - Usually normalized to 1 - Represents sampling period - Only affects interpretation, not dynamics"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#equilibria-and-fixed-points",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#equilibria-and-fixed-points",
    "title": "",
    "section": "Equilibria and Fixed Points:",
    "text": "Equilibria and Fixed Points:\nFixed points satisfy: x* = 1 - a·x² + y y* = b·x*\nSubstituting second into first: x* = 1 - a·x² + b·x a·x² - (b-1)·x + 1 = 0\nSolutions (for standard b = 0.3, a varies): x* = [(b-1) ± √((b-1)² - 4a)] / (2a)\nFixed points exist if: (b-1)² ≥ 4a\nFor b = 0.3: 0.49 ≥ 4a a ≤ 0.1225\nFor a &gt; 0.1225, fixed points are complex (no real equilibria).\nTypical scenario (a = 1.4, b = 0.3): - No real fixed points - System has no equilibria - All dynamics are transient or on attractor - Attractor is only long-term behavior\nStability of fixed points: When fixed points exist, linearization gives: λ₁, λ₂ = eigenvalues of Jacobian\nFixed point is stable if |λ₁|, |λ₂| &lt; 1."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#strange-attractor",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#strange-attractor",
    "title": "",
    "section": "Strange Attractor:",
    "text": "Strange Attractor:\nThe Hénon attractor (a = 1.4, b = 0.3) is a STRANGE ATTRACTOR:\nDefinition: A strange attractor is an attracting set that: 1. Is an attractor (nearby trajectories approach it) 2. Is strange (exhibits sensitive dependence on IC) 3. Has fractal structure (non-integer dimension)\nProperties of Hénon attractor: - Fractal dimension: D ≈ 1.26 (between 1D and 2D) - Correlation dimension: d_c ≈ 1.25 - Lyapunov exponents: λ₁ ≈ 0.42, λ₂ ≈ -1.62 - Lyapunov dimension: D_L = 1 + λ₁/|λ₂| ≈ 1.26 - Information dimension: Similar to fractal dimension\nVisual structure: - Appears as collection of parallel curves (bands) - Actually infinitely many curves (fractal layering) - Self-similar structure at all scales - Gaps between bands contain saddle points\nUnstable manifolds: - Curves connecting unstable fixed points/periodic orbits - Create complicated tangles (homoclinic tangles) - Fold back on themselves infinitely - Define skeleton of attractor"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#chaos-characterization",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#chaos-characterization",
    "title": "",
    "section": "Chaos Characterization:",
    "text": "Chaos Characterization:\nLyapunov Exponents: For canonical Hénon map (a = 1.4, b = 0.3): λ₁ ≈ 0.42 (positive → chaos) λ₂ ≈ -1.62 (negative → dissipation) λ₁ + λ₂ = ln|b| ≈ -1.20 (contraction rate)\nThe positive Lyapunov exponent confirms: - Exponential divergence of nearby trajectories - Sensitive dependence on initial conditions - Chaotic dynamics (deterministic but unpredictable)\nBasin of Attraction: The set of initial conditions leading to the attractor. For Hénon map: - Basin is typically simply connected (single piece) - But can have fractal boundary - Some parameters → multiple attractors with intertwined basins\nPeriodic Orbits: Embedded in attractor are infinitely many unstable periodic orbits: - Period-1, 2, 3, 4, … orbits - All are unstable (saddles) - Dense in the attractor - Can be used for control (OGY method)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#bifurcations-and-route-to-chaos",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#bifurcations-and-route-to-chaos",
    "title": "",
    "section": "Bifurcations and Route to Chaos:",
    "text": "Bifurcations and Route to Chaos:\nAs ‘a’ increases (with b = 0.3 fixed), the Hénon map undergoes:\n1. Fixed point stability loss (a ≈ 0.37): - Flip bifurcation (period-doubling) - Stable fixed point → period-2 orbit\n2. Period-doubling cascade (0.37 &lt; a &lt; 1.06): - Period-2 → period-4 → period-8 → … - Geometric convergence (Feigenbaum constants) - δ ≈ 4.669… (universal) - α ≈ 2.502… (universal)\n3. Onset of chaos (a ≈ 1.06): - Accumulation point of cascade - Lyapunov exponent becomes positive - Attractor dimension becomes fractal\n4. Fully developed chaos (1.06 &lt; a &lt; 1.4): - Strange attractor forms - Sensitive dependence maximizes - Periodic windows may appear\n5. Attractor crisis (a &gt; 1.4): - Attractor may collide with unstable manifold - Sudden destruction or enlargement - Possible escape to infinity\nThis sequence is the period-doubling route to chaos, one of three universal routes (along with intermittency and quasi-periodicity)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\n1. Chaos Control (OGY Method): Goal: Stabilize unstable periodic orbits embedded in attractor Method: Apply small parameter perturbations - Locate periodic orbit (e.g., period-1) - Compute local stable/unstable directions - Apply control when trajectory near orbit - Perturbation: u[n] = -K·(x[n] - x_orbit)\n2. Chaos Synchronization: Goal: Make two Hénon maps follow same trajectory Applications: Secure communication, pattern recognition Method: Couple systems or drive-response configuration\n3. Targeting: Goal: Steer trajectory to specific location on attractor Useful for optimization and search\n4. Anti-control (Chaotification): Goal: Make periodic system chaotic Applications: Mixing, encryption, avoiding resonance\n5. Basin of attraction enlargement: Goal: Expand region attracting to desired attractor Important when multiple attractors coexist"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\nAttractor Visualization: Standard method: 1. Choose initial condition (often random) 2. Discard first ~1000 iterations (transient) 3. Plot next 10,000+ points 4. Result shows attractor structure\nTransient Behavior: - First iterations may not reflect attractor - Discard typically 100-1000 initial points - Longer transients near bifurcations\nNumerical Precision: - Double precision (64-bit) sufficient - Chaos amplifies roundoff errors exponentially - Long-term trajectories unreliable (&gt;1000 iterations) - Statistical properties converge faster than trajectories\nBasin of Attraction Computation: - Grid initial conditions in (x, y) plane - Iterate each until convergence or escape - Color-code by attractor reached - Reveals basin structure and boundaries\nDimension Estimation: Several algorithms available: - Box-counting dimension (covers attractor with boxes) - Correlation dimension (uses point correlations) - Lyapunov dimension (from Lyapunov exponents) - Information dimension (uses entropies)\nAll give similar values (~1.26) for canonical Hénon attractor."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate canonical Hénon map\nsystem = HenonMap(a=1.4, b=0.3)\nVisualize strange attractor\nx0 = np.array([0.1, 0.1]) result = system.simulate( … x0=x0, … u_sequence=None, … n_steps=10000 … )\nPlot attractor (discard transient)\nimport plotly.graph_objects as go states_attractor = result[‘states’][1000:, :] # Skip first 1000\nfig = go.Figure() fig.add_trace(go.Scatter( … x=states_attractor[:, 0], … y=states_attractor[:, 1], … mode=‘markers’, … marker=dict(size=1, color=‘blue’, opacity=0.5), … name=‘Hénon Attractor’ … ))\nfig.update_layout( … title=f’Hénon Attractor (a={system.a}, b={system.b})‘, … xaxis_title=’x’, … yaxis_title=‘y’, … width=800, … height=600, … plot_bgcolor=‘white’ … ) fig.show()\nCompute Lyapunov exponents\nlyap_exp = system.compute_lyapunov_exponents( … x0=np.array([0.1, 0.1]), … n_iterations=50000 … ) print(f”Lyapunov exponents: λ₁ = {lyap_exp[0]:.4f}, λ₂ = {lyap_exp[1]:.4f}“) print(f”Sum: λ₁ + λ₂ = {sum(lyap_exp):.4f} (should ≈ ln|b| = {np.log(abs(system.b)):.4f})“)\nif lyap_exp[0] &gt; 0: … print(“System is CHAOTIC”) … # Estimate attractor dimension … D_L = 1 + lyap_exp[0] / abs(lyap_exp[1]) … print(f”Lyapunov dimension: D_L ≈ {D_L:.3f}“)\nSensitive dependence on initial conditions\nx0_a = np.array([0.1, 0.1]) x0_b = np.array([0.1 + 1e-10, 0.1]) # Tiny difference\nresult_a = system.simulate(x0_a, None, n_steps=50) result_b = system.simulate(x0_b, None, n_steps=50)\ndivergence = np.linalg.norm( … result_a[‘states’] - result_b[‘states’], … axis=1 … )\nfig = go.Figure() fig.add_trace(go.Scatter( … x=np.arange(51), … y=divergence, … mode=‘lines+markers’, … name=‘Distance’ … )) fig.update_yaxes(type=‘log’) fig.update_layout( … title=‘Exponential Divergence (Sensitive Dependence)’, … xaxis_title=‘Iteration n’, … yaxis_title=‘||x_a - x_b||’, … ) fig.show()\nGenerate bifurcation diagram (varying ‘a’)\nbifurcation_data = system.generate_bifurcation_diagram( … parameter=‘a’, … param_range=(0.8, 1.5), … n_points=500, … n_transient=500, … n_samples=200 … )\nfig = go.Figure() fig.add_trace(go.Scatter( … x=bifurcation_data[‘param’], … y=bifurcation_data[‘x’], … mode=‘markers’, … marker=dict(size=0.5, color=‘black’), … name=‘Bifurcation’ … )) fig.update_layout( … title=‘Hénon Map Bifurcation Diagram’, … xaxis_title=‘a (nonlinearity parameter)’, … yaxis_title=’x*’, … width=1000, … height=600 … ) fig.show()\nExplore basin of attraction\nbasin_data = system.compute_basin_of_attraction( … x_range=(-2, 2), … y_range=(-2, 2), … resolution=400, … max_iterations=100 … )\nfig = go.Figure(data=go.Heatmap( … z=basin_data[‘converged’], … x=basin_data[‘x_grid’][0, :], … y=basin_data[‘y_grid’][:, 0], … colorscale=‘RdBu’, … showscale=True … )) fig.update_layout( … title=‘Basin of Attraction (blue=converges, red=escapes)’, … xaxis_title=‘x₀’, … yaxis_title=‘y₀’, … width=800, … height=800 … ) fig.show()\nCompare multiple parameter values\nfrom plotly.subplots import make_subplots\na_values = [0.9, 1.1, 1.3, 1.4] fig = make_subplots( … rows=2, cols=2, … subplot_titles=[f’a = {a}’ for a in a_values] … )\nfor idx, a_val in enumerate(a_values): … row = idx // 2 + 1 … col = idx % 2 + 1 … … sys_temp = HenonMap(a=a_val, b=0.3) … res_temp = sys_temp.simulate( … x0=np.array([0.1, 0.1]), … u_sequence=None, … n_steps=5000 … ) … … states_plot = res_temp[‘states’][1000:, :] … … fig.add_trace( … go.Scatter( … x=states_plot[:, 0], … y=states_plot[:, 1], … mode=‘markers’, … marker=dict(size=0.5), … showlegend=False … ), … row=row, col=col … )\nfig.update_xaxes(title_text=‘x’) fig.update_yaxes(title_text=‘y’) fig.update_layout( … title_text=‘Hénon Map: Transition to Chaos’, … height=800, … width=1000 … ) fig.show()\nEstimate correlation dimension\ncorr_dim = system.estimate_correlation_dimension( … x0=np.array([0.1, 0.1]), … n_points=5000, … n_transient=1000 … ) print(f”Correlation dimension: d_c ≈ {corr_dim:.3f}“) print(f”(Theoretical for Hénon attractor: ≈ 1.25)“)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nWhy 2D is Different from 1D: - 1D maps (logistic): Attractors are points or periodic cycles - 2D maps (Hénon): Attractors can be STRANGE (fractal curves) - Dimension 1 &lt; D &lt; 2 possible (impossible in 1D!) - Richer dynamics: homoclinic tangles, cantori, etc.\nDissipation Creates Attractors: - Area contraction (det(J) = -b with |b| &lt; 1) crucial - Without dissipation: no attractors (like Standard Map) - Dissipation “squeezes” phase space onto lower-dimensional set - Competition: folding (nonlinearity) vs contraction (dissipation)\nFolding Mechanism: The x² term creates quadratic folding: - Phase space is stretched along one direction - Then folded back on itself - Repeated stretching + folding → fractal structure - This is the “baker’s transformation” in disguise\nConnection to Continuous Systems: Hénon map approximates Poincaré section of: - Lorenz system (chaotic convection) - Duffing oscillator (forced nonlinear pendulum) - Other 3D continuous flows with strange attractors\nDiscrete map captures essential features while being: - Easier to compute (no integration) - Easier to analyze (algebraic not differential) - Still exhibiting all chaos phenomena\nUniversality: The period-doubling cascade in Hénon map obeys same scaling laws (Feigenbaum constants) as logistic map, forced pendulum, and countless other systems. This is UNIVERSAL - a profound discovery showing chaos theory has quantitative predictions!\nFractal Basin Boundaries: When multiple attractors coexist, basin boundaries can be fractal: - Impossibly complicated boundary structure - Arbitrarily close ICs can lead to different attractors - “Riddled basins” - attractor’s basin has holes everywhere - Final-state uncertainty for practical systems"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n\nNot discarding transient: First hundreds of iterations may not show attractor Always skip initial points before plotting\nWrong parameter values: Using a &gt; 1.5 or b &gt; 1 can cause escape to infinity Canonical values (a=1.4, b=0.3) are well-behaved\nInsufficient points: Need thousands of points to see attractor structure Fractal detail requires high point density\nConfusing with Hamiltonian systems: Hénon map is DISSIPATIVE (area-contracting) Has attractors (unlike Standard Map) Lyapunov exponents sum to negative value\nExpecting simple fixed points: For typical parameters, no real fixed points exist All dynamics are transient or on attractor Cannot linearize around equilibrium (none exists!)\nIgnoring basin of attraction: Not all ICs converge to same attractor Some ICs escape to infinity Basin can have complex structure"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#extensions-and-variations",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#extensions-and-variations",
    "title": "",
    "section": "Extensions and Variations:",
    "text": "Extensions and Variations:\n\nGeneralized Hénon map: x[n+1] = c - a·x[n]^p + y[n] y[n+1] = b·x[n] Different exponents p change dynamics\nLozi map: x[n+1] = 1 - a·|x[n]| + y[n] y[n+1] = b·x[n] Piecewise-linear version (easier analysis)\nCoupled Hénon maps: Network of interacting Hénon maps Models spatiotemporal chaos\n3D Hénon map: Extension to three dimensions Hyperchaos (multiple positive Lyapunov exponents)\nDelayed Hénon map: Include time delays in coupling Richer bifurcation structure\nNoisy Hénon map: Add stochastic perturbations Studies chaos-noise interaction"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nLogisticMap : 1D chaotic map StandardMap : 2D conservative (Hamiltonian) chaos Lorenz : Continuous 3D chaos (Hénon as Poincaré section)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#attributes",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\na\nNonlinearity parameter.\n\n\narea_contraction_rate\nPhase space area contraction rate (|det(J)| = |b|).\n\n\nb\nDissipation parameter."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.HenonMap.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.HenonMap.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nclassify_regime\nClassify dynamical regime based on parameters.\n\n\ncompute_basin_of_attraction\nCompute basin of attraction.\n\n\ncompute_jacobian\nCompute Jacobian matrix at state x.\n\n\ncompute_lyapunov_exponents\nCompute both Lyapunov exponents using QR decomposition method.\n\n\ndefine_system\nDefine Hénon map dynamics.\n\n\nestimate_correlation_dimension\nEstimate correlation dimension using Grassberger-Procaccia algorithm.\n\n\ngenerate_bifurcation_diagram\nGenerate bifurcation diagram by varying a parameter.\n\n\nsetup_equilibria\nSet up fixed points if they exist.\n\n\n\n\nclassify_regime\nsystems.builtin.deterministic.discrete.HenonMap.classify_regime()\nClassify dynamical regime based on parameters.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nRegime description\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = HenonMap(a=1.4, b=0.3)\n&gt;&gt;&gt; print(system.classify_regime())\n'strange_attractor'\n\n\n\ncompute_basin_of_attraction\nsystems.builtin.deterministic.discrete.HenonMap.compute_basin_of_attraction(\n    x_range=(-2, 2),\n    y_range=(-2, 2),\n    resolution=400,\n    max_iterations=100,\n    escape_radius=1000.0,\n)\nCompute basin of attraction.\nGrids initial conditions and determines which converge to attractor vs escape to infinity.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_range\ntuple\nRange of x initial conditions\n(-2, 2)\n\n\ny_range\ntuple\nRange of y initial conditions\n(-2, 2)\n\n\nresolution\nint\nGrid resolution (points per dimension)\n400\n\n\nmax_iterations\nint\nIterations before declaring convergence/escape\n100\n\n\nescape_radius\nfloat\nRadius beyond which orbit considered escaped\n1000.0\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with: - ‘x_grid’: Meshgrid of x values - ‘y_grid’: Meshgrid of y values - ‘converged’: Boolean array (True=converged, False=escaped)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = HenonMap(a=1.4, b=0.3)\n&gt;&gt;&gt; basin = system.compute_basin_of_attraction(resolution=300)\n&gt;&gt;&gt;\n&gt;&gt;&gt; import plotly.graph_objects as go\n&gt;&gt;&gt; fig = go.Figure(data=go.Heatmap(\n...     z=basin['converged'].astype(int),\n...     x=basin['x_grid'][0, :],\n...     y=basin['y_grid'][:, 0],\n...     colorscale='RdBu'\n... ))\n&gt;&gt;&gt; fig.show()\n\n\n\ncompute_jacobian\nsystems.builtin.deterministic.discrete.HenonMap.compute_jacobian(x)\nCompute Jacobian matrix at state x.\nFor Hénon map: J = | -2ax 1 | | b 0 |\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState [x, y]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nJacobian matrix (2×2)\n\n\n\n\n\nNotes\nDeterminant is constant: det(J) = -b (independent of state!) This gives constant area contraction rate.\n\n\n\ncompute_lyapunov_exponents\nsystems.builtin.deterministic.discrete.HenonMap.compute_lyapunov_exponents(\n    x0,\n    n_iterations=50000,\n    n_transient=1000,\n)\nCompute both Lyapunov exponents using QR decomposition method.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nnp.ndarray\nInitial state [x₀, y₀]\nrequired\n\n\nn_iterations\nint\nNumber of iterations for averaging\n50000\n\n\nn_transient\nint\nNumber of initial iterations to discard\n1000\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nArray of two Lyapunov exponents [λ₁, λ₂] λ₁: Largest (expansion rate) λ₂: Smallest (contraction rate)\n\n\n\n\n\nNotes\nFor dissipative systems: λ₁ + λ₂ = ln|det(J)| = ln|b|\nFor canonical Hénon (a=1.4, b=0.3): λ₁ ≈ 0.42 (positive → chaos) λ₂ ≈ -1.62 (negative → dissipation) λ₁ + λ₂ ≈ -1.20 ≈ ln(0.3)\n\n\nExamples\n&gt;&gt;&gt; system = HenonMap(a=1.4, b=0.3)\n&gt;&gt;&gt; lyap = system.compute_lyapunov_exponents(\n...     x0=np.array([0.1, 0.1]),\n...     n_iterations=100000\n... )\n&gt;&gt;&gt; print(f\"λ₁ = {lyap[0]:.4f}, λ₂ = {lyap[1]:.4f}\")\n&gt;&gt;&gt; print(f\"Sum = {sum(lyap):.4f} (should be ln|b| = {np.log(abs(system.b)):.4f})\")\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.HenonMap.define_system(\n    a=1.4,\n    b=0.3,\n    dt=1.0,\n    use_controlled_version=False,\n)\nDefine Hénon map dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na\nfloat\nNonlinearity parameter (controls folding)\n1.4\n\n\nb\nfloat\nDissipation parameter (controls area contraction)\n0.3\n\n\ndt\nfloat\nTime step between iterations (usually 1.0)\n1.0\n\n\nuse_controlled_version\nbool\nIf True, adds control input u[n] to x dynamics\nFalse\n\n\n\n\n\n\nestimate_correlation_dimension\nsystems.builtin.deterministic.discrete.HenonMap.estimate_correlation_dimension(\n    x0,\n    n_points=5000,\n    n_transient=1000,\n    r_min=0.001,\n    r_max=1.0,\n    n_radii=50,\n)\nEstimate correlation dimension using Grassberger-Procaccia algorithm.\nThe correlation dimension d_c characterizes the fractal structure of the attractor.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nnp.ndarray\nInitial state\nrequired\n\n\nn_points\nint\nNumber of points on attractor to use\n5000\n\n\nn_transient\nint\nPoints to discard as transient\n1000\n\n\nr_min\nfloat\nMinimum radius for correlation sum\n0.001\n\n\nr_max\nfloat\nMaximum radius\n1.0\n\n\nn_radii\nint\nNumber of radii to test\n50\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEstimated correlation dimension\n\n\n\n\n\nNotes\nFor canonical Hénon attractor: d_c ≈ 1.25\n\n\nExamples\n&gt;&gt;&gt; system = HenonMap(a=1.4, b=0.3)\n&gt;&gt;&gt; d_c = system.estimate_correlation_dimension(\n...     x0=np.array([0.1, 0.1]),\n...     n_points=10000\n... )\n&gt;&gt;&gt; print(f\"Correlation dimension: {d_c:.3f}\")\n\n\n\ngenerate_bifurcation_diagram\nsystems.builtin.deterministic.discrete.HenonMap.generate_bifurcation_diagram(\n    parameter='a',\n    param_range=(0.8, 1.5),\n    n_points=500,\n    n_transient=500,\n    n_samples=200,\n    x0=None,\n)\nGenerate bifurcation diagram by varying a parameter.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nparameter\nstr\nParameter to vary (‘a’ or ‘b’)\n'a'\n\n\nparam_range\ntuple\nRange of parameter values (min, max)\n(0.8, 1.5)\n\n\nn_points\nint\nNumber of parameter values to test\n500\n\n\nn_transient\nint\nIterations to discard (transient)\n500\n\n\nn_samples\nint\nPoints to sample after transient\n200\n\n\nx0\nOptional[np.ndarray]\nInitial condition (None = use [0.1, 0.1])\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with: - ‘param’: Parameter values - ‘x’: x-coordinate values - ‘y’: y-coordinate values (optional)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = HenonMap()\n&gt;&gt;&gt; bifurc_data = system.generate_bifurcation_diagram(\n...     parameter='a',\n...     param_range=(0.8, 1.5),\n...     n_points=1000\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; import plotly.graph_objects as go\n&gt;&gt;&gt; fig = go.Figure()\n&gt;&gt;&gt; fig.add_trace(go.Scatter(\n...     x=bifurc_data['param'],\n...     y=bifurc_data['x'],\n...     mode='markers',\n...     marker=dict(size=0.3, color='black')\n... ))\n&gt;&gt;&gt; fig.update_layout(title='Hénon Bifurcation Diagram')\n&gt;&gt;&gt; fig.show()\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.HenonMap.setup_equilibria()\nSet up fixed points if they exist.\nFixed points satisfy: x* = 1 - a·x² + y y* = b·x*\nSubstituting: a·x² - (b-1)·x + 1 = 0\nReal solutions exist only if (b-1)² ≥ 4a."
  },
  {
    "objectID": "api/systems.base.core.SymbolicSystemBase.html",
    "href": "api/systems.base.core.SymbolicSystemBase.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.SymbolicSystemBase.html#attributes",
    "href": "api/systems.base.core.SymbolicSystemBase.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nstate_vars\nList[sp.Symbol]\nState variables as SymPy symbols (e.g., [x, v, theta])\n\n\ncontrol_vars\nList[sp.Symbol]\nControl variables as SymPy symbols (e.g., [u1, u2])\n\n\noutput_vars\nList[sp.Symbol]\nOutput variable names (optional)\n\n\nparameters\nDict[sp.Symbol, float]\nSystem parameters with Symbol keys (e.g., {m: 1.0, k: 10.0})\n\n\n_f_sym\nsp.Matrix\nSymbolic dynamics expression (interpretation depends on subclass)\n\n\n_h_sym\nOptional[sp.Matrix]\nSymbolic output expression (None = identity output)\n\n\norder\nint\nSystem order (1 = first-order, 2 = second-order, etc.)\n\n\nbackend\nBackendManager\nBackend management component\n\n\nequilibria\nEquilibriumHandler\nEquilibrium point management"
  },
  {
    "objectID": "api/systems.base.core.SymbolicSystemBase.html#examples",
    "href": "api/systems.base.core.SymbolicSystemBase.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nConcrete system combining symbolic base with continuous interface:\n&gt;&gt;&gt; class LinearOscillator(SymbolicSystemBase, ContinuousSystemBase):\n...     def define_system(self, k=1.0, c=0.1):\n...         x, v = sp.symbols('x v', real=True)\n...         u = sp.symbols('u', real=True)\n...         k_sym, c_sym = sp.symbols('k c', positive=True)\n...\n...         self.state_vars = [x, v]\n...         self.control_vars = [u]\n...         self._f_sym = sp.Matrix([v, -k_sym*x - c_sym*v + u])\n...         self.parameters = {k_sym: k, c_sym: c}\n...         self.order = 1\n...\n...     def print_equations(self, simplify=True):\n...         print(\"Continuous dynamics: dx/dt = f(x, u)\")\n...         # ... implementation\n...\n...     # Also implement ContinuousSystemBase interface\n...     def __call__(self, x, u=None, t=0.0):\n...         # ... implementation\n...         pass\n...\n&gt;&gt;&gt; system = LinearOscillator(k=2.0, c=0.5)\n&gt;&gt;&gt; system.nx  # Number of states\n2\n&gt;&gt;&gt; system.parameters  # Numerical values\n{k: 2.0, c: 0.5}"
  },
  {
    "objectID": "api/systems.base.core.SymbolicSystemBase.html#methods",
    "href": "api/systems.base.core.SymbolicSystemBase.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nadd_equilibrium\nAdd an equilibrium point with optional verification.\n\n\ncompile\nPre-compile dynamics functions for specified backends.\n\n\ndefine_system\nDefine the symbolic system (must be implemented by subclasses).\n\n\nget_backend_info\nGet comprehensive information about backend configuration and status.\n\n\nget_config_dict\nGet system configuration as dictionary.\n\n\nget_equilibrium\nGet equilibrium state and control in specified backend.\n\n\nget_equilibrium_metadata\nGet metadata for equilibrium.\n\n\nget_performance_stats\nGet performance statistics for system operations.\n\n\nlist_equilibria\nList all equilibrium names.\n\n\nprint_equations\nPrint symbolic equations in human-readable format.\n\n\nremove_equilibrium\nRemove an equilibrium point.\n\n\nreset_caches\nReset cached compiled functions for specified backends.\n\n\nreset_performance_stats\nReset all performance counters to zero.\n\n\nsave_config\nSave system configuration to JSON file.\n\n\nset_default_backend\nSet default backend and optionally device for this system.\n\n\nset_default_equilibrium\nSet default equilibrium for get operations without name.\n\n\nsetup_equilibria\nOptional hook to add equilibria after system initialization.\n\n\nsubstitute_parameters\nSubstitute numerical parameter values into symbolic expression.\n\n\nto_device\nSet preferred device for PyTorch/JAX backends.\n\n\nuse_backend\nTemporarily switch to a different backend and/or device.\n\n\n\n\nadd_equilibrium\nsystems.base.core.SymbolicSystemBase.add_equilibrium(\n    name,\n    x_eq,\n    u_eq,\n    verify=True,\n    tol=1e-06,\n    **metadata,\n)\nAdd an equilibrium point with optional verification.\nEquilibrium points are states where the dynamics are zero (or identity for discrete systems). The system can have multiple equilibria (e.g., pendulum upright vs downward).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nUnique name for this equilibrium (e.g., ‘origin’, ‘upright’, ‘inverted’)\nrequired\n\n\nx_eq\nnp.ndarray\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nnp.ndarray\nEquilibrium control (nu,)\nrequired\n\n\nverify\nbool\nIf True, verify that equilibrium condition holds (default: True)\nTrue\n\n\ntol\nfloat\nTolerance for verification (default: 1e-6)\n1e-06\n\n\n**metadata\ndict\nAdditional metadata to store (e.g., stability=‘stable’)\n{}\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf dimensions don’t match system dimensions\n\n\n\nUserWarning\nIf verification fails (not actually an equilibrium)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Pendulum downward equilibrium\n&gt;&gt;&gt; system.add_equilibrium(\n...     'downward',\n...     x_eq=np.array([0.0, 0.0]),\n...     u_eq=np.array([0.0]),\n...     verify=True\n... )\n&gt;&gt;&gt; # Inverted pendulum (with metadata)\n&gt;&gt;&gt; system.add_equilibrium(\n...     'inverted',\n...     x_eq=np.array([np.pi, 0.0]),\n...     u_eq=np.array([0.0]),\n...     stability='unstable',\n...     notes='Requires active control'\n... )\n&gt;&gt;&gt; # Get equilibrium back\n&gt;&gt;&gt; x_eq = system.equilibria.get_x('inverted')\n&gt;&gt;&gt; u_eq = system.equilibria.get_u('inverted')\n\n\nNotes\n\nVerification implementation depends on concrete subclass\nIf verification fails, a warning is issued but equilibrium is still added\nDelegates to EquilibriumHandler.add() for storage and management\nConcrete subclasses may override to provide custom verification\n\n\n\nSee Also\nsetup_equilibrium: Automatically add equilibria after system initialization get_equilibrium : Retrieve equilibrium in specified backend list_equilibria : List all equilibrium names set_default_equilibrium : Set default equilibrium remove_equilibrium : Remove an equilibrium\n\n\n\ncompile\nsystems.base.core.SymbolicSystemBase.compile(\n    backends=None,\n    verbose=False,\n    **kwargs,\n)\nPre-compile dynamics functions for specified backends.\nCompilation happens lazily by default (on first use). This method allows eager compilation to reduce first-call latency and validate that code generation works correctly.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackends\nOptional[List[str]]\nList of backends to compile (‘numpy’, ‘torch’, ‘jax’). If None, compiles for all available backends.\nNone\n\n\nverbose\nbool\nIf True, print compilation progress and timing\nFalse\n\n\n**kwargs\ndict\nBackend-specific compilation options\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, float]\nCompilation times per backend (seconds)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compile for all available backends\n&gt;&gt;&gt; times = system.compile(verbose=True)\nCompiling for numpy... 0.123s\nCompiling for torch... 0.456s\nCompiling for jax... 0.789s\n&gt;&gt;&gt; # Compile only for specific backends\n&gt;&gt;&gt; system.compile(backends=['numpy', 'torch'])\n&gt;&gt;&gt; # Chain with other operations\n&gt;&gt;&gt; system.compile().set_default_backend('torch')\n\n\nNotes\n\nCompilation is cached - subsequent calls are no-ops unless cache is cleared\nJAX compilation includes JIT, which may take longer initially\nPyTorch compilation is optional (not JIT by default)\nNumPy always uses regular Python functions (fastest to “compile”)\n\n\n\nSee Also\nreset_caches : Clear compiled function cache get_backend_info : Check compilation status\n\n\n\ndefine_system\nsystems.base.core.SymbolicSystemBase.define_system(*args, **kwargs)\nDefine the symbolic system (must be implemented by subclasses).\nThis method must populate the following attributes:\nRequired Attributes:\n\nself.state_vars: List[sp.Symbol] State variables (e.g., [x, y, theta]) Cannot be empty\nself.control_vars: List[sp.Symbol] Control variables (e.g., [u1, u2]) Empty list for autonomous systems\nself._f_sym: sp.Matrix Symbolic dynamics (column vector)\nself.parameters: Dict[sp.Symbol, float] Parameter values with Symbol keys (NOT strings!)\n\nOptional Attributes:\n\nself.output_vars: List[sp.Symbol] Output variable names (optional)\nself._h_sym: sp.Matrix Symbolic output function (None = identity)\nself.order: int System order (default: 1)\n\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n*args\ntuple\nSystem-specific positional arguments (e.g., mass, length, damping)\n()\n\n\n**kwargs\ndict\nSystem-specific keyword arguments\n{}\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValidationError\nIf the defined system is invalid (checked after this method returns)\n\n\n\n\n\nNotes\nCRITICAL: self.parameters must use SymPy Symbol objects as keys!\nCorrect::\n{m: 1.0, l: 0.5}\nIncorrect::\n{'m': 1.0, 'l': 0.5}  # Strings won't work!\nSystem Order - Two Equivalent Formulations:\n\nFirst-Order State-Space Form (order=1):\n\nState: x = [q, q̇] for a 2nd-order physical system\n_f_sym returns ALL derivatives: [q̇, q̈]\nSet: self.order = 1\n\nExample::\nself.state_vars = [theta, theta_dot]\nself._f_sym = sp.Matrix([\n    theta_dot,                      # dθ/dt = θ̇\n    -k*theta - c*theta_dot + u      # dθ̇/dt = θ̈\n])\nself.order = 1\nHigher-Order Form (order=n):\n\nState: x = [q, q̇] for a 2nd-order physical system\n_f_sym returns ONLY highest derivative: q̈\nSet: self.order = 2\n\nExample::\nself.state_vars = [theta, theta_dot]\nself._f_sym = sp.Matrix([\n    -k*theta - c*theta_dot + u  # Only θ̈\n])\nself.order = 2\n\nBoth formulations are mathematically equivalent! The framework handles state-space construction automatically during linearization.\nWhen to use which:\n\nUse order=1 (state-space) for: simpler code, explicit derivatives\nUse order=n (higher-order) for: physics-focused definitions, cleaner dynamics\n\nValidation rules:\n\nFor order=1: len(_f_sym) must equal nx\nFor order=n: len(_f_sym) must equal nq, and nx must be divisible by order\n\n\n\nExamples\nFirst-order system::\ndef define_system(self, a=1.0):\n    x = sp.symbols('x')\n    u = sp.symbols('u')\n    a_sym = sp.symbols('a', real=True, positive=True)\n\n    self.state_vars = [x]\n    self.control_vars = [u]\n    self._f_sym = sp.Matrix([-a_sym * x + u])\n    self.parameters = {a_sym: a}\n    self.order = 1\nSecond-order (state-space form)::\ndef define_system(self, m=1.0, k=10.0, c=0.5):\n    q, q_dot = sp.symbols('q q_dot')\n    u = sp.symbols('u')\n    m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n\n    # Return both derivatives explicitly\n    self.state_vars = [q, q_dot]\n    self.control_vars = [u]\n    self._f_sym = sp.Matrix([\n        q_dot,                                  # dq/dt\n        (-k_sym*q - c_sym*q_dot + u)/m_sym     # dq̇/dt = q̈\n    ])\n    self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n    self.order = 1  # First-order state-space\nSecond-order (higher-order form)::\ndef define_system(self, m=1.0, k=10.0, c=0.5):\n    q, q_dot = sp.symbols('q q_dot')\n    u = sp.symbols('u')\n    m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n\n    # Return only acceleration\n    q_ddot = (-k_sym*q - c_sym*q_dot + u)/m_sym\n\n    self.state_vars = [q, q_dot]\n    self.control_vars = [u]\n    self._f_sym = sp.Matrix([q_ddot])  # Only highest derivative\n    self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n    self.order = 2  # Second-order form\n\n\n\nget_backend_info\nsystems.base.core.SymbolicSystemBase.get_backend_info()\nGet comprehensive information about backend configuration and status.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary containing: - ‘default_backend’: Current default backend - ‘preferred_device’: Current device setting - ‘available_backends’: List of installed backends - ‘compiled_backends’: List of backends with compiled functions - ‘torch_available’: Whether PyTorch is installed - ‘jax_available’: Whether JAX is installed - ‘numpy_version’: NumPy version string - ‘torch_version’: PyTorch version (or None) - ‘jax_version’: JAX version (or None) - ‘initialized’: Whether system is initialized\n\n\n\n\n\nExamples\n&gt;&gt;&gt; info = system.get_backend_info()\n&gt;&gt;&gt; print(f\"Default: {info['default_backend']}\")\n&gt;&gt;&gt; print(f\"Available: {info['available_backends']}\")\n&gt;&gt;&gt; print(f\"Compiled: {info['compiled_backends']}\")\n\n\n\nget_config_dict\nsystems.base.core.SymbolicSystemBase.get_config_dict()\nGet system configuration as dictionary.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict\nConfiguration dictionary containing: - ‘class_name’: System class name - ‘state_vars’: State variable names - ‘control_vars’: Control variable names - ‘output_vars’: Output variable names - ‘parameters’: Parameter values (as dict) - ‘order’: System order - ‘nx’, ‘nu’, ‘ny’: Dimensions - ‘backend’: Default backend - ‘device’: Preferred device\n\n\n\n\n\nExamples\n&gt;&gt;&gt; config = system.get_config_dict()\n&gt;&gt;&gt; config['nx']\n2\n&gt;&gt;&gt; config['parameters']\n{'m': 1.0, 'k': 10.0}\n\n\nNotes\n\nUseful for saving system configuration to file\nDoes not include compiled functions or cached data\nCan be used with save_config() for persistence\n\n\n\nSee Also\nsave_config : Save configuration to JSON file\n\n\n\nget_equilibrium\nsystems.base.core.SymbolicSystemBase.get_equilibrium(name=None, backend=None)\nGet equilibrium state and control in specified backend.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nOptional[str]\nEquilibrium name (None = default)\nNone\n\n\nbackend\nOptional[str]\nBackend for arrays (None = system default)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[ArrayLike, ArrayLike]\n(x_eq, u_eq) in requested backend\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x_eq, u_eq = system.get_equilibrium('inverted', backend='torch')\n&gt;&gt;&gt; x_eq, u_eq = system.get_equilibrium()  # Default equilibrium, default backend\n\n\n\nget_equilibrium_metadata\nsystems.base.core.SymbolicSystemBase.get_equilibrium_metadata(name=None)\nGet metadata for equilibrium.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nOptional[str]\nEquilibrium name (None = default)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict\nMetadata dictionary\n\n\n\n\n\nExamples\n&gt;&gt;&gt; meta = system.get_equilibrium_metadata('inverted')\n&gt;&gt;&gt; print(meta['stability'])\n'unstable'\n\n\n\nget_performance_stats\nsystems.base.core.SymbolicSystemBase.get_performance_stats()\nGet performance statistics for system operations.\nReturns timing and call count information for key operations. Useful for profiling and optimization.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, float]\nDictionary containing: - ‘forward_calls’: Number of forward dynamics calls - ‘forward_time’: Total time in forward dynamics (seconds) - ‘avg_forward_time’: Average time per forward call (seconds) - (Other stats depend on concrete subclass implementation)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Run some operations\n&gt;&gt;&gt; for _ in range(100):\n...     dx = system(x, u)\n...\n&gt;&gt;&gt; stats = system.get_performance_stats()\n&gt;&gt;&gt; print(f\"Forward calls: {stats['forward_calls']}\")\n&gt;&gt;&gt; print(f\"Avg time: {stats['avg_forward_time']:.6f}s\")\n\n\nNotes\n\nStatistics accumulate over system lifetime\nUse reset_performance_stats() to clear counters\nTiming includes overhead from backend detection/conversion\nConcrete subclasses may add additional statistics\n\n\n\nSee Also\nreset_performance_stats : Reset all performance counters\n\n\n\nlist_equilibria\nsystems.base.core.SymbolicSystemBase.list_equilibria()\nList all equilibrium names.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nNames of all defined equilibria\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.list_equilibria()\n['origin', 'downward', 'inverted']\n\n\n\nprint_equations\nsystems.base.core.SymbolicSystemBase.print_equations(simplify=True)\nPrint symbolic equations in human-readable format.\nThis method is abstract because the notation differs between continuous and discrete systems: - Continuous: “dx/dt = f(x, u)” or “dθ/dt”, “dθ̇/dt” - Discrete: “x[k+1] = f(x[k], u[k])” or “θ[k+1]”, “θ̇[k+1]”\nSubclasses must implement this with appropriate notation for their time-domain semantics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nIf True, simplify expressions before printing If False, print raw expressions\nTrue\n\n\n\n\n\nNotes\nTypical implementation should display: - System name - State and control variables - System order and dimensions - Dynamics equations with proper notation - Output equations (if defined)\n\n\nExamples\nContinuous implementation::\ndef print_equations(self, simplify=True):\n    print(\"=\" * 70)\n    print(f\"{self.__class__.__name__}\")\n    print(\"=\" * 70)\n    print(f\"State Variables: {self.state_vars}\")\n    print(f\"Control Variables: {self.control_vars}\")\n    print(f\"System Order: {self.order}\")\n    print(f\"Dimensions: nx={self.nx}, nu={self.nu}, ny={self.ny}\")\n\n    print(\"\\nDynamics: dx/dt = f(x, u)\")\n    for var, expr in zip(self.state_vars, self._f_sym):\n        expr_sub = self.substitute_parameters(expr)\n        if simplify:\n            expr_sub = sp.simplify(expr_sub)\n        print(f\"  d{var}/dt = {expr_sub}\")\n\n    if self._h_sym is not None:\n        print(\"\\nOutput: y = h(x)\")\n        for i, expr in enumerate(self._h_sym):\n            expr_sub = self.substitute_parameters(expr)\n            if simplify:\n                expr_sub = sp.simplify(expr_sub)\n            print(f\"  y[{i}] = {expr_sub}\")\n\n    print(\"=\" * 70)\nDiscrete implementation::\ndef print_equations(self, simplify=True):\n    print(\"=\" * 70)\n    print(f\"{self.__class__.__name__}\")\n    print(\"=\" * 70)\n    print(f\"State Variables: {self.state_vars}\")\n    print(f\"Control Variables: {self.control_vars}\")\n    print(f\"System Order: {self.order}\")\n    print(f\"Dimensions: nx={self.nx}, nu={self.nu}, ny={self.ny}\")\n\n    print(\"\\nDynamics: x[k+1] = f(x[k], u[k])\")\n    for var, expr in zip(self.state_vars, self._f_sym):\n        expr_sub = self.substitute_parameters(expr)\n        if simplify:\n            expr_sub = sp.simplify(expr_sub)\n        print(f\"  {var}[k+1] = {expr_sub}\")\n\n    if self._h_sym is not None:\n        print(\"\\nOutput: y[k] = h(x[k])\")\n        for i, expr in enumerate(self._h_sym):\n            expr_sub = self.substitute_parameters(expr)\n            if simplify:\n                expr_sub = sp.simplify(expr_sub)\n            print(f\"  y[{i}] = {expr_sub}\")\n\n    print(\"=\" * 70)\n\n\n\nremove_equilibrium\nsystems.base.core.SymbolicSystemBase.remove_equilibrium(name)\nRemove an equilibrium point.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nEquilibrium name to remove\nrequired\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf trying to remove ‘origin’ or nonexistent equilibrium\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.remove_equilibrium('test_point')\n\n\n\nreset_caches\nsystems.base.core.SymbolicSystemBase.reset_caches(backends=None)\nReset cached compiled functions for specified backends.\nClears the code generation cache, forcing recompilation on next use. Useful when system parameters change or to free memory.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackends\nOptional[List[str]]\nList of backends to reset (‘numpy’, ‘torch’, ‘jax’). If None, resets all backends.\nNone\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Reset all cached functions\n&gt;&gt;&gt; system.reset_caches()\n&gt;&gt;&gt; # Reset only PyTorch cache\n&gt;&gt;&gt; system.reset_caches(['torch'])\n&gt;&gt;&gt; # After parameter update\n&gt;&gt;&gt; system.parameters[m] = 2.0  # Changed mass\n&gt;&gt;&gt; system.reset_caches()  # Force recompilation with new value\n\n\nNotes\n\nDoes not affect the system definition (state_vars, _f_sym, etc.)\nOnly clears the compiled numerical functions\nNext function call will trigger recompilation\nUse sparingly - compilation has overhead\n\n\n\nSee Also\ncompile : Pre-compile functions _clear_backend_cache : Clear single backend (internal use)\n\n\n\nreset_performance_stats\nsystems.base.core.SymbolicSystemBase.reset_performance_stats()\nReset all performance counters to zero.\nClears timing and call count statistics across all components.\n\nExamples\n&gt;&gt;&gt; system.reset_performance_stats()\n&gt;&gt;&gt; stats = system.get_performance_stats()\n&gt;&gt;&gt; stats['forward_calls']\n0\n\n\nNotes\n\nResets counters in all components (DynamicsEvaluator, etc.)\nDoes not affect compilation cache or system definition\nConcrete subclasses override to reset their component stats\n\n\n\n\nsave_config\nsystems.base.core.SymbolicSystemBase.save_config(filename)\nSave system configuration to JSON file.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfilename\nstr\nPath to output file (will be created/overwritten)\nrequired\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.save_config('pendulum_config.json')\n&gt;&gt;&gt; # Load config (manually)\n&gt;&gt;&gt; import json\n&gt;&gt;&gt; with open('pendulum_config.json', 'r') as f:\n...     config = json.load(f)\n&gt;&gt;&gt; print(config['parameters'])\n\n\nNotes\n\nSaves only configuration, not compiled functions\nUse get_config_dict() to get config without saving\nJSON format enables easy sharing and version control\n\n\n\nSee Also\nget_config_dict : Get configuration dictionary\n\n\n\nset_default_backend\nsystems.base.core.SymbolicSystemBase.set_default_backend(backend, device=None)\nSet default backend and optionally device for this system.\nThe default backend is used when backend=‘default’ is passed to methods, or when no backend is specified and conversion is needed.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nstr\nBackend name (‘numpy’, ‘torch’, or ‘jax’)\nrequired\n\n\ndevice\nOptional[str]\nDevice for GPU backends (‘cpu’, ‘cuda’, ‘cuda:0’, ‘gpu:0’, etc.) If None, device is not changed.\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSymbolicSystemBase\nSelf (for method chaining)\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf backend name is invalid\n\n\n\nRuntimeError\nIf backend is not available (not installed)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.set_default_backend('torch', device='cuda:0')\n&gt;&gt;&gt; system._default_backend\n'torch'\n&gt;&gt;&gt; system._preferred_device\n'cuda:0'\nMethod chaining:\n&gt;&gt;&gt; system.set_default_backend('jax').compile(verbose=True)\n\n\n\nset_default_equilibrium\nsystems.base.core.SymbolicSystemBase.set_default_equilibrium(name)\nSet default equilibrium for get operations without name.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of equilibrium to use as default\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSymbolicSystemBase\nSelf for method chaining\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.set_default_equilibrium('inverted')\n&gt;&gt;&gt; x_eq = system.equilibria.get_x()  # Gets 'inverted' by default\nMethod chaining:\n&gt;&gt;&gt; system.set_default_equilibrium('upright').compile()\n\n\n\nsetup_equilibria\nsystems.base.core.SymbolicSystemBase.setup_equilibria()\nOptional hook to add equilibria after system initialization.\nThis method is called automatically after the system is fully initialized if auto_add_equilibria=True (default).\nOverride this method in subclasses to add standard equilibria. Can access self.parameters for parameter-dependent equilibria.\n\nExamples\nParameter-independent:\n&gt;&gt;&gt; def setup_equilibria(self):\n...     self.equilibria.add('origin', np.zeros(self.nx), np.zeros(self.nu))\nParameter-dependent:\n&gt;&gt;&gt; def setup_equilibria(self):\n...     g = self.parameters[self._g_sym]  # Access parameter value\n...     x_eq = np.array([0, np.sqrt(g)])\n...     self.equilibria.add('special', x_eq, np.zeros(self.nu))\n\n\n\nsubstitute_parameters\nsystems.base.core.SymbolicSystemBase.substitute_parameters(expr)\nSubstitute numerical parameter values into symbolic expression.\nReplaces all parameter symbols with their numerical values from self.parameters dictionary.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpr\nUnion[sp.Expr, sp.Matrix]\nSymbolic expression or matrix\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nUnion[sp.Expr, sp.Matrix]\nExpression with parameters substituted\n\n\n\n\n\nExamples\n&gt;&gt;&gt; m, k = sp.symbols('m k')\n&gt;&gt;&gt; expr = m * sp.symbols('x') + k\n&gt;&gt;&gt; system.parameters = {m: 1.0, k: 10.0}\n&gt;&gt;&gt; system.substitute_parameters(expr)\nx + 10.0\n\n\nNotes\nThis is used internally by code generation to create parameter-specific numerical functions.\n\n\n\nto_device\nsystems.base.core.SymbolicSystemBase.to_device(device)\nSet preferred device for PyTorch/JAX backends.\nChanges the device for all subsequent operations. Clears cached functions for backends that need recompilation (PyTorch, JAX) because device-specific code may differ.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndevice\nstr\nDevice string (‘cpu’, ‘cuda’, ‘cuda:0’, ‘gpu:0’, ‘tpu:0’, etc.)\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSymbolicSystemBase\nSelf (for method chaining)\n\n\n\n\n\nNotes\n\nNumPy always uses CPU (device setting ignored)\nPyTorch and JAX respect device setting\nChanging device clears cached functions for affected backends\n\n\n\nExamples\n&gt;&gt;&gt; system.to_device('cuda:0')\n&gt;&gt;&gt; system.set_default_backend('torch')\n&gt;&gt;&gt; # All torch operations now use CUDA device 0\nMethod chaining:\n&gt;&gt;&gt; system.to_device('cuda').set_default_backend('torch')\n\n\n\nuse_backend\nsystems.base.core.SymbolicSystemBase.use_backend(backend, device=None)\nTemporarily switch to a different backend and/or device.\nThis context manager allows temporary backend changes without affecting the configured default. Useful for benchmarking or comparing backend performance.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nstr\nTemporary backend to use (‘numpy’, ‘torch’, ‘jax’)\nrequired\n\n\ndevice\nOptional[str]\nTemporary device to use (None = keep current device)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nGenerator[SymbolicSystemBase, None, None]\nContext manager yielding self with temporary backend configuration\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.set_default_backend('numpy')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Temporarily use PyTorch\n&gt;&gt;&gt; with system.use_backend('torch', device='cuda'):\n...     dx = system(x, u, backend='default')  # Uses torch on CUDA\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Back to NumPy after context\n&gt;&gt;&gt; system._default_backend\n'numpy'\nNested contexts:\n&gt;&gt;&gt; with system.use_backend('torch'):\n...     with system.use_backend('jax'):\n...         # Uses JAX\n...         pass\n...     # Back to torch\n...     pass\n&gt;&gt;&gt; # Back to original"
  },
  {
    "objectID": "api/types.control_advanced.H2ControlResult.html",
    "href": "api/types.control_advanced.H2ControlResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_advanced.H2ControlResult.html#fields",
    "href": "api/types.control_advanced.H2ControlResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ngain : GainMatrix H₂ optimal controller gain K (nu, nx) h2_norm : float Achieved H₂ norm ‖G‖₂ cost_to_go : CovarianceMatrix Riccati solution P (nx, nx) closed_loop_stable : bool Closed-loop system is stable closed_loop_poles : np.ndarray Eigenvalues of (A - BK)"
  },
  {
    "objectID": "api/types.control_advanced.H2ControlResult.html#examples",
    "href": "api/types.control_advanced.H2ControlResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Design H₂ controller\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; B = np.array([[0], [1]])\n&gt;&gt;&gt; C_z = np.eye(2)  # Performance output\n&gt;&gt;&gt; D_zu = np.zeros((2, 1))\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: H2ControlResult = design_h2_controller(A, B, C_z, D_zu)\n&gt;&gt;&gt;\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt; print(f\"H₂ norm: {result['h2_norm']:.3f}\")\n&gt;&gt;&gt; print(f\"Stable: {result['closed_loop_stable']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply control\n&gt;&gt;&gt; u = -K @ x"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#difference-equation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#difference-equation",
    "title": "",
    "section": "Difference Equation",
    "text": "Difference Equation\nStandard form: X[k+1] = φ·X[k] + σ·w[k]\nWith control: X[k+1] = φ·X[k] + u[k] + σ·w[k]\nwhere: - X[k]: State at time k - φ: Autoregressive coefficient (persistence parameter) - u[k]: Control input (optional) - σ: Innovation standard deviation - w[k] ~ N(0,1): Standard normal white noise"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nPersistence: Parameter φ controls memory: - φ near 1: High persistence (long memory) - φ near 0: Low persistence (short memory) - φ = 0: White noise (no memory)\nStationarity: Process stationary if and only if |φ| &lt; 1: - |φ| &lt; 1: Stable, mean-reverting - φ = 1: Unit root (random walk) - |φ| &gt; 1: Explosive\nAdditive Noise: Innovation w[k] independent of state. Constant variance σ².\nMarkov Property: Future depends only on present, not past history."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nStationary Distribution (|φ| &lt; 1): Mean: E[X[∞]] = u/(1-φ) Variance: Var[X[∞]] = σ²/(1-φ²) Distribution: N(u/(1-φ), σ²/(1-φ²))\nAutocorrelation: ρ(h) = φ^h\nGeometric decay with lag h.\nMean Reversion: Half-life: h = ln(0.5)/ln(φ) periods Time constant: τ = -1/ln(φ) periods"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nAutoregressive Coefficient φ: - Dimensionless (ratio) - Fraction of value persisting to next period - Typical range: 0 to 0.95\nInterpretation by Value: - φ = 0.9: High persistence, slow decay - φ = 0.5: Moderate persistence - φ = 0.1: Low persistence, fast decay - φ = 1: Random walk (non-stationary)\nInnovation Variance σ²: - Units: [state]² - Shock variance each period - Stationary variance: σ²/(1-φ²)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x ∈ ℝ - Unbounded (can take any real value) - Equilibrium: u/(1-φ) (for |φ| &lt; 1)\nControl: u ∈ ℝ (optional) - Shifts equilibrium - External forcing"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nphi\nfloat\nAutoregressive coefficient - |φ| &lt; 1: Stationary (typical) - φ = 1: Unit root (special case) - |φ| &gt; 1: Explosive (avoid) - Typical: 0.5 to 0.95\n0.9\n\n\nsigma\nfloat\nInnovation standard deviation (must be positive) - Controls noise magnitude - Stationary std: σ/√(1-φ²)\n0.1\n\n\ndt\nfloat\nSampling period (time between observations) - Sets time units - Needed for discrete system\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nNoise Type: ADDITIVE\nInnovation: w[k] ~ N(0,1) iid\nMarkov: Memoryless given current state\nStationary: If |φ| &lt; 1\nErgodic: If |φ| &lt; 1"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Econometrics: - GDP growth (quarterly data) - Inflation rates (monthly data) - Interest rates (daily/weekly) - Unemployment rates\n2. Finance: - Asset returns (daily) - Volatility models (log-volatility) - Exchange rates\n3. Signal Processing: - Colored noise generation - Digital filtering (one-pole filter) - Prediction algorithms\n4. Control Systems: - Disturbance models - State estimation (Kalman filter) - Model predictive control\n5. Time Series: - Foundation for ARMA, ARIMA - Benchmark for forecasting"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nExact Sampling: X[k+1] = φ·X[k] + u + σ·Z[k]\nwhere Z[k] ~ N(0,1).\nThis is exact (no discretization needed).\nVectorized: Can use scipy.signal.lfilter for efficient generation."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#statistical-analysis",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#statistical-analysis",
    "title": "",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\nParameter Estimation: - OLS: φ̂ = Σ X[k]·X[k+1] / Σ X[k]² - MLE: Same as OLS for Gaussian - Yule-Walker: From autocorrelations\nModel Validation: - Unit root test (Dickey-Fuller) - Residual diagnostics (Ljung-Box) - Information criteria (AIC, BIC)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#comparison-with-other-models",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#comparison-with-other-models",
    "title": "",
    "section": "Comparison with Other Models",
    "text": "Comparison with Other Models\nvs. White Noise: - WN: φ = 0 (no persistence) - AR(1): φ ≠ 0 (memory)\nvs. Random Walk: - RW: φ = 1 (unit root) - AR(1): |φ| &lt; 1 (stationary)\nvs. Ornstein-Uhlenbeck: - OU: Continuous time - AR(1): Discrete time - Connection: φ = e^(-α·Δt)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nLinear dynamics only\nConstant parameters\nGaussian innovations\nShort memory (one lag)\n\nExtensions: - AR(p): Higher-order lags - ARMA: Add moving average - GARCH: Time-varying variance - TAR: Threshold/regime-switching"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nOrnsteinUhlenbeck : Continuous-time analog DiscreteRandomWalk : Unit root case (φ=1) DiscreteWhiteNoise : No persistence (φ=0)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteAR1.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine AR(1) process dynamics.\n\n\nget_half_life\nGet half-life: number of periods to reduce deviation by 50%.\n\n\nget_stationary_variance\nGet theoretical stationary variance σ²/(1-φ²).\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteAR1.define_system(\n    phi=0.9,\n    sigma=0.1,\n    dt=1.0,\n)\nDefine AR(1) process dynamics.\nSets up the difference equation: X[k+1] = φ·X[k] + u[k] + σ·w[k]\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nphi\nfloat\nAutoregressive coefficient - |φ| &lt; 1: Stationary (mean-reverting) - φ = 1: Unit root (random walk) - |φ| &gt; 1: Explosive (unstable) - Typical: 0.5 to 0.95\n0.9\n\n\nsigma\nfloat\nInnovation standard deviation (must be positive) - Controls shock magnitude - Stationary std: σ/√(1-φ²)\n0.1\n\n\ndt\nfloat\nSampling period [time units] - Required for discrete system - Sets time scale\n1.0\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf sigma ≤ 0\n\n\n\nUserWarning\nIf |phi| ≥ 1 (non-stationary)\n\n\n\n\n\nNotes\nStationarity Condition: Process is stationary if and only if |φ| &lt; 1.\nCritical Cases: - φ = 1: Unit root (random walk) * Non-stationary * Variance grows linearly: Var[X[k]] = k·σ² * Requires different statistical treatment\n\nφ = -1: Perfect negative autocorrelation\n\nAlternates between extremes\nNon-stationary\n\n|φ| &gt; 1: Explosive\n\nVariance grows exponentially\nDiverges to ±∞\n\n\nStationary Properties: For |φ| &lt; 1: - Mean: μ = u/(1-φ) - Variance: γ(0) = σ²/(1-φ²) - Autocorrelation: ρ(h) = φ^h - Half-life: ln(0.5)/ln(φ) periods\nRelationship to Continuous Time: If discretizing OU process with parameter α: φ = exp(-α·dt) σ ≈ σ_continuous·√(2α·dt) (approximate)\nParameter Selection: - High persistence (φ ≈ 0.9): Financial returns, macro data - Moderate (φ ≈ 0.5): GDP growth, some commodities - Low (φ ≈ 0.1): Nearly white noise\nInnovation Variance: Total variance decomposes: - Stationary variance: σ²/(1-φ²) - Innovation variance: σ² - Ratio: 1/(1-φ²) ≥ 1\n\n\n\nget_half_life\nsystems.builtin.stochastic.discrete.DiscreteAR1.get_half_life()\nGet half-life: number of periods to reduce deviation by 50%.\nFormula: h = ln(0.5) / ln(φ)\nOnly meaningful for 0 &lt; φ &lt; 1.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nHalf-life [periods]\n\n\n\n\n\n\nget_stationary_variance\nsystems.builtin.stochastic.discrete.DiscreteAR1.get_stationary_variance()\nGet theoretical stationary variance σ²/(1-φ²).\nOnly valid for |φ| &lt; 1.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nStationary variance\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf |φ| ≥ 1 (non-stationary)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nDiffusion approximation of discrete SIR:\ndS = -β·S·I/N·dt + σ_S·dW_S\ndI = (β·S·I/N - γ·I)·dt + σ_I·dW_I\ndR = γ·I·dt + σ_R·dW_R\nwhere: - S(t): Number susceptible (can be infected) - I(t): Number infected (infectious) - R(t): Number recovered (immune) - N = S + I + R: Total population (constant) - β: Transmission rate [1/time] - γ: Recovery rate [1/time] - σ_S, σ_I, σ_R: Noise intensities - W_S, W_I, W_R: Wiener processes\nPhysical Meaning:\nTransmission: β·S·I/N - Rate of new infections - Mass action: Proportional to S·I - β: Contacts per time × transmission probability\nRecovery: γ·I - Rate of recoveries - First-order: Proportional to I - γ = 1/(infectious period)\nDemographic Noise:\nTrue stochastic SIR has √ diffusion: Diffusion ~ √(rate)\nFrom Poisson statistics of discrete events.\nThis implementation: Simplified additive noise for tractability."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nSusceptibles S:\nDecrease only (monotonic): - Start: S(0) ≈ N (nearly all susceptible) - End: S(∞) &gt; 0 (some escape infection) - Never increases (no loss of immunity modeled)\nInfected I:\nNon-monotonic (rise then fall): - Start: I(0) = small (index cases) - Peak: I_max at t_peak (outbreak peak) - End: I(∞) = 0 (disease dies out)\nRecovered R:\nIncrease only (monotonic): - Start: R(0) = 0 (no immunity initially) - End: R(∞) = final outbreak size - Measure of epidemic impact\nConservation: S + I + R = N (total population constant)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nNonlinearity: S·I term creates threshold behavior and epidemic curve.\nPositivity: Must have S, I, R ≥ 0 (counts of people).\nConservation: S + I + R = N always (no births/deaths).\nExtinction: I → 0 eventually (disease dies out). Time random, final size random.\nThreshold (R₀): Probabilistic in stochastic model.\nFinite Time: Epidemic is transient (not steady state)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nBasic Reproduction Number: R₀ = β/γ\nCritical threshold (deterministic): - R₀ &lt; 1: Dies out - R₀ &gt; 1: Epidemic\nStochastic Threshold: Even R₀ &gt; 1: Can die out with probability (1/R₀)^{I₀}\nFinal Size Relation:\nDeterministic: R_∞ satisfies R_∞ = N - S₀·exp(-R₀·R_∞/N)\nStochastic: Distribution around this value.\nEpidemic Peak:\nDeterministic: I_max ≈ I₀ + S₀ - N/R₀ - (N/R₀)·ln(S₀·R₀/N) t_peak ≈ (1/γ)·ln(R₀·S₀/N)\nStochastic: Random variables (compute via simulation)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nTransmission Rate β: - Units: [1/time] - β = contact rate × transmission probability - Typical: 0.2-2.0 per day\nExamples: - Influenza: β ≈ 0.5 per day - Measles: β ≈ 1.5 per day - COVID-19: β ≈ 0.3-0.6 per day (varies)\nRecovery Rate γ: - Units: [1/time] - γ = 1/(infectious period) - Typical: 0.1-1.0 per day\nExamples: - Influenza: γ ≈ 0.5 per day (2 days infectious) - COVID-19: γ ≈ 0.1 per day (10 days) - Measles: γ ≈ 0.1 per day (10 days)\nBasic Reproduction Number: R₀ = β/γ\nExamples: - Influenza: R₀ ≈ 1-2 - COVID-19: R₀ ≈ 2-5 (variant dependent) - Measles: R₀ ≈ 12-18\nNoise Intensity:\nFrom demographic stochasticity (Poisson): σ ≈ √(rate/N)\nRelative noise: 1/√N"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X = [S, I, R] ∈ ℝ₊³ - S, I, R ≥ 0 (non-negative counts) - S + I + R = N (conservation) - Bounded: 0 ≤ S, I, R ≤ N\nControl: u (optional, interventions) - Reduce β (social distancing) - Increase recovery (treatment) - Vaccination (move S → R)\nNoise: w = [w_S, w_I, w_R] ∈ ℝ³ - Demographic stochasticity - Should be correlated (conservation) - This implementation: Simplified independent"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbeta\nfloat\nTransmission rate [1/day] - Typical: 0.2-2.0 - Disease and behavior dependent\n0.5\n\n\ngamma\nfloat\nRecovery rate [1/day] - 1/γ = infectious period - Typical: 0.1-1.0\n0.1\n\n\nN\nfloat\nTotal population - Larger N: More deterministic - Smaller N: More stochastic\n1000.0\n\n\nsigma_S\nfloat\nSusceptible noise intensity [1/√day] - From √(rate/N) for demographic noise - Typical: √(β·S·I/N²)\n0.1\n\n\nsigma_I\nfloat\nInfected noise intensity [1/√day]\n0.1\n\n\nsigma_R\nfloat\nRecovered noise intensity [1/√day]\n0.1"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR\nNoise Type: ADDITIVE (simplified)\nSDE Type: Itô\nNoise Dimension: nw = 3\nStationary: No (epidemic is transient)\nPositive: Should be (may need projection)\nConserved: S + I + R = N (approximately)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Epidemiology: - COVID-19, influenza, measles modeling - Outbreak prediction with uncertainty - Intervention timing and effectiveness\n2. Parameter Estimation: - Estimate β, γ from outbreak data - Bayesian inference with uncertainty - Real-time estimation (particle filter)\n3. Public Health Policy: - Vaccination strategies - Social distancing timing - Resource allocation (ICU beds)\n4. Extinction Analysis: - Probability small outbreak dies out - Early intervention effectiveness - Import risk assessment\n5. Rare Events: - Superspreading events - Large outbreaks in small populations - Timing of peak (ICU planning)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nRecommended: - Euler-Maruyama: dt = 0.01-0.1 days - Project to non-negative: max(X, 0) - Check conservation: S+I+R ≈ N\nEvent Detection: - Extinction: I &lt; 0.5 (declare extinct) - Peak: Max I(t) - Duration: Time I &gt; threshold"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#monte-carlo-guidelines",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#monte-carlo-guidelines",
    "title": "",
    "section": "Monte Carlo Guidelines",
    "text": "Monte Carlo Guidelines\nEnsemble Analysis: - N_runs = 100-1,000 - Compute: Extinction probability, mean final size - Histogram: Final R (bimodal if near threshold)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#comparison-with-deterministic",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#comparison-with-deterministic",
    "title": "",
    "section": "Comparison with Deterministic",
    "text": "Comparison with Deterministic\nDeterministic: - Smooth epidemic curve - Single final size - R₀ sharp threshold\nStochastic: - Variable epidemic curves - Distribution of final sizes - R₀ probabilistic threshold - Extinction possible"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nAdditive noise (not √ diffusion)\nIndependent noise (should be correlated)\nHomogeneous mixing (no network structure)\nConstant β, γ (no seasonality)\nClosed population (no births/deaths)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nSEIR: Add Exposed class\nAge structure: Multiple age groups\nSpatial: Geographic spread\nNetwork: Contact structure\nTime-varying: Seasonal β(t)\nVaccination: Control via S → R"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nCoxIngersollRoss : Similar √ diffusion structure"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.StochasticSIR.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncheck_conservation\nCheck conservation constraint S + I + R = N.\n\n\ndefine_system\nDefine stochastic SIR epidemic dynamics.\n\n\nestimate_extinction_probability\nEstimate probability of stochastic extinction (approximation).\n\n\nget_basic_reproduction_number\nGet basic reproduction number R₀ = β/γ.\n\n\nget_herd_immunity_threshold\nGet herd immunity threshold H = 1 - 1/R₀.\n\n\n\n\ncheck_conservation\nsystems.builtin.stochastic.continuous.StochasticSIR.check_conservation(x)\nCheck conservation constraint S + I + R = N.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState [S, I, R]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nAbsolute error |S+I+R - N|\n\n\n\n\n\nExamples\n&gt;&gt;&gt; sir = StochasticSIR(N=1000)\n&gt;&gt;&gt; x = np.array([500, 200, 300])\n&gt;&gt;&gt; error = sir.check_conservation(x)\n&gt;&gt;&gt; print(f\"Conservation error: {error:.2f}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.StochasticSIR.define_system(\n    beta=0.5,\n    gamma=0.1,\n    N=1000.0,\n    sigma_S=0.1,\n    sigma_I=0.1,\n    sigma_R=0.1,\n)\nDefine stochastic SIR epidemic dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbeta\nfloat\nTransmission rate [1/day] - β = contact rate × transmission probability - Typical: 0.2-2.0 per day - Higher → faster spread\n0.5\n\n\ngamma\nfloat\nRecovery rate [1/day] - γ = 1/(infectious period) - Typical: 0.1-1.0 per day - Higher → faster recovery\n0.1\n\n\nN\nfloat\nTotal population (constant) - Larger N: More deterministic - Smaller N: More stochastic - Typical: 100-1,000,000\n1000.0\n\n\nsigma_S\nfloat\nSusceptible noise intensity [1/√day] - From demographic noise: ~ √(β·S·I/N²) - Typical: 0.01-1.0\n0.1\n\n\nsigma_I\nfloat\nInfected noise intensity [1/√day] - From demographic noise: ~ √(β·S·I/N² + γ·I/N) - Most critical (affects outbreak dynamics)\n0.1\n\n\nsigma_R\nfloat\nRecovered noise intensity [1/√day] - From demographic noise: ~ √(γ·I/N)\n0.1\n\n\n\n\n\nNotes\nBasic Reproduction Number: R₀ = β/γ\nDetermines epidemic threshold: - R₀ &lt; 1: Dies out (subcritical) - R₀ = 1: Critical (boundary) - R₀ &gt; 1: Epidemic (supercritical)\nStochastic Extinction:\nEven if R₀ &gt; 1, can randomly die out: P(extinction | I₀) ≈ (1/R₀)^{I₀}\nExample: R₀ = 2, I₀ = 1 → P_ext = 50%\nNoise Scaling:\nPhysical demographic noise: σ_physical ~ √(rate/N)\nFor N = 1000, typical rates ~ 0.1-1: σ ~ 0.01-0.1\nLarger population → smaller relative noise.\nInfectious Period: T_inf = 1/γ\nExamples: - Influenza: 2-3 days (γ ≈ 0.4) - COVID-19: 7-14 days (γ ≈ 0.1) - Measles: 7-10 days (γ ≈ 0.12)\nHerd Immunity: H = 1 - 1/R₀\nFraction immune needed to prevent epidemic.\nValidation:\nCheck conservation: S + I + R should equal N. If drifts: Renormalize periodically.\n\n\n\nestimate_extinction_probability\nsystems.builtin.stochastic.continuous.StochasticSIR.estimate_extinction_probability(\n    I0,\n)\nEstimate probability of stochastic extinction (approximation).\nFor R₀ &gt; 1: P_ext ≈ (1/R₀)^{I₀}\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nI0\nfloat\nInitial number infected\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nExtinction probability\n\n\n\n\n\nExamples\n&gt;&gt;&gt; sir = StochasticSIR(beta=0.6, gamma=0.2)  # R₀=3\n&gt;&gt;&gt; P_ext_1 = sir.estimate_extinction_probability(I0=1)\n&gt;&gt;&gt; P_ext_10 = sir.estimate_extinction_probability(I0=10)\n&gt;&gt;&gt; print(f\"1 infected: P_ext = {P_ext_1:.2%}\")\n&gt;&gt;&gt; print(f\"10 infected: P_ext = {P_ext_10:.2%}\")\n\n\n\nget_basic_reproduction_number\nsystems.builtin.stochastic.continuous.StochasticSIR.get_basic_reproduction_number(\n)\nGet basic reproduction number R₀ = β/γ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nR₀\n\n\n\n\n\nExamples\n&gt;&gt;&gt; sir = StochasticSIR(beta=0.5, gamma=0.1)\n&gt;&gt;&gt; R0 = sir.get_basic_reproduction_number()\n&gt;&gt;&gt; print(f\"R₀ = {R0:.2f}\")\n\n\n\nget_herd_immunity_threshold\nsystems.builtin.stochastic.continuous.StochasticSIR.get_herd_immunity_threshold(\n)\nGet herd immunity threshold H = 1 - 1/R₀.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nHerd immunity threshold (fraction)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; sir = StochasticSIR(beta=0.5, gamma=0.1)\n&gt;&gt;&gt; H = sir.get_herd_immunity_threshold()\n&gt;&gt;&gt; print(f\"Herd immunity: {H:.1%}\")"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nModels the error dynamics of a kinematic vehicle (car, robot, boat) as it attempts to follow a circular trajectory.\nThe vehicle uses a bicycle model (front-wheel steering) and the error coordinates are relative to the closest point on the reference circle."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html#coordinate-frames",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html#coordinate-frames",
    "title": "",
    "section": "Coordinate Frames:",
    "text": "Coordinate Frames:\n\nReference path: Circular trajectory with radius R\nPath frame: Moving frame tangent to reference path\nVehicle frame: Body-fixed frame of the vehicle\nError coordinates: Deviations from reference path in path frame"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [d_e, θ_e] - d_e: Lateral (cross-track) error [m] * d_e &gt; 0: vehicle is to the left of the path * d_e &lt; 0: vehicle is to the right of the path * d_e = 0: vehicle is exactly on the path\n- θ_e: Heading error [rad]\n  * θ_e &gt; 0: vehicle heading points left of desired direction\n  * θ_e &lt; 0: vehicle heading points right of desired direction\n  * θ_e = 0: vehicle heading is tangent to path\nControl: u = [δ] - δ (delta): Front wheel steering angle [rad] * δ &gt; 0: steer left * δ &lt; 0: steer right * δ = 0: straight ahead\nOutput: y = [d_e, θ_e] - Full state observation (both errors measured)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe error dynamics describe how tracking errors evolve:\nḋ_e = v·sin(θ_e)\n\nθ̇_e = (v·δ)/L - cos(θ_e)/(R/v - sin(θ_e))\nLateral error rate ḋ_e: - Proportional to forward speed v - Depends on heading error through sin(θ_e) - When θ_e &gt; 0 (heading left), d_e increases (moves left) - When θ_e &lt; 0 (heading right), d_e decreases (moves right)\n**Heading error rate θ̇_e**: - First term (v·δ)/L: Vehicle’s turning rate (Ackermann steering) - Second term: Path’s curvature rate projection - At equilibrium, these balance to track the circle\nPhysical interpretation: - If vehicle steers more than needed → heading error increases - If vehicle steers less than needed → heading error decreases - Coupling: lateral error affects required steering through geometry"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nspeed : float, default=1.0 Constant forward speed of vehicle [m/s]. Assumed to be maintained by a low-level speed controller. Higher speed → faster error dynamics. length : float, default=1.0 Vehicle wheelbase [m]. Distance between front and rear axles. Longer wheelbase → less maneuverable (smaller turning rate). radius : float, default=10.0 Radius of the circular reference path [m]. Larger radius → gentler turn, easier to track. radius → ∞ approaches straight line tracking."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html#equilibrium",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html#equilibrium",
    "title": "",
    "section": "Equilibrium:",
    "text": "Equilibrium:\nPerfect tracking equilibrium: x_eq = [0, 0] (no lateral error, no heading error) u_eq = L/R (steady-state steering angle for circle)\nAt equilibrium: - Vehicle is on the path (d_e = 0) - Vehicle heading is tangent to path (θ_e = 0) - Steering angle exactly matches path curvature - Steady-state steering: δ = L/R = wheelbase/radius"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.PathTracking.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.PathTracking.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDubinsVehicle : Full kinematic model (not error dynamics) PVTOL : Another vehicle with reference tracking CartPole : Another system with error dynamics formulation"
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/index.html#systems-core-classes",
    "href": "api/index.html#systems-core-classes",
    "title": "",
    "section": "Systems: Core Classes",
    "text": "Systems: Core Classes\nAbstract base classes and core system implementations\n\n\n\nsystems.base.core.SymbolicSystemBase\nAbstract base class for symbolic systems (time-domain agnostic).\n\n\nsystems.base.core.ContinuousSystemBase\nAbstract base class for all continuous-time dynamical systems.\n\n\nsystems.base.core.DiscreteSystemBase\nAbstract base class for all discrete-time dynamical systems.\n\n\nsystems.base.core.ContinuousSymbolicSystem\nConcrete symbolic continuous-time dynamical system.\n\n\nsystems.base.core.DiscreteSymbolicSystem\nConcrete symbolic discrete-time dynamical system.\n\n\nsystems.base.core.ContinuousStochasticSystem\nConcrete symbolic continuous-time stochastic dynamical system (SDE).\n\n\nsystems.base.core.DiscreteStochasticSystem\nConcrete symbolic discrete-time stochastic dynamical system.\n\n\nsystems.base.core.DiscretizedSystem\nPure wrapper providing discrete interface to continuous systems.\n\n\nsystems.base.core.discretize\nConvenience wrapper for creating a discretized system."
  },
  {
    "objectID": "api/index.html#systems-numerical-integration",
    "href": "api/index.html#systems-numerical-integration",
    "title": "",
    "section": "Systems: Numerical Integration",
    "text": "Systems: Numerical Integration\nODE and SDE integrators for multiple backends\n\n\n\nsystems.base.numerical_integration.is_sde_method\nCheck if integration method is for stochastic differential equations.\n\n\nsystems.base.numerical_integration.is_fixed_step\nCheck if integration method uses fixed time stepping.\n\n\nsystems.base.numerical_integration.normalize_method_name\nNormalize method names across backends to canonical form.\n\n\nsystems.base.numerical_integration.get_available_methods\nGet available integration methods for a backend.\n\n\nsystems.base.numerical_integration.validate_method\nValidate method for backend and system type.\n\n\nsystems.base.numerical_integration.get_method_info\nGet comprehensive information about a method.\n\n\nsystems.base.numerical_integration.list_all_methods\nList all integration methods across all categories.\n\n\nsystems.base.numerical_integration.get_implementing_library\nGet which library/package implements this method.\n\n\nsystems.base.numerical_integration.IntegratorFactory\nFactory for creating numerical integrators.\n\n\nsystems.base.numerical_integration.IntegratorBase\nAbstract base class for numerical integrators.\n\n\nsystems.base.numerical_integration.ScipyIntegrator\nAdaptive integrator using scipy.integrate.solve_ivp.\n\n\nsystems.base.numerical_integration.DiffraxIntegrator\nJAX-based ODE integrator using the Diffrax library.\n\n\nsystems.base.numerical_integration.TorchDiffEqIntegrator\nPyTorch-based ODE integrator using the torchdiffeq library.\n\n\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory\nFactory for creating SDE numerical integrators.\n\n\nsystems.base.numerical_integration.stochastic.SDEIntegratorBase\nAbstract base class for SDE integrators.\n\n\nsystems.base.numerical_integration.stochastic.DiffEqPySDEIntegrator\nJulia-based SDE integrator using DifferentialEquations.jl via diffeqpy.\n\n\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator\nPyTorch-based SDE integrator using the torchsde library.\n\n\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator\nJAX-based SDE integrator using the Diffrax library.\n\n\nsystems.base.numerical_integration.stochastic.CustomBrownianPath\nCustom Brownian motion that uses provided dW increments.\n\n\nsystems.base.numerical_integration.stochastic.create_custom_or_random_brownian\nCreate either custom or random Brownian motion for Diffrax."
  },
  {
    "objectID": "api/index.html#systems-utilities",
    "href": "api/index.html#systems-utilities",
    "title": "",
    "section": "Systems: Utilities",
    "text": "Systems: Utilities\nBackend management, linearization, and code generation\n\n\n\nsystems.base.utils.BackendManager\nManages backend detection, conversion, and device placement.\n\n\nsystems.base.utils.CodeGenerator\nOrchestrates code generation and caching for a dynamical system.\n\n\nsystems.base.utils.DynamicsEvaluator\nEvaluates forward dynamics across backends.\n\n\nsystems.base.utils.EquilibriumHandler\nManages multiple equilibrium points for a dynamical system.\n\n\nsystems.base.utils.LinearizationEngine\nComputes linearized dynamics across backends.\n\n\nsystems.base.utils.ObservationEngine\nEvaluates observation/output functions across backends.\n\n\nsystems.base.utils.SymbolicValidator\nValidates symbolic dynamical system definitions.\n\n\nsystems.base.utils.stochastic.NoiseCharacteristics\nContainer for noise structure analysis results.\n\n\nsystems.base.utils.stochastic.NoiseCharacterizer\nAnalyzes symbolic diffusion expressions to determine noise structure.\n\n\nsystems.base.utils.stochastic.analyze_noise_structure\nConvenience function for analyzing noise structure.\n\n\nsystems.base.utils.stochastic.DiffusionHandler\nHandles code generation and caching for diffusion terms.\n\n\nsystems.base.utils.stochastic.SDEValidator\nValidates stochastic dynamical system definitions."
  },
  {
    "objectID": "api/index.html#control-design-analysis",
    "href": "api/index.html#control-design-analysis",
    "title": "",
    "section": "Control Design & Analysis",
    "text": "Control Design & Analysis\nControl synthesis, system analysis, and classical control functions\n\n\n\ncontrol.ControlSynthesis\nControl synthesis wrapper for system composition.\n\n\ncontrol.SystemAnalysis\nSystem analysis wrapper for composition.\n\n\ncontrol.design_lqr\nDesign Linear Quadratic Regulator (LQR) controller.\n\n\ncontrol.design_lqg\nDesign Linear Quadratic Gaussian (LQG) controller.\n\n\ncontrol.design_kalman_filter\nDesign Kalman filter for optimal state estimation.\n\n\ncontrol.analyze_stability\nAnalyze system stability via eigenvalue analysis.\n\n\ncontrol.analyze_controllability\nTest controllability of linear system (A, B).\n\n\ncontrol.analyze_observability\nTest observability of linear system (A, C)."
  },
  {
    "objectID": "api/index.html#visualization",
    "href": "api/index.html#visualization",
    "title": "",
    "section": "Visualization",
    "text": "Visualization\nPlotting and visualization tools for dynamical systems\n\n\n\nvisualization.TrajectoryPlotter\nTime-domain trajectory visualization.\n\n\nvisualization.PhasePortraitPlotter\nPhase space visualization for dynamical systems.\n\n\nvisualization.ControlPlotter\nControl system analysis visualization.\n\n\nvisualization.ColorSchemes\nPredefined color palettes for plotting.\n\n\nvisualization.PlotThemes\nComplete plotting theme configurations."
  },
  {
    "objectID": "api/index.html#builtin-deterministic-continuous",
    "href": "api/index.html#builtin-deterministic-continuous",
    "title": "",
    "section": "Builtin: Deterministic Continuous",
    "text": "Builtin: Deterministic Continuous\nContinuous-time deterministic dynamical systems\n\n\n\nsystems.builtin.deterministic.continuous.LinearSystem\nFirst-order linear system: dx/dt = -ax + bu\n\n\nsystems.builtin.deterministic.continuous.AutonomousLinearSystem\nAutonomous first-order linear system: dx/dt = -a*x\n\n\nsystems.builtin.deterministic.continuous.LinearSystem2D\nTwo-dimensional linear system.\n\n\nsystems.builtin.deterministic.continuous.SymbolicPendulum\nSimple inverted pendulum system - first-order state-space formulation.\n\n\nsystems.builtin.deterministic.continuous.SymbolicPendulum2ndOrder\nInverted pendulum - second-order formulation (returns ONLY acceleration).\n\n\nsystems.builtin.deterministic.continuous.CartPole\nCart-pole system (inverted pendulum on cart) - classic underactuated system.\n\n\nsystems.builtin.deterministic.continuous.Lorenz\nLorenz system - famous chaotic dynamical system from atmospheric convection.\n\n\nsystems.builtin.deterministic.continuous.ControlledLorenz\nLorenz system - famous chaotic dynamical system from atmospheric convection with a forcing term\n\n\nsystems.builtin.deterministic.continuous.VanDerPolOscillator\nVan der Pol oscillator - self-excited nonlinear oscillator with limit cycle.\n\n\nsystems.builtin.deterministic.continuous.ControlledVanDerPolOscillator\nVan der Pol oscillator - self-excited nonlinear oscillator with limit cycle and forcing term\n\n\nsystems.builtin.deterministic.continuous.DuffingOscillator\nDuffing oscillator - nonlinear oscillator with cubic stiffness term.\n\n\nsystems.builtin.deterministic.continuous.CoupledOscillatorSystem\nCoupled mass-spring-damper system with rotational coupling - first-order formulation.\n\n\nsystems.builtin.deterministic.continuous.NonlinearChainSystem\nChain of five coupled nonlinear oscillators - first-order formulation.\n\n\nsystems.builtin.deterministic.continuous.DubinsVehicle\nDubins vehicle - kinematic car model with unicycle dynamics.\n\n\nsystems.builtin.deterministic.continuous.PathTracking\nPath tracking error dynamics for a vehicle following a circular reference path.\n\n\nsystems.builtin.deterministic.continuous.SymbolicQuadrotor2D\nPlanar quadrotor (quadcopter) - second-order formulation.\n\n\nsystems.builtin.deterministic.continuous.SymbolicQuadrotor2DLidar\nSymbolic representation of a planar (2D) quadrotor with lidar-based partial observations.\n\n\nsystems.builtin.deterministic.continuous.PVTOL\nPlanar Vertical Take-Off and Landing (PVTOL) aircraft - second-order formulation.\n\n\nsystems.builtin.deterministic.continuous.Manipulator2Link\nTwo-link planar robotic manipulator - second-order formulation.\n\n\nsystems.builtin.deterministic.continuous.FifthOrderMechanicalSystem\nFifth-order mechanical system - extremely high-order dynamics.\n\n\nsystems.builtin.deterministic.continuous.ContinuousBatchReactor\nContinuous-time chemical batch reactor with temperature control.\n\n\nsystems.builtin.deterministic.continuous.ContinuousCSTR\nContinuous-time Continuous Stirred-Tank Reactor (CSTR) with cooling jacket."
  },
  {
    "objectID": "api/index.html#builtin-deterministic-discrete",
    "href": "api/index.html#builtin-deterministic-discrete",
    "title": "",
    "section": "Builtin: Deterministic Discrete",
    "text": "Builtin: Deterministic Discrete\nDiscrete-time deterministic dynamical systems\n\n\n\nsystems.builtin.deterministic.discrete.DiscreteOscillator\nDiscrete-time damped harmonic oscillator with external forcing.\n\n\nsystems.builtin.deterministic.discrete.DiscretePendulum\nDiscrete-time simple pendulum with friction and optional control.\n\n\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator\nDiscrete-time double integrator (position-controlled point mass).\n\n\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegratorWithForce\nDiscrete double integrator with explicit force input and mass.\n\n\nsystems.builtin.deterministic.discrete.DiscreteRobotArm\nDiscrete-time single-link robot arm with gravity and friction.\n\n\nsystems.builtin.deterministic.discrete.DiscreteCartPole\nDiscrete-time cart-pole (inverted pendulum on cart) system.\n\n\nsystems.builtin.deterministic.discrete.DifferentialDriveRobot\nDiscrete-time differential drive mobile robot with nonholonomic constraints.\n\n\nsystems.builtin.deterministic.discrete.DiscreteBatchReactor\nDiscrete-time chemical batch reactor with temperature control.\n\n\nsystems.builtin.deterministic.discrete.DiscreteCSTR\nDiscrete-time Continuous Stirred-Tank Reactor (CSTR) with cooling jacket.\n\n\nsystems.builtin.deterministic.discrete.DiscreteSolowModel\nDiscrete-time Solow-Swan neoclassical growth model.\n\n\nsystems.builtin.deterministic.discrete.LogisticMap\nThe logistic map: x[k+1] = r·x[k]·(1 - x[k])\n\n\nsystems.builtin.deterministic.discrete.HenonMap\nThe Hénon Map: Paradigm of 2D dissipative chaos and strange attractors.\n\n\nsystems.builtin.deterministic.discrete.StandardMap\nThe Standard Map (Chirikov-Taylor Map): Paradigm of Hamiltonian chaos."
  },
  {
    "objectID": "api/index.html#builtin-stochastic-continuous",
    "href": "api/index.html#builtin-stochastic-continuous",
    "title": "",
    "section": "Builtin: Stochastic Continuous",
    "text": "Builtin: Stochastic Continuous\nContinuous-time stochastic dynamical systems (SDEs)\n\n\n\nsystems.builtin.stochastic.continuous.BrownianMotion\nStandard Brownian motion (Wiener process) - pure diffusion process.\n\n\nsystems.builtin.stochastic.continuous.BrownianMotion2D\nTwo-dimensional Brownian motion with independent components.\n\n\nsystems.builtin.stochastic.continuous.BrownianMotionWithDrift\nAlias for GeometricBrownianMotion.\n\n\nsystems.builtin.stochastic.continuous.GeometricBrownianMotion\nGeometric Brownian motion with multiplicative (state-dependent) noise.\n\n\nsystems.builtin.stochastic.continuous.OrnsteinUhlenbeck\nOrnstein-Uhlenbeck process with mean reversion and additive noise.\n\n\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck\nMultivariate Ornstein-Uhlenbeck process with coupling and correlated noise.\n\n\nsystems.builtin.stochastic.continuous.CoxIngersollRoss\nCox-Ingersoll-Ross process with mean reversion and square-root diffusion.\n\n\nsystems.builtin.stochastic.continuous.LangevinDynamics\nLangevin dynamics - particle in viscous fluid with thermal noise.\n\n\nsystems.builtin.stochastic.continuous.StochasticDoubleIntegrator\nStochastic double integrator - canonical LQG benchmark system.\n\n\nsystems.builtin.stochastic.continuous.ContinuousStochasticPendulum\nStochastic pendulum with random forcing - canonical nonlinear stochastic system.\n\n\nsystems.builtin.stochastic.continuous.StochasticCartPole\nStochastic inverted pendulum on cart with random disturbances.\n\n\nsystems.builtin.stochastic.continuous.StochasticLorenz\nStochastic Lorenz system - deterministic chaos with random perturbations.\n\n\nsystems.builtin.stochastic.continuous.StochasticSIR\nStochastic SIR epidemic model with demographic noise.\n\n\nsystems.builtin.stochastic.continuous.ContinuousStochasticBatchReactor\nContinuous-time stochastic batch reactor with process noise.\n\n\nsystems.builtin.stochastic.continuous.ContinuousStochasticCSTR\nContinuous-time stochastic CSTR with multiple equilibria and Brownian noise."
  },
  {
    "objectID": "api/index.html#builtin-stochastic-discrete",
    "href": "api/index.html#builtin-stochastic-discrete",
    "title": "",
    "section": "Builtin: Stochastic Discrete",
    "text": "Builtin: Stochastic Discrete\nDiscrete-time stochastic dynamical systems\n\n\n\nsystems.builtin.stochastic.discrete.DiscreteAR1\nFirst-order autoregressive process with additive noise.\n\n\nsystems.builtin.stochastic.discrete.DiscreteWhiteNoise\nPure white noise process - memoryless random sequence.\n\n\nsystems.builtin.stochastic.discrete.DiscreteRandomWalk\nRandom walk - non-stationary process with unit root.\n\n\nsystems.builtin.stochastic.discrete.DiscreteARMA11\nARMA(1,1) process - combines autoregressive and moving average.\n\n\nsystems.builtin.stochastic.discrete.DiscreteVAR1\nVector Autoregressive process of order 1 - multivariate time series model.\n\n\nsystems.builtin.stochastic.discrete.DiscreteGARCH11\nGARCH(1,1) - time-varying volatility model (Nobel Prize 2003).\n\n\nsystems.builtin.stochastic.discrete.DiscreteStochasticDoubleIntegrator\nDiscrete-time stochastic double integrator - canonical digital LQG benchmark.\n\n\nsystems.builtin.stochastic.discrete.DiscreteStochasticPendulum\nDiscrete-time stochastic pendulum for digital control and RL.\n\n\nsystems.builtin.stochastic.discrete.DiscreteStochasticQueue\nDiscrete-time stochastic queue with random arrivals and service.\n\n\nsystems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor\nDiscrete-time stochastic batch reactor for digital control and estimation.\n\n\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR\nDiscrete-time stochastic CSTR with multiple steady states and process noise.\n\n\nsystems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap\nDiscrete-time stochastic logistic map - chaos meets noise."
  },
  {
    "objectID": "api/index.html#types-core",
    "href": "api/index.html#types-core",
    "title": "",
    "section": "Types: Core",
    "text": "Types: Core\nFundamental vectors, matrices, dimensions, and function types\n\n\n\ntypes.core.ScalarLike\nScalar value in any backend.\n\n\ntypes.core.ArrayLike\nArray-like type supporting multiple backends.\n\n\ntypes.core.StateVector\nState vector x ∈ ℝⁿˣ.\n\n\ntypes.core.ControlVector\nControl input vector u ∈ ℝⁿᵘ.\n\n\ntypes.core.OutputVector\nOutput/observation/measurement vector y ∈ ℝⁿʸ.\n\n\ntypes.core.NoiseVector\nNoise/disturbance vector w ∈ ℝⁿʷ (stochastic systems only).\n\n\ntypes.core.ParameterVector\nParameter vector θ ∈ ℝⁿᵖ.\n\n\ntypes.core.StateMatrix\nState matrix (nx, nx).\n\n\ntypes.core.InputMatrix\nInput matrix B (nx, nu).\n\n\ntypes.core.OutputMatrix\nOutput/observation matrix (ny, nx).\n\n\ntypes.core.DiffusionMatrix\nDiffusion/noise gain matrix (nx, nw) - stochastic systems only.\n\n\ntypes.core.FeedthroughMatrix\nFeedthrough/direct transmission matrix (ny, nu).\n\n\ntypes.core.GainMatrix\nGain matrix for control or estimation.\n\n\ntypes.core.CovarianceMatrix\nCovariance matrix (symmetric, positive semidefinite).\n\n\ntypes.core.SystemDimensions\nSystem dimensions as dictionary.\n\n\ntypes.core.DynamicsFunction\nDynamics function f(x, u).\n\n\ntypes.core.OutputFunction\nOutput/observation function h(x).\n\n\ntypes.core.DiffusionFunction\nDiffusion function g(x, u) for stochastic systems.\n\n\ntypes.core.ControlPolicy\nControl policy/controller π(x).\n\n\ntypes.core.TimeVaryingControl\nTime-varying control function u(t).\n\n\ntypes.core.FeedbackController\nFeedback controller with time awareness π(x, t).\n\n\ntypes.core.ControlInput\nUnified type for control inputs to integration methods."
  },
  {
    "objectID": "api/index.html#types-backend-configuration",
    "href": "api/index.html#types-backend-configuration",
    "title": "",
    "section": "Types: Backend & Configuration",
    "text": "Types: Backend & Configuration\nBackend support and configuration types\n\n\n\ntypes.backends.Backend\nBackend identifier for numerical computation.\n\n\ntypes.backends.Device\nDevice identifier for hardware acceleration.\n\n\ntypes.backends.BackendConfig\nBackend configuration dictionary.\n\n\ntypes.backends.IntegrationMethod\nIntegration method for continuous-time systems (ODEs).\n\n\ntypes.backends.SDEIntegrationMethod\nSDE integration method for stochastic differential equations.\n\n\ntypes.backends.DiscretizationMethod\nDiscretization method for continuous → discrete transformation.\n\n\ntypes.backends.OptimizationMethod\nOptimization method for control/estimation problems.\n\n\ntypes.backends.NoiseType\nNoise structure classification for stochastic systems.\n\n\ntypes.backends.SDEType\nSDE interpretation type.\n\n\ntypes.backends.ConvergenceType\nSDE convergence type for numerical integration.\n\n\ntypes.backends.IntegratorConfig\nConfiguration for continuous-time integrators.\n\n\ntypes.backends.SDEIntegratorConfig\nConfiguration for SDE integrators.\n\n\ntypes.backends.DiscretizerConfig\nConfiguration for system discretization.\n\n\ntypes.backends.SystemConfig\nComplete system configuration dictionary.\n\n\ntypes.backends.validate_backend\nValidate and normalize backend string.\n\n\ntypes.backends.validate_device\nValidate device for given backend.\n\n\ntypes.backends.get_backend_default_method\nGet default integration method for backend."
  },
  {
    "objectID": "api/index.html#types-trajectories-simulation",
    "href": "api/index.html#types-trajectories-simulation",
    "title": "",
    "section": "Types: Trajectories & Simulation",
    "text": "Types: Trajectories & Simulation\nTime series, trajectories, and simulation results\n\n\n\ntypes.trajectories.TimePoints\nArray of time points for simulation or evaluation.\n\n\ntypes.trajectories.TimeSpan\nTime interval for continuous integration: (t_start, t_end).\n\n\ntypes.trajectories.StateTrajectory\nState trajectory over time.\n\n\ntypes.trajectories.ControlSequence\nControl input sequence over time.\n\n\ntypes.trajectories.OutputSequence\nOutput/measurement sequence over time.\n\n\ntypes.trajectories.NoiseSequence\nNoise/disturbance sequence for stochastic simulation.\n\n\ntypes.trajectories.SimulationResult\nResult from continuous-time system simulation.\n\n\ntypes.trajectories.IntegrationResult\nResult from continuous-time integration (ODE/SDE solver).\n\n\ntypes.trajectories.TrajectoryStatistics\nStatistical summary of trajectory.\n\n\ntypes.trajectories.TrajectorySegment\nSegment of trajectory between two time points."
  },
  {
    "objectID": "api/index.html#types-control-results",
    "href": "api/index.html#types-control-results",
    "title": "",
    "section": "Types: Control Results",
    "text": "Types: Control Results\nControl design and analysis result types\n\n\n\ntypes.control_classical.LQRResult\nLinear Quadratic Regulator (LQR) design result.\n\n\ntypes.control_classical.LQGResult\nLinear Quadratic Gaussian (LQG) controller design result.\n\n\ntypes.control_classical.KalmanFilterResult\nKalman Filter (optimal state estimator) design result.\n\n\ntypes.control_classical.StabilityInfo\nStability analysis result dictionary.\n\n\ntypes.control_classical.ControllabilityInfo\nControllability analysis result.\n\n\ntypes.control_classical.ObservabilityInfo\nObservability analysis result.\n\n\ntypes.control_classical.PolePlacementResult\nPole placement (eigenvalue assignment) result.\n\n\ntypes.control_classical.LuenbergerObserverResult\nLuenberger observer (deterministic state estimator) design result.\n\n\ntypes.control_advanced.MPCResult\nModel Predictive Control (MPC) solution result.\n\n\ntypes.control_advanced.MHEResult\nMoving Horizon Estimation (MHE) result.\n\n\ntypes.control_advanced.H2ControlResult\nH₂ optimal control result.\n\n\ntypes.control_advanced.HInfControlResult\nH∞ robust control result.\n\n\ntypes.control_advanced.LMIResult\nLinear Matrix Inequality (LMI) solver result.\n\n\ntypes.control_advanced.AdaptiveControlResult\nAdaptive control result.\n\n\ntypes.control_advanced.SlidingModeResult\nSliding Mode Control (SMC) result."
  },
  {
    "objectID": "api/index.html#types-estimation",
    "href": "api/index.html#types-estimation",
    "title": "",
    "section": "Types: Estimation",
    "text": "Types: Estimation\nState estimation result types\n\n\n\ntypes.estimation.EKFResult\nExtended Kalman Filter (EKF) state and result.\n\n\ntypes.estimation.UKFResult\nUnscented Kalman Filter (UKF) result.\n\n\ntypes.estimation.ParticleFilterResult\nParticle Filter (Sequential Monte Carlo) result."
  },
  {
    "objectID": "api/index.html#types-linearization",
    "href": "api/index.html#types-linearization",
    "title": "",
    "section": "Types: Linearization",
    "text": "Types: Linearization\nLinearization and Jacobian types\n\n\n\ntypes.linearization.LinearizationResult\nFlexible linearization result type.\n\n\ntypes.linearization.DeterministicLinearization\nLinearization result for deterministic systems: (A, B).\n\n\ntypes.linearization.StochasticLinearization\nLinearization result for stochastic systems: (A, B, G).\n\n\ntypes.linearization.ContinuousLinearization\nAlias for continuous-time deterministic linearization.\n\n\ntypes.linearization.DiscreteLinearization\nAlias for discrete-time deterministic linearization.\n\n\ntypes.linearization.ContinuousStochasticLinearization\nAlias for continuous-time stochastic linearization.\n\n\ntypes.linearization.DiscreteStochasticLinearization\nAlias for discrete-time stochastic linearization.\n\n\ntypes.linearization.FullLinearization\nComplete linearization including output: (A, B, C, D).\n\n\ntypes.linearization.FullStochasticLinearization\nComplete stochastic linearization: (A, B, G, C, D).\n\n\ntypes.linearization.ObservationLinearization\nObservation/output linearization: (C, D).\n\n\ntypes.linearization.StateJacobian\nState Jacobian ∂f/∂x.\n\n\ntypes.linearization.ControlJacobian\nControl Jacobian ∂f/∂u.\n\n\ntypes.linearization.OutputJacobian\nOutput Jacobian ∂h/∂x.\n\n\ntypes.linearization.DiffusionJacobian\nDiffusion Jacobian ∂g/∂x (stochastic systems).\n\n\ntypes.linearization.LinearizationCacheKey\nCache key for linearization results."
  },
  {
    "objectID": "api/index.html#types-symbolic",
    "href": "api/index.html#types-symbolic",
    "title": "",
    "section": "Types: Symbolic",
    "text": "Types: Symbolic\nSymbolic computation types\n\n\n\ntypes.symbolic.SymbolicExpression\nSingle symbolic expression.\n\n\ntypes.symbolic.SymbolicMatrix\nMatrix of symbolic expressions.\n\n\ntypes.symbolic.SymbolicStateEquations\nSymbolic state equations: f(x, u, params).\n\n\ntypes.symbolic.SymbolicJacobian\nJacobian matrix: ∂f/∂x."
  },
  {
    "objectID": "api/index.html#types-advanced",
    "href": "api/index.html#types-advanced",
    "title": "",
    "section": "Types: Advanced",
    "text": "Types: Advanced\nReachability, robustness, optimization, and learning types\n\n\n\ntypes.reachability.ReachabilityResult\nReachability analysis result.\n\n\ntypes.reachability.ROAResult\nRegion of Attraction (ROA) analysis result.\n\n\ntypes.reachability.CBFResult\nControl Barrier Function (CBF) result.\n\n\ntypes.reachability.CLFResult\nControl Lyapunov Function (CLF) result.\n\n\ntypes.robustness.RobustStabilityResult\nRobust stability analysis result.\n\n\ntypes.robustness.TubeMPCResult\nTube-based MPC result.\n\n\ntypes.optimization.OptimizationResult\nGeneral nonlinear optimization result.\n\n\ntypes.optimization.TrajectoryOptimizationResult\nTrajectory optimization result.\n\n\ntypes.learning.TrainingResult\nNeural network training result.\n\n\ntypes.learning.RLTrainingResult\nReinforcement learning training result.\n\n\ntypes.contraction.ContractionAnalysisResult\nContraction analysis result.\n\n\ntypes.contraction.CCMResult\nControl Contraction Metrics (CCM) result.\n\n\ntypes.conformal.ConformalPredictionResult\nConformal prediction result for test points."
  },
  {
    "objectID": "api/index.html#types-protocols",
    "href": "api/index.html#types-protocols",
    "title": "",
    "section": "Types: Protocols",
    "text": "Types: Protocols\nStructural subtyping protocols for system interfaces\n\n\n\ntypes.protocols.ContinuousSystemProtocol\nMinimal interface for continuous-time dynamical systems.\n\n\ntypes.protocols.DiscreteSystemProtocol\nMinimal interface for discrete-time dynamical systems.\n\n\ntypes.protocols.StochasticSystemProtocol\nSystem with stochastic dynamics (continuous or discrete).\n\n\ntypes.protocols.LinearizableContinuousProtocol\nContinuous system with linearization capability.\n\n\ntypes.protocols.LinearizableDiscreteProtocol\nDiscrete system with linearization capability."
  },
  {
    "objectID": "api/index.html#state-observers",
    "href": "api/index.html#state-observers",
    "title": "",
    "section": "State Observers",
    "text": "State Observers\nState estimation and observer design\n\n\n\nobservers.LinearObserver\nLinear state observer with constant gain.\n\n\nobservers.ExtendedKalmanFilter\nExtended Kalman Filter (EKF) for nonlinear state estimation."
  },
  {
    "objectID": "api/systems.base.core.ContinuousStochasticSystem.html",
    "href": "api/systems.base.core.ContinuousStochasticSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.ContinuousStochasticSystem.html#attributes-set-by-user-in-define_system",
    "href": "api/systems.base.core.ContinuousStochasticSystem.html#attributes-set-by-user-in-define_system",
    "title": "",
    "section": "Attributes (Set by User in define_system)",
    "text": "Attributes (Set by User in define_system)\ndiffusion_expr : sp.Matrix Symbolic diffusion matrix g(x, u), shape (nx, nw) REQUIRED - must be set in define_system() sde_type : SDEType or str SDE interpretation (‘ito’ or ‘stratonovich’) Optional - defaults to Itô"
  },
  {
    "objectID": "api/systems.base.core.ContinuousStochasticSystem.html#attributes-created-automatically",
    "href": "api/systems.base.core.ContinuousStochasticSystem.html#attributes-created-automatically",
    "title": "",
    "section": "Attributes (Created Automatically)",
    "text": "Attributes (Created Automatically)\ndiffusion_handler : DiffusionHandler Generates and caches diffusion functions noise_characteristics : NoiseCharacteristics Automatic noise structure analysis results nw : int Number of independent Wiener processes is_stochastic : bool Always True for this class"
  },
  {
    "objectID": "api/systems.base.core.ContinuousStochasticSystem.html#examples",
    "href": "api/systems.base.core.ContinuousStochasticSystem.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; class OrnsteinUhlenbeck(ContinuousStochasticSystem):\n...     '''Ornstein-Uhlenbeck process with mean reversion.'''\n...\n...     def define_system(self, alpha=1.0, sigma=0.5):\n...         x = sp.symbols('x')\n...         u = sp.symbols('u')\n...         alpha_sym = sp.symbols('alpha', positive=True)\n...         sigma_sym = sp.symbols('sigma', positive=True)\n...\n...         # Drift (deterministic part)\n...         self.state_vars = [x]\n...         self.control_vars = [u]\n...         self._f_sym = sp.Matrix([[-alpha_sym * x + u]])\n...         self.parameters = {alpha_sym: alpha, sigma_sym: sigma}\n...         self.order = 1\n...\n...         # Diffusion (stochastic part)\n...         self.diffusion_expr = sp.Matrix([[sigma_sym]])\n...         self.sde_type = 'ito'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Instantiate system\n&gt;&gt;&gt; system = OrnsteinUhlenbeck(alpha=2.0, sigma=0.3)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Automatic noise analysis\n&gt;&gt;&gt; print(system.noise_characteristics.noise_type)\nNoiseType.ADDITIVE\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Evaluate drift and diffusion\n&gt;&gt;&gt; x = np.array([1.0])\n&gt;&gt;&gt; u = np.array([0.0])\n&gt;&gt;&gt; f = system.drift(x, u)  # Drift term\n&gt;&gt;&gt; g = system.diffusion(x, u)  # Diffusion matrix"
  },
  {
    "objectID": "api/systems.base.core.ContinuousStochasticSystem.html#attributes",
    "href": "api/systems.base.core.ContinuousStochasticSystem.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ndiffusion_expr\nSymbolic diffusion matrix g(x, u) - MUST be set in define_system()\n\n\nis_stochastic\nReturn True (this is a stochastic system).\n\n\nsde_type\nSDE interpretation - can be ‘ito’ or ‘stratonovich’ (string or enum)"
  },
  {
    "objectID": "api/systems.base.core.ContinuousStochasticSystem.html#methods",
    "href": "api/systems.base.core.ContinuousStochasticSystem.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncan_optimize_for_additive\nCheck if additive-noise optimizations are applicable.\n\n\ncompile_all\nCompile both drift and diffusion for all backends.\n\n\ncompile_diffusion\nPre-compile diffusion functions for specified backends.\n\n\ndepends_on_control\nCheck if diffusion depends on control inputs.\n\n\ndepends_on_state\nCheck if diffusion depends on state variables.\n\n\ndepends_on_time\nCheck if diffusion depends on time.\n\n\ndiffusion\nEvaluate diffusion term g(x, u, t) or g(x, t) for autonomous.\n\n\ndrift\nEvaluate drift term f(x, u, t) or f(x, t) for autonomous.\n\n\nget_constant_noise\nGet constant noise matrix for additive noise.\n\n\nget_info\nGet comprehensive system information.\n\n\nget_noise_type\nGet classified noise type.\n\n\nget_optimization_opportunities\nGet optimization opportunities based on noise structure.\n\n\nintegrate\nIntegrate stochastic system using SDE solver.\n\n\nis_additive_noise\nCheck if noise is additive (constant, state-independent).\n\n\nis_diagonal_noise\nCheck if noise sources are independent (diagonal diffusion).\n\n\nis_multiplicative_noise\nCheck if noise is multiplicative (state-dependent).\n\n\nis_pure_diffusion\nCheck if system is pure diffusion (zero drift).\n\n\nis_scalar_noise\nCheck if system has single noise source.\n\n\nlinearize\nCompute linearization including diffusion: A = ∂f/∂x, B = ∂f/∂u, G = g(x_eq).\n\n\nprint_sde_info\nPrint formatted SDE system information.\n\n\nrecommend_solvers\nRecommend efficient SDE solvers based on noise structure.\n\n\nreset_all_caches\nClear both drift and diffusion caches.\n\n\nreset_diffusion_cache\nClear cached diffusion functions.\n\n\n\n\ncan_optimize_for_additive\nsystems.base.core.ContinuousStochasticSystem.can_optimize_for_additive()\nCheck if additive-noise optimizations are applicable.\n\n\ncompile_all\nsystems.base.core.ContinuousStochasticSystem.compile_all(\n    backends=None,\n    verbose=False,\n    **kwargs,\n)\nCompile both drift and diffusion for all backends.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Dict[str, float]]\nNested dict: backend → {‘drift’: time, ‘diffusion’: time}\n\n\n\n\n\n\ncompile_diffusion\nsystems.base.core.ContinuousStochasticSystem.compile_diffusion(\n    backends=None,\n    verbose=False,\n    **kwargs,\n)\nPre-compile diffusion functions for specified backends.\n\n\ndepends_on_control\nsystems.base.core.ContinuousStochasticSystem.depends_on_control()\nCheck if diffusion depends on control inputs.\n\n\ndepends_on_state\nsystems.base.core.ContinuousStochasticSystem.depends_on_state()\nCheck if diffusion depends on state variables.\n\n\ndepends_on_time\nsystems.base.core.ContinuousStochasticSystem.depends_on_time()\nCheck if diffusion depends on time.\n\n\ndiffusion\nsystems.base.core.ContinuousStochasticSystem.diffusion(\n    x,\n    u=None,\n    t=0.0,\n    backend=None,\n)\nEvaluate diffusion term g(x, u, t) or g(x, t) for autonomous.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState vector (nx,) or batch (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl vector (nu,) or batch (batch, nu) For autonomous systems (nu=0), u can be None\nNone\n\n\nt\nfloat\nTime (currently ignored)\n0.0\n\n\nbackend\nOptional[Backend]\nBackend selection (None = auto-detect)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nDiffusion matrix g(x, u), shape (nx, nw) or (batch, nx, nw)\n\n\n\n\n\nExamples\nControlled SDE:\n&gt;&gt;&gt; g = system.diffusion(np.array([2.0]), np.array([0.0]))\n&gt;&gt;&gt; print(g.shape)\n(1, 1)\nAutonomous SDE:\n&gt;&gt;&gt; g = system.diffusion(np.array([2.0]))  # u=None\n&gt;&gt;&gt; print(g.shape)\n(1, 1)\nFor additive noise (precompute once):\n&gt;&gt;&gt; if system.is_additive_noise():\n...     G = system.get_constant_noise()  # Precompute once\n\n\n\ndrift\nsystems.base.core.ContinuousStochasticSystem.drift(\n    x,\n    u=None,\n    t=0.0,\n    backend=None,\n)\nEvaluate drift term f(x, u, t) or f(x, t) for autonomous.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState vector (nx,) or batch (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl vector (nu,) or batch (batch, nu) For autonomous systems (nu=0), u can be None\nNone\n\n\nt\nfloat\nTime (currently ignored for time-invariant systems)\n0.0\n\n\nbackend\nOptional[Backend]\nBackend selection (None = auto-detect)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nDrift vector f(x, u), shape (nx,) or (batch, nx)\n\n\n\n\n\nNotes\nDelegates to parent class - reuses ALL drift evaluation logic. Supports both controlled and autonomous SDEs.\n\n\nExamples\nControlled SDE:\n&gt;&gt;&gt; f = system.drift(np.array([1.0]), np.array([0.0]))\n&gt;&gt;&gt; print(f)\n[-1.0]\nAutonomous SDE:\n&gt;&gt;&gt; f = system.drift(np.array([1.0]))  # u=None\n&gt;&gt;&gt; print(f)\n[-2.0]\n\n\n\nget_constant_noise\nsystems.base.core.ContinuousStochasticSystem.get_constant_noise(backend='numpy')\nGet constant noise matrix for additive noise.\nFor additive noise, diffusion is constant and can be precomputed once for significant performance gains.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nstr\nBackend for array type\n'numpy'\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nConstant diffusion matrix (nx, nw)\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf noise is not additive\n\n\n\n\n\n\nget_info\nsystems.base.core.ContinuousStochasticSystem.get_info()\nGet comprehensive system information.\n\n\nget_noise_type\nsystems.base.core.ContinuousStochasticSystem.get_noise_type()\nGet classified noise type.\n\n\nget_optimization_opportunities\nsystems.base.core.ContinuousStochasticSystem.get_optimization_opportunities()\nGet optimization opportunities based on noise structure.\n\n\nintegrate\nsystems.base.core.ContinuousStochasticSystem.integrate(\n    x0,\n    u=None,\n    t_span=(0.0, 10.0),\n    method='euler_maruyama',\n    t_eval=None,\n    n_paths=1,\n    seed=None,\n    **integrator_kwargs,\n)\nIntegrate stochastic system using SDE solver.\nCRITICAL OVERRIDE: This method overrides the parent’s deterministic integrate() to use SDEIntegratorFactory instead of IntegratorFactory. This ensures proper handling of Brownian motion and noise structure.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu\nControlInput\nControl input (constant, callable, or None)\nNone\n\n\nt_span\nTimeSpan\nIntegration interval (t_start, t_end)\n(0.0, 10.0)\n\n\nmethod\nstr\nSDE integration method (default: ‘euler_maruyama’)\n'euler_maruyama'\n\n\nt_eval\nOptional[TimePoints]\nSpecific times to return solution\nNone\n\n\nn_paths\nint\nNumber of Monte Carlo paths to simulate (default: 1) For n_paths &gt; 1, performs Monte Carlo simulation\n1\n\n\nseed\nOptional[int]\nRandom seed for reproducibility\nNone\n\n\n**integrator_kwargs\n\nAdditional options: - dt : float (required for most SDE methods) - rtol, atol : float (adaptive methods only) - convergence_type : ConvergenceType (‘strong’ or ‘weak’)\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegrationResult\nTypedDict containing: - t: Time points (T,) - x: State trajectories - Single path: (T, nx) - Multiple paths: (n_paths, T, nx) - success: Integration success - n_paths: Number of paths - noise_type: Detected noise type - sde_type: Itô or Stratonovich - nfev: Drift function evaluations - diffusion_evals: Diffusion evaluations - integration_time: Computation time\n\n\n\n\n\nExamples\nSingle trajectory:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u=None,\n...     t_span=(0.0, 10.0),\n...     method='euler_maruyama',\n...     dt=0.01,\n...     seed=42\n... )\nMonte Carlo simulation:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     t_span=(0, 10),\n...     n_paths=1000,\n...     dt=0.01,\n...     seed=42\n... )\n&gt;&gt;&gt; mean_traj = result['x'].mean(axis=0)\nState feedback:\n&gt;&gt;&gt; def controller(x, t):\n...     return -K @ x\n&gt;&gt;&gt; result = system.integrate(x0, controller, t_span=(0, 10), dt=0.01)\n\n\n\nis_additive_noise\nsystems.base.core.ContinuousStochasticSystem.is_additive_noise()\nCheck if noise is additive (constant, state-independent).\n\n\nis_diagonal_noise\nsystems.base.core.ContinuousStochasticSystem.is_diagonal_noise()\nCheck if noise sources are independent (diagonal diffusion).\n\n\nis_multiplicative_noise\nsystems.base.core.ContinuousStochasticSystem.is_multiplicative_noise()\nCheck if noise is multiplicative (state-dependent).\n\n\nis_pure_diffusion\nsystems.base.core.ContinuousStochasticSystem.is_pure_diffusion()\nCheck if system is pure diffusion (zero drift).\n\n\nis_scalar_noise\nsystems.base.core.ContinuousStochasticSystem.is_scalar_noise()\nCheck if system has single noise source.\n\n\nlinearize\nsystems.base.core.ContinuousStochasticSystem.linearize(x_eq, u_eq=None)\nCompute linearization including diffusion: A = ∂f/∂x, B = ∂f/∂u, G = g(x_eq).\nFor stochastic systems, linearization returns three matrices: - A: State Jacobian ∂f/∂x - B: Control Jacobian ∂f/∂u - G: Diffusion matrix evaluated at equilibrium g(x_eq, u_eq)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control (nu,)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[ArrayLike, ArrayLike, ArrayLike]\n(A, B, G) where: - A: State Jacobian (nx, nx) - B: Control Jacobian (nx, nu) - G: Diffusion matrix (nx, nw)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x_eq = np.zeros(2)\n&gt;&gt;&gt; u_eq = np.zeros(1)\n&gt;&gt;&gt; A, B, G = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check continuous stability: Re(λ) &lt; 0\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(A)\n&gt;&gt;&gt; is_stable = np.all(np.real(eigenvalues) &lt; 0)\n\n\n\nprint_sde_info\nsystems.base.core.ContinuousStochasticSystem.print_sde_info()\nPrint formatted SDE system information.\n\n\nrecommend_solvers\nsystems.base.core.ContinuousStochasticSystem.recommend_solvers(backend='jax')\nRecommend efficient SDE solvers based on noise structure.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nstr\nIntegration backend (‘jax’, ‘torch’, ‘numpy’)\n'jax'\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nRecommended solver names, ordered by efficiency/accuracy\n\n\n\n\n\nExamples\n&gt;&gt;&gt; solvers = system.recommend_solvers('jax')\n&gt;&gt;&gt; print(solvers)\n['sea', 'shark', 'sra1']  # For additive noise\n\n\n\nreset_all_caches\nsystems.base.core.ContinuousStochasticSystem.reset_all_caches(backends=None)\nClear both drift and diffusion caches.\n\n\nreset_diffusion_cache\nsystems.base.core.ContinuousStochasticSystem.reset_diffusion_cache(\n    backends=None,\n)\nClear cached diffusion functions."
  },
  {
    "objectID": "api/systems.base.core.DiscreteStochasticSystem.html",
    "href": "api/systems.base.core.DiscreteStochasticSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.DiscreteStochasticSystem.html#attributes-set-by-user-in-define_system",
    "href": "api/systems.base.core.DiscreteStochasticSystem.html#attributes-set-by-user-in-define_system",
    "title": "",
    "section": "Attributes (Set by User in define_system)",
    "text": "Attributes (Set by User in define_system)\ndiffusion_expr : sp.Matrix Symbolic diffusion matrix g(x, u), shape (nx, nw) REQUIRED - must be set in define_system() sde_type : SDEType or str SDE interpretation (‘ito’ or ‘stratonovich’) Optional - defaults to Itô (convention for discrete time) Note: In discrete time, both interpretations are equivalent"
  },
  {
    "objectID": "api/systems.base.core.DiscreteStochasticSystem.html#attributes-created-automatically",
    "href": "api/systems.base.core.DiscreteStochasticSystem.html#attributes-created-automatically",
    "title": "",
    "section": "Attributes (Created Automatically)",
    "text": "Attributes (Created Automatically)\ndiffusion_handler : DiffusionHandler Generates and caches diffusion functions noise_characteristics : NoiseCharacteristics Automatic noise structure analysis results nw : int Number of independent noise sources is_stochastic : bool Always True for this class"
  },
  {
    "objectID": "api/systems.base.core.DiscreteStochasticSystem.html#examples",
    "href": "api/systems.base.core.DiscreteStochasticSystem.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nDiscrete-time Ornstein-Uhlenbeck process:\n&gt;&gt;&gt; class DiscreteOU(DiscreteStochasticSystem):\n...     '''AR(1) process with mean reversion.'''\n...\n...     def define_system(self, alpha=1.0, sigma=0.5, dt=0.1):\n...         x = sp.symbols('x')\n...         u = sp.symbols('u')\n...         alpha_sym = sp.symbols('alpha', positive=True)\n...         sigma_sym = sp.symbols('sigma', positive=True)\n...         dt_sym = sp.symbols('dt', positive=True)\n...\n...         # Deterministic part (Euler discretization)\n...         self.state_vars = [x]\n...         self.control_vars = [u]\n...         self._f_sym = sp.Matrix([(1 - alpha_sym*dt_sym) * x + u])\n...         self.parameters = {alpha_sym: alpha, sigma_sym: sigma, dt_sym: dt}\n...         self._dt = dt  # REQUIRED!\n...         self.order = 1\n...\n...         # Stochastic part (additive noise)\n...         self.diffusion_expr = sp.Matrix([[sigma_sym]])\n...         self.sde_type = 'ito'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Instantiate system\n&gt;&gt;&gt; system = DiscreteOU(alpha=2.0, sigma=0.3, dt=0.1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Automatic noise analysis\n&gt;&gt;&gt; print(system.noise_characteristics.noise_type)\nNoiseType.ADDITIVE\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Evaluate deterministic and stochastic parts\n&gt;&gt;&gt; x_k = np.array([1.0])\n&gt;&gt;&gt; u_k = np.array([0.0])\n&gt;&gt;&gt; f = system(x_k, u_k)  # Deterministic next state mean\n&gt;&gt;&gt; g = system.diffusion(x_k, u_k)  # Noise gain\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Full stochastic step\n&gt;&gt;&gt; w_k = np.random.randn(1)\n&gt;&gt;&gt; x_next = f + g @ w_k"
  },
  {
    "objectID": "api/systems.base.core.DiscreteStochasticSystem.html#attributes",
    "href": "api/systems.base.core.DiscreteStochasticSystem.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ndiffusion_expr\nSymbolic diffusion matrix g(x, u) - MUST be set in define_system()\n\n\nis_stochastic\nReturn True (this is a stochastic system).\n\n\nsde_type\nSDE interpretation - ‘ito’ or ‘stratonovich’ (equivalent in discrete time)"
  },
  {
    "objectID": "api/systems.base.core.DiscreteStochasticSystem.html#methods",
    "href": "api/systems.base.core.DiscreteStochasticSystem.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncan_optimize_for_additive\nCheck if additive-noise optimizations are applicable.\n\n\ncompile_all\nCompile both deterministic and diffusion for all backends.\n\n\ncompile_diffusion\nPre-compile diffusion functions for specified backends.\n\n\ndepends_on_control\nCheck if diffusion depends on control inputs.\n\n\ndepends_on_state\nCheck if diffusion depends on state variables.\n\n\ndepends_on_time\nCheck if diffusion depends on time (always False for time-invariant).\n\n\ndiffusion\nEvaluate diffusion term g(x[k], u[k]).\n\n\nget_constant_noise\nGet constant noise matrix for additive noise.\n\n\nget_info\nGet comprehensive system information.\n\n\nget_noise_type\nGet classified noise type.\n\n\nget_optimization_opportunities\nGet optimization opportunities based on noise structure.\n\n\nget_sde_type\nGet SDE interpretation type (Itô convention for discrete).\n\n\nis_additive_noise\nCheck if noise is additive (constant, state-independent).\n\n\nis_diagonal_noise\nCheck if noise sources are independent (diagonal diffusion).\n\n\nis_multiplicative_noise\nCheck if noise is multiplicative (state-dependent).\n\n\nis_pure_diffusion\nCheck if system is pure diffusion (zero deterministic part).\n\n\nis_scalar_noise\nCheck if system has single noise source.\n\n\nlinearize\nCompute linearization including diffusion: Ad = ∂f/∂x, Bd = ∂f/∂u, Gd = g(x_eq).\n\n\nprint_equations\nPrint symbolic equations using discrete-time stochastic notation.\n\n\nprint_stochastic_info\nPrint formatted stochastic system information.\n\n\nreset_all_caches\nClear both deterministic and diffusion caches.\n\n\nreset_diffusion_cache\nClear cached diffusion functions.\n\n\nsimulate_stochastic\nSimulate stochastic discrete system with optional Monte Carlo.\n\n\nstep_stochastic\nCompute full stochastic step: x[k+1] = f(x[k], u[k]) + g(x[k], u[k]) * w[k].\n\n\n\n\ncan_optimize_for_additive\nsystems.base.core.DiscreteStochasticSystem.can_optimize_for_additive()\nCheck if additive-noise optimizations are applicable.\n\n\ncompile_all\nsystems.base.core.DiscreteStochasticSystem.compile_all(\n    backends=None,\n    verbose=False,\n    **kwargs,\n)\nCompile both deterministic and diffusion for all backends.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[Backend, Dict[str, float]]\nNested dict: backend → {‘deterministic’: time, ‘diffusion’: time}\n\n\n\n\n\n\ncompile_diffusion\nsystems.base.core.DiscreteStochasticSystem.compile_diffusion(\n    backends=None,\n    verbose=False,\n    **kwargs,\n)\nPre-compile diffusion functions for specified backends.\n\n\ndepends_on_control\nsystems.base.core.DiscreteStochasticSystem.depends_on_control()\nCheck if diffusion depends on control inputs.\n\n\ndepends_on_state\nsystems.base.core.DiscreteStochasticSystem.depends_on_state()\nCheck if diffusion depends on state variables.\n\n\ndepends_on_time\nsystems.base.core.DiscreteStochasticSystem.depends_on_time()\nCheck if diffusion depends on time (always False for time-invariant).\n\n\ndiffusion\nsystems.base.core.DiscreteStochasticSystem.diffusion(\n    x,\n    u=None,\n    k=0,\n    backend=None,\n)\nEvaluate diffusion term g(x[k], u[k]).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState vector (nx,) or batched (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl vector (nu,) or batched (batch, nu) None for autonomous systems\nNone\n\n\nk\nint\nTime step (currently ignored for time-invariant systems)\n0\n\n\nbackend\nOptional[Backend]\nBackend selection (None = auto-detect)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nDiffusion matrix g(x, u), shape (nx, nw) or (batch, nx, nw)\n\n\n\n\n\nExamples\nControlled system:\n&gt;&gt;&gt; g = system.diffusion(np.array([2.0]), np.array([0.0]))\n&gt;&gt;&gt; print(g.shape)\n(1, 1)\nAutonomous system:\n&gt;&gt;&gt; g = system.diffusion(np.array([2.0]))  # u=None\n&gt;&gt;&gt; print(g.shape)\n(1, 1)\nFor additive noise (precompute once):\n&gt;&gt;&gt; if system.is_additive_noise():\n...     G = system.get_constant_noise()  # Precompute once\n...     # Use G directly in simulation - huge speedup!\n\n\n\nget_constant_noise\nsystems.base.core.DiscreteStochasticSystem.get_constant_noise(backend='numpy')\nGet constant noise matrix for additive noise.\nFor additive noise, diffusion is constant and can be precomputed once for significant performance gains.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nBackend for array type\n'numpy'\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nConstant diffusion matrix (nx, nw)\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf noise is not additive\n\n\n\n\n\nExamples\n&gt;&gt;&gt; if system.is_additive_noise():\n...     G = system.get_constant_noise('numpy')\n...     print(G)\n...     [[0.3]]\n...\n...     # Simulation loop with precomputed noise\n...     for k in range(1000):\n...         w_k = np.random.randn(nw)\n...         x_next = system(x, u) + G @ w_k\n...         x = x_next\n\n\n\nget_info\nsystems.base.core.DiscreteStochasticSystem.get_info()\nGet comprehensive system information.\n\n\nget_noise_type\nsystems.base.core.DiscreteStochasticSystem.get_noise_type()\nGet classified noise type.\n\n\nget_optimization_opportunities\nsystems.base.core.DiscreteStochasticSystem.get_optimization_opportunities()\nGet optimization opportunities based on noise structure.\n\n\nget_sde_type\nsystems.base.core.DiscreteStochasticSystem.get_sde_type()\nGet SDE interpretation type (Itô convention for discrete).\n\n\nis_additive_noise\nsystems.base.core.DiscreteStochasticSystem.is_additive_noise()\nCheck if noise is additive (constant, state-independent).\n\n\nis_diagonal_noise\nsystems.base.core.DiscreteStochasticSystem.is_diagonal_noise()\nCheck if noise sources are independent (diagonal diffusion).\n\n\nis_multiplicative_noise\nsystems.base.core.DiscreteStochasticSystem.is_multiplicative_noise()\nCheck if noise is multiplicative (state-dependent).\n\n\nis_pure_diffusion\nsystems.base.core.DiscreteStochasticSystem.is_pure_diffusion()\nCheck if system is pure diffusion (zero deterministic part).\n\n\nis_scalar_noise\nsystems.base.core.DiscreteStochasticSystem.is_scalar_noise()\nCheck if system has single noise source.\n\n\nlinearize\nsystems.base.core.DiscreteStochasticSystem.linearize(x_eq, u_eq=None)\nCompute linearization including diffusion: Ad = ∂f/∂x, Bd = ∂f/∂u, Gd = g(x_eq).\nFor stochastic systems, linearization returns three matrices: - Ad: State Jacobian ∂f/∂x - Bd: Control Jacobian ∂f/∂u - Gd: Diffusion matrix evaluated at equilibrium g(x_eq, u_eq)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control (nu,)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[ArrayLike, ArrayLike, ArrayLike]\n(Ad, Bd, Gd) where: - Ad: State Jacobian (nx, nx) - Bd: Control Jacobian (nx, nu) - Gd: Diffusion matrix (nx, nw)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x_eq = np.zeros(2)\n&gt;&gt;&gt; u_eq = np.zeros(1)\n&gt;&gt;&gt; Ad, Bd, Gd = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check discrete stability: |λ| &lt; 1\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(Ad)\n&gt;&gt;&gt; is_stable = np.all(np.abs(eigenvalues) &lt; 1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stochastic covariance propagation\n&gt;&gt;&gt; # P[k+1] = Ad @ P[k] @ Ad.T + Gd @ Gd.T\n\n\n\nprint_equations\nsystems.base.core.DiscreteStochasticSystem.print_equations(simplify=True)\nPrint symbolic equations using discrete-time stochastic notation.\nOverrides parent to show both deterministic and stochastic parts.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nIf True, simplify expressions before printing\nTrue\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.print_equations()\n======================================================================\nDiscreteOU (Discrete-Time Stochastic, dt=0.1)\n======================================================================\nState Variables: [x]\nControl Variables: [u]\nDimensions: nx=1, nu=1, nw=1\nNoise Type: additive\nDeterministic Part: f(x[k], u[k]) f_0 = 0.9*x + u\nStochastic Part: g(x[k], u[k]) g_0 = [0.3]\nFull Dynamics: x[k+1] = f(x[k], u[k]) + g(x[k], u[k]) * w[k] where w[k] ~ N(0, I) ======================================================================\n\n\n\nprint_stochastic_info\nsystems.base.core.DiscreteStochasticSystem.print_stochastic_info()\nPrint formatted stochastic system information.\n\n\nreset_all_caches\nsystems.base.core.DiscreteStochasticSystem.reset_all_caches(backends=None)\nClear both deterministic and diffusion caches.\n\n\nreset_diffusion_cache\nsystems.base.core.DiscreteStochasticSystem.reset_diffusion_cache(backends=None)\nClear cached diffusion functions.\n\n\nsimulate_stochastic\nsystems.base.core.DiscreteStochasticSystem.simulate_stochastic(\n    x0,\n    u_sequence=None,\n    n_steps=100,\n    n_paths=1,\n    seed=None,\n    **kwargs,\n)\nSimulate stochastic discrete system with optional Monte Carlo.\nPerforms either single-path or Monte Carlo simulation of the stochastic difference equation.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_sequence\nOptional[Union[ControlVector, DiscreteControlInput]]\nControl sequence (same format as parent simulate())\nNone\n\n\nn_steps\nint\nNumber of simulation steps\n100\n\n\nn_paths\nint\nNumber of Monte Carlo paths (default: 1)\n1\n\n\nseed\nOptional[int]\nRandom seed for reproducibility\nNone\n\n\n**kwargs\n\nAdditional simulation options\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteSimulationResult\nTypedDict containing: - states: State trajectories - Single path: (n_steps+1, nx) - Multiple paths: (n_paths, n_steps+1, nx) - controls: Control sequence (n_steps, nu) - time_steps: [0, 1, …, n_steps] - dt: Sampling period - metadata: Additional info including: - n_paths: Number of paths - noise_type: Detected noise type - seed: Random seed used\n\n\n\n\n\nExamples\nSingle trajectory:\n&gt;&gt;&gt; result = system.simulate_stochastic(\n...     x0=np.array([1.0]),\n...     u_sequence=None,\n...     n_steps=1000,\n...     seed=42\n... )\n&gt;&gt;&gt; plt.plot(result['time_steps'], result['states'][:, 0])\nMonte Carlo simulation:\n&gt;&gt;&gt; result = system.simulate_stochastic(\n...     x0=np.array([1.0]),\n...     u_sequence=None,\n...     n_steps=1000,\n...     n_paths=100,\n...     seed=42\n... )\n&gt;&gt;&gt; # result['states'] has shape (100, 1001, 1)\n&gt;&gt;&gt; mean_traj = result['states'].mean(axis=0)\n&gt;&gt;&gt; std_traj = result['states'].std(axis=0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; plt.plot(result['time_steps'], mean_traj[:, 0], label='Mean')\n&gt;&gt;&gt; plt.fill_between(\n...     result['time_steps'],\n...     mean_traj[:, 0] - std_traj[:, 0],\n...     mean_traj[:, 0] + std_traj[:, 0],\n...     alpha=0.3\n... )\nState feedback with stochastic dynamics:\n&gt;&gt;&gt; def policy(x, k):\n...     return -0.5 * x\n&gt;&gt;&gt; result = system.simulate_stochastic(\n...     x0=np.array([1.0]),\n...     u_sequence=policy,\n...     n_steps=1000\n... )\n\n\n\nstep_stochastic\nsystems.base.core.DiscreteStochasticSystem.step_stochastic(\n    x,\n    u=None,\n    w=None,\n    k=0,\n    backend=None,\n)\nCompute full stochastic step: x[k+1] = f(x[k], u[k]) + g(x[k], u[k]) * w[k].\nThis is the primary method for stochastic simulation, computing the complete state update including both deterministic and stochastic components.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,) or batched (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl (nu,) or batched (batch, nu), None for autonomous\nNone\n\n\nw\nOptional[ArrayLike]\nStandard normal noise (nw,) or batched (batch, nw) If None, generated automatically\nNone\n\n\nk\nint\nTime step (currently ignored for time-invariant systems)\n0\n\n\nbackend\nOptional[Backend]\nBackend selection (None = auto-detect)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x[k+1], same shape and backend as input\n\n\n\n\n\nExamples\nAutomatic noise generation:\n&gt;&gt;&gt; x_next = system.step_stochastic(x_k, u_k)\nCustom noise (for reproducibility):\n&gt;&gt;&gt; w_k = np.random.randn(system.nw)\n&gt;&gt;&gt; x_next = system.step_stochastic(x_k, u_k, w=w_k)\nDeterministic (w=0):\n&gt;&gt;&gt; x_next = system.step_stochastic(x_k, u_k, w=np.zeros(system.nw))\nBatched inputs:\n&gt;&gt;&gt; x_batch = np.random.randn(100, 2)  # 100 states\n&gt;&gt;&gt; u_batch = np.random.randn(100, 1)  # 100 controls\n&gt;&gt;&gt; w_batch = np.random.randn(100, 1)  # 100 noise samples\n&gt;&gt;&gt; x_next_batch = system.step_stochastic(x_batch, u_batch, w_batch)\n\n\nNotes\nFor batched inputs: x: (batch, nx) u: (batch, nu) or None w: (batch, nw) or None → x_next: (batch, nx)\nIf w is None, noise is generated per sample in batch.\nWith DiffusionHandler batching support: - Additive noise: g returns (nx, nw) - constant - Multiplicative noise: g returns (batch, nx, nw) - state-dependent\nThe function automatically handles both cases efficiently."
  },
  {
    "objectID": "api/types.core.OutputVector.html",
    "href": "api/types.core.OutputVector.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.OutputVector.html#examples",
    "href": "api/types.core.OutputVector.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Full state observation\n&gt;&gt;&gt; y: OutputVector = np.array([1.0, 0.0, 0.5])  # y = x\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Partial observation (position only)\n&gt;&gt;&gt; y_partial: OutputVector = np.array([1.0])  # y = C*x where C = [1, 0, 0]"
  },
  {
    "objectID": "api/types.linearization.StateJacobian.html",
    "href": "api/types.linearization.StateJacobian.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.StateJacobian.html#examples",
    "href": "api/types.linearization.StateJacobian.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Ac: StateJacobian = system.state_jacobian(x_eq, u_eq)\n&gt;&gt;&gt; # For pendulum: Ac = [[0, 1], [-g/L*cos(θ), -b]]"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#parameters",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\nIntegration method name (normalized or original)\nrequired"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#returns",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if method uses fixed time steps, False if adaptive"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#classification-rules",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#classification-rules",
    "title": "",
    "section": "Classification Rules",
    "text": "Classification Rules\n\nDeterministic fixed-step: euler, midpoint, rk4, heun → True\nDeterministic adaptive: RK45, LSODA, dopri5, tsit5, etc. → False\nSDE fixed-step: Most SDE methods (EM, euler_maruyama, etc.) → True\nSDE adaptive: Rare cases (LambaEM, AutoEM, adaptive_heun) → False\nUnknown methods: Conservative default → False (more flexible)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#notes",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nFixed-step methods take exactly n_steps integrations of size dt\nAdaptive methods adjust step size internally for accuracy/efficiency\nMost SDE methods are fixed-step (adaptive SDE solvers are rare)\nUnknown methods default to False (adaptive mode works for both cases)\nUsed to auto-select DiscretizationMode.FIXED_STEP vs DENSE_OUTPUT"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#design-decision-conservative-default",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#design-decision-conservative-default",
    "title": "",
    "section": "Design Decision: Conservative Default",
    "text": "Design Decision: Conservative Default\nWhen method is unknown, returns False (assume adaptive) because: - DENSE_OUTPUT mode works for both fixed and adaptive methods - FIXED_STEP mode ONLY works for fixed-step methods - Better to be conservative than raise unexpected errors"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#examples",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Deterministic fixed-step methods\n&gt;&gt;&gt; is_fixed_step('euler')\nTrue\n&gt;&gt;&gt; is_fixed_step('rk4')\nTrue\n&gt;&gt;&gt; is_fixed_step('heun')\nTrue\n&gt;&gt;&gt; # Deterministic adaptive methods\n&gt;&gt;&gt; is_fixed_step('RK45')\nFalse\n&gt;&gt;&gt; is_fixed_step('LSODA')\nFalse\n&gt;&gt;&gt; is_fixed_step('dopri5')  # PyTorch\nFalse\n&gt;&gt;&gt; is_fixed_step('tsit5')  # JAX\nFalse\n&gt;&gt;&gt; # SDE methods (mostly fixed-step)\n&gt;&gt;&gt; is_fixed_step('euler_maruyama')\nTrue\n&gt;&gt;&gt; is_fixed_step('EM')  # NumPy/Julia\nTrue\n&gt;&gt;&gt; is_fixed_step('milstein')\nTrue\n&gt;&gt;&gt; is_fixed_step('SRIW1')  # Julia SDE\nTrue\n&gt;&gt;&gt; # Rare adaptive SDE methods\n&gt;&gt;&gt; is_fixed_step('LambaEM')  # Julia adaptive\nFalse\n&gt;&gt;&gt; is_fixed_step('AutoEM')  # Julia adaptive\nFalse\n&gt;&gt;&gt; is_fixed_step('adaptive_heun')  # PyTorch\nFalse\n&gt;&gt;&gt; is_fixed_step('reversible_heun')  # Can be adaptive\nFalse\n&gt;&gt;&gt; # Unknown method (conservative default)\n&gt;&gt;&gt; is_fixed_step('my_custom_method')\nFalse"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#notes-on-ambiguous-methods",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#notes-on-ambiguous-methods",
    "title": "",
    "section": "Notes on Ambiguous Methods",
    "text": "Notes on Ambiguous Methods\nSome methods appear in both deterministic and SDE contexts:\n\n‘euler’: In both DETERMINISTIC_FIXED_STEP and SDE_FIXED_STEP Classification: Fixed-step (True) for both contexts\n‘midpoint’: In both DETERMINISTIC_FIXED_STEP and SDE_FIXED_STEP Classification: Fixed-step (True) for both contexts\n‘reversible_heun’: In both SDE_FIXED_STEP and SDE_ADAPTIVE Classification: Adaptive (False) - prioritizes adaptive classification since it CAN be used in adaptive mode\n\nThe ambiguity is resolved at runtime by the system type (stochastic vs deterministic) passed to validate_method()."
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_fixed_step.html#see-also",
    "href": "api/systems.base.numerical_integration.is_fixed_step.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nis_sde_method : Check if method is for stochastic systems normalize_method_name : Normalize method names across backends"
  },
  {
    "objectID": "api/control.analyze_stability.html",
    "href": "api/control.analyze_stability.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.analyze_stability.html#examples",
    "href": "api/control.analyze_stability.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Stable continuous system\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; stability = analyze_stability(A, system_type='continuous')\n&gt;&gt;&gt; print(stability['is_stable'])  # True\n&gt;&gt;&gt; print(stability['eigenvalues'])  # [-1, -2]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Unstable continuous system\n&gt;&gt;&gt; A_unstable = np.array([[1, 1], [0, 1]])\n&gt;&gt;&gt; stability = analyze_stability(A_unstable, system_type='continuous')\n&gt;&gt;&gt; print(stability['is_unstable'])  # True\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stable discrete system\n&gt;&gt;&gt; Ad = np.array([[0.9, 0.1], [0, 0.8]])\n&gt;&gt;&gt; stability = analyze_stability(Ad, system_type='discrete')\n&gt;&gt;&gt; print(stability['is_stable'])  # True\n&gt;&gt;&gt; print(stability['spectral_radius'])  # 0.9\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Marginally stable (on boundary)\n&gt;&gt;&gt; A_marginal = np.array([[0, 1], [-1, 0]])  # Pure oscillation\n&gt;&gt;&gt; stability = analyze_stability(A_marginal, system_type='continuous')\n&gt;&gt;&gt; print(stability['is_marginally_stable'])  # True"
  },
  {
    "objectID": "api/control.analyze_stability.html#notes",
    "href": "api/control.analyze_stability.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nMarginal stability: Eigenvalues on stability boundary\n\nContinuous: Re(λ) = 0 (imaginary axis)\nDiscrete: |λ| = 1 (unit circle)\n\nAsymptotic stability: All trajectories converge to zero\nLyapunov stability: Bounded trajectories (includes marginal)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nThe stochastic Lorenz equations:\ndx = σ·(y - x)·dt + σ_x·dW_x\ndy = (x·(ρ - z) - y)·dt + σ_y·dW_y\ndz = (x·y - β·z)·dt + σ_z·dW_z\nwhere: - x: Convection intensity (horizontal circulation) [dimensionless] - y: Horizontal temperature variation [dimensionless] - z: Vertical temperature variation [dimensionless] - σ: Prandtl number (fluid property, typically 10) - ρ: Rayleigh number (driving force, typically 28 for chaos) - β: Geometric factor (aspect ratio, typically 8/3) - σ_x, σ_y, σ_z: Noise intensities [1/√s] - W_x, W_y, W_z: Independent Wiener processes\nDeterministic Part: Classic Lorenz dynamics - creates strange attractor and chaos.\nStochastic Part: Additive noise representing: - Unresolved turbulent fluctuations - Measurement errors - Model uncertainty - External forcing variability"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nOriginal Context: Rayleigh-Bénard Convection\nFluid layer heated from below: - x: Convection roll intensity - y: Temperature difference (horizontal) - z: Temperature difference (vertical)\nParameters: - σ = 10: Prandtl number (momentum/thermal diffusivity) - ρ = 28: Rayleigh number (buoyancy/viscosity) - β = 8/3: Geometry (cell aspect ratio)\nAtmospheric Interpretation: - x: Zonal wind component - y: Meridional wind component - z: Temperature deviation\nNoise Sources: - Turbulent eddies below grid scale - Latent heat release variations - Radiation fluctuations - Measurement uncertainty"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#deterministic-chaos-primer",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#deterministic-chaos-primer",
    "title": "",
    "section": "Deterministic Chaos Primer",
    "text": "Deterministic Chaos Primer\nStrange Attractor:\nFor σ=10, ρ=28, β=8/3: - Butterfly-shaped attractor in 3D - Fractal dimension: D ≈ 2.06 - Trajectories never repeat - Sensitive to initial conditions\nLyapunov Exponents: - λ₁ ≈ +0.9: Positive (chaos!) - λ₂ ≈ 0: Zero (volume-preserving direction) - λ₃ ≈ -14.6: Negative (dissipation)\nPredictability Time: - Doubling time: τ ≈ 1/λ₁ ≈ 1.1 Lorenz time units - After ~10 doubling times: Completely unpredictable\nEquilibria: - Origin (0,0,0): Unstable for ρ &gt; 1 - C± = (±√(β(ρ-1)), ±√(β(ρ-1)), ρ-1): Unstable for ρ &gt; ρ_crit\nAll unstable → trajectories on attractor."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#effect-of-noise-on-chaos",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#effect-of-noise-on-chaos",
    "title": "",
    "section": "Effect of Noise on Chaos",
    "text": "Effect of Noise on Chaos\nSmall Noise (σ_noise &lt;&lt; 1): - Attractor recognizable (slightly blurred) - Lyapunov exponent nearly unchanged - Chaos dominates, noise is perturbation\nMedium Noise (σ_noise ~ 1): - Attractor significantly blurred - Lyapunov exponent increases - Chaos and noise comparable\nLarge Noise (σ_noise &gt;&gt; 1): - Attractor destroyed (fills volume) - Noise dominates dynamics - Chaos irrelevant (randomness wins)\nCrossover Scale: When σ_noise ~ √λ_max, chaos and noise equally important.\nFractal Dimension: Noise increases effective dimension: - Deterministic: D ≈ 2.06 (fractal) - With noise: D → 3 (fills space)\nPredictability: Combined error growth: δ²(t) = δ_0²·exp(2λt) + (σ²/λ)·(exp(2λt) - 1)\nBoth exponential growth (chaos) and accumulation (noise)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#key-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#key-properties",
    "title": "",
    "section": "Key Properties",
    "text": "Key Properties\n1. Nonlinearity: Quadratic terms: x·y, x·z create complex dynamics.\n2. Chaos (Deterministic Part): Positive Lyapunov exponent → sensitive dependence.\n3. Strange Attractor: Fractal structure (deterministic) blurred by noise.\n4. Non-Stationary Locally: On attractor, system never settles.\n5. Stationary Globally: Probability distribution on attractor converges (Fokker-Planck).\n6. Three-Dimensional: Minimum dimension for chaos (Poincaré-Bendixson theorem).\n7. Additive Noise (This Implementation): Constant diffusion coefficients (simplest model)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nNo Closed-Form Solution: Even deterministic Lorenz has no analytical solution. Must integrate numerically.\nFokker-Planck Equation:\nProbability density p(x,y,z,t) satisfies: ∂p/∂t = -∇·(f·p) + (1/2)·Σᵢ ∂²((σᵢ²)·p)/∂xᵢ²\nFor stationary distribution: ∂p/∂t = 0\nStationary Distribution: Concentrated on noise-perturbed attractor: - No simple analytical form - Compute via long-time simulation (ergodic hypothesis)\nMoments: No simple analytical expressions. Compute empirically from ensemble or long trajectory."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X = [x, y, z] ∈ ℝ³ - Unbounded (but attracted to finite region) - Chaotic wandering on strange attractor - Noise perturbs trajectories\nControl: u (optional, not standard) - Can add control to stabilize UPOs - Chaos control applications\nNoise: W = [W_x, W_y, W_z] ∈ ℝ³ - Three independent Wiener processes - Models unresolved fluctuations"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nPrandtl number (deterministic parameter) - Controls x-y coupling strength - Standard: 10\n10.0\n\n\nrho\nfloat\nRayleigh number (deterministic parameter) - Controls bifurcations - ρ &lt; 1: Stable origin - 1 &lt; ρ &lt; 24.74: Stable C± - ρ &gt; 24.74: Chaos - Standard: 28 (chaotic regime)\n28.0\n\n\nbeta\nfloat\nGeometric factor (deterministic parameter) - Standard: 8/3 ≈ 2.667\n8/3\n\n\nsigma_x\nfloat\nNoise intensity for x [1/√s]\n0.1\n\n\nsigma_y\nfloat\nNoise intensity for y [1/√s]\n0.1\n\n\nsigma_z\nfloat\nNoise intensity for z [1/√s]\n0.1"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR (quadratic)\nNoise Type: ADDITIVE (constant)\nSDE Type: Itô\nNoise Dimension: nw = 3\nChaotic: Yes (deterministic part)\nStationary: Yes (global, on attractor)\nErgodic: Yes (time = ensemble averages)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Meteorology: - Weather prediction limits - Ensemble forecasting - Data assimilation (EnKF, 4D-Var)\n2. Climate Science: - Chaos vs variability - Tipping points under noise - Extreme events\n3. Chaos Theory: - Noise effects on strange attractors - Modified Lyapunov exponents - Stochastic bifurcations\n4. Signal Processing: - Chaotic time series analysis - Noise reduction - Chaos vs noise discrimination\n5. Nonlinear Filtering: - Benchmark for EnKF, particle filters - Chaotic dynamics challenge\n6. Control: - Chaos control under noise - Targeting unstable periodic orbits - Synchronization"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nRecommended: - Euler-Maruyama: dt = 0.001-0.01 - Smaller than deterministic (chaos + noise) - Check attractor structure\nValidation: - Small noise: Should resemble Lorenz attractor - Statistics: Mean, variance converge - Lyapunov: Positive λ₁ (chaos indicator)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#monte-carlo-analysis",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#monte-carlo-analysis",
    "title": "",
    "section": "Monte Carlo Analysis",
    "text": "Monte Carlo Analysis\nEnsemble Methods:\nRun N = 100-1,000 trajectories: - Mean trajectory (climbs to attractor) - Spread on attractor - Long-time statistics\nAttractor Visualization: - 3D scatter plot of all trajectories - Should show butterfly shape (if noise small)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#comparison-with-deterministic",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#comparison-with-deterministic",
    "title": "",
    "section": "Comparison with Deterministic",
    "text": "Comparison with Deterministic\nDeterministic Lorenz: - Pure chaos (no external randomness) - Clean strange attractor - Exponential divergence only\nStochastic Lorenz: - Chaos + noise combined - Blurred attractor - Exponential + diffusive error growth\nWhen Stochastic Needed: - Real data has noise (always) - Predictability limits more realistic - Data assimilation applications"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nAdditive noise only\nConstant noise (not state-dependent)\nIndependent noise (no correlation)\nNo control (in standard form)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nMultiplicative noise: σᵢ(X)\nColored noise: OU driving processes\nCoupled Lorenz systems\nControlled Lorenz\nStochastic Rössler system"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nLorenz : Deterministic version"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.StochasticLorenz.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_attractor_size\nEstimate typical attractor size (order of magnitude).\n\n\ndefine_system\nDefine stochastic Lorenz system dynamics.\n\n\nget_noise_intensities\nGet noise intensity parameters.\n\n\nsetup_equilibria\nSet up equilibrium points (deterministic part).\n\n\n\n\ncompute_attractor_size\nsystems.builtin.stochastic.continuous.StochasticLorenz.compute_attractor_size()\nEstimate typical attractor size (order of magnitude).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nApproximate attractor diameter\n\n\n\n\n\nNotes\nRough estimate based on C± equilibria distance from origin.\n\n\nExamples\n&gt;&gt;&gt; lorenz = StochasticLorenz(rho=28.0, beta=8/3)\n&gt;&gt;&gt; size = lorenz.compute_attractor_size()\n&gt;&gt;&gt; print(f\"Attractor size: ~{size:.1f}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.StochasticLorenz.define_system(\n    sigma=10.0,\n    rho=28.0,\n    beta=8.0 / 3.0,\n    sigma_x=0.1,\n    sigma_y=0.1,\n    sigma_z=0.1,\n)\nDefine stochastic Lorenz system dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nPrandtl number (deterministic parameter) - Controls x-y coupling - Standard: 10 - Ratio of momentum/thermal diffusivity\n10.0\n\n\nrho\nfloat\nRayleigh number (deterministic parameter) - Controls convection strength - ρ &lt; 1: Stable origin (no convection) - 1 &lt; ρ &lt; 24.74: Stable C± (steady convection) - ρ &gt; 24.74: Chaos (turbulent convection) - Standard: 28 (chaotic regime)\n28.0\n\n\nbeta\nfloat\nGeometric factor (deterministic parameter) - Standard: 8/3 ≈ 2.667 - Related to cell aspect ratio\n8/3\n\n\nsigma_x\nfloat\nNoise intensity for x [1/√s] - Unresolved turbulence - Typical: 0.01-1.0\n0.1\n\n\nsigma_y\nfloat\nNoise intensity for y [1/√s]\n0.1\n\n\nsigma_z\nfloat\nNoise intensity for z [1/√s]\n0.1\n\n\n\n\n\nNotes\nParameter Regimes:\nρ (Rayleigh Number): - ρ &lt; 1: No convection (stable origin) - 1 &lt; ρ &lt; 13.93: Steady convection (stable C±) - 13.93 &lt; ρ &lt; 24.06: Transient chaos - 24.74 &lt; ρ &lt; 30: Strange attractor (standard) - ρ &gt; 30: Different attractor structures\nClassic Chaotic: σ = 10, ρ = 28, β = 8/3\nNoise Intensity Guidelines:\nRelative to chaos strength: - σ_noise &lt; 0.1: Noise negligible (chaos dominates) - σ_noise ~ 0.1-1.0: Noise perturbs chaos (typical) - σ_noise &gt; 1.0: Noise dominates (chaos obscured)\nPhysical Interpretation:\nFor atmospheric application: - σ_noise represents unresolved processes - Should be calibrated from data (residuals) - Typical: 0.1-0.5 for simplified models\nNoise Correlation:\nCurrently: Independent noise on each variable.\nIn reality: May be correlated (common weather systems). Extension: Use full 3×3 covariance matrix.\nChaos Indicators:\nCheck if deterministic part is chaotic: - Compute Lyapunov exponents from noise-free simulation - λ₁ &gt; 0 indicates chaos - For ρ = 28: λ₁ ≈ 0.9 (strongly chaotic)\nNoise Impact on Lyapunov:\nNoise increases apparent Lyapunov exponent: λ_apparent ≈ λ_det + σ²/(2·scale²)\nwhere scale is attractor size.\n\n\n\nget_noise_intensities\nsystems.builtin.stochastic.continuous.StochasticLorenz.get_noise_intensities()\nGet noise intensity parameters.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{‘sigma_x’: …, ‘sigma_y’: …, ‘sigma_z’: …}\n\n\n\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.continuous.StochasticLorenz.setup_equilibria()\nSet up equilibrium points (deterministic part).\nNote: All equilibria are unstable in chaotic regime (ρ=28). Trajectories never settle but wander on attractor."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html",
    "href": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nTwo masses connected by springs to fixed walls and to each other, with an additional rotational degree of freedom that couples to the second mass.\nThe system consists of: - Two point masses (m₁, m₂) that can move horizontally - Springs connecting each mass to ground (k₁, k₂) - Coupling spring between the masses (k_coupling) - Viscous dampers on both masses (shared coefficient c) - Rotational element (moment of inertia J) coupled to mass 2"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x₁, x₂, v₁, v₂, θ] Position coordinates: - x₁: Position of mass 1 [m] - x₂: Position of mass 2 [m] - θ (theta): Rotational angle [rad]\nVelocity coordinates:\n- v₁: Velocity of mass 1 [m/s]\n- v₂: Velocity of mass 2 [m/s]\nControl: u = [u₁, u₂] - u₁: Force applied to mass 1 [N] - u₂: Combined force/torque applied to mass 2 and rotational element\nOutput: y = [x₁, x₂, θ] - Measures positions of both masses and rotational angle"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe equations of motion are:\nMass 1 (standard spring-mass-damper): dx₁/dt = v₁ dv₁/dt = -(k₁/m₁)x₁ - (k_c/m₁)(x₁ - x₂) - (c/m₁)v₁ + u₁/m₁\nMass 2 (coupled to rotation): dx₂/dt = v₂ dv₂/dt = -(k₂/m₂)x₂ - (k_c/m₂)(x₂ - x₁) - (c/m₂)v₂ + sin(θ)/m₂ + u₂/m₂\nRotational element: dθ/dt = -θ/J - x₂/J + u₂/(2J)\nPhysical interpretation: - Springs create restoring forces proportional to displacement - Coupling spring connects the two masses - Dampers dissipate energy proportionally to velocity - Rotation affects mass 2 through sin(θ) term (nonlinear coupling) - Control u₂ affects both mass 2 translation and rotation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm1 : float, default=1.0 Mass of first oscillator [kg]. Larger m₁ → slower response to forces. m2 : float, default=0.5 Mass of second oscillator [kg]. Typically different from m₁ to create interesting modal behavior. k1 : float, default=2.0 Spring stiffness connecting mass 1 to ground [N/m]. Higher k₁ → higher natural frequency for mass 1. k2 : float, default=1.0 Spring stiffness connecting mass 2 to ground [N/m]. k_coupling : float, default=0.5 Coupling spring stiffness between masses [N/m]. Controls strength of interaction between oscillators. Higher k_c → stronger coupling. c : float, default=0.1 Damping coefficient [N·s/m]. Applied to both masses. Higher c → more energy dissipation. J : float, default=0.1 Moment of inertia for rotational element [kg·m²]. Affects rotational response time."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#equilibrium",
    "href": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#equilibrium",
    "title": "",
    "section": "Equilibrium:",
    "text": "Equilibrium:\nOrigin equilibrium (all zeros): x_eq = [0, 0, 0, 0, 0] (masses at rest, no rotation) u_eq = [0, 0] (no external forces)\nThis equilibrium is stable due to spring restoring forces and damping."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.CoupledOscillatorSystem.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nNonlinearChainSystem : Chain of coupled oscillators Manipulator2Link : Another coupled multi-body system"
  },
  {
    "objectID": "api/types.backends.validate_backend.html",
    "href": "api/types.backends.validate_backend.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.validate_backend.html#parameters",
    "href": "api/types.backends.validate_backend.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nstr\nBackend name to validate\nrequired"
  },
  {
    "objectID": "api/types.backends.validate_backend.html#returns",
    "href": "api/types.backends.validate_backend.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nBackend\nValidated backend (typed)"
  },
  {
    "objectID": "api/types.backends.validate_backend.html#raises",
    "href": "api/types.backends.validate_backend.html#raises",
    "title": "",
    "section": "Raises",
    "text": "Raises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf backend is not valid"
  },
  {
    "objectID": "api/types.backends.validate_backend.html#examples",
    "href": "api/types.backends.validate_backend.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; validate_backend('numpy')\n'numpy'\n&gt;&gt;&gt; validate_backend('pytorch')  # ValueError"
  },
  {
    "objectID": "api/types.robustness.TubeMPCResult.html",
    "href": "api/types.robustness.TubeMPCResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.robustness.TubeMPCResult.html#fields",
    "href": "api/types.robustness.TubeMPCResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nnominal_control : ControlSequence Nominal control sequence v (N, nu) feedback_control : GainMatrix Ancillary feedback gain K (nu, nx) actual_control : ControlSequence Applied control u = v + K(x - x̄) (N, nu) nominal_trajectory : StateTrajectory Nominal state trajectory x̄ (N+1, nx) tube_definition : TubeDefinition Robust invariant tube tightened_constraints : ArrayLike Tightened constraints accounting for tube"
  },
  {
    "objectID": "api/types.robustness.TubeMPCResult.html#examples",
    "href": "api/types.robustness.TubeMPCResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Setup tube MPC\n&gt;&gt;&gt; tube_mpc = TubeMPC(\n...     system=A, B,\n...     Q=Q, R=R,\n...     disturbance_bound=0.1,\n...     horizon=20\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Solve at current state\n&gt;&gt;&gt; x_current = np.array([1.0, 0.5])\n&gt;&gt;&gt; result: TubeMPCResult = tube_mpc.solve(x_current)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract control\n&gt;&gt;&gt; v_nom = result['nominal_control'][0]\n&gt;&gt;&gt; K = result['feedback_control']\n&gt;&gt;&gt; x_nom = result['nominal_trajectory'][0]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Actual control with feedback\n&gt;&gt;&gt; u = v_nom + K @ (x_current - x_nom)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Visualize tube\n&gt;&gt;&gt; tube = result['tube_definition']\n&gt;&gt;&gt; center = tube['center_trajectory']\n&gt;&gt;&gt; radii = tube['tube_radii']\n&gt;&gt;&gt;\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(center[:, 0], center[:, 1], 'b-', label='Nominal')\n&gt;&gt;&gt; plt.fill_between(\n...     center[:, 0] - radii,\n...     center[:, 0] + radii,\n...     alpha=0.3, label='Tube'\n... )"
  },
  {
    "objectID": "api/visualization.PhasePortraitPlotter.html",
    "href": "api/visualization.PhasePortraitPlotter.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/visualization.PhasePortraitPlotter.html#attributes",
    "href": "api/visualization.PhasePortraitPlotter.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbackend\nBackend\nDefault computational backend for array conversion\n\n\ndefault_theme\nstr\nDefault plot theme to apply"
  },
  {
    "objectID": "api/visualization.PhasePortraitPlotter.html#examples",
    "href": "api/visualization.PhasePortraitPlotter.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n2D phase portrait:\n&gt;&gt;&gt; plotter = PhasePortraitPlotter()\n&gt;&gt;&gt; x = np.column_stack([np.sin(t), np.cos(t)])  # (T, 2)\n&gt;&gt;&gt; fig = plotter.plot_2d(x, state_names=('sin', 'cos'))\n&gt;&gt;&gt; fig.show()\nWith vector field and equilibrium:\n&gt;&gt;&gt; def f(x1, x2):\n...     return np.array([x2, -x1 - 0.1*x2])\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_2d(\n...     x,\n...     vector_field=f,\n...     equilibria=[np.zeros(2)],\n...     show_direction=True,\n...     theme='publication'\n... )\n3D phase portrait (Lorenz attractor):\n&gt;&gt;&gt; fig = plotter.plot_3d(\n...     x_lorenz,  # (T, 3)\n...     state_names=('x', 'y', 'z'),\n...     color_scheme='tableau',\n...     theme='dark'\n... )"
  },
  {
    "objectID": "api/visualization.PhasePortraitPlotter.html#methods",
    "href": "api/visualization.PhasePortraitPlotter.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nlist_available_color_schemes\nList available color schemes.\n\n\nlist_available_themes\nList available plot themes.\n\n\nplot_2d\nCreate 2D phase portrait (x₂ vs x₁).\n\n\nplot_3d\nCreate 3D phase portrait.\n\n\nplot_limit_cycle\nVisualize limit cycle (periodic orbit).\n\n\n\n\nlist_available_color_schemes\nvisualization.PhasePortraitPlotter.list_available_color_schemes()\nList available color schemes.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nAvailable color scheme names\n\n\n\n\n\nExamples\n&gt;&gt;&gt; schemes = PhasePortraitPlotter.list_available_color_schemes()\n&gt;&gt;&gt; print(schemes)\n['plotly', 'd3', 'colorblind_safe', 'tableau', ...]\n\n\n\nlist_available_themes\nvisualization.PhasePortraitPlotter.list_available_themes()\nList available plot themes.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nAvailable theme names\n\n\n\n\n\nExamples\n&gt;&gt;&gt; themes = PhasePortraitPlotter.list_available_themes()\n&gt;&gt;&gt; print(themes)\n['default', 'publication', 'dark', 'presentation']\n\n\n\nplot_2d\nvisualization.PhasePortraitPlotter.plot_2d(\n    x,\n    state_names=('x₁', 'x₂'),\n    trajectory_names=None,\n    show_direction=True,\n    show_start_end=True,\n    vector_field=None,\n    equilibria=None,\n    title='2D Phase Portrait',\n    color_scheme='plotly',\n    theme=None,\n    **kwargs,\n)\nCreate 2D phase portrait (x₂ vs x₁).\nPlots trajectory through 2D state space with optional vector field overlay and equilibrium point markers.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState trajectory, shape (T, 2) or (n_batch, T, 2) Must be 2-dimensional state\nrequired\n\n\nstate_names\nTuple[str, str]\nNames for horizontal and vertical axes Default: (‘x₁’, ‘x₂’)\n('x₁', 'x₂')\n\n\ntrajectory_names\nOptional[List[str]]\nCustom names for each trajectory (for batched trajectories) If None, uses “Trajectory 1”, “Trajectory 2”, etc. Length must equal number of batches\nNone\n\n\nshow_direction\nbool\nIf True, add arrows showing trajectory direction\nTrue\n\n\nshow_start_end\nbool\nIf True, mark initial and final points\nTrue\n\n\nvector_field\nOptional[Callable]\nFunction f(x1, x2) -&gt; [dx1, dx2] for vector field If provided, overlays arrow field showing dynamics\nNone\n\n\nequilibria\nOptional[List[np.ndarray]]\nList of equilibrium points to mark, each shape (2,)\nNone\n\n\ntitle\nstr\nPlot title\n'2D Phase Portrait'\n\n\ncolor_scheme\nstr\nColor scheme name Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, ‘sequential_blue’, ‘diverging_red_blue’, etc. Default: ‘plotly’\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional customization arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nPlotly figure object\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Simple phase portrait\n&gt;&gt;&gt; t = np.linspace(0, 10, 100)\n&gt;&gt;&gt; x = np.column_stack([np.sin(t), np.cos(t)])\n&gt;&gt;&gt; fig = plotter.plot_2d(x, state_names=('Position', 'Velocity'))\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With vector field (pendulum) and publication theme\n&gt;&gt;&gt; def pendulum_dynamics(x1, x2):\n...     return np.array([x2, -np.sin(x1) - 0.1*x2])\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = plotter.plot_2d(\n...     x,\n...     vector_field=pendulum_dynamics,\n...     equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n...     show_direction=True,\n...     color_scheme='colorblind_safe',\n...     theme='publication'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Batched trajectories (multiple initial conditions)\n&gt;&gt;&gt; x_batch = np.random.randn(5, 100, 2)\n&gt;&gt;&gt; fig = plotter.plot_2d(\n...     x_batch,\n...     trajectory_names=['IC 1', 'IC 2', 'IC 3', 'IC 4', 'IC 5'],\n...     theme='dark'\n... )\n\n\nNotes\n\nAutomatically handles batched trajectories\nVector field computed on grid if provided\nStart point: green circle, End point: red square\nDirection arrows added at regular intervals\n\n\n\n\nplot_3d\nvisualization.PhasePortraitPlotter.plot_3d(\n    x,\n    state_names=('x₁', 'x₂', 'x₃'),\n    trajectory_names=None,\n    show_direction=True,\n    show_start_end=True,\n    title='3D Phase Portrait',\n    color_scheme='plotly',\n    direction_colorscale='Viridis',\n    theme=None,\n    **kwargs,\n)\nCreate 3D phase portrait.\nPlots trajectory through 3D state space with interactive rotation.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState trajectory, shape (T, 3) or (n_batch, T, 3) Must be 3-dimensional state\nrequired\n\n\nstate_names\nTuple[str, str, str]\nNames for x, y, z axes Default: (‘x₁’, ‘x₂’, ‘x₃’)\n('x₁', 'x₂', 'x₃')\n\n\ntrajectory_names\nOptional[List[str]]\nCustom names for each trajectory (for batched trajectories) If None, uses “Trajectory 1”, “Trajectory 2”, etc. Length must equal number of batches\nNone\n\n\nshow_direction\nbool\nIf True, show temporal direction via line color gradient (single trajectory only)\nTrue\n\n\nshow_start_end\nbool\nIf True, mark initial and final points\nTrue\n\n\ntitle\nstr\nPlot title\n'3D Phase Portrait'\n\n\ncolor_scheme\nstr\nColor scheme name Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, etc. Default: ‘plotly’ Note: Only used for batched trajectories; single trajectories use direction_colorscale\n'plotly'\n\n\ndirection_colorscale\nstr\nColorscale for temporal gradient (single trajectory only) Options: ‘Viridis’, ‘Plasma’, ‘Inferno’, ‘Magma’, ‘Cividis’, ‘Turbo’, ‘Rainbow’, ‘Jet’, ‘Hot’, ‘Cool’, ‘Blues’, ‘Reds’, ‘Greens’, ‘Portland’, ‘Picnic’, ‘Electric’, ‘Blackbody’ Default: ‘Viridis’\n'Viridis'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional customization arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nInteractive 3D Plotly figure\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Lorenz attractor with temporal gradient\n&gt;&gt;&gt; x_lorenz = solve_lorenz(...)  # (T, 3)\n&gt;&gt;&gt; fig = plotter.plot_3d(\n...     x_lorenz,\n...     state_names=('x', 'y', 'z'),\n...     title='Lorenz Attractor',\n...     show_direction=True,\n...     theme='dark'\n... )\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Multiple trajectories with custom names\n&gt;&gt;&gt; x_batch = np.random.randn(3, 1000, 3)\n&gt;&gt;&gt; fig = plotter.plot_3d(\n...     x_batch,\n...     trajectory_names=['Low Energy', 'Medium Energy', 'High Energy'],\n...     color_scheme='colorblind_safe',\n...     theme='publication'\n... )\n\n\nNotes\n\nInteractive: Click and drag to rotate\nScroll to zoom\nSingle trajectory: Line color shows time progression (dark→light)\nBatched trajectories: Each trajectory has distinct solid color\nStart: green sphere, End: red cube\n\n\n\n\nplot_limit_cycle\nvisualization.PhasePortraitPlotter.plot_limit_cycle(\n    x,\n    state_names=('x₁', 'x₂'),\n    trajectory_names=None,\n    period_estimate=None,\n    title='Limit Cycle',\n    color_scheme='plotly',\n    theme=None,\n    **kwargs,\n)\nVisualize limit cycle (periodic orbit).\nHighlights periodic behavior in phase space by overlaying multiple periods if detected.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState trajectory, shape (T, 2) Should contain at least one full period\nrequired\n\n\nstate_names\nTuple[str, str]\nNames for axes\n('x₁', 'x₂')\n\n\ntrajectory_names\nOptional[List[str]]\nCustom names for trajectories If None, uses “Trajectory 1”\nNone\n\n\nperiod_estimate\nOptional[float]\nEstimated period (in samples) If None, attempts auto-detection\nNone\n\n\ntitle\nstr\nPlot title\n'Limit Cycle'\n\n\ncolor_scheme\nstr\nColor scheme name Default: ‘plotly’\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nPhase portrait with limit cycle highlighted\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Van der Pol oscillator\n&gt;&gt;&gt; x_vdp = solve_van_der_pol(...)  # (T, 2)\n&gt;&gt;&gt; fig = plotter.plot_limit_cycle(\n...     x_vdp,\n...     period_estimate=100,\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n\n\nNotes\n\nLimit cycle detection is heuristic\nWorks best with long trajectories (many periods)\nHighlights the periodic attractor"
  },
  {
    "objectID": "api/control.analyze_observability.html",
    "href": "api/control.analyze_observability.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.analyze_observability.html#examples",
    "href": "api/control.analyze_observability.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Fully observable\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position only\n&gt;&gt;&gt; info = analyze_observability(A, C)\n&gt;&gt;&gt; print(info['is_observable'])  # True\n&gt;&gt;&gt; print(info['rank'])  # 2\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Unobservable system\n&gt;&gt;&gt; A = np.array([[1, 0], [0, 2]])\n&gt;&gt;&gt; C = np.array([[1, 1]])  # Can't distinguish states\n&gt;&gt;&gt; info = analyze_observability(A, C)\n&gt;&gt;&gt; print(info['is_observable'])  # False\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Full state measurement\n&gt;&gt;&gt; A = np.array([[0, 1, 0], [0, 0, 1], [-1, -2, -3]])\n&gt;&gt;&gt; C = np.eye(3)  # Measure all states\n&gt;&gt;&gt; info = analyze_observability(A, C)\n&gt;&gt;&gt; print(info['is_observable'])  # True"
  },
  {
    "objectID": "api/control.analyze_observability.html#notes",
    "href": "api/control.analyze_observability.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nObservability is necessary for state estimation (Kalman filter)\nDetectability: Unstable modes must be observable (weaker condition)\nDual to controllability: (A, C) observable ⟺ (A’, C’) controllable\nFor large systems, use dual controllability test"
  },
  {
    "objectID": "api/types.reachability.ROAResult.html",
    "href": "api/types.reachability.ROAResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.reachability.ROAResult.html#fields",
    "href": "api/types.reachability.ROAResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nregion_of_attraction : SafeSet ROA estimate (level set of Lyapunov function) lyapunov_function : Callable V(x) Lyapunov function lyapunov_matrix : CovarianceMatrix P matrix if V(x) = x’Px (quadratic) level_set : float c where {x : V(x) ≤ c} defines ROA volume_estimate : float Estimated volume of ROA verification_samples : int Number of samples used for verification certification_method : str Method used (‘SOS’, ‘sampling’, ‘LMI’, ‘bisection’)"
  },
  {
    "objectID": "api/types.reachability.ROAResult.html#examples",
    "href": "api/types.reachability.ROAResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Quadratic Lyapunov function\n&gt;&gt;&gt; P = np.array([[2, 0], [0, 1]])\n&gt;&gt;&gt; V = lambda x: x.T @ P @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: ROAResult = compute_roa(\n...     system=pendulum,\n...     equilibrium=np.array([0, 0]),\n...     lyapunov_function=V,\n...     method='SOS'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract ROA\n&gt;&gt;&gt; roa = result['region_of_attraction']\n&gt;&gt;&gt; c = result['level_set']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check if state in ROA\n&gt;&gt;&gt; x_test = np.array([0.5, 0.1])\n&gt;&gt;&gt; if V(x_test) &lt;= c:\n...     print(\"State in ROA - will converge to equilibrium\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"ROA volume: {result['volume_estimate']:.3f}\")\n&gt;&gt;&gt; print(f\"Certified by: {result['certification_method']}\")"
  },
  {
    "objectID": "api/systems.base.core.ContinuousSymbolicSystem.html",
    "href": "api/systems.base.core.ContinuousSymbolicSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.ContinuousSymbolicSystem.html#examples",
    "href": "api/systems.base.core.ContinuousSymbolicSystem.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nDefine a linear oscillator:\n&gt;&gt;&gt; class Oscillator(ContinuousSymbolicSystem):\n...     def define_system(self, k=1.0, c=0.1):\n...         x, v = sp.symbols('x v', real=True)\n...         u = sp.symbols('u', real=True)\n...         k_sym, c_sym = sp.symbols('k c', positive=True)\n...\n...         self.state_vars = [x, v]\n...         self.control_vars = [u]\n...         self._f_sym = sp.Matrix([v, -k_sym*x - c_sym*v + u])\n...         self.parameters = {k_sym: k, c_sym: c}\n...         self.order = 1\n...\n&gt;&gt;&gt; system = Oscillator(k=2.0, c=0.5)\n&gt;&gt;&gt; x = np.array([0.1, 0.0])\n&gt;&gt;&gt; dx = system(x, u=None)  # Evaluate dynamics\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Integrate\n&gt;&gt;&gt; result = system.integrate(x, t_span=(0, 10), method='RK45')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Linearize\n&gt;&gt;&gt; A, B = system.linearize(np.zeros(2), np.zeros(1))"
  },
  {
    "objectID": "api/systems.base.core.ContinuousSymbolicSystem.html#methods",
    "href": "api/systems.base.core.ContinuousSymbolicSystem.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nforward\nAlias for dynamics evaluation with explicit backend specification.\n\n\nget_performance_stats\nGet performance statistics from all components.\n\n\nh\nEvaluate output equation: y = h(x).\n\n\nintegrate\nIntegrate continuous system using numerical ODE solver.\n\n\nlinearize\nCompute linearization of continuous dynamics: A = ∂f/∂x, B = ∂f/∂u.\n\n\nlinearized_dynamics\nCompute numerical linearization: A = ∂f/∂x, B = ∂f/∂u.\n\n\nlinearized_dynamics_symbolic\nCompute symbolic linearization: A = ∂f/∂x, B = ∂f/∂u.\n\n\nlinearized_observation\nCompute linearized observation matrix: C = ∂h/∂x.\n\n\nlinearized_observation_symbolic\nCompute symbolic observation Jacobian: C = ∂h/∂x.\n\n\nprint_equations\nPrint symbolic equations using continuous-time notation.\n\n\nreset_performance_stats\nReset all performance counters to zero.\n\n\nverify_jacobians\nVerify symbolic Jacobians against automatic differentiation.\n\n\nwarmup\nWarm up backend by compiling and running test evaluation.\n\n\n\n\nforward\nsystems.base.core.ContinuousSymbolicSystem.forward(x, u=None, backend=None)\nAlias for dynamics evaluation with explicit backend specification.\nEquivalent to call but allows explicit backend override.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState (nx,)\nrequired\n\n\nu\nOptional[ControlVector]\nControl (nu,)\nNone\n\n\nbackend\nOptional[Backend]\nBackend override (None = use default)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nState derivative dx/dt\n\n\n\n\n\nExamples\n&gt;&gt;&gt; dx = system.forward(x, u)  # Use default backend\n&gt;&gt;&gt; dx = system.forward(x, u, backend='torch')  # Force PyTorch\n\n\n\nget_performance_stats\nsystems.base.core.ContinuousSymbolicSystem.get_performance_stats()\nGet performance statistics from all components.\nCollects timing and call count from DynamicsEvaluator and LinearizationEngine.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, float]\nStatistics: - ‘forward_calls’: Number of forward dynamics calls - ‘forward_time’: Total forward time (seconds) - ‘avg_forward_time’: Average forward time - ‘linearization_calls’: Number of linearizations - ‘linearization_time’: Total linearization time - ‘avg_linearization_time’: Average linearization time\n\n\n\n\n\nExamples\n&gt;&gt;&gt; for _ in range(100):\n...     dx = system(x, u)\n&gt;&gt;&gt;\n&gt;&gt;&gt; stats = system.get_performance_stats()\n&gt;&gt;&gt; print(f\"Forward calls: {stats['forward_calls']}\")\n&gt;&gt;&gt; print(f\"Avg time: {stats['avg_forward_time']:.6f}s\")\n\n\n\nh\nsystems.base.core.ContinuousSymbolicSystem.h(x, backend=None)\nEvaluate output equation: y = h(x).\nComputes the system output at the given state. If no custom output function is defined, returns the full state (identity map).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState vector (nx,) or batched (batch, nx)\nrequired\n\n\nbackend\nOptional[Backend]\nBackend selection (None = auto-detect)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nOutput vector y, shape (ny,) or (batch, ny)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Identity output\n&gt;&gt;&gt; y = system.h(x)\n&gt;&gt;&gt; np.allclose(y, x)\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom output\n&gt;&gt;&gt; x = np.array([1.0, 2.0])\n&gt;&gt;&gt; y = system.h(x)  # Might return energy, distance, etc.\n\n\n\nintegrate\nsystems.base.core.ContinuousSymbolicSystem.integrate(\n    x0,\n    u=None,\n    t_span=(0.0, 10.0),\n    method='RK45',\n    t_eval=None,\n    dense_output=False,\n    **integrator_kwargs,\n)\nIntegrate continuous system using numerical ODE solver.\nThis method creates an appropriate integrator via IntegratorFactory and delegates the integration. Different methods can be used for different calls without storing integrator state, making it flexible and stateless.\nControl Input Handling: This method accepts flexible control input formats and automatically converts them to the internal (t, x) → u function signature expected by numerical solvers. The conversion is handled by _prepare_control_input(), which intelligently detects function signatures and wraps appropriately.\nIntegration Strategy: Creates a fresh integrator for each call via the factory pattern. This allows: - Different methods for different integration tasks - No state management overhead - Clean separation between system and integrator - Easy backend/method switching\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu\nUnion[ControlVector, Callable, None]\nControl input in flexible formats: - None: Zero control or autonomous system - Array (nu,): Constant control u(t) = u_const for all t - Callable u(t): Time-varying control, signature: t → u - Callable u(t, x): State-feedback, scipy convention (time first) - Callable u(x, t): State-feedback, control theory convention (state first) The method automatically detects callable signatures by: 1. Checking parameter names (‘t’, ‘x’, ‘time’, ‘state’) 2. Testing with dummy values if names are ambiguous 3. Falling back to (t, x) assumption with warning Recommendation: For two-parameter callables, use standard (t, x) order to avoid ambiguity. If your controller uses (x, t), the wrapper will attempt detection, but explicit wrapping is safer: python     u_func = lambda t, x: my_controller(x, t)\nNone\n\n\nt_span\nTimeSpan\nIntegration interval (t_start, t_end)\n(0.0, 10.0)\n\n\nmethod\nIntegrationMethod\nIntegration method. Options:\n'RK45'\n\n\nt_eval\nOptional[TimePoints]\nSpecific times to return solution. If provided, interpolates/evaluates solution at these times. If None: - Adaptive methods: Returns solver’s internal time points - Fixed-step methods: Returns uniform grid with spacing dt\nNone\n\n\ndense_output\nbool\nIf True, return dense interpolated solution object (adaptive methods only). Allows evaluating solution at arbitrary times post-integration via result‘sol’. Default: False\nFalse\n\n\n**integrator_kwargs\n\nAdditional integrator options passed to the solver: Required for fixed-step methods: - dt : float - Time step (required for ‘euler’, ‘midpoint’, ‘rk4’) Tolerance control (adaptive methods): - rtol : float - Relative tolerance (default: 1e-6) - atol : float - Absolute tolerance (default: 1e-8) Step size control (adaptive methods): - max_step : float - Maximum step size (default: inf) - first_step : float - Initial step size guess (default: auto) - min_step : float - Minimum step size (default: 0) Limits: - max_steps : int - Maximum number of steps (default: 10000) Backend-specific (see integrator documentation): - JAX: ‘stepsize_controller’, ‘adjoint’ - PyTorch: ‘adjoint’, ‘method_options’ - Julia: ‘reltol’, ‘abstol’ (note different names)\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nTypedDict containing: Always present: - t: Time points (T,) - adaptive or uniform grid - x: State trajectory (T, nx) - time-major ordering - success: bool - Whether integration succeeded - message: str - Status message or error description - solver: str - Name of integrator used Performance metrics: - nfev: int - Number of function evaluations (dynamics calls) - nsteps: int - Number of integration steps taken - integration_time: float - Wall-clock time (seconds) Optional (method-dependent): - njev: int - Number of Jacobian evaluations (implicit methods) - nlu: int - Number of LU decompositions (implicit methods) - sol: Callable - Dense output interpolant (if dense_output=True) - status: int - Termination status code\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\n- If fixed-step method specified without dt - If backend/method combination is invalid - If control dimensions don’t match system\n\n\n\nRuntimeError\n- If integration fails (convergence, step size issues) - If backend is not available (library not installed)\n\n\n\nImportError\n- If required integrator backend is not installed\n\n\n\n\n\nNotes\nFactory Pattern: Creates a fresh integrator for each call. Benefits: - No state management between calls - Different methods for different integration tasks - Clean separation of concerns - Easy to switch backends/methods\nControl Input Processing: The _prepare_control_input() method handles conversion of various control formats to the internal (t, x) → u signature: 1. None → returns None (autonomous) or zeros (nu &gt; 0) 2. Array → wraps as constant function 3. Callable(t) → wraps to (t, x) → u(t) 4. Callable(t, x) or (x, t) → detects order, normalizes to (t, x)\nAutonomous Systems: For systems with nu=0, control input is ignored. Pass u=None for clarity.\nTime-Major Ordering: Unlike simulate() which returns (nx, T) for backward compatibility, this method returns (T, nx) time-major ordering, which is: - Standard for numerical solvers - Efficient for time-series operations - Compatible with pandas DataFrames\nBackend Selection: Uses system’s default backend. Change with: python     system.set_default_backend('jax')     result = system.integrate(...)  # Uses JAX\n\n\nExamples\nBasic integration - autonomous system:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u=None,  # Autonomous\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Success: {result['success']}\")\n&gt;&gt;&gt; print(f\"Steps taken: {result['nsteps']}\")\n&gt;&gt;&gt; plt.plot(result['t'], result['x'][:, 0])\nConstant control:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u=np.array([0.5]),  # Constant\n...     t_span=(0.0, 10.0)\n... )\nTime-varying control - single parameter:\n&gt;&gt;&gt; def u_func(t):\n...     return np.array([np.sin(t)])\n&gt;&gt;&gt; result = system.integrate(x0, u=u_func, t_span=(0, 10))\nState feedback - standard (t, x) order:\n&gt;&gt;&gt; def controller(t, x):\n...     K = np.array([[-1.0, -2.0]])\n...     return -K @ x\n&gt;&gt;&gt; result = system.integrate(x0, u=controller, t_span=(0, 5))\nState feedback - control theory (x, t) order (auto-detected):\n&gt;&gt;&gt; def my_controller(x, t):\n...     # State-first convention\n...     K = np.array([[-1.0, -2.0]])\n...     return -K @ x\n&gt;&gt;&gt; result = system.integrate(x0, u=my_controller, t_span=(0, 5))\n&gt;&gt;&gt; # Method detects (x, t) order and adapts automatically\nStiff system with tight tolerances:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,\n...     t_span=(0, 100),\n...     method='Radau',\n...     rtol=1e-9,\n...     atol=1e-11\n... )\n&gt;&gt;&gt; print(f\"Stiff solver used {result['nfev']} function evaluations\")\nHigh-accuracy Julia solver:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,\n...     t_span=(0, 10),\n...     method='Vern9',  # Julia high-accuracy\n...     rtol=1e-12\n... )\n&gt;&gt;&gt; print(f\"Julia solver: {result['solver']}\")\nAuto-switching for unknown stiffness:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,\n...     t_span=(0, 10),\n...     method='LSODA'  # scipy auto-switching\n... )\n&gt;&gt;&gt; # Or use Julia:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,\n...     t_span=(0, 10),\n...     method='AutoTsit5(Rosenbrock23())'\n... )\nFixed-step RK4 for predictable behavior:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,\n...     t_span=(0, 10),\n...     method='rk4',\n...     dt=0.01  # Required!\n... )\n&gt;&gt;&gt; assert len(result['t']) == 1001  # 0 to 10 with dt=0.01\nSpecific evaluation times:\n&gt;&gt;&gt; t_eval = np.array([0.0, 1.0, 2.0, 5.0, 10.0])\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,\n...     t_span=(0, 10),\n...     t_eval=t_eval\n... )\n&gt;&gt;&gt; assert len(result['t']) == 5\nDense output for post-hoc interpolation:\n&gt;&gt;&gt; result = system.integrate(\n...     x0=x0,\n...     u=None,\n...     t_span=(0, 10),\n...     dense_output=True\n... )\n&gt;&gt;&gt; if 'sol' in result:\n...     t_fine = np.linspace(0, 10, 10000)\n...     x_fine = result['sol'](t_fine)\n...     plt.plot(t_fine, x_fine[:, 0])\nBackend switching:\n&gt;&gt;&gt; # NumPy (scipy)\n&gt;&gt;&gt; result_np = system.integrate(x0, u=None, t_span=(0, 10))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # JAX (JIT-compiled)\n&gt;&gt;&gt; system.set_default_backend('jax')\n&gt;&gt;&gt; result_jax = system.integrate(x0, u=None, t_span=(0, 10), method='tsit5')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # PyTorch (autodiff)\n&gt;&gt;&gt; system.set_default_backend('torch')\n&gt;&gt;&gt; result_torch = system.integrate(x0, u=None, t_span=(0, 10), method='dopri5')\nPerformance monitoring:\n&gt;&gt;&gt; result = system.integrate(x0, u=None, t_span=(0, 10))\n&gt;&gt;&gt; print(f\"Steps: {result['nsteps']}\")\n&gt;&gt;&gt; print(f\"Function evals: {result['nfev']}\")\n&gt;&gt;&gt; print(f\"Time: {result['integration_time']:.4f}s\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['nfev'] &gt; 10000:\n...     print(\"⚠ Warning: Many function evaluations!\")\n...     print(\"Consider: stiff solver, relaxed tolerances, or check dynamics\")\nError handling:\n&gt;&gt;&gt; try:\n...     result = system.integrate(\n...         x0=x0,\n...         u=None,\n...         t_span=(0, 10),\n...         method='Radau',\n...         max_steps=10  # Too low!\n...     )\n...     if not result['success']:\n...         print(f\"Failed: {result['message']}\")\n... except RuntimeError as e:\n...     print(f\"Integration error: {e}\")\nComparing methods:\n&gt;&gt;&gt; methods = ['RK45', 'Tsit5', 'Vern9', 'rk4']\n&gt;&gt;&gt; for method in methods:\n...     try:\n...         result = system.integrate(\n...             x0, u=None, t_span=(0, 10),\n...             method=method,\n...             dt=0.01 if method == 'rk4' else None\n...         )\n...         print(f\"{method}: {result['nfev']} evals, {result['nsteps']} steps\")\n...     except ImportError:\n...         print(f\"{method}: Backend not available\")\n\n\nSee Also\nsimulate : High-level simulation with regular time grid (recommended for most users) IntegratorFactory : Create custom integrators with specific methods _prepare_control_input : Internal method for control input conversion linearize : Compute linearized dynamics at equilibrium set_default_backend : Change backend for integration\n\n\n\nlinearize\nsystems.base.core.ContinuousSymbolicSystem.linearize(x_eq, u_eq=None)\nCompute linearization of continuous dynamics: A = ∂f/∂x, B = ∂f/∂u.\nFor continuous systems, this returns the continuous-time Jacobian matrices that define the linearized system: d(δx)/dt = A·δx + B·δu\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control (nu,) If None, uses zero control\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nLinearizationResult\nTuple (A, B) where: - A: State Jacobian ∂f/∂x, shape (nx, nx) - B: Control Jacobian ∂f/∂u, shape (nx, nu)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x_eq = np.zeros(2)\n&gt;&gt;&gt; u_eq = np.zeros(1)\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check continuous stability: Re(λ) &lt; 0\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(A)\n&gt;&gt;&gt; is_stable = np.all(np.real(eigenvalues) &lt; 0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # LQR design\n&gt;&gt;&gt; from scipy.linalg import solve_continuous_are\n&gt;&gt;&gt; P = solve_continuous_are(A, B, Q, R)\n&gt;&gt;&gt; K = np.linalg.inv(R) @ B.T @ P\n\n\nNotes\nFor higher-order systems, automatically constructs the full state-space representation with kinematic relationships.\nFor autonomous systems (nu=0), B will be an empty (nx, 0) matrix.\n\n\n\nlinearized_dynamics\nsystems.base.core.ContinuousSymbolicSystem.linearized_dynamics(\n    x,\n    u=None,\n    backend=None,\n)\nCompute numerical linearization: A = ∂f/∂x, B = ∂f/∂u.\nAlias for linearize() with support for named equilibria and explicit backend specification.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[StateVector, str]\nState to linearize at, OR equilibrium name\nrequired\n\n\nu\nOptional[ControlVector]\nControl to linearize at (ignored if x is string)\nNone\n\n\nbackend\nOptional[Backend]\nBackend for result arrays\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[ArrayLike, ArrayLike]\n(A, B) Jacobian matrices\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # By state/control\n&gt;&gt;&gt; A, B = system.linearized_dynamics(\n...     np.array([0.0, 0.0]),\n...     np.array([0.0])\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # By equilibrium name\n&gt;&gt;&gt; A, B = system.linearized_dynamics('inverted')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Force PyTorch backend\n&gt;&gt;&gt; A, B = system.linearized_dynamics(x, u, backend='torch')\n\n\n\nlinearized_dynamics_symbolic\nsystems.base.core.ContinuousSymbolicSystem.linearized_dynamics_symbolic(\n    x_eq=None,\n    u_eq=None,\n)\nCompute symbolic linearization: A = ∂f/∂x, B = ∂f/∂u.\nReturns symbolic matrices for analytical analysis.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nOptional[Union[sp.Matrix, str]]\nEquilibrium state (symbolic) OR equilibrium name If None, uses zeros\nNone\n\n\nu_eq\nOptional[sp.Matrix]\nEquilibrium control (symbolic) If None, uses zeros\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[sp.Matrix, sp.Matrix]\n(A, B) symbolic matrices with parameters substituted\n\n\n\n\n\nExamples\n&gt;&gt;&gt; A_sym, B_sym = system.linearized_dynamics_symbolic()\n&gt;&gt;&gt; print(A_sym)\nMatrix([[0, 1], [-10.0, -0.5]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # At named equilibrium\n&gt;&gt;&gt; A_sym, B_sym = system.linearized_dynamics_symbolic('inverted')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert to NumPy\n&gt;&gt;&gt; A_np = np.array(A_sym, dtype=float)\n\n\n\nlinearized_observation\nsystems.base.core.ContinuousSymbolicSystem.linearized_observation(\n    x,\n    backend=None,\n)\nCompute linearized observation matrix: C = ∂h/∂x.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState at which to linearize (nx,)\nrequired\n\n\nbackend\nOptional[Backend]\nBackend selection\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nC matrix, shape (ny, nx)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1.0, 2.0])\n&gt;&gt;&gt; C = system.linearized_observation(x)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # For identity output\n&gt;&gt;&gt; np.allclose(C, np.eye(system.nx))\nTrue\n\n\n\nlinearized_observation_symbolic\nsystems.base.core.ContinuousSymbolicSystem.linearized_observation_symbolic(\n    x_eq=None,\n)\nCompute symbolic observation Jacobian: C = ∂h/∂x.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nOptional[sp.Matrix]\nEquilibrium state (symbolic), None = zeros\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsp.Matrix\nSymbolic C matrix\n\n\n\n\n\nExamples\n&gt;&gt;&gt; C_sym = system.linearized_observation_symbolic()\n&gt;&gt;&gt; print(C_sym)\n\n\n\nprint_equations\nsystems.base.core.ContinuousSymbolicSystem.print_equations(simplify=True)\nPrint symbolic equations using continuous-time notation.\nDisplays the system’s symbolic dynamics and output equations with d/dt notation appropriate for continuous systems.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsimplify\nbool\nIf True, simplify expressions before printing\nTrue\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.print_equations()\n======================================================================\nPendulum\n======================================================================\nState Variables: [theta, omega]\nControl Variables: [u]\nSystem Order: 1\nDimensions: nx=2, nu=1, ny=2\nDynamics: dx/dt = f(x, u) dtheta/dt = omega domega/dt = -19.62sin(theta) - 0.1omega + 4.0*u ======================================================================\n\n\n\nreset_performance_stats\nsystems.base.core.ContinuousSymbolicSystem.reset_performance_stats()\nReset all performance counters to zero.\nClears statistics in DynamicsEvaluator and LinearizationEngine.\n\nExamples\n&gt;&gt;&gt; system.reset_performance_stats()\n&gt;&gt;&gt; stats = system.get_performance_stats()\n&gt;&gt;&gt; assert stats['forward_calls'] == 0\n\n\n\nverify_jacobians\nsystems.base.core.ContinuousSymbolicSystem.verify_jacobians(\n    x,\n    u=None,\n    tol=0.001,\n    backend='torch',\n)\nVerify symbolic Jacobians against automatic differentiation.\nCompares analytically-derived Jacobians (from SymPy) against numerically-computed Jacobians (from PyTorch/JAX autodiff).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState at which to verify\nrequired\n\n\nu\nOptional[ControlVector]\nControl at which to verify (None for autonomous)\nNone\n\n\ntol\nfloat\nTolerance for considering Jacobians equal\n0.001\n\n\nbackend\nstr\nBackend for autodiff (‘torch’ or ‘jax’, not ‘numpy’)\n'torch'\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Union[bool, float]]\nVerification results: - ‘A_match’: bool - True if A matches - ‘B_match’: bool - True if B matches - ‘A_error’: float - Maximum absolute error in A - ‘B_error’: float - Maximum absolute error in B\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([0.1, 0.0])\n&gt;&gt;&gt; u = np.array([0.0])\n&gt;&gt;&gt; results = system.verify_jacobians(x, u, backend='torch')\n&gt;&gt;&gt;\n&gt;&gt;&gt; if results['A_match'] and results['B_match']:\n...     print(\"✓ Jacobians verified!\")\n... else:\n...     print(f\"✗ A error: {results['A_error']:.2e}\")\n...     print(f\"✗ B error: {results['B_error']:.2e}\")\n\n\nNotes\nRequires PyTorch or JAX for automatic differentiation. Small errors (&lt; 1e-6) are usually numerical precision issues. Large errors indicate bugs in symbolic Jacobian computation.\n\n\n\nwarmup\nsystems.base.core.ContinuousSymbolicSystem.warmup(backend=None, test_point=None)\nWarm up backend by compiling and running test evaluation.\nUseful for JIT compilation warmup (especially JAX) and validating backend configuration before critical operations.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nOptional[Backend]\nBackend to warm up (None = default)\nNone\n\n\ntest_point\nOptional[Tuple[StateVector, ControlVector]]\nTest (x, u) point (None = use equilibrium)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if warmup successful\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system.set_default_backend('jax', device='gpu:0')\n&gt;&gt;&gt; success = system.warmup()\n&gt;&gt;&gt; # First call triggers JIT compilation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2DLidar.html",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicQuadrotor2DLidar.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nsystems.builtin.deterministic.continuous.SymbolicQuadrotor2DLidar\nsystems.builtin.deterministic.continuous.SymbolicQuadrotor2DLidar(\n    *args,\n    **kwargs,\n)\nSymbolic representation of a planar (2D) quadrotor with lidar-based partial observations.\nModels a quadrotor constrained to move in the y-z plane with dynamics derived from first principles. The system has 4 states (vertical position, pitch angle, and their derivatives) and 2 control inputs (thrust from each rotor). Unlike full-state feedback, this system uses a lidar sensor that measures distances to the ground at 4 different angles, providing partial observability that requires state estimation (e.g., Kalman filtering) for control. This implementation uses symbolic computation via SymPy to enable automatic Jacobian derivation for neural Lyapunov control synthesis.\nBased on the Stanford ASL neural-network-lyapunov quadrotor2d example: https://github.com/StanfordASL/neural-network-lyapunov/blob/master/neural_network_lyapunov/examples/quadrotor2d/quadrotor_2d.py\nState Vector (nx=4): - y: vertical position [m] - theta: pitch angle [rad] - y_dot: vertical velocity [m/s] - theta_dot: angular velocity [rad/s]\nControl Inputs (nu=2): - u1: thrust from rotor 1 [N] - u2: thrust from rotor 2 [N]\nOutput Vector (ny=4): - Lidar ray distances at 4 different angles [m] - Measured from quadrotor to ground, ranging from [0, H] - Angles span from theta - angle_max to theta + angle_max\nDynamics: The system is second-order, so forward() returns accelerations: - dy_dot = (1/m) * cos(theta) * (u1 + u2) - g - b * y_dot - dtheta_dot = (L/I) * (u1 - u2) - b * theta_dot\nwhere b is an optional damping coefficient (default: 0).\nObservation Model: Lidar rays measure distance to ground at different angles: - phi_i = theta - angle_offset_i - ray_i = (y + origin_height) / cos(phi_i) - Clamped to [0, H] and masked when out of valid range\nEquilibrium: - State: [0, 0, 0, 0] (hovering at origin) - Control: [mg/2, mg/2] (equal thrust counteracting gravity) - Output: Lidar readings at equilibrium depend on ray angles. Center rays measure approximately origin_height, while angled rays measure slightly longer distances (e.g., ~1.12m for rays at ±26.8° when origin_height=1.0)\nParameters: length: Distance from center of mass to rotor [m]. Default: 0.25 mass: Total quadrotor mass [kg]. Default: 0.486 inertia: Moment of inertia about pitch axis [kg⋅m²]. Default: 0.00383 gravity: Gravitational acceleration [m/s²]. Default: 9.81 b: Damping coefficient for both translational and angular velocities. Default: 0.0 H: Maximum lidar range [m]. Default: 5.0 angle_max: Maximum angle offset for lidar rays [rad]. Default: 0.149π origin_height: Height offset added to vertical position [m]. Default: 1.0\nNote: This symbolic implementation is compatible with the hardcoded Quadrotor2DLidarDynamics class when using matching parameters. The observation function h(x) uses smooth approximations (via tanh and smooth_clamp) instead of hard thresholding to maintain differentiability for automatic Jacobian computation."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#difference-equation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#difference-equation",
    "title": "",
    "section": "Difference Equation",
    "text": "Difference Equation\nStandard form (no drift): X[k+1] = X[k] + σ·w[k]\nWith drift: X[k+1] = X[k] + μ + σ·w[k]\nwhere w[k] ~ N(0,1) are iid.\nCumulative Form: X[k] = X[0] + μ·k + Σ_{j=0}^{k-1} σ·w[j]\nShows random walk as cumulative sum of innovations."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nUnit Root: AR(1) with φ = 1 (critical boundary): - Stationary: |φ| &lt; 1 - Random walk: φ = 1 - Explosive: |φ| &gt; 1\nNon-Stationarity: Variance grows with time: Var[X[k]] = k·σ²\nUnlike stationary processes with bounded variance.\nPerfect Memory: All past shocks permanently affect current value. Shocks never decay (contrast with AR(1)).\nMartingale (μ=0): Best prediction of future is present: E[X[k+1] | past] = X[k]\n“Fair game” property.\nRecurrence (1D): Returns to any value infinitely often (Pólya’s theorem). But transient in 3D and higher."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nMoments (μ = 0): Mean: E[X[k]] = X[0] Variance: Var[X[k]] = k·σ² Std Dev: σ·√k\nDistribution: X[k] ~ N(X[0] + μ·k, k·σ²)\nAutocorrelation: For k ≥ j: Corr[X[k], X[j]] = √(j/k)\nDecays slowly (does not go to zero).\nStationary Differences: ΔX[k] = X[k] - X[k-1] = μ + σ·w[k]\nDifferences are stationary (integrated of order 1)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nStep Size σ: - Standard deviation of each step - Units: [state] - RMS displacement after k steps: σ·√k\nDrift μ: - Expected change per step - Units: [state]/[step] - Creates deterministic trend\nScaling: Displacement scales as √k (characteristic of diffusion).\nDiffusion Coefficient: D = σ²/(2·Δt)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x ∈ ℝ (unbounded) - No equilibrium (non-stationary) - Wanders arbitrarily far - No tendency to return\nControl: None (autonomous) - Pure stochastic dynamics - No external forcing"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nStep size (innovation std dev) - Must be positive - Controls diffusion rate - Typical: 0.1 to 10.0\n1.0\n\n\nmu\nfloat\nDrift (trend per step) - Can be positive, negative, or zero - μ = 0: Symmetric random walk - μ ≠ 0: Biased random walk\n0.0\n\n\ndt\nfloat\nTime step [units] - Required for discrete system - Sets time scale\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nType: Unit root (φ = 1)\nStationary: No (non-stationary)\nMartingale: Yes (if μ = 0)\nMemory: Perfect (all shocks permanent)\nVariance: Unbounded (grows linearly)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Financial Economics: - Stock prices (efficient markets) - Exchange rates - Interest rates (sometimes) - Null hypothesis for predictability tests\n2. Physics: - Brownian motion (discrete time) - Particle diffusion - Polymer chains\n3. Econometrics: - Unit root testing - Cointegration analysis - Non-stationary time series\n4. Biology: - Genetic drift - Population dispersal - Foraging behavior\n5. Computer Science: - Random algorithms - Page rank - Monte Carlo methods"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nEfficient Generation: w = σ·np.random.randn(N) X = X₀ + μ·np.arange(N) + np.cumsum(w)\nUses cumulative sum for efficiency.\nTypical Behavior: - Starts at X₀ - Wanders with no equilibrium - Standard deviation: σ·√k - Never settles down"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#statistical-analysis",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#statistical-analysis",
    "title": "",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\nUnit Root Testing: - Dickey-Fuller test - Augmented Dickey-Fuller (ADF) - Phillips-Perron\nDifferencing: Transform to stationarity: ΔX[k] = X[k] - X[k-1] ~ N(μ, σ²)\nParameter Estimation: From differences: μ̂ = mean(ΔX) σ̂² = var(ΔX)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#comparison-with-other-processes",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#comparison-with-other-processes",
    "title": "",
    "section": "Comparison with Other Processes",
    "text": "Comparison with Other Processes\nvs. AR(1): - AR(1): Stationary (|φ| &lt; 1) - Random walk: Unit root (φ = 1) - RW is critical boundary\nvs. White Noise: - White noise: Independent, stationary - Random walk: Cumulative sum of white noise\nvs. Brownian Motion: - Brownian motion: Continuous time - Random walk: Discrete time - RW → BM in scaling limit\nvs. Trend-Stationary: - Trend-stationary: Detrend → stationary - Random walk: Difference → stationary - Different implications"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nNon-stationary (need special methods)\nUnbounded variance (unrealistic)\nNo mean reversion (prices may revert)\nConstant volatility (often time-varying)\nNormal innovations (may have fat tails)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDiscreteWhiteNoise : Differences of random walk DiscreteAR1 : Stationary version (|φ| &lt; 1) BrownianMotion : Continuous-time analog"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteRandomWalk.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine random walk dynamics.\n\n\nget_mean\nGet expected value after n steps (from X[0]=0).\n\n\nget_std\nGet theoretical standard deviation after n steps.\n\n\nget_variance\nGet theoretical variance after n steps.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteRandomWalk.define_system(\n    sigma=1.0,\n    mu=0.0,\n    dt=1.0,\n)\nDefine random walk dynamics.\nSets up the difference equation: X[k+1] = X[k] + μ + σ·w[k]\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma\nfloat\nStep size (innovation standard deviation) - Must be positive - Controls diffusion rate - Variance grows as k·σ²\n1.0\n\n\nmu\nfloat\nDrift (expected change per step) - Can be any real number - μ = 0: Symmetric random walk - μ &gt; 0: Upward drift - μ &lt; 0: Downward drift\n0.0\n\n\ndt\nfloat\nTime step [units] - Required for discrete system - Sets time scale\n1.0\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf sigma ≤ 0\n\n\n\n\n\nNotes\nUnit Root Property: This is AR(1) with φ = 1: X[k+1] = 1·X[k] + μ + σ·w[k]\nCritical boundary between stationary and explosive.\nNon-Stationarity: Unlike AR(1) with |φ| &lt; 1: - Variance grows: Var[X[k]] = k·σ² - No equilibrium distribution - Wanders arbitrarily far\nPerfect Memory: All past shocks permanently affect current value: X[k] = X[0] + μ·k + Σ σ·w[j]\nMartingale (μ=0): Best forecast: E[X[k+1] | X[k]] = X[k]\nFair game - expected change is zero.\nWith Drift (μ≠0): Expected value: E[X[k]] = X[0] + μ·k Linear trend in addition to random fluctuations.\nScaling to Brownian Motion: As Δt → 0 with σ² ∝ Δt: X[t/Δt] / √(Δt) → Brownian motion\nThis is Donsker’s invariance principle.\nDiffusion Coefficient: In continuous limit: D = σ²/(2·Δt)\nParameter Selection: - Financial returns: σ ≈ 0.01-0.03 (daily) - Physics: σ from Einstein relation - Generic: σ = 1 for baseline\nComparison with AR(1): AR(1) with φ close to 1 approximates random walk: - φ = 0.99: Nearly unit root - φ = 1.00: Exact random walk - Hard to distinguish in finite samples\nFirst Difference: ΔX[k] = X[k] - X[k-1] = μ + σ·w[k]\nDifferences are stationary white noise (with mean μ).\n\n\n\nget_mean\nsystems.builtin.stochastic.discrete.DiscreteRandomWalk.get_mean(n_steps)\nGet expected value after n steps (from X[0]=0).\nFor random walk: E[X[k]] = μ·k\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_steps\nint\nNumber of steps\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nExpected value\n\n\n\n\n\n\nget_std\nsystems.builtin.stochastic.discrete.DiscreteRandomWalk.get_std(n_steps)\nGet theoretical standard deviation after n steps.\nFor random walk: Std[X[k]] = σ·√k\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_steps\nint\nNumber of steps\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nStandard deviation after n steps\n\n\n\n\n\nNotes\n√k scaling characteristic of diffusion.\n\n\n\nget_variance\nsystems.builtin.stochastic.discrete.DiscreteRandomWalk.get_variance(n_steps)\nGet theoretical variance after n steps.\nFor random walk: Var[X[k]] = k·σ²\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_steps\nint\nNumber of steps (must be non-negative)\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nVariance after n steps\n\n\n\n\n\nNotes\nVariance grows linearly with time - hallmark of diffusion."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA continuous flow reactor where reactant A converts to product B in\nan exothermic reaction, modeled in discrete time with periodic sampling\nand control actuation.\n\nUnlike batch reactors, CSTRs operate at steady state with continuous\nfeed and product removal. The discrete-time formulation is appropriate\nfor digital control systems with:\n- Periodic concentration measurements (e.g., via online analyzers)\n- Discrete temperature sensor readings\n- Digital control actuation of cooling jacket\n\nKey features:\n- Continuous flow: Feed enters, product exits at same rate\n- Perfect mixing: Uniform concentration and temperature\n- Exothermic reaction: Heat generation from reaction\n- Jacket cooling: Heat removal to maintain temperature\n- Discrete measurements and control updates\n\nThe reactor can exhibit:\n- Multiple steady states (low/high conversion)\n- Oscillatory behavior (limit cycles)\n- Thermal runaway (if cooling insufficient)\n- Complex bifurcations as parameters vary"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] = [Cₐ[k], T[k]]\n    Concentration state:\n    - Cₐ: Concentration of reactant A in reactor [mol/L]\n      * Lower than feed concentration due to reaction\n      * Cₐ,feed &gt; Cₐ &gt; 0\n      * Steady-state value depends on temperature and residence time\n      * High Cₐ → low conversion (inefficient)\n      * Low Cₐ → high conversion (efficient but expensive cooling)\n\n    Temperature state:\n    - T: Reactor temperature [K]\n      * Higher than feed due to exothermic reaction\n      * T &gt; T_feed (for exothermic reactions)\n      * Critical state: affects reaction rate exponentially\n      * Small T change → large rate change (Arrhenius)\n      * Must be controlled to prevent runaway\n\nControl: u[k] = [T_jacket[k]]\n    - T_jacket: Cooling jacket temperature [K]\n      * Manipulated variable for temperature control\n      * Typically T_jacket &lt; T (removing heat)\n      * Can be T_jacket &gt; T for startup heating\n      * Typical range: 280-340 K\n      * Physical limits: chiller/heater capacity\n\nOutput: y[k] = [Cₐ[k], T[k]]\n    - Full state measurement\n    - In practice:\n      * Cₐ measured via online analyzer (GC, HPLC, spectroscopy)\n      * T measured via thermocouple or RTD\n      * Both have sampling delays and noise"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#dynamics",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe discrete-time dynamics use Euler discretization:\n\n    Cₐ[k+1] = Cₐ[k] + dt·[(F/V)·(Cₐ,feed - Cₐ[k]) - r[k]]\n    T[k+1] = T[k] + dt·[(F/V)·(T_feed - T[k]) + (-ΔH/ρCₚ)·r[k] + UA/(VρCₚ)·(T_jacket[k] - T[k])]\n\n**Reaction Rate (Arrhenius kinetics)**:\n    r[k] = k₀·Cₐ[k]·exp(-E/T[k])  [mol/(L·s)]\n\nwhere:\n- k₀: Pre-exponential factor [1/s]\n- E: Activation energy [K] (using Eₐ/R as temperature)\n- exp(-E/T): Arrhenius temperature dependence\n\n**Physical Interpretation**:\n\nMaterial Balance:\n- (F/V)·(Cₐ,feed - Cₐ): Convective in/out (dilution)\n- F/V = 1/τ: Inverse residence time [1/s]\n- τ = V/F: Average time molecule spends in reactor [s]\n- -r: Consumption by reaction\n- At steady state: inflow - outflow - reaction = 0\n\nEnergy Balance:\n- (F/V)·(T_feed - T): Convective heat in/out\n- (-ΔH/ρCₚ)·r: Heat generation from reaction\n  * ΔH &lt; 0 (exothermic) → heat generation\n  * |ΔH| large → strong thermal coupling\n- UA/(VρCₚ)·(T_jacket - T): Heat removal via jacket\n  * UA: Overall heat transfer coefficient × area\n  * Larger UA → better temperature control\n  * T_jacket &lt; T → cooling (typical)\n\n**Nonlinear Coupling**:\n1. Temperature affects reaction rate exponentially (Arrhenius)\n2. Reaction generates heat (thermal feedback)\n3. High T → fast reaction → more heat → higher T (runaway risk)\n4. Cooling must balance heat generation for stability"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nF : float, default=100.0\n    Volumetric flow rate [L/s]\n    Higher F → shorter residence time → lower conversion\n    Lower F → longer residence time → higher conversion\n\nV : float, default=100.0\n    Reactor volume [L]\n    Determines residence time τ = V/F\n    Larger V → more conversion for given F\n\nC_A_feed : float, default=1.0\n    Feed concentration [mol/L]\n    Typical: 0.5-2.0 mol/L\n    Higher feed → more product but more heat generation\n\nT_feed : float, default=350.0\n    Feed temperature [K]\n    Typical: 300-360 K\n    Pre-heating can improve conversion but reduces stability margin\n\nk0 : float, default=7.2e10\n    Pre-exponential factor [1/s]\n    Collision frequency in Arrhenius equation\n    Typical: 10⁶-10¹² for liquid phase reactions\n    Determines reaction speed at given temperature\n\nE : float, default=8750.0\n    Activation energy [K] (actually Eₐ/R)\n    Energy barrier for reaction to occur\n    Typical: 5000-15000 K for Eₐ/R\n    Higher E → more temperature-sensitive\n    Physical Eₐ typically 40-120 kJ/mol\n\ndelta_H : float, default=-5e4\n    Heat of reaction [J/mol]\n    Negative = exothermic (releases heat)\n    Positive = endothermic (absorbs heat)\n    Typical for exothermic: -20,000 to -200,000 J/mol\n    Larger |ΔH| → stronger thermal coupling, harder control\n\nrho : float, default=1000.0\n    Density [kg/L]\n    Typical for aqueous solutions: 900-1100 kg/L\n    Affects thermal inertia (heat capacity)\n\nCp : float, default=0.239\n    Specific heat capacity [J/(kg·K)]\n    Typical for aqueous: 0.2-0.5 J/(kg·K)\n    Higher Cₚ → slower temperature changes (more stable)\n\nUA : float, default=5e4\n    Overall heat transfer coefficient × area [J/(s·K)]\n    Combines jacket film coefficient, wall conduction, reactor-side film\n    Typical: 10³-10⁵ J/(s·K)\n    Higher UA → better temperature control, faster cooling\n    Limited by physical design (jacket size, flow rate)\n\ndt : float, default=0.1\n    Sampling/discretization time step [s]\n    Critical parameter for stability!\n    - Too large → numerical instability, oscillations\n    - Too small → slow simulation, high computational cost\n    - Rule of thumb: dt &lt; 0.1/max(λ) where λ are eigenvalues\n    - Typical for CSTR: 0.01-1.0 seconds\n    - Must be smaller than fastest system time scale"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\n**Multiple Steady States** (hallmark of CSTRs!):\n\nCSTR can have 1, 2, or 3 steady states depending on parameters.\nFor given feed conditions and jacket temperature:\n\n1. **Low conversion state** (stable):\n   - Low T ≈ T_feed + small rise\n   - Low reaction rate (slow kinetics)\n   - High Cₐ ≈ Cₐ,feed (minimal conversion)\n   - Heat generation &lt; Heat removal\n   - Easy to control but inefficient\n   - Attractive for cold startup\n\n2. **High conversion state** (stable):\n   - High T &gt;&gt; T_feed\n   - High reaction rate (fast kinetics)\n   - Low Cₐ &lt;&lt; Cₐ,feed (high conversion)\n   - Heat generation balanced by cooling\n   - Desirable operating point (efficient)\n   - Risk: close to instability/runaway\n\n3. **Intermediate state** (unstable):\n   - Saddle point in phase space\n   - Not physically realizable (unstable)\n   - Forms separatrix between basins of attraction\n   - System will move toward stable states\n\n**Stability depends on**:\n- Residence time τ = V/F (longer → more conversion, less stable)\n- Activation energy E (higher → more sensitive)\n- Heat of reaction ΔH (larger |ΔH| → more coupling)\n- Cooling capacity UA (higher → more stable)\n- Feed temperature T_feed (higher → less stable margin)\n\n**Bifurcation Behavior**:\nAs cooling capacity (T_jacket) decreases:\n1. Unique stable high-conversion state\n2. Saddle-node bifurcation → 3 steady states appear\n3. Two stable states (low and high conversion)\n4. Another saddle-node → only low-conversion state\n5. Further decrease → thermal runaway (no steady state)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\nCommon control goals for CSTR:\n\n1. **Setpoint tracking**: Maintain T[k] ≈ T_setpoint\n   - Most common objective\n   - Balances conversion and stability\n   - PID/LQR/MPC controllers typical\n   - Challenge: nonlinearity and multiple steady states\n\n2. **Startup control**: Transition low → high conversion state\n   - Must cross unstable intermediate state\n   - Requires large transient cooling capacity\n   - Bang-bang or optimal trajectory control\n   - Risk of overshoot → runaway\n\n3. **Disturbance rejection**: Handle feed variations\n   - Feed concentration changes: Cₐ,feed(t)\n   - Feed temperature disturbances: T_feed(t)\n   - Flow rate fluctuations: F(t)\n   - Jacket temperature limits\n\n4. **Optimal operation**: Maximize profit\n   - Balance conversion (revenue) vs cooling cost\n   - Economic objective: J = price·F·(Cₐ,feed - Cₐ) - cooling_cost\n   - Constraint: T_max safety limit\n   - May operate near instability for profit\n\n5. **Runaway prevention**: Safety constraint\n   - Monitor temperature rate: dT/dt &lt; threshold\n   - Emergency cooling if T &gt; T_max\n   - May require batch shutdown"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\nPhysical constraints that must be enforced:\n\n1. **Non-negativity**: Cₐ[k] ≥ 0\n   - Concentration cannot be negative\n   - Physical meaning: species present or absent\n   - Euler discretization may violate if dt too large\n\n2. **Concentration bounds**: 0 ≤ Cₐ[k] ≤ Cₐ,feed\n   - Cannot exceed feed concentration (dilution + reaction)\n   - Upper bound: Cₐ ≤ Cₐ,feed (no reaction case)\n   - Useful for validation\n\n3. **Temperature limits**: T_min ≤ T[k] ≤ T_max\n   - Safety: prevent runaway (T_max ≈ 450-500 K)\n   - Operability: prevent freezing/solidification (T_min ≈ 280 K)\n   - Jacket temperature limits: T_jacket,min ≤ T_jacket ≤ T_jacket,max\n   - Typical limits: 280 K ≤ T ≤ 450 K\n\n4. **Jacket temperature constraints**: T_jacket,min ≤ T_jacket[k] ≤ T_jacket,max\n   - Physical cooling/heating capacity\n   - Chiller: T_jacket,min ≈ 280 K\n   - Heater: T_jacket,max ≈ 400 K\n   - Rate limit: |T_jacket[k+1] - T_jacket[k]| ≤ ΔT_jacket,max"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\n**Stability**: The explicit Euler discretization is stable if:\n    dt &lt; 2/λ_max\n\nwhere λ_max is the maximum eigenvalue of the Jacobian.\n\nFor CSTR, typical eigenvalues:\n    λ₁ ≈ -(1/τ + k₀·exp(-E/T))  (concentration dynamics)\n    λ₂ ≈ -(1/τ + UA/(VρCₚ))  (temperature dynamics)\n\nAt high temperature, λ_max can be large (fast dynamics), requiring\nsmall dt for stability.\n\n**Rule of thumb**:\n    dt &lt; 0.1 · min(τ, VρCₚ/UA, 1/(k₀·exp(-E/T)))\n\n**Stiffness**: CSTR is moderately stiff due to:\n- Fast reaction at high temperature\n- Different time scales (concentration vs temperature)\n- Exponential temperature dependence\n\nFor better accuracy, use higher-order discretization:\n        cstr_continuous = ContinuousCSTR(...)\n        cstr_discrete = cstr_continuous.discretize(dt=0.1, method='rk4')\n**Multiple Steady States**: Discrete system inherits multiple equilibria\nfrom continuous system. Simulation starting point determines which\nequilibrium is reached (basin of attraction)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n&gt;&gt;&gt; # Create CSTR with default parameters\n&gt;&gt;&gt; cstr = DiscreteCSTR(dt=0.1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # High conversion steady state (typical operating point)\n&gt;&gt;&gt; x_high = np.array([0.1, 390.0])  # [Low Cₐ, High T]\n&gt;&gt;&gt; u_high = np.array([350.0])  # [Cool jacket temperature]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Verify it's an equilibrium\n&gt;&gt;&gt; x_next = cstr.step(x_high, u_high)\n&gt;&gt;&gt; print(f\"Change: {np.linalg.norm(x_next - x_high):.2e}\")  # Should be small\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simulate with constant cooling\n&gt;&gt;&gt; result = cstr.simulate(\n...     x0=x_high,\n...     u_sequence=np.array([350.0]),  # Constant jacket temp\n...     n_steps=100\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot concentration and temperature\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; fig, axes = plt.subplots(2, 1, figsize=(10, 6))\n&gt;&gt;&gt; axes[0].plot(result['time_steps'] * cstr.dt, result['states'][:, 0])\n&gt;&gt;&gt; axes[0].set_ylabel('Cₐ [mol/L]')\n&gt;&gt;&gt; axes[1].plot(result['time_steps'] * cstr.dt, result['states'][:, 1])\n&gt;&gt;&gt; axes[1].set_ylabel('T [K]')\n&gt;&gt;&gt; axes[1].set_xlabel('Time [s]')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design LQR controller for temperature regulation\n&gt;&gt;&gt; T_setpoint = 390.0\n&gt;&gt;&gt; C_A_setpoint = 0.1\n&gt;&gt;&gt; x_ref = np.array([C_A_setpoint, T_setpoint])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Calculate required jacket temperature for steady state\n&gt;&gt;&gt; # This requires solving energy balance, simplified here\n&gt;&gt;&gt; u_ref = np.array([350.0])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Linearize at operating point\n&gt;&gt;&gt; Ad, Bd = cstr.linearize(x_ref, u_ref)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check discrete stability\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(Ad)\n&gt;&gt;&gt; print(f\"Eigenvalues: {eigenvalues}\")\n&gt;&gt;&gt; print(f\"Stable: {np.all(np.abs(eigenvalues) &lt; 1)}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design LQR (care more about temperature than concentration)\n&gt;&gt;&gt; Q_lqr = np.diag([1.0, 100.0])  # Penalize temperature error heavily\n&gt;&gt;&gt; R_lqr = np.array([[1.0]])\n&gt;&gt;&gt; lqr_result = cstr.control.design_lqr(Ad, Bd, Q_lqr, R_lqr,\n...                                       system_type='discrete')\n&gt;&gt;&gt; K = lqr_result['gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simulate with LQR control\n&gt;&gt;&gt; def lqr_controller(x, k):\n...     return -K @ (x - x_ref) + u_ref\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_lqr = cstr.rollout(x_high, lqr_controller, n_steps=200)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Startup simulation: low conversion → high conversion\n&gt;&gt;&gt; x_low = np.array([0.9, 355.0])  # Low conversion state\n&gt;&gt;&gt;\n&gt;&gt;&gt; def startup_controller(x, k):\n...     # Aggressive cooling to reach high-conversion state\n...     if k &lt; 50:\n...         return np.array([340.0])  # Strong cooling\n...     else:\n...         return lqr_controller(x, k)  # Switch to regulator\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_startup = cstr.rollout(x_low, startup_controller, n_steps=200)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check if startup was successful\n&gt;&gt;&gt; final_state = result_startup['states'][-1, :]\n&gt;&gt;&gt; distance_to_target = np.linalg.norm(final_state - x_ref)\n&gt;&gt;&gt; print(f\"Final state: Cₐ={final_state[0]:.3f}, T={final_state[1]:.1f}\")\n&gt;&gt;&gt; print(f\"Distance to target: {distance_to_target:.3f}\")"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\n**Thermal Runaway Risk**:\nIf cooling is insufficient, positive feedback occurs:\n1. Temperature increases\n2. Reaction rate increases exponentially (Arrhenius)\n3. More heat generated (exothermic)\n4. Temperature increases further → runaway!\n\nPrevention:\n- Adequate cooling capacity (large UA)\n- Temperature limits and alarms\n- Emergency cooling/shutdown procedures\n- Conservative setpoint selection\n\n**Multiple Steady States**:\nCreates control challenges:\n- Which steady state to operate at?\n- How to transition between states?\n- Risk of unintended switching due to disturbances\n- Hysteresis in startup/shutdown procedures\n\n**Residence Time Effects**:\n- Short τ (high F/V): Low conversion, stable, safe\n- Long τ (low F/V): High conversion, less stable, runaway risk\n- Economic optimum: maximize profit subject to stability\n\n**Jacket Temperature Selection**:\n- Lower T_jacket: More cooling, enables higher conversion\n- But: smaller stability margin, closer to bifurcation\n- Higher T_jacket: More stable, but lower conversion\n- Must balance economics and safety\n\n**Startup Strategy**:\nTransitioning from low to high conversion:\n1. Begin at low-conversion state (safe, stable)\n2. Gradually decrease T_jacket (increase cooling)\n3. System may jump to high-conversion state (bifurcation)\n4. Or use aggressive transient cooling\n5. Once at high conversion, switch to regulatory control\n\n**Oscillatory Behavior**:\nNear instability boundaries, system may exhibit:\n- Sustained oscillations (Hopf bifurcation)\n- Limit cycles in Cₐ-T phase plane\n- Period-doubling route to chaos (rare but possible)\n- Quasiperiodic dynamics"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#comparison-with-continuous-version",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#comparison-with-continuous-version",
    "title": "",
    "section": "Comparison with Continuous Version:",
    "text": "Comparison with Continuous Version:\nThis discrete-time CSTR approximates the continuous-time system:\n- Continuous system: dx/dt = f(x, u) (ground truth)\n- Discrete system: x[k+1] = x[k] + dt·f(x[k], u[k]) (Euler approximation)\n\nAdvantages of discrete formulation:\n- Natural for digital control (computers, PLCs)\n- Fixed time step (predictable computation)\n- Easy to implement in simulation\n- Matches physical sampling of sensors\n\nDisadvantages:\n- Approximation error (depends on dt)\n- Stability limited by time step\n- May not capture fast transients accurately\n\nFor better accuracy, create from continuous version:\n    cstr_continuous = ContinuousCSTR(F=100, V=100, ...)\n    cstr_discrete = cstr_continuous.discretize(dt=0.1, method='rk4')"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nContinuousCSTR : Continuous-time version (more accurate)\nDiscreteBatchReactor : Batch operation instead of continuous\nContinuousBatchReactor : Continuous batch reactor"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCSTR.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_conversion\nCompute fractional conversion of reactant A.\n\n\ncompute_damkohler_number\nCompute Damköhler number Da = k·τ (reaction rate × residence time).\n\n\ncompute_residence_time\nCompute residence time τ = V/F.\n\n\ndefine_system\nDefine discrete-time CSTR dynamics.\n\n\nfind_steady_states\nFind all steady states for a given jacket temperature.\n\n\nsetup_equilibria\nSet up steady-state equilibrium if provided.\n\n\n\n\ncompute_conversion\nsystems.builtin.deterministic.discrete.DiscreteCSTR.compute_conversion(\n    C_A,\n    C_A_feed,\n)\nCompute fractional conversion of reactant A.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_A\nfloat\nCurrent reactor concentration [mol/L]\nrequired\n\n\nC_A_feed\nfloat\nFeed concentration [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nConversion fraction X_A = (C_A_feed - C_A) / C_A_feed\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = DiscreteCSTR()\n&gt;&gt;&gt; X = cstr.compute_conversion(C_A=0.1, C_A_feed=1.0)\n&gt;&gt;&gt; print(f\"Conversion: {X*100:.1f}%\")\nConversion: 90.0%\n\n\nNotes\nHigh conversion (X &gt; 0.9) typically corresponds to high-temperature steady state with fast kinetics and strong exothermic heat generation.\n\n\n\ncompute_damkohler_number\nsystems.builtin.deterministic.discrete.DiscreteCSTR.compute_damkohler_number(T)\nCompute Damköhler number Da = k·τ (reaction rate × residence time).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT\nfloat\nTemperature [K]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDamköhler number [dimensionless]\n\n\n\n\n\nNotes\nDamköhler number measures reaction rate relative to flow rate: - Da &lt;&lt; 1: Reaction slow, flow dominates, low conversion - Da &gt;&gt; 1: Reaction fast, kinetics dominate, high conversion - Da ≈ 1: Balanced, optimal efficiency\n\n\nExamples\n&gt;&gt;&gt; cstr = DiscreteCSTR()\n&gt;&gt;&gt; Da_low = cstr.compute_damkohler_number(T=350.0)\n&gt;&gt;&gt; Da_high = cstr.compute_damkohler_number(T=400.0)\n&gt;&gt;&gt; print(f\"Da(350K) = {Da_low:.2f}\")\n&gt;&gt;&gt; print(f\"Da(400K) = {Da_high:.2f}\")\n\n\n\ncompute_residence_time\nsystems.builtin.deterministic.discrete.DiscreteCSTR.compute_residence_time()\nCompute residence time τ = V/F.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nResidence time [s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = DiscreteCSTR(F=100.0, V=100.0)\n&gt;&gt;&gt; tau = cstr.compute_residence_time()\n&gt;&gt;&gt; print(f\"Residence time: {tau} s\")\nResidence time: 1.0 s\n\n\nNotes\nResidence time is the average time a molecule spends in the reactor. - Longer τ (smaller F): More conversion, less stable - Shorter τ (larger F): Less conversion, more stable\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteCSTR.define_system(\n    F_val=100.0,\n    V_val=100.0,\n    C_A_feed_val=1.0,\n    T_feed_val=350.0,\n    k0_val=72000000000.0,\n    E_val=8750.0,\n    delta_H_val=-50000.0,\n    rho_val=1000.0,\n    Cp_val=0.239,\n    UA_val=50000.0,\n    dt=0.1,\n    x_ss=None,\n    u_ss=None,\n)\nDefine discrete-time CSTR dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nF_val\nfloat\nVolumetric flow rate [L/s]\n100.0\n\n\nV_val\nfloat\nReactor volume [L]\n100.0\n\n\nC_A_feed_val\nfloat\nFeed concentration [mol/L]\n1.0\n\n\nT_feed_val\nfloat\nFeed temperature [K]\n350.0\n\n\nk0_val\nfloat\nPre-exponential factor [1/s]\n72000000000.0\n\n\nE_val\nfloat\nActivation energy [K]\n8750.0\n\n\ndelta_H_val\nfloat\nHeat of reaction [J/mol] (negative = exothermic)\n-50000.0\n\n\nrho_val\nfloat\nDensity [kg/L]\n1000.0\n\n\nCp_val\nfloat\nSpecific heat capacity [J/(kg·K)]\n0.239\n\n\nUA_val\nfloat\nOverall heat transfer coefficient × area [J/(s·K)]\n50000.0\n\n\ndt\nfloat\nSampling time step [s]\n0.1\n\n\nx_ss\nOptional[np.ndarray]\nSteady-state [Cₐ, T] for equilibrium setup\nNone\n\n\nu_ss\nOptional[np.ndarray]\nSteady-state [T_jacket] for equilibrium setup\nNone\n\n\n\n\n\n\nfind_steady_states\nsystems.builtin.deterministic.discrete.DiscreteCSTR.find_steady_states(\n    T_jacket,\n    T_range=(300.0, 500.0),\n    n_points=100,\n)\nFind all steady states for a given jacket temperature.\nUses graphical method: plots dC_A/dt and dT/dt as functions of T, finds where both are zero simultaneously.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT_jacket\nfloat\nJacket temperature [K]\nrequired\n\n\nT_range\ntuple\nTemperature range to search (T_min, T_max) [K]\n(300.0, 500.0)\n\n\nn_points\nint\nNumber of points for graphical search\n100\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist\nList of (C_A, T) steady states\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = DiscreteCSTR()\n&gt;&gt;&gt; steady_states = cstr.find_steady_states(T_jacket=350.0)\n&gt;&gt;&gt; print(f\"Found {len(steady_states)} steady states\")\n&gt;&gt;&gt; for i, (C_A, T) in enumerate(steady_states):\n...     print(f\"  State {i+1}: C_A={C_A:.3f}, T={T:.1f}\")\n\n\nNotes\nThis is a simple implementation. For production code, use: - scipy.optimize.fsolve for more robust root finding - Continuation methods for bifurcation analysis - homotopy methods for finding all solutions\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscreteCSTR.setup_equilibria()\nSet up steady-state equilibrium if provided.\n\nNotes\nCSTR can have multiple steady states! Only add user-provided equilibrium. Finding all equilibria requires solving nonlinear algebraic equations (see find_steady_states() method)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA simplified model of atmospheric convection. The system models: - Fluid circulation in a heated layer between two plates - Rate of convective overturning (x) - Horizontal temperature variation (y) - Vertical temperature variation (z)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, y, z] - x: Rate of convective motion [dimensionless] * x &gt; 0: clockwise circulation * x &lt; 0: counterclockwise circulation * Proportional to velocity of fluid flow\n- y: Horizontal temperature variation [dimensionless]\n  * y &gt; 0: warmer on one side\n  * y &lt; 0: warmer on other side\n  * Temperature difference driving convection\n\n- z: Vertical temperature variation from linearity [dimensionless]\n  * z &gt; 0: more stratified (stable)\n  * z &lt; 0: less stratified (unstable)\n  * Deviation from conductive temperature profile\nOutput: y = [x, y] - Partial observation: measures x and y, not z - Models limited sensor availability - Creates observability challenges for state estimation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe Lorenz equations:\nẋ = σ(y - x)\nẏ = x(ρ - z) - y\nż = xy - βz\nFirst equation (convection rate): - σ(y - x): Proportional to temperature difference - σ (sigma): Prandtl number - ratio of viscosity to thermal diffusivity - Drives x toward y at rate σ\nSecond equation (horizontal temperature): - x(ρ - z): Nonlinear coupling - convection affects temperature - ρ (rho): Rayleigh number - ratio of buoyancy to viscous forces - -y: Damping term (heat diffusion) - When z &lt; ρ, convection x amplifies y\nThird equation (vertical temperature): - xy: Nonlinear product - convection creates temperature gradients - -βz: Damping/relaxation toward linear profile - β (beta): Geometric factor (aspect ratio of convection cell)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nsigma : float, default=10.0 Prandtl number [dimensionless]. Ratio of momentum diffusivity (viscosity) to thermal diffusivity. Standard Chaotic Lorenz: σ = 10 Higher σ → faster adjustment of x to y\nrho : float, default=28.0 Rayleigh number [dimensionless]. Measures temperature difference driving convection relative to dissipative effects. Critical values: - ρ &lt; 1: No convection (conduction only) - 1 &lt; ρ &lt; 24.74: Steady convection - ρ &gt; 24.74: Chaotic behavior possible - ρ = 28: Classic chaotic Lorenz attractor Higher ρ → stronger driving force\nbeta : float, default=8/3 Geometric factor [dimensionless]. Related to aspect ratio of convection cell (width/height). Standard value 8/3 ≈ 2.667 gives the classic “butterfly” attractor shape. - Affects dissipation rate in z - Controls attractor shape and size"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nOrigin (unstable for ρ &gt; 1): x_eq = [0, 0, 0] (no convection)\nStable when ρ &lt; 1 (conduction dominates). Unstable when ρ &gt; 1 (convection develops).\nConvective equilibria (for ρ &gt; 1): C+ = [√(β(ρ-1)), √(β(ρ-1)), ρ-1] C- = [-√(β(ρ-1)), -√(β(ρ-1)), ρ-1]\nThese represent steady clockwise (C+) and counterclockwise (C-) convection cells. Both become unstable for ρ &gt; 24.74, leading to chaos."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#behavior-regimes",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#behavior-regimes",
    "title": "",
    "section": "Behavior Regimes:",
    "text": "Behavior Regimes:\n\nρ &lt; 1 (No convection):\n\nOrigin is stable\nAll trajectories decay to zero\nHeat transported by conduction only\n\n1 &lt; ρ &lt; 13.926 (Steady convection):\n\nOrigin becomes unstable\nC+ or C- are stable (bistable system)\nSteady convection cells form\n\n13.926 &lt; ρ &lt; 24.74 (Periodic/complex):\n\nC+ and C- lose stability\nCan have limit cycles or complex behavior\n\nρ &gt; 24.74 (Chaos):\n\nChaotic behavior emerges\nSensitive dependence on initial conditions\nStrange attractor (Lorenz butterfly)\n\nρ = 28 (Classic chaos):\n\nWell-studied chaotic attractor\nFractal structure\nPositive Lyapunov exponent"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#the-lorenz-attractor",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#the-lorenz-attractor",
    "title": "",
    "section": "The Lorenz Attractor:",
    "text": "The Lorenz Attractor:\nFor standard parameters (σ=10, ρ=28, β=8/3): - Shape: Two wing-like lobes (butterfly shape) - Structure: Strange attractor (fractal dimension ≈ 2.06) - Behavior: Trajectories spiral around C+ or C-, occasionally switching between wings - Predictability: Initial condition error doubles ~every 2 time units - Volume contraction: Phase space volume shrinks → dissipative system"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#physical-interpretation",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation:",
    "text": "Physical Interpretation:\n\nx: Velocity of convection roll\ny: Temperature difference between ascending and descending fluid\nz: Deviation from linear temperature profile\nρ: Driving force (heating from below)\nσ: Fluid properties (viscosity vs. thermal conductivity)\nβ: Cell geometry"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Lorenz.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.Lorenz.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDuffingOscillator : Another chaotic system (forced oscillator) VanDerPolOscillator : Limit cycle oscillator NonlinearChainSystem : Coupled oscillators with complex dynamics"
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorBase.html",
    "href": "api/systems.base.numerical_integration.IntegratorBase.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorBase.html#result-types",
    "href": "api/systems.base.numerical_integration.IntegratorBase.html#result-types",
    "title": "",
    "section": "Result Types",
    "text": "Result Types\nAll integrators return IntegrationResult TypedDict with: - t: Time points (T,) - x: State trajectory (T, nx) - success: Integration succeeded - message: Status message - nfev: Number of function evaluations - nsteps: Number of steps taken - integration_time: Computation time - solver: Integrator name"
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorBase.html#examples",
    "href": "api/systems.base.numerical_integration.IntegratorBase.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Create integrator\n&gt;&gt;&gt; integrator = RK4Integrator(system, dt=0.01, backend='numpy')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Single step\n&gt;&gt;&gt; x_next = integrator.step(x, u)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Multi-step integration\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.zeros(1),\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; t, x_traj = result[\"t\"], result[\"x\"]\n&gt;&gt;&gt; print(f\"Integration {'succeeded' if result['success'] else 'failed'}\")\n&gt;&gt;&gt; print(f\"Steps: {result['nsteps']}, Function evals: {result['nfev']}\")"
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorBase.html#attributes",
    "href": "api/systems.base.numerical_integration.IntegratorBase.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nname\nGet integrator name for display and logging."
  },
  {
    "objectID": "api/systems.base.numerical_integration.IntegratorBase.html#methods",
    "href": "api/systems.base.numerical_integration.IntegratorBase.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nget_stats\nGet integration statistics.\n\n\nintegrate\nIntegrate over time interval with control policy.\n\n\nreset_stats\nReset integration statistics to zero.\n\n\nstep\nTake one integration step: x(t) → x(t + dt).\n\n\n\n\nget_stats\nsystems.base.numerical_integration.IntegratorBase.get_stats()\nGet integration statistics.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nStatistics with keys: - ‘total_steps’: Total integration steps taken - ‘total_fev’: Total function evaluations - ‘total_time’: Total integration time - ‘avg_fev_per_step’: Average function evaluations per step\n\n\n\n\n\nExamples\n&gt;&gt;&gt; result = integrator.integrate(x0, u_func, (0, 10))\n&gt;&gt;&gt; stats = integrator.get_stats()\n&gt;&gt;&gt; print(f\"Steps: {stats['total_steps']}\")\n&gt;&gt;&gt; print(f\"Function evals: {stats['total_fev']}\")\n&gt;&gt;&gt; print(f\"Evals/step: {stats['avg_fev_per_step']:.1f}\")\n\n\n\nintegrate\nsystems.base.numerical_integration.IntegratorBase.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n)\nIntegrate over time interval with control policy.\nAPI Level: This is a low-level integration method that directly interfaces with numerical ODE/SDE solvers. For typical use cases, prefer the high-level simulate() method which provides a cleaner interface.\nControl Function Convention: This method uses the scipy/ODE solver convention where control functions have signature (t, x) → u, with time as the FIRST argument. This differs from the high-level simulate() API which uses (x, t) → u with state as the primary argument. The difference is intentional:\n\nLow-level integrate(): Uses (t, x) for direct solver compatibility\nHigh-level simulate(): Uses (x, t) for intuitive control-theoretic API\n\nIf you’re implementing controllers for simulate(), use (x, t) order. If calling integrate() directly, use (t, x) order as shown in the examples below.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nArrayLike\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable[[float, ArrayLike], ArrayLike]\nControl policy with low-level convention: (t, x) → u - t: float - current time (FIRST argument, scipy convention) - x: ArrayLike - current state (SECOND argument) - Returns: ArrayLike - control input u Can be: - Constant control: lambda t, x: u_const - State feedback: lambda t, x: -K @ x - Time-varying: lambda t, x: u(t) - Autonomous: lambda t, x: None\nrequired\n\n\nt_span\nTuple[float, float]\nIntegration interval (t_start, t_end)\nrequired\n\n\nt_eval\nOptional[ArrayLike]\nSpecific times at which to store solution If None: - FIXED mode: Uses t = t_start + k*dt for k=0,1,2,… - ADAPTIVE mode: Uses solver’s internal time points\nNone\n\n\ndense_output\nbool\nIf True, return dense interpolated solution (adaptive only)\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nTypedDict containing: - t: Time points (T,) - x: State trajectory (T, nx) - time-major ordering - success: Whether integration succeeded - message: Status message - nfev: Number of function evaluations - nsteps: Number of steps taken - integration_time: Computation time (seconds) - solver: Integrator name - sol: Dense output object (if dense_output=True)\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nRuntimeError\nIf integration fails (e.g., step size too small, max steps exceeded)\n\n\n\n\n\nExamples\nLow-level integrate() usage (uses (t, x) convention):\nZero control (autonomous):\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,  # Autonomous\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Final state: {result['x'][-1]}\")\nConstant control:\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.array([0.5]),  # Note: (t, x) order\n...     t_span=(0.0, 10.0)\n... )\nState feedback controller (note time-first order):\n&gt;&gt;&gt; K = np.array([[1.0, 2.0]])\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: -K @ x,  # (t, x) order for integrate()\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Function evaluations: {result['nfev']}\")\nTime-varying control:\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.array([np.sin(t)]),  # Time-dependent\n...     t_span=(0.0, 10.0)\n... )\nEvaluate at specific times:\n&gt;&gt;&gt; t_eval = np.linspace(0, 10, 1001)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.zeros(1),\n...     t_span=(0, 10),\n...     t_eval=t_eval\n... )\n&gt;&gt;&gt; assert len(result[\"t\"]) == 1001\nHigh-level simulate() usage (uses (x, t) convention - recommended):\nFor typical use cases, prefer system.simulate() which uses the more intuitive (x, t) convention:\n&gt;&gt;&gt; # Controller with (x, t) order - state is primary\n&gt;&gt;&gt; def controller(x, t):  # Note: (x, t) order for simulate()\n...     K = np.array([[1.0, 2.0]])\n...     return -K @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = system.simulate(\n...     x0=np.array([1.0, 0.0]),\n...     controller=controller,  # Uses (x, t) signature\n...     t_span=(0.0, 10.0),\n...     dt=0.01\n... )\nConverting between conventions:\nIf you have a controller designed for simulate() and need to use integrate():\n&gt;&gt;&gt; # Controller for simulate() - uses (x, t)\n&gt;&gt;&gt; def my_controller(x, t):\n...     return -K @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Wrap for integrate() - convert to (t, x)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=x0,\n...     u_func=lambda t, x: my_controller(x, t),  # Swap argument order\n...     t_span=(0, 10)\n... )\n\n\nNotes\n\nThe (t, x) signature matches scipy.integrate.solve_ivp convention\nThis allows direct compatibility with numerical solver libraries\nThe high-level simulate() method handles the conversion automatically\nMost users should use simulate() instead of calling integrate() directly\n\n\n\nSee Also\nsimulate : High-level simulation with (x, t) controller convention (recommended) step : Single integration step\n\n\n\nreset_stats\nsystems.base.numerical_integration.IntegratorBase.reset_stats()\nReset integration statistics to zero.\n\nExamples\n&gt;&gt;&gt; integrator.reset_stats()\n&gt;&gt;&gt; integrator.get_stats()['total_steps']\n0\n\n\n\nstep\nsystems.base.numerical_integration.IntegratorBase.step(x, u, dt=None)\nTake one integration step: x(t) → x(t + dt).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nArrayLike\nCurrent state (nx,) or (batch, nx)\nrequired\n\n\nu\nArrayLike\nControl input (nu,) or (batch, nu)\nrequired\n\n\ndt\nOptional[float]\nStep size (uses self.dt if None)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nNext state x(t + dt), same shape and type as input\n\n\n\n\n\nNotes\nFor fixed-step integrators, dt should match self.dt. For adaptive integrators, dt may be adjusted internally.\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1.0, 0.0])\n&gt;&gt;&gt; u = np.array([0.5])\n&gt;&gt;&gt; x_next = integrator.step(x, u)\n&gt;&gt;&gt; x_next.shape\n(2,)"
  },
  {
    "objectID": "api/types.core.StateVector.html",
    "href": "api/types.core.StateVector.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.StateVector.html#examples",
    "href": "api/types.core.StateVector.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Single state\n&gt;&gt;&gt; x: StateVector = np.array([1.0, 0.0, 0.5])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Batched (100 states)\n&gt;&gt;&gt; x_batch: StateVector = np.random.randn(100, 3)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Trajectory (101 time steps)\n&gt;&gt;&gt; x_traj: StateVector = np.random.randn(101, 3)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA point mass attached to a massless rigid rod, free to rotate about a fixed pivot. The pendulum experiences: - Gravitational torque (proportional to sin(θ)) - Viscous damping (proportional to angular velocity) - External control torque"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [θ, θ̇] - θ (theta): Angular position from upward vertical [rad] * θ = 0: upright (unstable equilibrium) * θ = π: hanging down (stable equilibrium) - θ̇ (theta_dot): Angular velocity [rad/s]\nControl: u = [τ] - τ (torque): Applied torque at pivot [N⋅m]\nOutput: y = [θ] - Measures only the angle (partial observation)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe equations of motion are: θ̇ = θ̇ θ̈ = -(β/I)θ̇ + (g/l)sin(θ) + τ/I\nwhere I = ml² is the moment of inertia.\nRewritten as first-order system: dx/dt = [θ̇, -(β/ml²)θ̇ + (g/l)sin(θ) + τ/(ml²)]ᵀ"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.SymbolicPendulum.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm : float, default=1.0 Mass of the bob [kg]. Larger mass → more inertia, slower response. l : float, default=1.0 Length of the rod [m]. Longer rod → more gravity torque, slower dynamics. beta : float, default=1.0 Damping coefficient [N⋅m⋅s/rad]. Larger β → more energy dissipation. g : float, default=9.81 Gravitational acceleration [m/s²]."
  },
  {
    "objectID": "api/systems.base.core.ContinuousSystemBase.html",
    "href": "api/systems.base.core.ContinuousSystemBase.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.ContinuousSystemBase.html#examples",
    "href": "api/systems.base.core.ContinuousSystemBase.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; class MyODESystem(ContinuousSystemBase):\n...     def __call__(self, x, u=None, t=0.0):\n...         return -x + (u if u is not None else 0.0)\n...\n...     def integrate(self, x0, u, t_span, method=\"RK45\", **kwargs):\n...         # Use scipy.integrate.solve_ivp or similar\n...         result = solve_ivp(...)\n...         return {\n...             \"t\": result.t,\n...             \"y\": result.y,\n...             \"success\": result.success,\n...             \"nfev\": result.nfev,\n...             ...\n...         }\n...\n...     def linearize(self, x_eq, u_eq):\n...         A = -np.eye(self.nx)\n...         B = np.eye(self.nx, self.nu)\n...         return (A, B)"
  },
  {
    "objectID": "api/systems.base.core.ContinuousSystemBase.html#attributes",
    "href": "api/systems.base.core.ContinuousSystemBase.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nanalysis\nAccess system analysis utilities.\n\n\ncontrol\nAccess control synthesis utilities.\n\n\ncontrol_plotter\nAccess control system analysis plotting utilities.\n\n\nis_continuous\nReturn True (this is a continuous-time system).\n\n\nis_discrete\nReturn False (this is NOT a discrete-time system).\n\n\nis_stochastic\nReturn True if system has stochastic dynamics.\n\n\nis_time_varying\nReturn True if system dynamics depend explicitly on time.\n\n\nphase_plotter\nAccess phase portrait plotting utilities.\n\n\nplotter\nAccess trajectory plotting utilities."
  },
  {
    "objectID": "api/systems.base.core.ContinuousSystemBase.html#methods",
    "href": "api/systems.base.core.ContinuousSystemBase.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nintegrate\nLow-level numerical integration with ODE solver diagnostics.\n\n\nlinearize\nCompute linearized dynamics around an equilibrium point.\n\n\nplot\nPlot integration result (convenience method).\n\n\nrollout\nRollout system trajectory with optional state-feedback policy.\n\n\nsimulate\nHigh-level simulation interface with regular time grid.\n\n\n\n\nintegrate\nsystems.base.core.ContinuousSystemBase.integrate(\n    x0,\n    u=None,\n    t_span=(0.0, 10.0),\n    method='RK45',\n    **integrator_kwargs,\n)\nLow-level numerical integration with ODE solver diagnostics.\nNumerically solve the initial value problem: dx/dt = f(x, u, t) x(t0) = x0\nAPI Level: This is a low-level integration method that exposes raw solver output including adaptive time points, convergence information, and performance metrics. For typical use cases, prefer simulate() which provides a cleaner interface with regular time grids and the intuitive (x, t) controller convention.\nControl Input Handling: This method accepts flexible control input formats and automatically converts them to the internal (t, x) → u function signature expected by numerical solvers. You can provide: - None for autonomous/zero control - Arrays for constant control - Functions with various signatures (see below)\nThe conversion to solver convention is handled internally - you don’t need to worry about the (t, x) vs (x, t) distinction at this level.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu\nUnion[ControlVector, Callable[[float], ControlVector], None]\nControl input in flexible formats: - None: Zero control or autonomous system - Array (nu,): Constant control u(t) = u_const for all t - Callable u(t): Time-varying control, signature: t → u - Callable u(t, x): State-feedback control (auto-detected) - Callable u(x, t): State-feedback control (auto-detected) The method will automatically detect the function signature and convert to the internal (t, x) → u convention used by solvers. For callables with two parameters, it attempts to detect the order by inspecting parameter names or testing with dummy values. Standard Convention: Functions with two parameters should use (t, x) order to avoid ambiguity. If using (x, t) order, the wrapper will attempt detection but may fail on edge cases - prefer wrapping explicitly: &gt;&gt;&gt; u_func = lambda t, x: my_controller(x, t)\nNone\n\n\nt_span\ntuple[float, float]\nTime interval (t_start, t_end)\n(0.0, 10.0)\n\n\nmethod\nstr\nIntegration method. Options:\n'RK45'\n\n\n**integrator_kwargs\n\nAdditional arguments passed to the ODE solver: - dt : float (required for fixed-step methods) - rtol : float (relative tolerance, default: 1e-6) - atol : float (absolute tolerance, default: 1e-8) - max_steps : int (maximum steps, default: 10000) - t_eval : ArrayLike (specific times to return solution) - dense_output : bool (return interpolant, default: False) - first_step : float (initial step size guess) - max_step : float (maximum step size)\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nTypedDict containing: - t: Time points (T,) - adaptive, chosen by solver - x or y: State trajectory - scipy returns ‘y’ with shape (nx, T) - other backends return ‘x’ with shape (T, nx) - success: bool - whether integration succeeded - message: str - solver status message - nfev: int - number of function evaluations - nsteps: int - number of steps taken - integration_time: float - computation time (seconds) - solver: str - integrator name used - njev: int - number of Jacobian evaluations (if applicable) - nlu: int - number of LU decompositions (implicit methods) - status: int - termination status code\n\n\n\n\n\nNotes\nAdaptive Time Points: The time points in the result are chosen adaptively by the solver based on error control, NOT on a regular grid. This means: - Solver takes larger steps when dynamics are smooth - Solver takes smaller steps when dynamics change rapidly - Time points are NOT uniformly spaced\nFor a regular time grid suitable for plotting or analysis, use simulate() instead, or provide t_eval parameter.\nBackend Differences: - scipy: Returns ‘y’ with shape (nx, T) - state-major - torchdiffeq/diffrax: Return ‘x’ with shape (T, nx) - time-major - This method handles both conventions automatically in simulate()\n\n\nExamples\nBasic usage - autonomous system:\n&gt;&gt;&gt; x0 = np.array([1.0, 0.0])\n&gt;&gt;&gt; result = system.integrate(x0, u=None, t_span=(0, 10))\n&gt;&gt;&gt; print(f\"Success: {result['success']}\")\n&gt;&gt;&gt; print(f\"Function evaluations: {result['nfev']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Handle both scipy and other backends\n&gt;&gt;&gt; if 'y' in result:\n&gt;&gt;&gt;     trajectory = result['y']  # scipy: (nx, T)\n&gt;&gt;&gt;     plt.plot(result['t'], trajectory[0, :])\n&gt;&gt;&gt; else:\n&gt;&gt;&gt;     trajectory = result['x']  # others: (T, nx)\n&gt;&gt;&gt;     plt.plot(result['t'], trajectory[:, 0])\nConstant control:\n&gt;&gt;&gt; u_const = np.array([0.5])\n&gt;&gt;&gt; result = system.integrate(x0, u=u_const, t_span=(0, 10))\nTime-varying control - single parameter function:\n&gt;&gt;&gt; def u_func(t):\n...     return np.array([np.sin(t)])\n&gt;&gt;&gt; result = system.integrate(x0, u=u_func, t_span=(0, 10))\nState feedback - two parameter function (auto-detected):\n&gt;&gt;&gt; def u_func(t, x):\n...     K = np.array([[1.0, 2.0]])\n...     return -K @ x\n&gt;&gt;&gt; result = system.integrate(x0, u=u_func, t_span=(0, 10))\nStiff system with tight tolerances:\n&gt;&gt;&gt; result = system.integrate(\n...     x0,\n...     u=None,\n...     t_span=(0, 10),\n...     method='Radau',\n...     rtol=1e-8,\n...     atol=1e-10\n... )\n&gt;&gt;&gt; print(f\"Stiff solver steps: {result['nsteps']}\")\nHigh-accuracy Julia solver:\n&gt;&gt;&gt; result = system.integrate(\n...     x0,\n...     u=None,\n...     t_span=(0, 10),\n...     method='Vern9',  # Julia high-accuracy\n...     rtol=1e-12,\n...     atol=1e-14\n... )\nRegular time grid for plotting:\n&gt;&gt;&gt; t_eval = np.linspace(0, 10, 1001)  # 1001 points\n&gt;&gt;&gt; result = system.integrate(\n...     x0,\n...     u=None,\n...     t_span=(0, 10),\n...     t_eval=t_eval\n... )\n&gt;&gt;&gt; assert len(result['t']) == 1001\nFixed-step integration (RK4):\n&gt;&gt;&gt; result = system.integrate(\n...     x0,\n...     u=None,\n...     t_span=(0, 10),\n...     method='rk4',\n...     dt=0.01  # Required for fixed-step\n... )\nCheck solver performance:\n&gt;&gt;&gt; result = system.integrate(x0, u=None, t_span=(0, 10))\n&gt;&gt;&gt; if result['nfev'] &gt; 10000:\n...     print(\"⚠ Warning: Many function evaluations!\")\n...     print(\"Consider:\")\n...     print(\"  - Using stiff solver (Radau, BDF)\")\n...     print(\"  - Relaxing tolerances\")\n...     print(\"  - Checking for stiffness\")\nDense output (interpolation):\n&gt;&gt;&gt; result = system.integrate(\n...     x0,\n...     u=None,\n...     t_span=(0, 10),\n...     dense_output=True\n... )\n&gt;&gt;&gt; if 'sol' in result:\n...     # Evaluate at arbitrary times\n...     t_fine = np.linspace(0, 10, 10000)\n...     x_fine = result['sol'](t_fine)\nComparing backends:\n&gt;&gt;&gt; # NumPy (scipy)\n&gt;&gt;&gt; result_np = system.integrate(x0, u=None, t_span=(0, 10), method='RK45')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Julia (DiffEqPy)\n&gt;&gt;&gt; result_jl = system.integrate(x0, u=None, t_span=(0, 10), method='Tsit5')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # JAX (diffrax)\n&gt;&gt;&gt; system.set_default_backend('jax')\n&gt;&gt;&gt; result_jax = system.integrate(x0, u=None, t_span=(0, 10), method='tsit5')\nError handling:\n&gt;&gt;&gt; try:\n...     result = system.integrate(\n...         x0,\n...         u=None,\n...         t_span=(0, 10),\n...         method='RK45',\n...         max_steps=100  # Very low limit\n...     )\n...     if not result['success']:\n...         print(f\"Integration failed: {result['message']}\")\n... except RuntimeError as e:\n...     print(f\"Runtime error: {e}\")\n\n\nSee Also\nsimulate : High-level simulation with regular time grid (recommended) IntegratorFactory : Create custom integrators with specific methods linearize : Compute linearized dynamics at equilibrium\n\n\n\nlinearize\nsystems.base.core.ContinuousSystemBase.linearize(x_eq, u_eq=None)\nCompute linearized dynamics around an equilibrium point.\nFor a continuous-time system dx/dt = f(x, u), compute the linearization: d(δx)/dt = A·δx + B·δu\nwhere: A = ∂f/∂x|(x_eq, u_eq) (State Jacobian, nx × nx) B = ∂f/∂u|(x_eq, u_eq) (Control Jacobian, nx × nu)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control (nu,) If None, uses zero control\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nLinearizationResult\nTuple containing Jacobian matrices: - Deterministic systems: (A, B) - Stochastic systems: (A, B, G) where G is diffusion matrix\n\n\n\n\n\nNotes\nThe linearization is valid for small deviations from the equilibrium: δx = x - x_eq δu = u - u_eq\nFor symbolic systems, Jacobians are computed symbolically then evaluated. For data-driven systems, Jacobians may be computed via finite differences or automatic differentiation.\nThe equilibrium point should satisfy f(x_eq, u_eq) ≈ 0 (within tolerance).\n\n\nExamples\nLinearize at origin:\n&gt;&gt;&gt; x_eq = np.zeros(2)\n&gt;&gt;&gt; u_eq = np.zeros(1)\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; print(f\"A matrix:\\n{A}\")\n&gt;&gt;&gt; print(f\"B matrix:\\n{B}\")\nCheck stability (continuous-time):\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(A)\n&gt;&gt;&gt; is_stable = np.all(np.real(eigenvalues) &lt; 0)\n&gt;&gt;&gt; print(f\"System stable: {is_stable}\")\nDesign LQR controller:\n&gt;&gt;&gt; from scipy.linalg import solve_continuous_are\n&gt;&gt;&gt; P = solve_continuous_are(A, B, Q, R)\n&gt;&gt;&gt; K = np.linalg.inv(R) @ B.T @ P\n\n\n\nplot\nsystems.base.core.ContinuousSystemBase.plot(result, state_names=None, **kwargs)\nPlot integration result (convenience method).\nWrapper around plotter.plot_trajectory() for quick visualization of continuous-time integration results.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nresult\nIntegrationResult\nIntegration result dictionary with ‘t’ and ‘x’ keys from integrate() or simulate()\nrequired\n\n\nstate_names\nOptional[list]\nNames for state variables (e.g., [‘Position’, ‘Velocity’]) If None, uses generic labels [‘x₁’, ‘x₂’, …]\nNone\n\n\n**kwargs\n\nAdditional arguments passed to plot_trajectory(): - title : str - Plot title - color_scheme : str - Color scheme name - show_legend : bool - Show legend for batched trajectories\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nInteractive Plotly figure object\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Simple usage\n&gt;&gt;&gt; result = system.integrate(x0, u=None, t_span=(0, 10))\n&gt;&gt;&gt; fig = system.plot(result)\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With state names and custom title\n&gt;&gt;&gt; fig = system.plot(\n...     result,\n...     state_names=['θ', 'ω'],\n...     title='Pendulum Dynamics'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Export to HTML\n&gt;&gt;&gt; fig.write_html('simulation.html')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply publication theme\n&gt;&gt;&gt; from controldesymulation.visualization.themes import PlotThemes\n&gt;&gt;&gt; fig = system.plot(result)\n&gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme='publication')\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Batched trajectories (Monte Carlo for stochastic systems)\n&gt;&gt;&gt; results = []\n&gt;&gt;&gt; for trial in range(10):\n...     results.append(system.integrate(x0, u=None, t_span=(0, 10)))\n&gt;&gt;&gt; x_batch = np.stack([r['x'] for r in results])\n&gt;&gt;&gt; result_batch = {'t': results[0]['t'], 'x': x_batch}\n&gt;&gt;&gt; fig = system.plot(result_batch)  # Plots all 10 trajectories\n\n\nSee Also\nplotter.plot_trajectory : Full trajectory plotting method plotter.plot_state_and_control : Plot states and controls together phase_plotter.plot_2d : Phase space visualization control_plotter : Control analysis plots\n\n\nNotes\nThis is a convenience wrapper that: - Extracts time and state from result dictionary - Calls plotter.plot_trajectory() with appropriate arguments - Returns Plotly figure for further customization\nFor more control over plotting, use plotter methods directly.\n\n\n\nrollout\nsystems.base.core.ContinuousSystemBase.rollout(\n    x0,\n    policy=None,\n    t_span=(0.0, 10.0),\n    dt=0.01,\n    method='RK45',\n    **kwargs,\n)\nRollout system trajectory with optional state-feedback policy.\nThis is an alias for simulate() that provides API consistency with discrete systems. The name “rollout” is commonly used in reinforcement learning and control theory for executing a policy over time.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\npolicy\nOptional[Callable[[StateVector, float], ControlVector]]\nState-feedback policy u = policy(x, t) STANDARD CONVENTION: State is primary argument, time is secondary If None, uses zero control (open-loop)\nNone\n\n\nt_span\ntuple[float, float]\nSimulation time interval (t_start, t_end)\n(0.0, 10.0)\n\n\ndt\nfloat\nOutput time step for regular grid (default: 0.01)\n0.01\n\n\nmethod\nstr\nIntegration method passed to integrate()\n'RK45'\n\n\n**kwargs\n\nAdditional arguments passed to integrate()\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSimulationResult\nTypedDict containing: - time: Time points array (T,) with uniform spacing dt - states: State trajectory (T, nx) - TIME-MAJOR ordering - controls: Control trajectory (T, nu) if policy provided - metadata: Additional information with ‘closed_loop’ flag\n\n\n\n\n\nNotes\nAPI Consistency: This method provides the same interface as DiscreteSystemBase.rollout(), making it easier to work with both continuous and discrete systems using identical code patterns.\nThe only difference from simulate() is: - Parameter name: “policy” instead of “controller” (same semantics) - Metadata includes ‘closed_loop’ flag for compatibility - Name emphasizes trajectory generation with state feedback\nWhen to Use: - Use rollout() when emphasizing policy execution (RL/control context) - Use simulate() for general-purpose simulation - Both methods are functionally equivalent for continuous systems\n\n\nPolicy Signature\nPolicies must have signature (x, t) -&gt; u: - x: StateVector - current state (PRIMARY argument) - t: float - current time (secondary argument) - Returns: ControlVector - control input\n\n\nExamples\nOpen-loop rollout:\n&gt;&gt;&gt; result = system.rollout(x0, t_span=(0, 10), dt=0.01)\n&gt;&gt;&gt; plt.plot(result[\"time\"], result[\"states\"][:, 0])\nState feedback policy (LQR):\n&gt;&gt;&gt; K = np.array([[-1.0, -2.0]])  # LQR gain\n&gt;&gt;&gt; def policy(x, t):\n...     return -K @ x\n&gt;&gt;&gt; result = system.rollout(x0, policy, t_span=(0, 10))\nTime-varying policy with reference:\n&gt;&gt;&gt; x_ref_func = lambda t: np.array([np.sin(t), np.cos(t)])\n&gt;&gt;&gt; def policy(x, t):\n...     x_ref = x_ref_func(t)\n...     K = np.array([[1.0, 0.5]])\n...     return K @ (x_ref - x)\n&gt;&gt;&gt; result = system.rollout(x0, policy, t_span=(0, 10))\nNonlinear policy (e.g., neural network):\n&gt;&gt;&gt; def neural_policy(x, t):\n...     # Example: simple nonlinear policy\n...     hidden = np.tanh(W1 @ x + b1)\n...     u = W2 @ hidden + b2\n...     return u\n&gt;&gt;&gt; result = system.rollout(x0, neural_policy, t_span=(0, 5))\nMPC-style receding horizon:\n&gt;&gt;&gt; def mpc_policy(x, t):\n...     # Solve optimization at each step\n...     u_opt = solve_mpc(x, horizon=10, Q=Q, R=R)\n...     return u_opt\n&gt;&gt;&gt; result = system.rollout(x0, mpc_policy, t_span=(0, 10), dt=0.1)\nComparing policies:\n&gt;&gt;&gt; policies = {\n...     \"LQR\": lqr_policy,\n...     \"MPC\": mpc_policy,\n...     \"Neural\": neural_policy\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; results = {}\n&gt;&gt;&gt; for name, policy in policies.items():\n...     results[name] = system.rollout(x0, policy, t_span=(0, 10))\n...\n&gt;&gt;&gt; # Plot comparison\n&gt;&gt;&gt; for name, result in results.items():\n...     plt.plot(result[\"time\"], result[\"states\"][:, 0], label=name)\n&gt;&gt;&gt; plt.legend()\nTrajectory optimization context:\n&gt;&gt;&gt; # Generate initial trajectory\n&gt;&gt;&gt; result = system.rollout(x0, initial_policy, t_span=(0, 5))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract trajectory for optimization\n&gt;&gt;&gt; trajectory = result[\"states\"]  # (T, nx)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Optimize policy\n&gt;&gt;&gt; optimized_policy = optimize_policy(trajectory)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Re-rollout with optimized policy\n&gt;&gt;&gt; final_result = system.rollout(x0, optimized_policy, t_span=(0, 5))\nReinforcement learning context:\n&gt;&gt;&gt; # Collect rollout for policy gradient\n&gt;&gt;&gt; def stochastic_policy(x, t):\n...     mu = policy_network(x)\n...     u = mu + np.random.randn(*mu.shape) * sigma\n...     return u\n&gt;&gt;&gt;\n&gt;&gt;&gt; rollouts = []\n&gt;&gt;&gt; for episode in range(num_episodes):\n...     result = system.rollout(x0, stochastic_policy, t_span=(0, 10))\n...     reward = compute_reward(result[\"states\"], result[\"controls\"])\n...     rollouts.append((result, reward))\nMonte Carlo evaluation:\n&gt;&gt;&gt; # Evaluate policy robustness\n&gt;&gt;&gt; results = []\n&gt;&gt;&gt; for _ in range(100):\n...     x0_perturbed = x0 + np.random.randn(len(x0)) * 0.1\n...     result = system.rollout(x0_perturbed, policy, t_span=(0, 10))\n...     results.append(result)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Analyze performance distribution\n&gt;&gt;&gt; final_errors = [np.linalg.norm(r[\"states\"][-1, :]) for r in results]\n&gt;&gt;&gt; print(f\"Mean final error: {np.mean(final_errors):.3f}\")\n&gt;&gt;&gt; print(f\"Std final error: {np.std(final_errors):.3f}\")\nUsing metadata closed_loop flag:\n&gt;&gt;&gt; result = system.rollout(x0, policy, t_span=(0, 10))\n&gt;&gt;&gt; if result[\"metadata\"][\"closed_loop\"]:\n...     print(\"Closed-loop rollout with state feedback\")\n... else:\n...     print(\"Open-loop rollout\")\n\n\nSee Also\nsimulate : Equivalent method with “controller” parameter name integrate : Low-level integration with solver diagnostics DiscreteSystemBase.rollout : Discrete-time analog\n\n\n\nsimulate\nsystems.base.core.ContinuousSystemBase.simulate(\n    x0,\n    controller=None,\n    t_span=(0.0, 10.0),\n    dt=0.01,\n    method='RK45',\n    **kwargs,\n)\nHigh-level simulation interface with regular time grid.\nThis method wraps integrate() and post-processes the result to provide a regular time grid and cleaner output. This is the recommended method for most use cases (currently, may be deprecated once DiscretizedSystem is developed).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\ncontroller\nOptional[Callable[[StateVector, float], ControlVector]]\nFeedback controller u = controller(x, t) STANDARD CONVENTION: State is primary argument, time is secondary This aligns with discrete systems’ policy(x, k) signature If None, uses zero control (open-loop)\nNone\n\n\nt_span\ntuple[float, float]\nSimulation time interval (t_start, t_end)\n(0.0, 10.0)\n\n\ndt\nfloat\nOutput time step for regular grid (default: 0.01)\n0.01\n\n\nmethod\nstr\nIntegration method passed to integrate()\n'RK45'\n\n\n**kwargs\n\nAdditional arguments passed to integrate()\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSimulationResult\nTypedDict containing: - time: Time points array (T,) with uniform spacing dt - states: State trajectory (T, nx) - TIME-MAJOR ordering - controls: Control trajectory (T, nu) if controller provided - metadata: Additional information (method, dt, success, nfev)\n\n\n\n\n\nNotes\nTime-Major Convention: This method returns states in (T, nx) shape, which is the modern standard for time series data: - Compatible with pandas DataFrames - Natural for time-series analysis - Consistent with ML/data science conventions - Matches discrete systems’ output format\nUnlike integrate(), this method: - Returns states on a regular time grid (not adaptive) - Supports state-feedback controllers - Hides solver diagnostics (cleaner output) - Is easier to use for plotting and analysis\n\n\nController Signature\nControllers must have signature (x, t) -&gt; u: - x: StateVector - current state (PRIMARY argument) - t: float - current time (secondary argument) - Returns: ControlVector - control input\nThis matches the discrete systems’ policy(x, k) convention where state is the primary argument. An internal adapter converts to scipy’s (t, x) convention when calling integrate().\n\n\nExamples\nOpen-loop simulation:\n&gt;&gt;&gt; result = system.simulate(x0, t_span=(0, 5), dt=0.01)\n&gt;&gt;&gt; # Time-major indexing\n&gt;&gt;&gt; plt.plot(result[\"time\"], result[\"states\"][:, 0])  # First state\n&gt;&gt;&gt; plt.plot(result[\"time\"], result[\"states\"][:, 1])  # Second state\n&gt;&gt;&gt; plt.xlabel(\"Time (s)\")\n&gt;&gt;&gt; plt.ylabel(\"State\")\nUsing with pandas (natural with time-major):\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\n&gt;&gt;&gt; df = pd.DataFrame(\n...     result[\"states\"],\n...     index=result[\"time\"],\n...     columns=[f\"x{i}\" for i in range(system.nx)]\n... )\n&gt;&gt;&gt; df.plot()\nClosed-loop with state feedback:\n&gt;&gt;&gt; K = np.array([[-1.0, -2.0]])  # LQR gain\n&gt;&gt;&gt; def controller(x, t):\n...     return -K @ x\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 5))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract trajectory\n&gt;&gt;&gt; t = result[\"time\"]\n&gt;&gt;&gt; x = result[\"states\"]  # (T, nx)\n&gt;&gt;&gt; u = result[\"controls\"]  # (T, nu)\nTime-varying reference tracking:\n&gt;&gt;&gt; def controller(x, t):\n...     x_ref = np.array([np.sin(t), np.cos(t)])\n...     K = np.array([[1.0, 0.5]])\n...     return K @ (x_ref - x)\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\nAdaptive gain controller:\n&gt;&gt;&gt; def controller(x, t):\n...     K = 1.0 + 0.1 * t  # Gain increases with time\n...     return np.array([-K * x[0]])\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\nSaturated control:\n&gt;&gt;&gt; def controller(x, t):\n...     u_raw = -2.0 * x[0] - 0.5 * x[1]\n...     return np.array([np.clip(u_raw, -1.0, 1.0)])\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\nTime-only control (uncommon, but supported):\n&gt;&gt;&gt; def controller(x, t):\n...     return np.array([np.sin(2 * np.pi * t)])\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\nBatch plotting multiple states:\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\n&gt;&gt;&gt; fig, axes = plt.subplots(system.nx, 1, sharex=True)\n&gt;&gt;&gt; for i, ax in enumerate(axes):\n...     ax.plot(result[\"time\"], result[\"states\"][:, i])\n...     ax.set_ylabel(f\"$x_{i}$\")\n&gt;&gt;&gt; axes[-1].set_xlabel(\"Time (s)\")\nPhase portrait (using time-major indexing):\n&gt;&gt;&gt; result = system.simulate(x0, controller, t_span=(0, 10))\n&gt;&gt;&gt; plt.plot(result[\"states\"][:, 0], result[\"states\"][:, 1])\n&gt;&gt;&gt; plt.xlabel(\"$x_0$\")\n&gt;&gt;&gt; plt.ylabel(\"$x_1$\")\n\n\nSee Also\nintegrate : Low-level integration with solver diagnostics rollout : Alternative name for simulation"
  },
  {
    "objectID": "api/types.trajectories.IntegrationResult.html",
    "href": "api/types.trajectories.IntegrationResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.IntegrationResult.html#shape-convention",
    "href": "api/types.trajectories.IntegrationResult.html#shape-convention",
    "title": "",
    "section": "Shape Convention",
    "text": "Shape Convention\nTime-major ordering for easy analysis and plotting: - t: (T,) - Time points - x: (T, nx) - State at each time point\nThis differs from scipy’s (nx, T) convention but is more natural for analysis: x[:, i] gives i-th component over time."
  },
  {
    "objectID": "api/types.trajectories.IntegrationResult.html#attributes",
    "href": "api/types.trajectories.IntegrationResult.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nt\nArrayLike\nTime points (T,)\n\n\nx\nArrayLike\nState trajectory (T, nx) - time-major ordering\n\n\nsuccess\nbool\nWhether integration succeeded\n\n\nmessage\nstr\nStatus message\n\n\nnfev\nint\nNumber of function evaluations\n\n\nnsteps\nint\nNumber of integration steps\n\n\nintegration_time\nfloat\nComputation time in seconds\n\n\nsolver\nstr\nName of solver used"
  },
  {
    "objectID": "api/types.trajectories.IntegrationResult.html#optional-fields",
    "href": "api/types.trajectories.IntegrationResult.html#optional-fields",
    "title": "",
    "section": "Optional Fields",
    "text": "Optional Fields\nnjev : int Number of Jacobian evaluations nlu : int Number of LU decompositions status : int Solver-specific status code sol : Any Dense output object (solver-specific) dense_output : bool Whether dense output is available"
  },
  {
    "objectID": "api/types.trajectories.IntegrationResult.html#examples",
    "href": "api/types.trajectories.IntegrationResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Integrate system\n&gt;&gt;&gt; result: IntegrationResult = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: np.zeros(1),\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Access results\n&gt;&gt;&gt; t = result[\"t\"]        # Time points (T,)\n&gt;&gt;&gt; x = result[\"x\"]        # States (T, nx)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot first state component\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(t, x[:, 0], label='x1')\n&gt;&gt;&gt; plt.plot(t, x[:, 1], label='x2')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check success\n&gt;&gt;&gt; if result[\"success\"]:\n...     print(f\"Completed in {result['integration_time']:.3f}s\")\n...     print(f\"Function evals: {result['nfev']}\")"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nThe logistic map was introduced by Robert May in 1976 as a discrete-time model for population dynamics with limited resources. It represents the simplest nonlinear difference equation exhibiting complex behavior.\nBiological Interpretation: Consider a population with: - x[k]: Population at generation k (normalized: 0 ≤ x ≤ 1) * x = 0: Extinction * x = 1: Maximum carrying capacity * x = 0.5: Half of carrying capacity\n\nr: Growth rate parameter (0 ≤ r ≤ 4)\n\nControls reproduction rate\nHigher r → faster growth\nToo high r → instability, chaos\n\n\nThe dynamics capture: 1. Reproduction: r·x[k] term (proportional to population) 2. Competition: -r·x[k]² term (limited resources) 3. Net growth: Balance between birth and death\nDiscrete Time Steps: Unlike continuous models (differential equations), the logistic map assumes discrete generations with no overlap. This is appropriate for: - Insects with distinct seasonal generations - Annual plants - Laboratory populations with controlled breeding - Economic cycles with discrete time periods - Digital sampling of continuous processes\nThe Remarkable Complexity: Despite having only ONE parameter (r) and ONE state variable (x), the logistic map exhibits virtually all known behaviors of dynamical systems: - Fixed points (equilibria) - Periodic orbits (period-2, 4, 8, 16, …) - Period-doubling cascades - Deterministic chaos - Intermittency - Crises and sudden changes - Strange attractors\nThis makes it a “Rosetta Stone” for understanding nonlinear dynamics."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] ∈ [0, 1] Population fraction: - x[k] = 0: Extinction - x[k] = 1: Maximum capacity - 0 &lt; x[k] &lt; 1: Viable population\n**Physical meaning:**\nIf N_max is carrying capacity, actual population is:\n    N[k] = x[k]·N_max\nControl: u[k] (optional, for controlled logistic map) - Can represent: * Harvesting/culling: u &lt; 0 * Stocking/immigration: u &gt; 0 * Environmental intervention - Standard logistic map: u = 0 (autonomous)\nOutput: y[k] = x[k] - Direct observation of population fraction - In practice, population counts with measurement noise"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#dynamics",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe defining equation is deceptively simple:\nx[k+1] = r·x[k]·(1 - x[k])\nMathematical Properties:\n\nQuadratic map:\n\nSecond-order polynomial\nSingle hump (inverted parabola)\nMaximum at x = 0.5: f(0.5) = r/4\n\nBounded dynamics:\n\nIf x[0] ∈ [0, 1], then x[k] ∈ [0, 1] for all k (when r ≤ 4)\nInvariant interval: [0, 1]\nEscape possible if r &gt; 4\n\nTwo fixed points: Setting x[k+1] = x[k]: x* = r·x·(1 - x)\nSolutions: x₁* = 0 (extinction) x₂* = 1 - 1/r (nontrivial equilibrium)\nStability via eigenvalue: The Jacobian is just a scalar: λ(x*) = df/dx|_{x} = r·(1 - 2x)\nFixed point is stable if |λ| &lt; 1."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nr : float, default=3.5 Growth rate parameter (must satisfy 0 &lt; r ≤ 4 for bounded dynamics)\n**Parameter Regimes:**\n\n**0 &lt; r &lt; 1:**\n- Extinction regime\n- All initial conditions → 0\n- Both fixed points unstable or non-existent\n- Not biologically realistic (population dies out)\n\n**1 ≤ r &lt; 3:**\n- Stable fixed point regime\n- Population converges to x* = 1 - 1/r\n- Monotonic approach (no oscillations)\n- λ = r·(1 - 2x*) = 2 - r\n- |λ| &lt; 1 requires r &lt; 3\n\n**3 ≤ r &lt; 1 + √6 ≈ 3.449:**\n- Period-2 oscillations\n- Fixed point becomes unstable (|λ| &gt; 1)\n- Population oscillates between two values\n- First period-doubling bifurcation at r = 3\n\n**3.449 &lt; r &lt; 3.544:**\n- Period-doubling cascade\n- Period-4, 8, 16, 32, ... orbits\n- Feigenbaum cascade to chaos\n- Each bifurcation occurs at specific r values\n- Spacing between bifurcations decreases geometrically\n\n**3.544 &lt; r &lt; 3.569:**\n- Onset of chaos\n- Aperiodic, bounded, deterministic behavior\n- Sensitive dependence on initial conditions\n- Strange attractor forms\n- Lyapunov exponent becomes positive\n\n**3.569 &lt; r &lt; 4:**\n- Fully developed chaos with periodic windows\n- Period-3 window at r ≈ 3.83 (remarkable!)\n- Li-Yorke theorem: period-3 implies chaos\n- Infinitely many periodic windows\n- Fractal structure in bifurcation diagram\n\n**r = 4:**\n- Special case: fully chaotic\n- Exact solution possible (analytically)\n- Probability density: ρ(x) = 1/(π√(x(1-x)))\n- Maximum Lyapunov exponent: λ = ln(2)\n\n**r &gt; 4:**\n- Escape regime\n- Trajectories can leave [0, 1]\n- Eventually diverge to -∞\n- Not physically meaningful for population model\ndt : float, default=1.0 Time step between generations - Usually normalized to 1 (one generation) - Can represent actual time scale (years, days, etc.) - Purely for interpretation (doesn’t affect dynamics)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nThe logistic map has two fixed points:\n1. Extinction equilibrium: x* = 0 Stability: λ = r - Stable if r &lt; 1 (low growth → extinction) - Unstable if r &gt; 1 (population survives)\nBiological meaning: If population is too small (below critical threshold), it cannot sustain itself and dies out.\n2. Nontrivial equilibrium: x* = 1 - 1/r (for r &gt; 1) Stability: λ = 2 - r - Stable if 1 &lt; r &lt; 3 (|λ| &lt; 1) - Unstable if r &gt; 3 (period-doubling begins)\nBiological meaning: Population reaches carrying capacity balance where births equal deaths.\nBifurcation Points: - r = 1: Transcritical bifurcation (extinction ↔︎ survival) - r = 3: Period-doubling bifurcation (fixed point → period-2) - r ≈ 3.449: Period-4 bifurcation - r ≈ 3.544: Period-8 bifurcation - r ≈ 3.569: Onset of chaos (accumulation point) - r ≈ 3.83: Period-3 window opens\nFeigenbaum Constants: The period-doubling cascade follows universal scaling: δ = lim (rₙ - rₙ₋₁)/(rₙ₊₁ - rₙ) = 4.669… α = lim (dₙ/dₙ₊₁) = 2.502…\nThese constants are universal across all period-doubling systems!"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#chaos-theory-concepts",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#chaos-theory-concepts",
    "title": "",
    "section": "Chaos Theory Concepts:",
    "text": "Chaos Theory Concepts:\nSensitive Dependence on Initial Conditions: The hallmark of chaos. Two trajectories starting infinitesimally close diverge exponentially:\n|δx(k)| ≈ |δx(0)|·e^(λk)\nwhere λ &gt; 0 is the Lyapunov exponent.\nFor logistic map in chaotic regime: λ = lim (1/N)·Σ ln|r·(1 - 2x[k])| N→∞\n\nλ &lt; 0: Periodic or fixed point (convergence)\nλ = 0: Neutral stability (period-doubling point)\nλ &gt; 0: Chaos (divergence)\n\nPredictability Horizon: If measurement accuracy is ε, prediction fails after time: T_predict ~ |λ|⁻¹·ln(ε)\nExample: For λ = 0.5 and ε = 10⁻⁶: T_predict ~ 2·ln(10⁶) ≈ 28 generations\nThis is why weather prediction is limited despite deterministic physics!\nStrange Attractor: In chaotic regime, the system visits a fractal set: - Infinite complexity at all scales - Non-integer (fractal) dimension - Dense periodic orbits - Mixing property (ergodic)\nDeterminism vs Randomness: The logistic map is COMPLETELY DETERMINISTIC (no randomness), yet produces output that appears random: - Passes statistical tests for randomness - Used in pseudo-random number generation - Cannot predict long-term behavior - “Deterministic chaos” is not an oxymoron!"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\nUnlike typical control systems, controlling chaos involves different goals:\n\nChaos Control (OGY Method): Goal: Stabilize unstable periodic orbits embedded in attractor Method: Small perturbations to system parameter Applications: Laser dynamics, cardiac arrhythmias\nChaos Synchronization: Goal: Make two chaotic systems follow same trajectory Applications: Secure communications, neural networks\nAnti-control (Chaotification): Goal: Make periodic system chaotic Applications: Mixing, encryption, avoiding resonance\nHarvesting Optimization: Goal: Maximize sustainable yield while maintaining stability Control: u[k] = h·x[k] (proportional harvesting) Constraint: Keep r_effective in stable regime\nBifurcation Control: Goal: Move bifurcation points by parameter variation Applications: Preventing unwanted oscillations"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#bifurcation-analysis",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#bifurcation-analysis",
    "title": "",
    "section": "Bifurcation Analysis:",
    "text": "Bifurcation Analysis:\nCreating Bifurcation Diagrams: 1. Choose r values from 0 to 4 2. For each r: a. Iterate from random initial condition b. Discard transient (e.g., first 1000 iterations) c. Plot next 100 iterations 3. Result: shows all attractors vs parameter\nReading Bifurcation Diagrams: - Single line: Fixed point - Two lines: Period-2 orbit - Four lines: Period-4 orbit - Dense region: Chaos - White gaps: Periodic windows\nUniversality: All unimodal maps with quadratic maximum exhibit same qualitative bifurcation structure. The Feigenbaum constants are universal!"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\nFloating-Point Precision: Computer arithmetic introduces errors that can affect long-term behavior: - Chaotic systems amplify roundoff errors exponentially - Cannot compute trajectory accurately beyond predictability horizon - Use high-precision arithmetic for numerical studies - Machine epsilon (≈10⁻¹⁶) limits practical predictions\nInitial Condition Sensitivity: Even tiny errors in initial condition grow exponentially: |error[k]| ≈ |error[0]|·e^(λk)\nFor λ = 0.5 and error[0] = 10⁻¹⁵: error[50] ≈ 10⁻¹⁵·e²⁵ ≈ 10⁻²\nStability of Fixed Points: To find stability, compute derivative: λ = df/dx = r·(1 - 2x)\nAt x* = 1 - 1/r: λ = r·(1 - 2(1 - 1/r)) = 2 - r\nStable if |2 - r| &lt; 1, i.e., 1 &lt; r &lt; 3.\nCobweb Diagrams: Graphical method to visualize iterations: 1. Plot y = f(x) and y = x 2. Start at (x₀, 0) 3. Go vertically to curve: (x₀, f(x₀)) 4. Go horizontally to diagonal: (f(x₀), f(x₀)) 5. Repeat\nPatterns: - Spiral inward → stable fixed point - Spiral outward → unstable fixed point - Rectangle → period-2 orbit - Complicated path → chaos"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate logistic map in chaotic regime\nsystem = LogisticMap(r=3.9)\nSimulate from random initial condition\nx0 = np.array([0.4]) result = system.simulate( … x0=x0, … u_sequence=None, # Autonomous system … n_steps=100 … )\nPlot trajectory\nimport matplotlib.pyplot as plt plt.figure(figsize=(10, 6)) plt.plot(result[‘time_steps’], result[‘states’][:, 0], ‘b.-’, markersize=3) plt.xlabel(‘Generation k’) plt.ylabel(‘Population x[k]’) plt.title(f’Logistic Map (r = {system.r})’) plt.grid(alpha=0.3) plt.show()\nDemonstrate sensitivity to initial conditions\nx0_a = np.array([0.4]) x0_b = np.array([0.4 + 1e-10]) # Tiny difference\nresult_a = system.simulate(x0_a, None, n_steps=50) result_b = system.simulate(x0_b, None, n_steps=50)\nCompute divergence\ndivergence = np.abs(result_a[‘states’][:, 0] - result_b[‘states’][:, 0])\nplt.figure(figsize=(10, 6)) plt.semilogy(result_a[‘time_steps’], divergence, ‘r-’, linewidth=2) plt.xlabel(‘Generation k’) plt.ylabel(‘|x_a[k] - x_b[k]|’) plt.title(‘Exponential Divergence (Sensitive Dependence)’) plt.grid(alpha=0.3) plt.show()\nEstimate Lyapunov exponent\nlyapunov = system.compute_lyapunov_exponent(x0=0.4, n_iterations=10000) print(f”Lyapunov exponent: λ = {lyapunov:.4f}“) if lyapunov &gt; 0: … print(”System is CHAOTIC”) … else: … print(“System is NOT chaotic (periodic or fixed point)”)\nGenerate bifurcation diagram\nr_values = np.linspace(2.5, 4.0, 1000) bifurcation_data = system.generate_bifurcation_diagram( … r_values=r_values, … n_transient=500, … n_samples=100 … )\nplt.figure(figsize=(12, 8)) plt.plot(bifurcation_data[‘r’], bifurcation_data[‘x’], … ‘k.’, markersize=0.5, alpha=0.5) plt.xlabel(‘Growth Rate r’) plt.ylabel(’Population x*‘) plt.title(’Bifurcation Diagram: Period-Doubling Route to Chaos’) plt.xlim(2.5, 4.0) plt.ylim(0, 1) plt.grid(alpha=0.3)\nAnnotate key bifurcation points\nplt.axvline(3.0, color=‘r’, linestyle=‘–’, alpha=0.5, label=‘Period-2 bifurcation’) plt.axvline(3.449, color=‘g’, linestyle=‘–’, alpha=0.5, label=‘Period-4’) plt.axvline(3.569, color=‘b’, linestyle=‘–’, alpha=0.5, label=‘Chaos onset’) plt.legend() plt.show()\nFind fixed points and check stability\nfixed_points = system.find_fixed_points() print(“Points:”) for fp in fixed_points: … x_star = fp[‘x’] … lambda_val = fp[‘eigenvalue’] … stable = fp[‘stable’] … print(f” x* = {x_star:.4f}, λ = {lambda_val:.4f}, stable = {stable}“)\nCobweb diagram for visualization\nfig, ax = plt.subplots(figsize=(8, 8)) system.plot_cobweb(ax, x0=0.1, n_iterations=50) plt.show()\nPeriod-3 window (r ≈ 3.83)\nsystem_p3 = LogisticMap(r=3.83) result_p3 = system_p3.simulate(x0=np.array([0.5]), u_sequence=None, n_steps=100)\nCheck for period-3 by looking at every 3rd point\nperiod = system_p3.detect_period(result_p3[‘states’][:, 0]) print(f”period: {period}“)\nCompare different r values\nr_test = [2.8, 3.2, 3.5, 3.9] fig, axes = plt.subplots(2, 2, figsize=(12, 10))\nfor idx, r_val in enumerate(r_test): … ax = axes[idx // 2, idx % 2] … sys_temp = LogisticMap(r=r_val) … res_temp = sys_temp.simulate(x0=np.array([0.4]), u_sequence=None, n_steps=100) … … ax.plot(res_temp[‘time_steps’], res_temp[‘states’][:, 0], ‘b.-’, markersize=3) … ax.set_xlabel(‘Generation k’) … ax.set_ylabel(‘Population x[k]’) … ax.set_title(f’r = {r_val}’) … ax.grid(alpha=0.3) … ax.set_ylim(0, 1)\nplt.tight_layout() plt.show()\nAnalyze return map (x[k+1] vs x[k])\nresult_long = system.simulate(x0=np.array([0.4]), u_sequence=None, n_steps=1000) x_k = result_long[‘states’][:-1, 0] x_k1 = result_long[‘states’][1:, 0]\nplt.figure(figsize=(8, 8)) plt.plot(x_k, x_k1, ‘b.’, markersize=1, alpha=0.5) plt.plot([0, 1], [0, 1], ‘r–’, label=‘y = x (fixed points)’) x_plot = np.linspace(0, 1, 1000) plt.plot(x_plot, system.r * x_plot * (1 - x_plot), ‘g-’, linewidth=2, … label=f’y = {system.r}x(1-x)‘) plt.xlabel(’x[k]’) plt.ylabel(‘x[k+1]’) plt.title(‘Return Map (First-Return Plot)’) plt.legend() plt.grid(alpha=0.3) plt.axis(‘equal’) plt.xlim(0, 1) plt.ylim(0, 1) plt.show()\nCompute histogram (invariant measure)\nresult_hist = system.simulate(x0=np.array([0.4]), u_sequence=None, n_steps=50000) x_hist = result_hist[‘states’][10000:, 0] # Discard transient\nplt.figure(figsize=(10, 6)) plt.hist(x_hist, bins=100, density=True, alpha=0.7, edgecolor=‘black’) plt.xlabel(‘Population x’) plt.ylabel(‘Probability Density’) plt.title(f’Invariant Measure (r = {system.r})’) plt.grid(alpha=0.3) plt.show()"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nWhy Does Chaos Occur? The logistic map has two competing effects: 1. Expansion: For small x, f(x) ≈ rx (exponential growth) 2. Folding: For x near 1, f(x) decreases (resource limitation)\nWhen r is large, expansion is strong, stretching the interval. The folding then brings points back, but in a complicated way. This “stretch and fold” mechanism creates sensitive dependence.\nBiological Meaning of Chaos: Chaotic population dynamics mean: - Population never settles to equilibrium - Year-to-year populations appear random - Long-term prediction impossible - Small environmental changes → large effects\nExamples in nature: - Measles epidemics (pre-vaccination) - Lynx-hare population cycles - Plankton blooms - Insect outbreaks\nPeriod-3 and Li-Yorke Theorem: “Period-3 implies chaos” (Li and Yorke, 1975)\nIf a continuous map has a period-3 orbit, then: - It has periodic orbits of all periods - It has uncountably many aperiodic orbits - It exhibits sensitive dependence\nThis is why the period-3 window at r ≈ 3.83 is remarkable!\nFeigenbaum Universality: Mitchell Feigenbaum (1975) discovered that ALL unimodal maps with quadratic maximum exhibit the same scaling: - δ = 4.669… (bifurcation spacing ratio) - α = 2.502… (parameter scaling)\nThis means chaos theory has universal laws, like physics!\nTent Map and Topological Conjugacy: The logistic map at r = 4 is topologically conjugate to the tent map: g(x) = { 2x if x &lt; 0.5 { 2(1-x) if x ≥ 0.5\nTransformation: x = sin²(πy/2)\nThis allows exact analytical solutions for r = 4.\nConnection to Cryptography: Chaotic maps used in encryption because: - Deterministic (key = initial condition and parameter) - Sensitive dependence (good mixing) - Appears random (passes statistical tests) - Fast computation\nHowever, not cryptographically secure due to: - Finite precision issues - Reconstructability from time series\nControl Paradox: It’s often EASIER to control chaotic systems than periodic ones! - Chaos has dense set of unstable periodic orbits - Can stabilize any orbit with small perturbations - Periodic systems may need large control effort to change behavior"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n\nEscaping the unit interval: For r &gt; 4, trajectories can escape [0, 1] and diverge to -∞. Always check x[k] ∈ [0, 1].\nTransient vs asymptotic behavior: Must discard initial transient before analyzing attractor. Typical: skip first 500-1000 iterations.\nNumerical precision limits: Cannot compute chaotic trajectory accurately beyond ~50-100 iterations. Use double precision and be aware of limitations.\nMistaking chaos for randomness: Chaos is deterministic! Same initial condition → same trajectory. But prediction is practically impossible for long times.\nPeriod detection: Short period easy to detect, but high-period orbits hard to distinguish from chaos. Use Lyapunov exponent, not just visual inspection.\nParameter precision: Bifurcation points occur at specific r values. Need high precision to locate them accurately."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#extensions-and-variations",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#extensions-and-variations",
    "title": "",
    "section": "Extensions and Variations:",
    "text": "Extensions and Variations:\n\nGeneralized logistic map: x[k+1] = r·x[k]^α·(1 - x[k]) Different values of α change bifurcation structure\nCoupled logistic maps: Spatial extension: x_i[k+1] = f(x_i[k]) + ε·(x_{i-1} + x_{i+1} - 2x_i) Creates spatiotemporal chaos\nDelayed logistic map: x[k+1] = r·x[k]·(1 - x[k-τ]) Time delay increases complexity\nStochastic logistic map: x[k+1] = r·x[k]·(1 - x[k]) + σ·ξ[k] Noise + deterministic chaos = rich dynamics\nDiscrete-time Ricker model: x[k+1] = x[k]·exp(r·(1 - x[k])) Similar dynamics, different form\nHenon map (2D): x[k+1] = 1 - a·x[k]² + y[k] y[k+1] = b·x[k] Classic 2D chaotic map"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nHenonMap : 2D chaotic map StandardMap : Hamiltonian chaos"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#attributes",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nr\nGrowth rate parameter."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.LogisticMap.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.LogisticMap.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nclassify_regime\nClassify dynamical regime based on r value.\n\n\ncompute_bifurcation_points\nCompute key bifurcation points.\n\n\ncompute_feigenbaum_delta\nEstimate Feigenbaum delta constant from period-doubling sequence.\n\n\ncompute_lyapunov_exponent\nCompute Lyapunov exponent to quantify chaos.\n\n\ndefine_system\nDefine logistic map dynamics.\n\n\ndetect_period\nDetect period of orbit from trajectory.\n\n\nfind_fixed_points\nFind all fixed points and their stability.\n\n\ngenerate_bifurcation_diagram\nGenerate bifurcation diagram data.\n\n\nplot_cobweb\nCreate cobweb diagram visualization.\n\n\nsetup_equilibria\nSet up fixed points of the logistic map.\n\n\n\n\nclassify_regime\nsystems.builtin.deterministic.discrete.LogisticMap.classify_regime()\nClassify dynamical regime based on r value.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nRegime classification\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = LogisticMap(r=2.8)\n&gt;&gt;&gt; print(system.classify_regime())\n'stable_fixed_point'\n&gt;&gt;&gt;\n&gt;&gt;&gt; system = LogisticMap(r=3.9)\n&gt;&gt;&gt; print(system.classify_regime())\n'chaos'\n\n\n\ncompute_bifurcation_points\nsystems.builtin.deterministic.discrete.LogisticMap.compute_bifurcation_points()\nCompute key bifurcation points.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary of bifurcation points: - ‘transcritical’: r = 1 (extinction ↔︎ nontrivial) - ‘period_2’: r = 3 (fixed point → period-2) - ‘period_4’: r ≈ 3.449 (period-2 → period-4) - ‘period_8’: r ≈ 3.544 (period-4 → period-8) - ‘chaos_onset’: r ≈ 3.569 (accumulation point) - ‘period_3_window’: r ≈ 3.83 (period-3 window opens)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = LogisticMap()\n&gt;&gt;&gt; bifurc_points = system.compute_bifurcation_points()\n&gt;&gt;&gt; for name, r_val in bifurc_points.items():\n...     print(f\"{name}: r = {r_val:.4f}\")\n\n\n\ncompute_feigenbaum_delta\nsystems.builtin.deterministic.discrete.LogisticMap.compute_feigenbaum_delta(\n    n_bifurcations=10,\n)\nEstimate Feigenbaum delta constant from period-doubling sequence.\nδ = lim (rₙ - rₙ₋₁)/(rₙ₊₁ - rₙ) ≈ 4.669… n→∞\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_bifurcations\nint\nNumber of bifurcation points to use\n10\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEstimated δ value\n\n\n\n\n\nNotes\nThis is a simplified estimation. Accurate computation requires finding bifurcation points numerically to high precision.\n\n\nExamples\n&gt;&gt;&gt; system = LogisticMap()\n&gt;&gt;&gt; delta = system.compute_feigenbaum_delta()\n&gt;&gt;&gt; print(f\"Feigenbaum δ ≈ {delta:.3f} (theoretical: 4.669)\")\n\n\n\ncompute_lyapunov_exponent\nsystems.builtin.deterministic.discrete.LogisticMap.compute_lyapunov_exponent(\n    x0=0.4,\n    n_iterations=10000,\n    n_transient=1000,\n)\nCompute Lyapunov exponent to quantify chaos.\nThe Lyapunov exponent λ measures average exponential divergence rate: λ = lim (1/N)·Σ ln|df/dx| N→∞\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nfloat\nInitial condition\n0.4\n\n\nn_iterations\nint\nNumber of iterations for averaging\n10000\n\n\nn_transient\nint\nNumber of initial iterations to discard\n1000\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nLyapunov exponent - λ &lt; 0: Stable fixed point or periodic orbit - λ = 0: Neutral (bifurcation point) - λ &gt; 0: Chaos\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = LogisticMap(r=3.9)\n&gt;&gt;&gt; lyapunov = system.compute_lyapunov_exponent(n_iterations=50000)\n&gt;&gt;&gt; print(f\"Lyapunov exponent: {lyapunov:.4f}\")\n&gt;&gt;&gt; if lyapunov &gt; 0.01:\n...     print(\"System is CHAOTIC\")\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.LogisticMap.define_system(\n    r=3.5,\n    dt=1.0,\n    use_controlled_version=False,\n)\nDefine logistic map dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr\nfloat\nGrowth rate parameter (typically 0 &lt; r ≤ 4)\n3.5\n\n\ndt\nfloat\nTime step between generations (typically 1.0)\n1.0\n\n\nuse_controlled_version\nbool\nIf True, adds control input u[k] to dynamics: x[k+1] = r·x[k]·(1 - x[k]) + u[k]\nFalse\n\n\n\n\n\n\ndetect_period\nsystems.builtin.deterministic.discrete.LogisticMap.detect_period(\n    trajectory,\n    max_period=20,\n    tolerance=1e-06,\n)\nDetect period of orbit from trajectory.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrajectory\nnp.ndarray\nTime series data\nrequired\n\n\nmax_period\nint\nMaximum period to check\n20\n\n\ntolerance\nfloat\nTolerance for periodicity\n1e-06\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nint or None\nDetected period, or None if aperiodic\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = LogisticMap(r=3.2)\n&gt;&gt;&gt; result = system.simulate(x0=np.array([0.5]), u_sequence=None, n_steps=200)\n&gt;&gt;&gt; period = system.detect_period(result['states'][:, 0])\n&gt;&gt;&gt; print(f\"Detected period: {period}\")\n\n\n\nfind_fixed_points\nsystems.builtin.deterministic.discrete.LogisticMap.find_fixed_points()\nFind all fixed points and their stability.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist\nList of dictionaries containing: - ‘x’: Fixed point value - ‘eigenvalue’: Stability eigenvalue - ‘stable’: Boolean stability flag\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = LogisticMap(r=2.5)\n&gt;&gt;&gt; fixed_points = system.find_fixed_points()\n&gt;&gt;&gt; for fp in fixed_points:\n...     print(f\"x* = {fp['x']:.3f}, λ = {fp['eigenvalue']:.3f}, stable = {fp['stable']}\")\n\n\n\ngenerate_bifurcation_diagram\nsystems.builtin.deterministic.discrete.LogisticMap.generate_bifurcation_diagram(\n    r_values,\n    n_transient=500,\n    n_samples=100,\n    x0=0.5,\n)\nGenerate bifurcation diagram data.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr_values\nnp.ndarray\nArray of r values to test\nrequired\n\n\nn_transient\nint\nNumber of iterations to discard (transient)\n500\n\n\nn_samples\nint\nNumber of points to sample after transient\n100\n\n\nx0\nfloat\nInitial condition for each r\n0.5\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with keys: - ‘r’: Array of r values (repeated for each sample) - ‘x’: Array of x values at attractor\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = LogisticMap()\n&gt;&gt;&gt; r_vals = np.linspace(2.5, 4.0, 1000)\n&gt;&gt;&gt; bifurc_data = system.generate_bifurcation_diagram(r_vals)\n&gt;&gt;&gt;\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.figure(figsize=(12, 8))\n&gt;&gt;&gt; plt.plot(bifurc_data['r'], bifurc_data['x'], 'k.', markersize=0.2)\n&gt;&gt;&gt; plt.xlabel('r')\n&gt;&gt;&gt; plt.ylabel('x*')\n&gt;&gt;&gt; plt.title('Bifurcation Diagram')\n&gt;&gt;&gt; plt.show()\n\n\n\nplot_cobweb\nsystems.builtin.deterministic.discrete.LogisticMap.plot_cobweb(\n    ax,\n    x0=0.1,\n    n_iterations=50,\n)\nCreate cobweb diagram visualization.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nax\nmatplotlib.axes.Axes\nAxes to plot on\nrequired\n\n\nx0\nfloat\nInitial condition\n0.1\n\n\nn_iterations\nint\nNumber of iterations to plot\n50\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8))\n&gt;&gt;&gt; system = LogisticMap(r=3.5)\n&gt;&gt;&gt; system.plot_cobweb(ax, x0=0.1, n_iterations=50)\n&gt;&gt;&gt; plt.show()\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.LogisticMap.setup_equilibria()\nSet up fixed points of the logistic map.\nAdds: - Extinction equilibrium (x* = 0) - Nontrivial equilibrium (x* = 1 - 1/r) if r &gt; 1"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA point mass m suspended by a massless, rigid rod of length L, swinging\nin a vertical plane under the influence of gravity. The pendulum can be:\n- Free (no control): Natural oscillatory motion\n- Forced (with control): External torque applied at pivot\n\n**Mechanical Configuration:**\n              ● Pivot (fixed)\n              |\n              | L (rod length)\n              |\n              ● m (point mass)\n              ↓\n              g (gravity)\nAngle θ measured from downward vertical:\n- θ = 0: Hanging down (stable equilibrium)\n- θ = π: Standing up (unstable equilibrium)\n- θ = π/2: Horizontal position (maximum potential energy during swing)\n\n**Equation of Motion (from Newton's Second Law):**\nThe continuous-time dynamics are:\n\n    m·L²·θ̈ = -m·g·L·sin(θ) - b·θ̇ + τ\n\nDividing by m·L²:\n\n    θ̈ = -(g/L)·sin(θ) - (b/m·L²)·θ̇ + τ/(m·L²)\n\nDefine:\n    ω₀² = g/L: Natural frequency squared [rad²/s²]\n    β = b/(m·L²): Damping coefficient [1/s]\n    u = τ/(m·L²): Normalized torque [rad/s²]\n\nThen:\n    θ̈ = -ω₀²·sin(θ) - β·θ̇ + u\n\n**Discrete-Time Dynamics:**\nMultiple discretization methods available (see parameters)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] = [θ[k], ω[k]]\n    Angular position:\n    - θ: Angle from vertical [rad]\n      * θ = 0: Downward equilibrium (lowest energy)\n      * θ = π: Upward equilibrium (highest energy)\n      * θ = ±π/2: Horizontal (maximum torque)\n      * Periodic: sin(θ) and cos(θ) are 2π-periodic\n      * Can be wrapped to [-π, π] or left unwrapped\n\n    Angular velocity:\n    - ω: Rate of change of angle [rad/s]\n      * ω &gt; 0: Counterclockwise rotation\n      * ω &lt; 0: Clockwise rotation\n      * ω = 0: Instantaneous rest\n      * In phase space: forms closed curves (periodic) or rotations\n\nControl: u[k] = [τ[k]]\n    Applied torque (optional):\n    - τ: External torque at pivot [N·m]\n      * Normalized: u = τ/(m·L²) [rad/s²]\n      * τ &gt; 0: Pushes pendulum counterclockwise\n      * τ &lt; 0: Pushes pendulum clockwise\n      * For swing-up or stabilization control\n\nOutput: y[k] = [θ[k]] or [θ[k], ω[k]]\n    - Position-only measurement (typical)\n    - Full state if velocity sensor available\n    - In practice: encoder for θ, gyroscope for ω"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#dynamics-physical-regimes",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#dynamics-physical-regimes",
    "title": "",
    "section": "Dynamics (Physical Regimes):",
    "text": "Dynamics (Physical Regimes):\n**Small Angle Approximation (|θ| &lt;&lt; 1):**\nFor small displacements, sin(θ) ≈ θ:\n    θ̈ ≈ -ω₀²·θ - β·θ̇\n\nThis is a LINEAR harmonic oscillator! (See DiscreteOscillator)\n- Valid for θ &lt; 0.2 rad (~10°)\n- Error: O(θ³)\n\n**Nonlinear Regime (arbitrary θ):**\nMust use full sin(θ) term:\n- Period depends on amplitude (not constant like linear!)\n- Large swings take longer\n- Complete rotation possible if sufficient energy\n\n**Phase Space Structure:**\nThe (θ, ω) phase portrait has rich structure:\n\n1. **Fixed points:**\n   - (0, 0): Stable focus/center (depends on damping)\n   - (±π, 0): Saddle points (unstable)\n\n2. **Periodic orbits (β = 0):**\n   - Closed curves around (0, 0)\n   - Period increases with amplitude\n\n3. **Separatrix (β = 0):**\n   - Special trajectory through saddle points\n   - Separates oscillations from rotations\n   - Homoclinic orbit (starts and ends at saddle)\n\n4. **Rotations (high energy):**\n   - Open curves (pendulum goes over the top)\n   - ω doesn't change sign\n   - Continuous rotation in one direction"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm : float, default=1.0\n    Mass of the pendulum bob [kg]\n    - Affects inertia (m·L²)\n    - Typical: 0.1-10 kg\n\nL : float, default=1.0\n    Length of the pendulum rod [m]\n    - Determines natural frequency: ω₀ = √(g/L)\n    - Longer pendulum → slower oscillations\n    - Typical: 0.1-2.0 m\n\ng : float, default=9.81\n    Gravitational acceleration [m/s²]\n    - Earth: 9.81\n    - Moon: 1.62\n    - Mars: 3.71\n\nb : float, default=0.1\n    Damping coefficient [N·m·s/rad]\n    - Air resistance + friction at pivot\n    - Larger b → faster decay\n    - b = 0: Undamped (conservative, energy-preserving)\n    - Typical: 0.01-1.0\n\ndt : float, default=0.01\n    Sampling period [s]\n    - Digital control update rate\n    - Must satisfy Nyquist criterion\n    - Smaller dt → better accuracy\n    - Typical: 0.001-0.1 s\n\nmethod : str, default='zoh'\n    Discretization method:\n    - 'zoh': Zero-order hold (exact for constant τ)\n    - 'euler': Forward Euler (simple, O(dt))\n    - 'rk4': Runge-Kutta 4th order (accurate, O(dt⁴))\n    - 'exact': Exact discretization for linear approximation\n\nuse_control : bool, default=True\n    If True, includes control input τ\n    If False, free pendulum (autonomous)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\n**Downward Equilibrium (θ = 0, ω = 0):**\nStability: STABLE (center if undamped, stable focus if damped)\n- Minimum potential energy\n- Small perturbations oscillate (if β &gt; 0: with decay)\n- Linearization: θ̈ = -ω₀²·θ - β·θ̇ (harmonic oscillator)\n\n**Upward Equilibrium (θ = ±π, ω = 0):**\nStability: UNSTABLE (saddle point)\n- Maximum potential energy\n- Small perturbations grow exponentially\n- Linearization: θ̈ = +ω₀²·(θ - π) - β·θ̇ (inverted)\n- Famous \"inverted pendulum\" control problem\n\n**Separatrix Energy (undamped):**\nThe energy separating oscillations from rotations:\n    E_sep = 2·m·g·L\n\nIf E &lt; E_sep: Oscillation (back and forth)\nIf E &gt; E_sep: Rotation (goes over the top)\nIf E = E_sep: Asymptotic approach to upward position"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#controllability",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#controllability",
    "title": "",
    "section": "Controllability:",
    "text": "Controllability:\n**With Control (u ≠ 0):**\nCompletely controllable - can reach any state from any other state.\n\n**Without Control (Free Pendulum):**\nNOT controllable - energy determines accessible states.\nCan only reach states with same or lower energy (due to damping)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#observability",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#observability",
    "title": "",
    "section": "Observability:",
    "text": "Observability:\n**Position-only measurement (y = θ):**\nObservable almost everywhere.\n- Can reconstruct ω from θ measurements over time\n- Singularity at equilibria (θ = constant → ω ambiguous)\n\n**Full state measurement:**\nTrivially observable."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#energy-and-integrals-of-motion",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#energy-and-integrals-of-motion",
    "title": "",
    "section": "Energy and Integrals of Motion:",
    "text": "Energy and Integrals of Motion:\n**Total Mechanical Energy:**\n    E = (1/2)·m·L²·ω² + m·g·L·(1 - cos(θ))\n\nKinetic: K = (1/2)·m·L²·ω²\nPotential: V = m·g·L·(1 - cos(θ))\n\n**For Undamped, Unforced Pendulum (β = 0, u = 0):**\nEnergy is conserved: dE/dt = 0\nPhase space trajectories are level sets of E(θ, ω).\n\n**For Damped Pendulum (β &gt; 0, u = 0):**\nEnergy decreases: dE/dt = -b·ω² ≤ 0\nAll trajectories asymptotically approach (0, 0).\n\n**For Forced Pendulum (u ≠ 0):**\nEnergy can increase or decrease:\n    dE/dt = (m·L²·u - b)·ω²"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\n**1. Stabilization at Downward Position:**\n   Goal: θ → 0, ω → 0\n   Method: PD control works well (linear regime)\n   Challenge: Minimal (natural equilibrium)\n\n**2. Swing-Up Control:**\n   Goal: Move from θ = 0 to θ = π\n   Methods:\n   - Energy-based: Pump energy until E ≈ E_target\n   - Bang-bang: Apply maximum torque\n   - Trajectory optimization\n   Challenge: Large control effort, multiple rotations\n\n**3. Inverted Stabilization:**\n   Goal: Stabilize at θ = π, ω = 0\n   Method: LQR around linearization\n   Challenge: Unstable equilibrium, requires continuous control\n\n**4. Trajectory Tracking:**\n   Goal: Follow θ_ref(t), ω_ref(t)\n   Method: Feedforward + feedback\n   Application: Robotic manipulation\n\n**5. Limit Cycle Creation:**\n   Goal: Create stable periodic oscillation\n   Method: Nonlinear feedback\n   Application: Rhythmic motion generation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\n**1. Angle Limits (if physical stops exist):**\n   θ_min ≤ θ ≤ θ_max\n   Otherwise: θ ∈ ℝ (unbounded rotations possible)\n\n**2. Velocity Limits:**\n   |ω| ≤ ω_max\n   Physical: Limited by energy or mechanism\n\n**3. Torque Limits:**\n   |τ| ≤ τ_max\n   Most critical practical constraint\n   Determines controllability"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\n**Discretization Accuracy:**\n- ZOH: Good for control applications\n- Euler: Simple but may be inaccurate/unstable for large dt\n- RK4: High accuracy, recommended for simulation\n\n**Angle Wrapping:**\nFor visualization and analysis:\n- Wrap θ to [-π, π]: θ_wrapped = atan2(sin(θ), cos(θ))\n- Or leave unwrapped to count rotations\n\n**Energy Verification:**\nFor undamped case, check energy conservation:\n    |E[k+1] - E[k]| should be small (numerical precision)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n&gt;&gt;&gt; # Create pendulum with realistic parameters\n&gt;&gt;&gt; system = DiscretePendulum(\n...     m=0.5,      # 500g mass\n...     L=1.0,      # 1m length\n...     g=9.81,\n...     b=0.05,     # Light damping\n...     dt=0.01,\n...     method='rk4'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"Natural frequency: {system.natural_frequency:.3f} rad/s\")\n&gt;&gt;&gt; print(f\"Period: {system.period:.3f} s\")\n&gt;&gt;&gt; print(f\"Damping ratio: {system.damping_ratio:.4f}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Free oscillation from initial displacement\n&gt;&gt;&gt; x0 = np.array([np.pi/4, 0.0])  # 45° release from rest\n&gt;&gt;&gt; result_free = system.simulate(\n...     x0=x0,\n...     u_sequence=None,\n...     n_steps=1000\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot phase portrait\n&gt;&gt;&gt; import plotly.graph_objects as go\n&gt;&gt;&gt; fig = go.Figure()\n&gt;&gt;&gt; fig.add_trace(go.Scatter(\n...     x=result_free['states'][:, 0],\n...     y=result_free['states'][:, 1],\n...     mode='lines',\n...     name='Trajectory'\n... ))\n&gt;&gt;&gt; fig.update_layout(\n...     title='Pendulum Phase Portrait',\n...     xaxis_title='θ [rad]',\n...     yaxis_title='ω [rad/s]'\n... )\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Energy analysis\n&gt;&gt;&gt; energies = np.array([\n...     system.compute_total_energy(x[0], x[1])\n...     for x in result_free['states']\n... ])\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig_energy = go.Figure()\n&gt;&gt;&gt; fig_energy.add_trace(go.Scatter(\n...     x=result_free['time_steps'] * system.dt,\n...     y=energies,\n...     name='Total Energy'\n... ))\n&gt;&gt;&gt; fig_energy.update_layout(\n...     title='Energy vs Time (should decrease with damping)',\n...     xaxis_title='Time [s]',\n...     yaxis_title='Energy [J]'\n... )\n&gt;&gt;&gt; fig_energy.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Swing-up control (energy-based)\n&gt;&gt;&gt; def swing_up_energy_control(x, k):\n...     theta, omega = x\n...\n...     # Current energy\n...     E = system.compute_total_energy(theta, omega)\n...\n...     # Target energy (upward position)\n...     E_target = system.m * system.g * system.L * 2\n...\n...     # Energy error\n...     E_error = E - E_target\n...\n...     # If close to upward, switch to stabilization\n...     if abs(theta - np.pi) &lt; 0.3 and abs(omega) &lt; 1.0:\n...         # LQR around upward\n...         K_up = system.design_upward_stabilizer()\n...         return -K_up @ np.array([theta - np.pi, omega])\n...     else:\n...         # Energy pumping: add energy when moving in right direction\n...         k_swing = 5.0\n...         return k_swing * E_error * np.sign(omega * np.cos(theta))\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_swing = system.rollout(\n...     x0=np.array([0.0, 0.0]),\n...     policy=swing_up_energy_control,\n...     n_steps=2000\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Visualize swing-up in phase space\n&gt;&gt;&gt; fig_swing = system.plot_phase_portrait_with_separatrix()\n&gt;&gt;&gt; fig_swing.add_trace(go.Scatter(\n...     x=result_swing['states'][:, 0],\n...     y=result_swing['states'][:, 1],\n...     mode='lines',\n...     line=dict(color='red', width=2),\n...     name='Swing-up trajectory'\n... ))\n&gt;&gt;&gt; fig_swing.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compare small vs large angle dynamics\n&gt;&gt;&gt; # Small angle (linear regime)\n&gt;&gt;&gt; x0_small = np.array([0.1, 0.0])  # ~6°\n&gt;&gt;&gt; result_small = system.simulate(x0_small, None, n_steps=500)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Large angle (nonlinear regime)\n&gt;&gt;&gt; x0_large = np.array([2.0, 0.0])  # ~115°\n&gt;&gt;&gt; result_large = system.simulate(x0_large, None, n_steps=500)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compare periods\n&gt;&gt;&gt; def find_period(states, dt):\n...     # Find zero crossings\n...     theta = states[:, 0]\n...     crossings = np.where(np.diff(np.sign(theta)))[0]\n...     if len(crossings) &gt;= 2:\n...         period = 2 * (crossings[1] - crossings[0]) * dt\n...         return period\n...     return None\n&gt;&gt;&gt;\n&gt;&gt;&gt; period_small = find_period(result_small['states'], system.dt)\n&gt;&gt;&gt; period_large = find_period(result_large['states'], system.dt)\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"Small angle period: {period_small:.3f} s\")\n&gt;&gt;&gt; print(f\"Large angle period: {period_large:.3f} s\")\n&gt;&gt;&gt; print(f\"Linear theory: {system.period:.3f} s\")\n&gt;&gt;&gt; print(\"Note: Large angle period &gt; small angle period (nonlinearity)\")"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\n**Isochronism (Small Angles Only):**\nFor small oscillations, period is independent of amplitude:\n    T = 2π√(L/g) = 2π/ω₀\n\nThis is why pendulum clocks work! (But only for small swings)\n\n**Anharmonicity (Large Angles):**\nFor large amplitudes, period increases with amplitude:\n    T(θ₀) ≈ T₀·(1 + θ₀²/16 + ...) for initial angle θ₀\n\nThis breaks isochronism → pendulum clocks must limit amplitude.\n\n**Separatrix Dynamics:**\nTrajectories on the separatrix (E = E_sep) take infinite time to reach\nthe unstable equilibrium. This is a homoclinic orbit.\n\n**Conservation vs Dissipation:**\n- No damping: Phase space filled with nested closed curves\n- With damping: Spiral inward to stable equilibrium\n- Energy landscape funnels trajectories toward rest\n\n**Chaotic Forcing:**\nAdd periodic forcing: θ̈ = -ω₀²·sin(θ) + A·cos(Ω·t)\nCan produce chaos (sensitive dependence on initial conditions)!\nThis is the \"driven damped pendulum\" - route to chaos."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n1. **Using linear approximation for large angles:**\n   sin(θ) ≈ θ only valid for |θ| &lt; 0.2 rad\n   Large errors for θ &gt; π/4\n\n2. **Forgetting angle periodicity:**\n   θ = 0 and θ = 2π are the same state\n   Important for phase portraits\n\n3. **Ignoring separatrix:**\n   Qualitative dynamics change across separatrix\n   Control strategies differ for oscillations vs rotations\n\n4. **Wrong linearization for upward:**\n   Linearizing at θ = π gives θ̈ = +ω₀²·(θ - π)\n   Note: POSITIVE coefficient (unstable)\n\n5. **Energy not conserved numerically:**\n   Discretization introduces energy errors\n   Use symplectic integrators for better conservation\n\n6. **Insufficient damping modeling:**\n   Real pendulums have complex friction\n   Viscous approximation b·ω may be inadequate"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#extensions",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#extensions",
    "title": "",
    "section": "Extensions:",
    "text": "Extensions:\n1. **Driven pendulum:**\n   Add periodic forcing: u[k] = A·cos(Ω·k·dt)\n   Can produce chaos and strange attractors\n\n2. **Double pendulum:**\n   Two coupled pendula\n   Exhibits deterministic chaos\n\n3. **Spherical pendulum:**\n   3D motion (θ, φ)\n   Rich dynamics, Coriolis effects\n\n4. **Elastic pendulum:**\n   Pendulum with spring (varying L)\n   Coupled radial-angular motion\n\n5. **Pendulum on cart:**\n   Inverted pendulum (classic underactuated system)\n   Noncollocated control problem\n\n6. **Parametric excitation:**\n   Varying L sinusoidally\n   Parametric resonance effects"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDiscreteRobotArm : Similar dynamics (different notation)\nDiscreteOscillator : Linear limit (small angles)\nDoublePendulum : Chaotic extension"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#attributes",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ndamping_ratio\nDamping ratio ζ = β/(2ω₀) [-].\n\n\nnatural_frequency\nNatural frequency ω₀ = √(g/L) [rad/s].\n\n\nperiod\nPeriod of small oscillations T = 2π/ω₀ [s]."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscretePendulum.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_kinetic_energy\nKinetic energy K = (1/2)·I·ω² [J].\n\n\ncompute_potential_energy\nPotential energy V = m·g·L·(1 - cos(θ)) [J].\n\n\ncompute_separatrix\nCompute separatrix trajectory (for undamped case).\n\n\ncompute_separatrix_energy\nEnergy of separatrix (boundary between oscillation/rotation) [J].\n\n\ncompute_total_energy\nTotal mechanical energy E = K + V [J].\n\n\ndefine_system\nDefine discrete-time pendulum dynamics.\n\n\ndesign_upward_stabilizer\nDesign LQR controller for upward stabilization.\n\n\nsetup_equilibria\nSet up downward and upward equilibria.\n\n\n\n\ncompute_kinetic_energy\nsystems.builtin.deterministic.discrete.DiscretePendulum.compute_kinetic_energy(\n    omega,\n)\nKinetic energy K = (1/2)·I·ω² [J].\n\n\ncompute_potential_energy\nsystems.builtin.deterministic.discrete.DiscretePendulum.compute_potential_energy(\n    theta,\n)\nPotential energy V = m·g·L·(1 - cos(θ)) [J].\n\n\ncompute_separatrix\nsystems.builtin.deterministic.discrete.DiscretePendulum.compute_separatrix(\n    n_points=1000,\n)\nCompute separatrix trajectory (for undamped case).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(theta, omega) points on separatrix\n\n\n\n\n\n\ncompute_separatrix_energy\nsystems.builtin.deterministic.discrete.DiscretePendulum.compute_separatrix_energy(\n)\nEnergy of separatrix (boundary between oscillation/rotation) [J].\n\n\ncompute_total_energy\nsystems.builtin.deterministic.discrete.DiscretePendulum.compute_total_energy(\n    theta,\n    omega,\n)\nTotal mechanical energy E = K + V [J].\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscretePendulum.define_system(\n    m=1.0,\n    L=1.0,\n    g=9.81,\n    b=0.1,\n    dt=0.01,\n    method='zoh',\n    use_control=True,\n)\nDefine discrete-time pendulum dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nm\nfloat\nMass [kg]\n1.0\n\n\nL\nfloat\nLength [m]\n1.0\n\n\ng\nfloat\nGravity [m/s²]\n9.81\n\n\nb\nfloat\nDamping coefficient [N·m·s/rad]\n0.1\n\n\ndt\nfloat\nSampling period [s]\n0.01\n\n\nmethod\nstr\nDiscretization method (‘zoh’, ‘euler’, ‘rk4’)\n'zoh'\n\n\nuse_control\nbool\nIf True, include control input\nTrue\n\n\n\n\n\n\ndesign_upward_stabilizer\nsystems.builtin.deterministic.discrete.DiscretePendulum.design_upward_stabilizer(\n)\nDesign LQR controller for upward stabilization.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nLQR gain K\n\n\n\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscretePendulum.setup_equilibria()\nSet up downward and upward equilibria."
  },
  {
    "objectID": "api/systems.base.utils.CodeGenerator.html",
    "href": "api/systems.base.utils.CodeGenerator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.CodeGenerator.html#methods",
    "href": "api/systems.base.utils.CodeGenerator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompile_all\nPre-compile functions for multiple backends.\n\n\ngenerate_dynamics\nGenerate f(x, u) function for specified backend.\n\n\ngenerate_dynamics_jacobians\nGenerate A and B Jacobian functions.\n\n\ngenerate_observation_jacobian\nGenerate C Jacobian function (∂h/∂x).\n\n\ngenerate_output\nGenerate h(x) function for specified backend.\n\n\nget_dynamics\nGet cached dynamics function without generating.\n\n\nget_info\nGet comprehensive information about code generation status.\n\n\nget_jacobians\nGet cached Jacobian functions without generating.\n\n\nget_output\nGet cached output function without generating.\n\n\nis_compiled\nCheck which functions are compiled for a backend.\n\n\nreset_cache\nClear cached functions for specified backends.\n\n\n\n\ncompile_all\nsystems.base.utils.CodeGenerator.compile_all(\n    backends=None,\n    include_jacobians=False,\n    verbose=False,\n    **kwargs,\n)\nPre-compile functions for multiple backends.\nUseful for: - Reducing first-call latency - Validating code generation - Warming up JIT compilers (JAX)\nArgs: backends: List of backends to compile (None = all available) include_jacobians: Also compile Jacobian functions verbose: Print compilation progress **kwargs: Backend-specific options\nReturns: Dict mapping backend → function_name → compilation_time\nExample: &gt;&gt;&gt; timings = code_gen.compile_all( … backends=[‘numpy’, ‘torch’], … include_jacobians=True, … verbose=True … ) Compiling numpy… f: 0.05s h: 0.03s A, B: 0.08s Compiling torch… f: 0.12s\n\n\ngenerate_dynamics\nsystems.base.utils.CodeGenerator.generate_dynamics(backend, **kwargs)\nGenerate f(x, u) function for specified backend.\nUses caching - if function already generated, returns cached version.\nArgs: backend: Target backend (‘numpy’, ‘torch’, ‘jax’) **kwargs: Backend-specific options (e.g., jit=True for JAX)\nReturns: DynamicsFunction: (x, u) → dx/dt\nExample: &gt;&gt;&gt; f_numpy = code_gen.generate_dynamics(‘numpy’) &gt;&gt;&gt; dx = f_numpy(x_vals, u_vals)\n\n\ngenerate_dynamics_jacobians\nsystems.base.utils.CodeGenerator.generate_dynamics_jacobians(backend, **kwargs)\nGenerate A and B Jacobian functions.\nArgs: backend: Target backend **kwargs: Backend-specific options\nReturns: Tuple of (A_func, B_func) where: A_func: (x, u) → ∂f/∂x B_func: (x, u) → ∂f/∂u\nExample: &gt;&gt;&gt; A_func, B_func = code_gen.generate_dynamics_jacobians(‘numpy’) &gt;&gt;&gt; A = A_func(x_vals, u_vals) &gt;&gt;&gt; B = B_func(x_vals, u_vals)\n\n\ngenerate_observation_jacobian\nsystems.base.utils.CodeGenerator.generate_observation_jacobian(\n    backend,\n    **kwargs,\n)\nGenerate C Jacobian function (∂h/∂x).\nReturns None if no custom output function.\nArgs: backend: Target backend **kwargs: Backend-specific options\nReturns: C_func: (x) → ∂h/∂x, or None if no custom output\n\n\ngenerate_output\nsystems.base.utils.CodeGenerator.generate_output(backend, **kwargs)\nGenerate h(x) function for specified backend.\nReturns None if system has no custom output function (uses identity).\nArgs: backend: Target backend (‘numpy’, ‘torch’, ‘jax’) **kwargs: Backend-specific options\nReturns: OutputFunction: (x) → y, or None if no custom output\nExample: &gt;&gt;&gt; h_numpy = code_gen.generate_output(‘numpy’) &gt;&gt;&gt; if h_numpy is not None: &gt;&gt;&gt; y = h_numpy(x_vals)\n\n\nget_dynamics\nsystems.base.utils.CodeGenerator.get_dynamics(backend)\nGet cached dynamics function without generating.\nArgs: backend: Target backend\nReturns: Cached function or None if not yet generated\n\n\nget_info\nsystems.base.utils.CodeGenerator.get_info()\nGet comprehensive information about code generation status.\nReturns: Dict with compilation status for all backends\nExample: &gt;&gt;&gt; info = code_gen.get_info() &gt;&gt;&gt; print(info) { ‘numpy’: {‘f’: True, ‘h’: True, ‘A’: True, ‘B’: True, ‘C’: False}, ‘torch’: {‘f’: True, ‘h’: False, ‘A’: False, ‘B’: False, ‘C’: False}, ‘jax’: {‘f’: False, ‘h’: False, ‘A’: False, ‘B’: False, ‘C’: False} }\n\n\nget_jacobians\nsystems.base.utils.CodeGenerator.get_jacobians(backend)\nGet cached Jacobian functions without generating.\nArgs: backend: Target backend\nReturns: Tuple of (A_func, B_func, C_func) or None if not yet generated\n\n\nget_output\nsystems.base.utils.CodeGenerator.get_output(backend)\nGet cached output function without generating.\nArgs: backend: Target backend\nReturns: Cached function or None if not yet generated\n\n\nis_compiled\nsystems.base.utils.CodeGenerator.is_compiled(backend)\nCheck which functions are compiled for a backend.\nArgs: backend: Backend to check\nReturns: Dict mapping function_name → is_compiled\nExample: &gt;&gt;&gt; status = code_gen.is_compiled(‘numpy’) &gt;&gt;&gt; print(status) {‘f’: True, ‘h’: False, ‘A’: True, ‘B’: True, ‘C’: False}\n\n\nreset_cache\nsystems.base.utils.CodeGenerator.reset_cache(backends=None)\nClear cached functions for specified backends.\nUseful when: - Changing devices (need recompilation) - Freeing memory - Debugging\nArgs: backends: List of backends to reset (None = all)\nExample: &gt;&gt;&gt; # Clear all caches &gt;&gt;&gt; code_gen.reset_cache() &gt;&gt;&gt; &gt;&gt;&gt; # Clear only torch cache (e.g., after device change) &gt;&gt;&gt; code_gen.reset_cache([‘torch’])"
  },
  {
    "objectID": "api/types.backends.SystemConfig.html",
    "href": "api/types.backends.SystemConfig.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.SystemConfig.html#attributes",
    "href": "api/types.backends.SystemConfig.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nname\nstr\nSystem name (user-defined)\n\n\nclass_name\nstr\nPython class name\n\n\nnx\nint\nState dimension\n\n\nnu\nint\nControl dimension\n\n\nny\nint\nOutput dimension\n\n\nnw\nint\nNoise dimension (stochastic only)\n\n\nis_discrete\nbool\nDiscrete-time vs continuous-time\n\n\nis_stochastic\nbool\nStochastic vs deterministic\n\n\nis_autonomous\nbool\nAutonomous (nu=0) vs controlled\n\n\nbackend\nBackend\nDefault computational backend\n\n\ndevice\nDevice\nPreferred hardware device\n\n\nparameters\nDict\nSymbolic parameter values"
  },
  {
    "objectID": "api/types.backends.SystemConfig.html#examples",
    "href": "api/types.backends.SystemConfig.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; config: SystemConfig = system.get_config_dict()\n&gt;&gt;&gt; print(f\"System: {config['class_name']}\")\n&gt;&gt;&gt; print(f\"States: {config['nx']}, Controls: {config['nu']}\")\n&gt;&gt;&gt; print(f\"Backend: {config['backend']}, Device: {config['device']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create from scratch\n&gt;&gt;&gt; config: SystemConfig = {\n...     'name': 'Pendulum',\n...     'class_name': 'InvertedPendulum',\n...     'nx': 2,\n...     'nu': 1,\n...     'ny': 2,\n...     'is_discrete': False,\n...     'is_stochastic': False,\n...     'backend': 'numpy',\n... }"
  },
  {
    "objectID": "api/types.protocols.StochasticSystemProtocol.html",
    "href": "api/types.protocols.StochasticSystemProtocol.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.protocols.StochasticSystemProtocol.html#implementations",
    "href": "api/types.protocols.StochasticSystemProtocol.html#implementations",
    "title": "",
    "section": "Implementations",
    "text": "Implementations\n\nContinuousStochasticSystem\nDiscreteStochasticSystem"
  },
  {
    "objectID": "api/types.protocols.StochasticSystemProtocol.html#examples",
    "href": "api/types.protocols.StochasticSystemProtocol.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; def estimate_noise_covariance(\n...     system: StochasticSystemProtocol,\n...     n_samples: int = 1000\n... ) -&gt; np.ndarray:\n...     '''Estimate noise covariance from simulation.'''\n...     if system.is_additive_noise():\n...         # Constant noise - compute once\n...         G = system.get_constant_noise()\n...         return G @ G.T\n...     else:\n...         # State-dependent - estimate via Monte Carlo\n...         # ...\n...         pass"
  },
  {
    "objectID": "api/types.protocols.StochasticSystemProtocol.html#attributes",
    "href": "api/types.protocols.StochasticSystemProtocol.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nis_stochastic\nTrue for stochastic systems\n\n\nnw\nNumber of noise sources"
  },
  {
    "objectID": "api/types.protocols.StochasticSystemProtocol.html#methods",
    "href": "api/types.protocols.StochasticSystemProtocol.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nis_additive_noise\nTrue if noise is state-independent\n\n\nis_multiplicative_noise\nTrue if noise depends on state\n\n\n\n\nis_additive_noise\ntypes.protocols.StochasticSystemProtocol.is_additive_noise()\nTrue if noise is state-independent\n\n\nis_multiplicative_noise\ntypes.protocols.StochasticSystemProtocol.is_multiplicative_noise()\nTrue if noise depends on state"
  },
  {
    "objectID": "api/types.control_advanced.MPCResult.html",
    "href": "api/types.control_advanced.MPCResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_advanced.MPCResult.html#fields",
    "href": "api/types.control_advanced.MPCResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ncontrol_sequence : ControlSequence Optimal control trajectory u[0:N-1] (N, nu) predicted_trajectory : StateTrajectory Predicted state trajectory x[0:N] (N+1, nx) cost : float Optimal objective value J* success : bool Whether optimization converged successfully iterations : int Number of optimization iterations solve_time : float Computation time in seconds constraint_violations : Optional[ArrayLike] Slack variable values (if soft constraints used) dual_variables : Optional[ArrayLike] Lagrange multipliers (sensitivity to constraints)"
  },
  {
    "objectID": "api/types.control_advanced.MPCResult.html#examples",
    "href": "api/types.control_advanced.MPCResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Setup MPC\n&gt;&gt;&gt; mpc = ModelPredictiveController(\n...     system, horizon=20, Q=np.diag([10, 1]), R=np.array([[0.1]])\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Solve at current state\n&gt;&gt;&gt; x_current = np.array([1.0, 0.5])\n&gt;&gt;&gt; x_ref = np.zeros(2)\n&gt;&gt;&gt; result: MPCResult = mpc.solve(x_current, x_ref)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply first control (receding horizon)\n&gt;&gt;&gt; u_apply = result['control_sequence'][0]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check solution quality\n&gt;&gt;&gt; if result['success']:\n...     print(f\"Cost: {result['cost']:.3f}\")\n...     print(f\"Solve time: {result['solve_time']*1000:.1f} ms\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Examine predicted trajectory\n&gt;&gt;&gt; x_pred = result['predicted_trajectory']\n&gt;&gt;&gt; print(x_pred.shape)  # (21, 2) for horizon=20"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\n    A cart of mass M moving horizontally on a frictionless track, with a\n    pole (pendulum) of mass m and length L attached via a frictionless pivot.\n    The cart is actuated by a horizontal force F, while the pole is free to\n    rotate under gravity.\n\n    **Mechanical Configuration:**\n```\n                  ● m (pole mass)\n                 /|\n                / | L (pole length)\n               /  |\n              /   |\n         ====●====●==== Cart (mass M)\n         ←---F    |\n         _____|____|_____ Track (frictionless)\n              x (cart position)\n              θ (pole angle from vertical)\n```\n\n    **Key Features:**\n    - **Underactuated:** 4 states (x, ẋ, θ, θ̇), 1 control (F)\n    - **Nonlinear:** Coupled nonlinear dynamics\n    - **Non-minimum phase:** Zero at s = +√(g/L) (RHP for inverted)\n    - **Unstable:** Upright equilibrium is unstable without control\n\n    **This is THE classic underactuated system!**\n\n    **Equations of Motion (Lagrangian Mechanics):**\n    Using Euler-Lagrange equations with generalized coordinates q = [x, θ]:\n\n    Cart equation:\n        (M + m)·ẍ + m·L·θ̈·cos(θ) - m·L·θ̇²·sin(θ) = F\n\n    Pole equation:\n        m·L²·θ̈ + m·L·ẍ·cos(θ) - m·g·L·sin(θ) = 0\n\n    Solving for accelerations (ẍ, θ̈):\n\n        θ̈ = [g·sin(θ) - cos(θ)·(F + m·L·θ̇²·sin(θ))/(M + m)] /\n             [L·(4/3 - m·cos²(θ)/(M + m))]\n\n        ẍ = [F + m·L·(θ̇²·sin(θ) - θ̈·cos(θ))] / (M + m)\n\n    **Discrete-Time Dynamics:**\n    Zero-order hold discretization with numerical integration."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\n    State: x[k] = [x[k], ẋ[k], θ[k], θ̇[k]]\n        Cart position:\n        - x: Horizontal position of cart [m]\n          * Unbounded in principle: -∞ &lt; x &lt; ∞\n          * Typically constrained: |x| ≤ x_max (track length)\n          * x = 0: Reference position (often center of track)\n\n        Cart velocity:\n        - ẋ: Horizontal velocity of cart [m/s]\n          * Can be positive or negative\n          * Typical: |ẋ| &lt; 5 m/s\n\n        Pole angle:\n        - θ: Angle from upward vertical [rad]\n          * θ = 0: Pole upright (inverted, unstable)\n          * θ = π: Pole hanging down (stable)\n          * θ = ±π/2: Pole horizontal\n          * For control: typically keep |θ| &lt; π/4 (±45°)\n\n        Pole angular velocity:\n        - θ̇: Rate of change of pole angle [rad/s]\n          * Positive: Falling to the right\n          * Negative: Falling to the left\n          * Large |θ̇| indicates imminent fall\n\n    Control: u[k] = [F[k]]\n        Applied force on cart:\n        - F: Horizontal force [N]\n          * F &gt; 0: Push cart to the right\n          * F &lt; 0: Push cart to the left\n          * Bounded: |F| ≤ F_max (actuator limit)\n          * Typical: |F| ≤ 50 N\n\n    **Note on Convention:**\n    Some formulations measure θ from downward vertical (θ = 0 down, θ = π up).\n    This implementation uses θ = 0 for UPRIGHT (inverted), which is more\n    common in control literature and RL benchmarks.\n\n    Output: y[k] = [x[k], θ[k]] or full state\n        Typical measurements:\n        - x: Cart position (encoder, potentiometer)\n        - θ: Pole angle (encoder at pivot, IMU on pole)\n        - Velocities: Computed from differences or direct measurement"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#dynamics-physical-interpretation",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#dynamics-physical-interpretation",
    "title": "",
    "section": "Dynamics (Physical Interpretation):",
    "text": "Dynamics (Physical Interpretation):\n    **Coupling Between Cart and Pole:**\n    The dynamics are strongly coupled:\n    1. Moving cart → creates inertial force on pole (affects θ̈)\n    2. Pole falling → pulls cart in that direction (affects ẍ)\n    3. Centrifugal force: θ̇² term in cart equation\n    4. Gravitational torque: sin(θ) term in pole equation\n\n    **Underactuation:**\n    - 4 state variables (x, ẋ, θ, θ̇)\n    - 1 control input (F)\n    - Cannot independently control cart and pole\n    - Must use internal dynamics (coupling) to control pole\n\n    **Non-minimum Phase:**\n    If we try to move cart to the right (F &gt; 0):\n    - Initially, pole falls to the LEFT (opposite direction!)\n    - This is non-minimum phase behavior\n    - Complicates control design\n    - Cannot simply use output feedback\n\n    **Zero Dynamics:**\n    If we constrain x = constant (cart position fixed):\n    - Remaining dynamics are pole oscillations\n    - Zero dynamics unstable (pole falls down)\n    - This is why system is non-minimum phase"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\n    M : float, default=1.0\n        Mass of cart [kg]\n        - Typical: 0.5-5.0 kg\n        - Heavier cart: More inertia, slower response\n        - Lighter cart: Faster response, more sensitive to pole\n\n    m : float, default=0.1\n        Mass of pole [kg]\n        - Typical: 0.05-0.5 kg (much less than cart)\n        - Ratio m/M affects coupling strength\n        - Larger m: Stronger coupling, harder to balance\n\n    L : float, default=0.5\n        Half-length of pole [m]\n        - Distance from pivot to center of mass\n        - Full length = 2L\n        - Typical: 0.3-1.0 m\n        - Longer pole: Slower dynamics, easier to balance\n        - Shorter pole: Faster dynamics, harder to balance\n\n    g : float, default=9.81\n        Gravitational acceleration [m/s²]\n        - Earth: 9.81\n        - Moon: 1.62 (much easier to balance!)\n        - Mars: 3.71\n\n    b_cart : float, default=0.1\n        Cart friction coefficient [N·s/m]\n        - Linear viscous friction on cart\n        - Typical: 0.0-1.0\n        - b = 0: Frictionless (ideal)\n\n    b_pole : float, default=0.0\n        Pole friction coefficient [N·m·s/rad]\n        - Friction at pivot joint\n        - Typically negligible: b_pole ≈ 0\n        - Can include for realism\n\n    dt : float, default=0.02\n        Sampling period [s]\n        - Typical control rates: 20-100 Hz (dt = 0.01-0.05 s)\n        - Must be fast enough to stabilize unstable pole\n        - Rule of thumb: dt &lt; 0.1/ω_pole where ω_pole ~ √(g/L)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\n    **Four Equilibrium Points:**\n\n    1. **Downward, Center (x=0, ẋ=0, θ=π, θ̇=0):**\n       - STABLE: Pole hanging down, cart centered\n       - Natural resting position\n       - Easy to maintain (no control needed)\n       - Lowest potential energy\n\n    2. **Upward, Center (x=0, ẋ=0, θ=0, θ̇=0):**\n       - UNSTABLE: Pole inverted, cart centered\n       - Target for balancing control\n       - Requires continuous active control\n       - Highest potential energy\n       - Classic inverted pendulum problem\n\n    3. **Downward, Offset (x≠0, ẋ=0, θ=π, θ̇=0):**\n       - Family of stable equilibria\n       - Cart at any position, pole down\n       - Less interesting for control\n\n    4. **Upward, Offset (x≠0, ẋ=0, θ=0, θ̇=0):**\n       - Family of unstable equilibria\n       - Requires control to maintain both position and balance\n\n    **Linearization at Upright:**\n    Around (0, 0, 0, 0), with small angles (sin(θ) ≈ θ, cos(θ) ≈ 1):\n\n        θ̈ ≈ [(M + m)·g·θ - F] / [L·(M + m) - m·L]\n        ẍ ≈ [F - m·g·θ] / (M + m)\n\n    This gives a LINEAR system for control design."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#controllability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#controllability",
    "title": "",
    "section": "Controllability:",
    "text": "Controllability:\n    **The cart-pole is CONTROLLABLE:**\n    Despite being underactuated (4 states, 1 input), the system is completely\n    controllable. This is verified by checking rank of controllability matrix.\n\n    **Why controllable despite underactuation?**\n    - The coupling between cart and pole creates internal dynamics\n    - Moving cart affects pole angle (and vice versa)\n    - Can exploit this coupling to control both\n\n    **Lie Bracket Analysis:**\n    The system satisfies sufficient conditions for controllability:\n    - Control vector field and its Lie brackets span ℝ⁴\n\n    **Practical Controllability:**\n    With bounded control |F| ≤ F_max:\n    - Cannot balance pole beyond certain initial angles\n    - Cannot swing up from downward if F_max too small\n    - Reachable set depends on F_max and initial conditions"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#observability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#observability",
    "title": "",
    "section": "Observability:",
    "text": "Observability:\n    **Full State Measurement:**\n    Trivially observable (measure all 4 states directly).\n\n    **Partial Observations:**\n    - (x, θ) only: Observable (can reconstruct velocities)\n    - θ only: NOT observable (cart position decoupled)\n    - x only: NOT observable (pole angle decoupled)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\n    **1. Balance Control (Stabilization at Upright):**\n       Goal: Stabilize at (0, 0, 0, 0) from small perturbations\n       Methods:\n       - LQR (linearized around upright)\n       - Pole placement\n       - PID control\n       - Sliding mode control\n       Challenge: Unstable equilibrium, requires fast feedback\n\n    **2. Swing-Up Control:**\n       Goal: Move from downward (θ=π) to upright (θ=0)\n       Methods:\n       - Energy-based control\n       - Partial feedback linearization\n       - Trajectory optimization\n       - Reinforcement learning\n       Challenge: Large control effort, nonlinear dynamics\n\n    **3. Swing-Up + Balance (Full Problem):**\n       Goal: Swing up from any initial condition, then stabilize\n       Method: Switch between swing-up and balance controllers\n       - Swing-up when |θ - π| &gt; threshold\n       - Balance when |θ| &lt; threshold\n       Challenge: Smooth switching, mode transitions\n\n    **4. Trajectory Tracking:**\n       Goal: Follow reference trajectory (x_ref(t), θ_ref(t))\n       Application: Moving while balancing\n       Example: Segway following path\n\n    **5. Disturbance Rejection:**\n       Goal: Maintain balance despite pushes/bumps\n       Methods: Robust control, H∞, adaptive control"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\n    **1. Cart Position Limits: |x[k]| ≤ x_max**\n       - Physical track length\n       - Typical: x_max = 2-5 m\n       - Failure if cart hits end\n       - Must be enforced by controller\n\n    **2. Pole Angle Limits: |θ[k]| ≤ θ_max**\n       - Balancing region: θ_max ≈ π/12 (15°)\n       - Beyond this, typically considered \"fallen\"\n       - RL episode terminates if exceeded\n\n    **3. Velocity Limits:**\n       |ẋ[k]| ≤ ẋ_max: Cart velocity limit\n       |θ̇[k]| ≤ θ̇_max: Pole angular velocity limit\n\n    **4. Force Limits: |F[k]| ≤ F_max**\n       - Actuator saturation (most critical)\n       - Typical: F_max = 10-50 N\n       - Affects controllability region\n\n    **5. Success Criteria (Reinforcement Learning):**\n       - |x| &lt; x_max (typically 2.4 m)\n       - |θ| &lt; θ_max (typically 12° ≈ 0.2 rad)\n       - Episode fails if either violated"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\n    **Singularity at θ = ±π/2:**\n    The equations have division by [1 - m·cos²(θ)/(M+m)]\n    - Denominator → 0 as θ → ±π/2 for certain mass ratios\n    - Typically not an issue (pole doesn't reach horizontal when balancing)\n\n    **Angle Wrapping:**\n    For swing-up control, θ may exceed ±π:\n    - Can wrap to [-π, π] or leave unwrapped\n    - Unwrapped better for tracking rotations\n    - sin(θ), cos(θ) automatically handle periodicity"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n    &gt;&gt;&gt; # Create cart-pole with OpenAI Gym-like parameters\n    &gt;&gt;&gt; system = DiscreteCartPole(\n    ...     M=1.0,        # 1 kg cart\n    ...     m=0.1,        # 100g pole\n    ...     L=0.5,        # 1m pole (half-length)\n    ...     g=9.81,\n    ...     dt=0.02,      # 50 Hz\n    ...     method='rk4'\n    ... )\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; print(f\"Mass ratio m/M: {system.m/system.M:.2f}\")\n    &gt;&gt;&gt; print(f\"Pole natural frequency: {system.pole_frequency:.2f} rad/s\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Initial condition: upright with small perturbation\n    &gt;&gt;&gt; x0_upright = np.array([0.0, 0.0, 0.1, 0.0])  # Small angle\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Design LQR controller for balancing\n    &gt;&gt;&gt; x_eq = np.array([0.0, 0.0, 0.0, 0.0])\n    &gt;&gt;&gt; u_eq = np.array([0.0])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; Ad, Bd = system.linearize(x_eq, u_eq)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # LQR weights\n    &gt;&gt;&gt; Q = np.diag([1.0, 0.1, 100.0, 10.0])  # Care most about pole angle\n    &gt;&gt;&gt; R = np.array([[0.01]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; lqr_result = system.control.design_lqr(\n    ...     Ad, Bd, Q, R, system_type='discrete'\n    ... )\n    &gt;&gt;&gt; K = lqr_result['gain']\n    &gt;&gt;&gt; print(f\"\nLQR gain: K = {K}“) &gt;&gt;&gt; &gt;&gt;&gt; # Check closed-loop stability &gt;&gt;&gt; eigenvalues = lqr_result[‘closed_loop_eigenvalues’] &gt;&gt;&gt; print(f”Closed-loop eigenvalues: {eigenvalues}“) &gt;&gt;&gt; print(f”All stable: {np.all(np.abs(eigenvalues) &lt; 1)}“) &gt;&gt;&gt; &gt;&gt;&gt; # Simulate balancing &gt;&gt;&gt; def lqr_balance(x, k): … return -K @ x &gt;&gt;&gt; &gt;&gt;&gt; result_balance = system.rollout( … x0=x0_upright, … policy=lqr_balance, … n_steps=500 … ) &gt;&gt;&gt; &gt;&gt;&gt; # Plot balancing performance &gt;&gt;&gt; import plotly.graph_objects as go &gt;&gt;&gt; from plotly.subplots import make_subplots &gt;&gt;&gt; &gt;&gt;&gt; fig = make_subplots( … rows=3, cols=1, … subplot_titles=[‘Cart Position’, ‘Pole Angle’, ‘Control Force’] … ) &gt;&gt;&gt; &gt;&gt;&gt; t = result_balance[‘time_steps’] * system.dt &gt;&gt;&gt; &gt;&gt;&gt; # Cart position &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=result_balance[‘states’][:, 0], … name=‘x’), row=1, col=1) &gt;&gt;&gt; fig.add_hline(y=0, line_dash=‘dash’, row=1, col=1) &gt;&gt;&gt; &gt;&gt;&gt; # Pole angle (convert to degrees) &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t, y=np.rad2deg(result_balance[‘states’][:, 2]), … name=‘θ’), row=2, col=1) &gt;&gt;&gt; fig.add_hline(y=0, line_dash=‘dash’, row=2, col=1) &gt;&gt;&gt; fig.add_hline(y=12, line_dash=‘dot’, line_color=‘red’, row=2, col=1) &gt;&gt;&gt; fig.add_hline(y=-12, line_dash=‘dot’, line_color=‘red’, row=2, col=1) &gt;&gt;&gt; &gt;&gt;&gt; # Control force &gt;&gt;&gt; fig.add_trace(go.Scatter(x=t[:-1], y=result_balance[‘controls’][:, 0], … name=‘F’), row=3, col=1) &gt;&gt;&gt; &gt;&gt;&gt; fig.update_xaxes(title_text=‘Time [s]’, row=3, col=1) &gt;&gt;&gt; fig.update_yaxes(title_text=‘x [m]’, row=1, col=1) &gt;&gt;&gt; fig.update_yaxes(title_text=‘θ [deg]’, row=2, col=1) &gt;&gt;&gt; fig.update_yaxes(title_text=‘F [N]’, row=3, col=1) &gt;&gt;&gt; fig.update_layout(height=900, showlegend=False, … title_text=‘Cart-Pole Balancing Control (LQR)’) &gt;&gt;&gt; fig.show() &gt;&gt;&gt; &gt;&gt;&gt; # Energy-based swing-up control &gt;&gt;&gt; x0_down = np.array([0.0, 0.0, np.pi, 0.0]) # Pole hanging down &gt;&gt;&gt; &gt;&gt;&gt; def swing_up_controller(x, k): … x_pos, x_vel, theta, theta_vel = x … … # Current energy … E = system.compute_total_energy(theta, theta_vel) … … # Target energy (upright position) … E_target = system.m * system.g * system.L … … # Energy error … E_error = E - E_target … … # Switch to LQR when close to upright … if abs(theta) &lt; 0.3 and abs(theta_vel) &lt; 1.0: … # Stabilize using LQR … return -K @ x … else: … # Energy pumping … k_swing = 10.0 … # Pump energy: apply force in direction that increases energy … return k_swing * E_error * np.sign(theta_vel * np.cos(theta)) &gt;&gt;&gt; &gt;&gt;&gt; result_swing = system.rollout( … x0=x0_down, … policy=swing_up_controller, … n_steps=1000 … ) &gt;&gt;&gt; &gt;&gt;&gt; # Visualize swing-up &gt;&gt;&gt; fig_swing = system.plot_animation_frames(result_swing, frames=[0, 200, 400, 600, 800]) &gt;&gt;&gt; fig_swing.show() &gt;&gt;&gt; &gt;&gt;&gt; # Reinforcement learning evaluation &gt;&gt;&gt; def check_episode_success(states, x_threshold=2.4, theta_threshold=0.2): … ’‘’Check if episode stayed within success criteria.’’’ … x_ok = np.all(np.abs(states[:, 0]) &lt;= x_threshold) … theta_ok = np.all(np.abs(states[:, 2]) &lt;= theta_threshold) … return x_ok and theta_ok &gt;&gt;&gt; &gt;&gt;&gt; success = check_episode_success(result_balance[‘states’]) &gt;&gt;&gt; print(f” Balancing success: {success}“) &gt;&gt;&gt; &gt;&gt;&gt; # Compare different mass ratios &gt;&gt;&gt; mass_ratios = [0.05, 0.1, 0.2, 0.5] &gt;&gt;&gt; &gt;&gt;&gt; fig_compare = go.Figure() &gt;&gt;&gt; &gt;&gt;&gt; for m_ratio in mass_ratios: … sys_temp = DiscreteCartPole(M=1.0, m=m_ratio, L=0.5, dt=0.02) … … # Design LQR … Ad_temp, Bd_temp = sys_temp.linearize(x_eq, u_eq) … lqr_temp = sys_temp.control.design_lqr(Ad_temp, Bd_temp, Q, R, … system_type=‘discrete’) … K_temp = lqr_temp[‘gain’] … … # Simulate … result_temp = sys_temp.rollout( … x0=x0_upright, … policy=lambda x, k, K_=K_temp: -K_ @ x, … n_steps=500 … ) … … fig_compare.add_trace(go.Scatter( … x=t, … y=np.rad2deg(result_temp[‘states’][:, 2]), … name=f’m/M = {m_ratio:.2f}’ … )) &gt;&gt;&gt; &gt;&gt;&gt; fig_compare.update_layout( … title=‘Effect of Mass Ratio on Balancing’, … xaxis_title=‘Time [s]’, … yaxis_title=‘Pole Angle [deg]’ … ) &gt;&gt;&gt; fig_compare.show()"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\n    **Why Is It Hard to Balance?**\n    The upright position is an unstable saddle point:\n    - Any small disturbance causes pole to fall\n    - Falls faster as it tilts more (sin(θ) nonlinearity)\n    - Must apply corrective force before falling too far\n    - Human balancing uses same principles!\n\n    **The Balancing Strategy:**\n    To balance a falling pole:\n    1. Pole starts falling (θ ≠ 0)\n    2. Move cart in direction pole is falling\n    3. This creates inertial force opposing fall\n    4. Pole rights itself due to cart acceleration\n    5. Stop cart before oscillation grows\n\n    This is exactly what LQR does automatically!\n\n    **Energy Perspective for Swing-Up:**\n    Total energy: E = KE_cart + KE_pole + PE_pole\n\n    To swing up:\n    1. Pump energy by pushing cart back and forth\n    2. Exploit coupling: cart motion → pole motion\n    3. When E ≈ E_target, pole near vertical\n    4. Switch to stabilizing controller\n\n    **Non-Minimum Phase Behavior:**\n    Initial response is in \"wrong\" direction:\n    - Push cart right (F &gt; 0)\n    - Pole initially tilts LEFT\n    - Then cart movement brings pole back\n    - This is why simple controllers fail\n\n    **Mass Ratio Effects:**\n    The ratio m/M affects difficulty:\n    - Small m/M (light pole): Easier to balance, less coupling\n    - Large m/M (heavy pole): Harder to balance, strong coupling\n    - m/M = 1: Equal masses, maximum challenge\n    - Typical: m/M ≈ 0.1\n\n    **Pole Length Effects:**\n    Longer pole (larger L):\n    - Slower natural frequency: ω ~ √(g/L)\n    - Easier to balance (more reaction time)\n    - Larger moment of inertia\n    - But requires more space"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n    1. **Wrong angle convention:**\n       Some use θ = 0 for DOWN, others for UP\n       Check carefully! This implementation: θ = 0 is UPRIGHT\n\n    2. **Forgetting non-minimum phase:**\n       Cannot use simple output feedback\n       Need state feedback (or observer)\n\n    3. **Too slow sampling:**\n       Unstable pole requires fast control\n       dt &gt; 0.1 s typically too slow\n\n    4. **Linearization over-reach:**\n       Linear controller only works near upright\n       Breaks down for |θ| &gt; π/4\n       Need nonlinear control for swing-up\n\n    5. **Ignoring constraints:**\n       Real system has |x| &lt; x_max, |F| &lt; F_max\n       Must handle saturation and limits\n\n    6. **Switching controller discontinuities:**\n       Abrupt switch between swing-up and balance\n       Can cause chattering or instability\n       Use smooth transitions (hysteresis, blending)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#extensions",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#extensions",
    "title": "",
    "section": "Extensions:",
    "text": "Extensions:\n    1. **Rotary inverted pendulum (Furuta):**\n       Cart moves in circle instead of line\n       Different coupling dynamics\n\n    2. **Double inverted pendulum:**\n       Two poles in series (acrobot)\n       Much harder to control\n\n    3. **3D cart-pole:**\n       Pole can fall in any direction\n       Spherical coordinates needed\n\n    4. **Flexible pole:**\n       Pole bends (elastic)\n       Infinite-dimensional system\n\n    5. **With obstacles:**\n       Must avoid obstacles while balancing\n       Combines planning and control\n\n    6. **Multi-cart cooperation:**\n       Two carts balancing shared pole\n       Coordination problem"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#reinforcement-learning-context",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#reinforcement-learning-context",
    "title": "",
    "section": "Reinforcement Learning Context:",
    "text": "Reinforcement Learning Context:\n    The cart-pole is THE standard RL benchmark:\n    - **OpenAI Gym:** 'CartPole-v1' environment\n    - **State:** [x, ẋ, θ, θ̇]\n    - **Action:** Discrete {left, right} or continuous force\n    - **Reward:** +1 per timestep balanced\n    - **Done:** |x| &gt; 2.4 or |θ| &gt; 0.2 rad\n    - **Success:** Average reward &gt; 195 over 100 episodes\n\n    **Why Popular for RL?**\n    - Simple enough to learn quickly\n    - Complex enough to be interesting\n    - Unstable → requires intelligent control\n    - Fast simulation\n    - Well-understood theoretically (can validate)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\n    DiscretePendulum : Simpler (just pole, no cart)\n    CartPole : Continuous-time version"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#attributes",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\npole_frequency\nNatural frequency of pole oscillations √(g/L) [rad/s].\n\n\npole_period\nPeriod of small pole oscillations [s]."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteCartPole.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_total_energy\nCompute total mechanical energy of pole.\n\n\ndefine_system\nDefine discrete-time cart-pole dynamics.\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ncompute_total_energy\nsystems.builtin.deterministic.discrete.DiscreteCartPole.compute_total_energy(\n    theta,\n    theta_dot,\n)\nCompute total mechanical energy of pole.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntheta\nfloat\nPole angle [rad]\nrequired\n\n\ntheta_dot\nfloat\nPole angular velocity [rad/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTotal energy [J]\n\n\n\n\n\nNotes\nCart kinetic energy ignored (only pole energy for swing-up).\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteCartPole.define_system(\n    M=1.0,\n    m=0.1,\n    L=0.5,\n    g=9.81,\n    b_cart=0.1,\n    b_pole=0.0,\n    dt=0.02,\n)\nDefine discrete-time cart-pole dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nM\nfloat\nCart mass [kg]\n1.0\n\n\nm\nfloat\nPole mass [kg]\n0.1\n\n\nL\nfloat\nPole half-length [m] (distance from pivot to center of mass)\n0.5\n\n\ng\nfloat\nGravity [m/s²]\n9.81\n\n\nb_cart\nfloat\nCart friction [N·s/m]\n0.1\n\n\nb_pole\nfloat\nPole friction [N·m·s/rad]\n0.0\n\n\ndt\nfloat\nSampling period [s]\n0.02\n\n\nmethod\nstr\nDiscretization method (‘euler’, ‘rk4’)\nrequired\n\n\n\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscreteCartPole.setup_equilibria()\nSet up equilibrium points."
  },
  {
    "objectID": "api/types.linearization.DiscreteLinearization.html",
    "href": "api/types.linearization.DiscreteLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.DiscreteLinearization.html#examples",
    "href": "api/types.linearization.DiscreteLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Ad, Bd = discrete_system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; # Discrete-time stability: |λ| &lt; 1\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(Ad)\n&gt;&gt;&gt; is_stable = np.all(np.abs(eigenvalues) &lt; 1.0)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA rigid link of length L and mass m rotating about a fixed pivot (revolute\njoint) under the influence of:\n- Applied torque τ (control input)\n- Gravitational torque (proportional to sin(θ))\n- Viscous friction (proportional to angular velocity)\n- Coulomb friction (optional, velocity-dependent sign)\n\n**Mechanical Configuration:**\n              τ (motor torque)\n              ↓\n         ┌────●──── Pivot (fixed)\n         │\n         │ L (link length)\n         │\n         ●    ← m (mass at center of gravity)\n         │\n         │\n         ↓ g (gravity)\nThe link rotates in a vertical plane with angle θ measured from the downward\nvertical position (θ = 0 is straight down, θ = π is straight up).\n\n**Continuous-Time Dynamics (Euler-Lagrange):**\nThe equation of motion derived from Lagrangian mechanics:\n\n    I·θ̈ = τ - m·g·L_c·sin(θ) - b·θ̇\n\nwhere:\n    I: Moment of inertia about pivot [kg·m²]\n    τ: Applied torque (control input) [N·m]\n    m·g·L_c·sin(θ): Gravitational torque [N·m]\n    b·θ̇: Viscous friction torque [N·m]\n\nFor a uniform rod rotating about one end:\n    I = (1/3)·m·L²\n\nFor point mass at distance L_c:\n    I = m·L_c²\n\n**Discrete-Time Dynamics (Zero-Order Hold):**\nExact discretization assuming constant torque between samples:\n\n    θ[k+1] = θ[k] + dt·ω[k] + 0.5·dt²·α[k]\n    ω[k+1] = ω[k] + dt·α[k]\n\nwhere angular acceleration:\n    α[k] = (τ[k] - m·g·L_c·sin(θ[k]) - b·ω[k]) / I\n\nThis is the ZOH discretization of the second-order mechanical system."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] = [θ[k], ω[k]]\n    Angular position:\n    - θ: Joint angle [rad]\n      * θ = 0: Link pointing down (equilibrium, stable)\n      * θ = π: Link pointing up (equilibrium, unstable)\n      * θ = ±π/2: Horizontal positions\n      * Periodic: θ and θ + 2π are equivalent\n      * Typically unwrapped for control (track rotations)\n\n    Angular velocity:\n    - ω: Joint angular velocity [rad/s]\n      * ω &gt; 0: Counterclockwise rotation\n      * ω &lt; 0: Clockwise rotation\n      * ω = 0: Instantaneous rest\n      * Typical range: -10 to +10 rad/s for industrial robots\n\nControl: u[k] = [τ[k]]\n    Applied torque:\n    - τ: Motor/actuator torque [N·m]\n      * τ &gt; 0: Counterclockwise torque (lifts link)\n      * τ &lt; 0: Clockwise torque (lowers link)\n      * Bounded by actuator: τ_min ≤ τ ≤ τ_max\n      * Typical: |τ| ≤ 100 N·m for industrial arms\n\nOutput: y[k] = [θ[k]] or [θ[k], ω[k]]\n    - Position-only measurement (most common):\n      y[k] = θ[k]\n      Measured via encoder, resolver, or potentiometer\n    - Full state measurement:\n      y[k] = [θ[k], ω[k]]\n      Velocity from tachometer or differentiation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#dynamics-physical-interpretation",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#dynamics-physical-interpretation",
    "title": "",
    "section": "Dynamics (Physical Interpretation):",
    "text": "Dynamics (Physical Interpretation):\nThe discrete dynamics combine three effects:\n\n**1. Inertial Term (I·α):**\n   - Resistance to angular acceleration\n   - Larger I → slower response to torque\n   - Depends on mass distribution (I = ∫r²·dm)\n\n**2. Gravity Term (-m·g·L_c·sin(θ)):**\n   - Restoring torque toward θ = 0 (downward)\n   - Destabilizing torque near θ = π (upward)\n   - Maximum at θ = ±π/2 (horizontal)\n   - Zero at θ = 0, π (vertical positions)\n   - Creates nonlinearity (sinusoidal)\n\n**3. Friction Term (-b·ω):**\n   - Opposes motion (always negative sign relative to ω)\n   - Dissipates energy\n   - Causes exponential decay of free oscillations\n   - Linear approximation (Coulomb friction more realistic)\n\n**Energy Considerations:**\nTotal mechanical energy:\n    E = E_kinetic + E_potential\n    E = (1/2)·I·ω² + m·g·L_c·(1 - cos(θ))\n\nPotential energy reference at θ = 0 (downward).\n\nEnergy changes due to:\n- Control input: P_control = τ·ω (power delivered)\n- Friction: P_friction = -b·ω² (power dissipated, always negative)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm : float, default=1.0\n    Mass of the link [kg]\n    - Typical robot arms: 0.5-50 kg\n    - Satellite appendages: 1-100 kg\n    - Industrial robots: 5-500 kg\n\nL : float, default=1.0\n    Length of the link [m]\n    - Total physical length\n    - Typical: 0.1-3.0 m for robot arms\n    - Satellite booms: 1-20 m\n\nL_c : float, default=0.5\n    Distance from pivot to center of mass [m]\n    - For uniform rod: L_c = L/2\n    - For point mass at end: L_c = L\n    - For complex shapes: depends on mass distribution\n    - Must satisfy: 0 &lt; L_c ≤ L\n\ng : float, default=9.81\n    Gravitational acceleration [m/s²]\n    - Earth: 9.81\n    - Moon: 1.62\n    - Mars: 3.71\n    - Space (microgravity): ~0\n\nb : float, default=0.1\n    Viscous friction coefficient [N·m·s/rad]\n    - Models bearing friction, air resistance\n    - Typical: 0.01-1.0 for robot joints\n    - Larger values → more damping\n    - b = 0: No friction (conservative system)\n\ndt : float, default=0.01\n    Sampling period [s]\n    - Digital control update rate\n    - Typical: 0.001-0.1 s (10 Hz - 1 kHz)\n    - Must satisfy Nyquist criterion\n    - Smaller dt → better tracking, higher computation\n\nmethod : str, default='zoh'\n    Discretization method:\n    - 'zoh': Zero-order hold (exact for constant τ)\n    - 'euler': Forward Euler (simple, less accurate)\n    - 'rk4': Runge-Kutta 4th order (high accuracy)\n\ninertia_type : str, default='uniform_rod'\n    How to compute moment of inertia:\n    - 'uniform_rod': I = (1/3)·m·L² (rod about end)\n    - 'point_mass': I = m·L_c² (mass at L_c)\n    - 'thin_rod_center': I = (1/12)·m·L² (rod about center)\n    - 'custom': Use provided I value\n\nI_custom : Optional[float]\n    Custom moment of inertia [kg·m²] if inertia_type='custom'"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nThe system has two equilibrium points (where α = 0 with τ = 0):\n\n**1. Downward Equilibrium (θ = 0, ω = 0):**\n   Stability: STABLE (locally asymptotically stable)\n   - Link hanging down (lowest potential energy)\n   - Small perturbations oscillate and decay (if b &gt; 0)\n   - Eigenvalues in unit circle (|λ| &lt; 1)\n   - Natural resting position\n   - Requires no torque to maintain\n\n**2. Upward Equilibrium (θ = π, ω = 0):**\n   Stability: UNSTABLE (saddle point)\n   - Link pointing up (highest potential energy)\n   - Small perturbations grow exponentially\n   - Eigenvalues outside unit circle (|λ| &gt; 1)\n   - Requires active control to maintain (like inverted pendulum)\n   - Challenging control problem\n\n**Required Torque for Equilibrium at Arbitrary θ:**\nTo hold link at angle θ* with ω* = 0:\n    τ_eq = m·g·L_c·sin(θ*)\n\nExamples:\n- θ* = 0 (down): τ_eq = 0 (no torque needed)\n- θ* = π/2 (horizontal): τ_eq = m·g·L_c (maximum)\n- θ* = π (up): τ_eq = 0 (but unstable!)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#controllability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#controllability",
    "title": "",
    "section": "Controllability:",
    "text": "Controllability:\nThe discrete robot arm is COMPLETELY CONTROLLABLE from any state to any\nother state (in finite time) as long as τ is unbounded.\n\n**Proof:** The system is a discretization of:\n    ẍ = f(x, ẋ) + (1/I)·u\n\nwhere control u appears directly in acceleration. Since the system is\nsecond-order with full-rank controllability matrix, it's controllable.\n\n**Practical Controllability:**\nWith bounded control |τ| ≤ τ_max:\n- Some states unreachable in finite time\n- Upward position (θ = π) requires minimum τ_max &gt; m·g·L_c\n- Fast motions require large torques (I·α_max = τ_max)\n\n**Minimum Time Control:**\nFor point-to-point motion, optimal control is typically bang-bang:\n1. Apply maximum torque τ_max (accelerate)\n2. Coast (τ = 0) or partial torque\n3. Apply minimum torque -τ_max (decelerate)\n4. Arrive at target with ω = 0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#observability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#observability",
    "title": "",
    "section": "Observability:",
    "text": "Observability:\n**Position-only measurement: y[k] = θ[k]**\n    Observable for almost all trajectories.\n    Velocity can be estimated from position differences:\n        ω[k] ≈ (θ[k] - θ[k-1]) / dt\n\n    Better: Use Kalman filter or observer for ω estimation.\n\n**Full state measurement: y[k] = [θ[k], ω[k]]**\n    Trivially observable (direct measurement).\n\n**Nonlinear Observability:**\nThe system is nonlinear, so observability depends on trajectory.\nFor most motions, position measurement sufficient to reconstruct full state."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\n**1. Regulation (Stabilization):**\n   Goal: Drive to equilibrium (typically θ = 0, ω = 0)\n   Methods:\n   - PD control: τ = -k_p·θ - k_d·ω\n   - LQR (linearized): Optimal gains for quadratic cost\n   - Energy-based: Swing-up then stabilize\n   - Sliding mode: Robust to uncertainty\n\n**2. Trajectory Tracking:**\n   Goal: Follow reference trajectory θ_ref(t), ω_ref(t)\n   Control law:\n       τ = I·α_ref + m·g·L_c·sin(θ) + b·ω - K·e\n\n   where e = [θ - θ_ref, ω - ω_ref] is tracking error.\n\n   Applications:\n   - Pick-and-place operations\n   - Assembly tasks\n   - Welding/cutting paths\n\n**3. Swing-Up Control:**\n   Goal: Move from downward (θ = 0) to upward (θ = π)\n   Challenge: Requires energy injection, then stabilization\n   Methods:\n   - Energy-based control (pump energy until E = E_target)\n   - Partial feedback linearization\n   - Model predictive control (MPC)\n\n**4. Disturbance Rejection:**\n   Goal: Maintain position despite external forces\n   Disturbances:\n   - Unknown loads (changing m)\n   - Wind/vibrations\n   - Model uncertainties\n   Methods:\n   - Integral action (PI/PID)\n   - Disturbance observer\n   - Adaptive control\n\n**5. Optimal Control:**\n   Goal: Minimize cost functional (time, energy, jerk)\n   Examples:\n   - Minimum time: J = ∫ dt\n   - Minimum energy: J = ∫ τ² dt\n   - Minimum jerk: J = ∫ (dα/dt)² dt (smooth motion)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\n**1. Joint Limits: θ_min ≤ θ[k] ≤ θ_max**\n   - Physical stops prevent full rotation\n   - Typical: -π ≤ θ ≤ π or 0 ≤ θ ≤ 2π\n   - Some joints: limited range (e.g., ±90°)\n   - Must respect in trajectory planning\n\n**2. Velocity Limits: |ω[k]| ≤ ω_max**\n   - Motor speed limitations\n   - Safety considerations\n   - Typical: ω_max = 5-50 rad/s\n   - Affects trajectory feasibility\n\n**3. Torque Limits: |τ[k]| ≤ τ_max**\n   - Motor torque saturation (most critical)\n   - Typical: τ_max = 10-1000 N·m\n   - Causes anti-windup issues in PI/PID\n   - Must account for in MPC\n\n**4. Acceleration Limits: |α[k]| ≤ α_max**\n   - Mechanical stress limitations\n   - Passenger/payload comfort\n   - Jerk limits: |dα/dt| ≤ jerk_max"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\n**Discretization Accuracy:**\n- ZOH: Exact for piecewise-constant τ\n- Euler: O(dt) error, may be unstable for large dt\n- RK4: O(dt⁴) error, excellent accuracy\n\n**Stability Condition:**\nFor explicit methods, stability requires:\n    dt &lt; 2/√(ω_n²)\n\nwhere ω_n ≈ √(m·g·L_c/I) is natural frequency.\n\nFor typical parameters: dt &lt; 0.1 s is safe.\n\n**Angle Wrapping:**\nFor continuous rotation (no joint limits):\n- Wrap θ to [-π, π] or [0, 2π]\n- Avoid discontinuities in controller\n- Use sin(θ), cos(θ) when possible (smooth)\n\n**Singularities:**\n- θ = ±π: Linearization singular (sin(θ) ≈ -θ not valid)\n- Requires nonlinear control near upward position"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n&gt;&gt;&gt; # Create robot arm with realistic parameters\n&gt;&gt;&gt; system = DiscreteRobotArm(\n...     m=2.0,        # 2 kg link\n...     L=0.5,        # 50 cm long\n...     L_c=0.25,     # Center of mass at midpoint\n...     g=9.81,       # Earth gravity\n...     b=0.1,        # Light damping\n...     dt=0.01       # 100 Hz control rate\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Initial condition: hanging down, at rest\n&gt;&gt;&gt; x0 = np.array([0.0, 0.0])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design PD controller for downward stabilization\n&gt;&gt;&gt; Ad, Bd = system.linearize(np.zeros(2), np.zeros(1))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # LQR design\n&gt;&gt;&gt; Q = np.diag([100.0, 1.0])  # Care more about position\n&gt;&gt;&gt; R = np.array([[1.0]])\n&gt;&gt;&gt; lqr_result = system.control.design_lqr(\n...     Ad, Bd, Q, R, system_type='discrete'\n... )\n&gt;&gt;&gt; K = lqr_result['gain']\n&gt;&gt;&gt; print(f\"LQR gain: K = {K}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simulate with LQR control from perturbed initial condition\n&gt;&gt;&gt; x0_perturbed = np.array([0.5, 0.0])  # 30° displacement\n&gt;&gt;&gt;\n&gt;&gt;&gt; def lqr_controller(x, k):\n...     return -K @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_lqr = system.rollout(\n...     x0_perturbed,\n...     lqr_controller,\n...     n_steps=500\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot results\n&gt;&gt;&gt; import plotly.graph_objects as go\n&gt;&gt;&gt; from plotly.subplots import make_subplots\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig = make_subplots(\n...     rows=3, cols=1,\n...     subplot_titles=['Angle', 'Angular Velocity', 'Control Torque']\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; t = result_lqr['time_steps'] * system.dt\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Angle\n&gt;&gt;&gt; fig.add_trace(\n...     go.Scatter(x=t, y=result_lqr['states'][:, 0], name='θ'),\n...     row=1, col=1\n... )\n&gt;&gt;&gt; fig.add_hline(y=0, line_dash='dash', line_color='red', row=1, col=1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Angular velocity\n&gt;&gt;&gt; fig.add_trace(\n...     go.Scatter(x=t, y=result_lqr['states'][:, 1], name='ω'),\n...     row=2, col=1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Control torque\n&gt;&gt;&gt; fig.add_trace(\n...     go.Scatter(x=t, y=result_lqr['controls'][:, 0], name='τ'),\n...     row=3, col=1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; fig.update_xaxes(title_text='Time [s]', row=3, col=1)\n&gt;&gt;&gt; fig.update_yaxes(title_text='θ [rad]', row=1, col=1)\n&gt;&gt;&gt; fig.update_yaxes(title_text='ω [rad/s]', row=2, col=1)\n&gt;&gt;&gt; fig.update_yaxes(title_text='τ [N·m]', row=3, col=1)\n&gt;&gt;&gt; fig.update_layout(height=800, showlegend=False)\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Gravity compensation control\n&gt;&gt;&gt; def gravity_comp_pd(x, k):\n...     theta, omega = x\n...     # PD gains\n...     k_p, k_d = 50.0, 10.0\n...     # Desired position (horizontal)\n...     theta_d = np.pi / 2\n...     # PD + gravity compensation\n...     tau_pd = -k_p * (theta - theta_d) - k_d * omega\n...     tau_gravity = system.compute_gravity_torque(theta)\n...     return tau_pd + tau_gravity\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_grav = system.rollout(\n...     x0=np.array([0.0, 0.0]),\n...     policy=gravity_comp_pd,\n...     n_steps=1000\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Swing-up control (energy-based)\n&gt;&gt;&gt; def swing_up_controller(x, k):\n...     theta, omega = x\n...\n...     # Compute current energy\n...     E_current = system.compute_total_energy(theta, omega)\n...     E_target = system.compute_potential_energy(np.pi)  # Upward\n...\n...     # If near upward, switch to stabilization\n...     if abs(theta - np.pi) &lt; 0.2 and abs(omega) &lt; 0.5:\n...         # LQR around upward equilibrium\n...         x_error = np.array([theta - np.pi, omega])\n...         K_up = system.design_upward_controller()\n...         return -K_up @ x_error\n...     else:\n...         # Energy pumping\n...         E_error = E_current - E_target\n...         k_E = 2.0\n...         return -k_E * E_error * omega * np.cos(theta)\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_swing = system.rollout(\n...     x0=np.array([0.0, 0.0]),\n...     policy=swing_up_controller,\n...     n_steps=2000\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Trajectory tracking\n&gt;&gt;&gt; # Generate smooth trajectory\n&gt;&gt;&gt; n_steps_traj = 500\n&gt;&gt;&gt; t_traj = np.arange(n_steps_traj) * system.dt\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Polynomial trajectory (quintic for smooth accel/decel)\n&gt;&gt;&gt; theta_ref, omega_ref, alpha_ref = system.generate_quintic_trajectory(\n...     theta_0=0.0,\n...     theta_f=np.pi/2,\n...     T=t_traj[-1],\n...     n_points=n_steps_traj\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; def tracking_controller(x, k):\n...     if k &gt;= len(theta_ref):\n...         k = len(theta_ref) - 1\n...\n...     theta, omega = x\n...\n...     # Feedforward (inverse dynamics)\n...     tau_ff = (system.I * alpha_ref[k] +\n...               system.m * system.g * system.L_c * np.sin(theta_ref[k]) +\n...               system.b * omega_ref[k])\n...\n...     # Feedback (PD on error)\n...     e_theta = theta - theta_ref[k]\n...     e_omega = omega - omega_ref[k]\n...     tau_fb = -50.0 * e_theta - 10.0 * e_omega\n...\n...     return tau_ff + tau_fb\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_track = system.rollout(\n...     x0=np.array([0.0, 0.0]),\n...     policy=tracking_controller,\n...     n_steps=n_steps_traj\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot tracking performance\n&gt;&gt;&gt; fig_track = go.Figure()\n&gt;&gt;&gt; fig_track.add_trace(go.Scatter(\n...     x=t_traj, y=theta_ref,\n...     name='Reference', line=dict(dash='dash', width=3)\n... ))\n&gt;&gt;&gt; fig_track.add_trace(go.Scatter(\n...     x=t_traj, y=result_track['states'][:, 0],\n...     name='Actual'\n... ))\n&gt;&gt;&gt; fig_track.update_layout(\n...     title='Trajectory Tracking',\n...     xaxis_title='Time [s]',\n...     yaxis_title='Angle [rad]'\n... )\n&gt;&gt;&gt; fig_track.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute tracking error metrics\n&gt;&gt;&gt; error = result_track['states'][:, 0] - theta_ref\n&gt;&gt;&gt; rmse = np.sqrt(np.mean(error**2))\n&gt;&gt;&gt; max_error = np.max(np.abs(error))\n&gt;&gt;&gt; print(f\"RMSE: {rmse:.4f} rad\")\n&gt;&gt;&gt; print(f\"Max error: {max_error:.4f} rad\")"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\n**Underactuation:**\nThe robot arm is NOT underactuated - it has 2 states (θ, ω) and 1 control (τ),\nbut since τ directly affects acceleration (second derivative), it's\nfully actuated. Compare to cart-pole (4 states, 1 control = underactuated).\n\n**Gravity Compensation:**\nThe term m·g·L_c·sin(θ) represents gravitational torque. To hold the arm\nat angle θ without moving:\n    τ_hold = m·g·L_c·sin(θ)\n\nThis is feed-forward compensation - cancels gravity exactly.\n\nAt θ = π/2 (horizontal): Maximum torque = m·g·L_c\nAt θ = 0 or π (vertical): Zero torque needed\n\n**Energy Perspective:**\nTotal energy: E = (1/2)·I·ω² + m·g·L_c·(1 - cos(θ))\n\nFor swing-up without friction:\n- Pump energy until E = m·g·L_c·2 (upward position)\n- Strategy: Add energy when ω and (θ - θ_target) have same sign\n\n**Passivity:**\nThe robot arm (without control) is passive:\n- Energy dissipated by friction: dE/dt = -b·ω² ≤ 0\n- No energy created spontaneously\n- Useful property for stability analysis\n\n**Friction Effects:**\n- Viscous friction (b·ω): Opposes motion, smooth\n- Coulomb friction (F_c·sign(ω)): Constant magnitude, causes stick-slip\n- Static friction: Prevents motion until τ &gt; τ_static\n- Often modeled as: τ_friction = b·ω + F_c·sign(ω) + F_s·δ(ω)\n\n**Coriolis and Centrifugal Forces:**\nFor single link, these are zero. For multi-link arms:\n- Coriolis: velocity-dependent coupling between joints\n- Centrifugal: velocity-squared terms\n- Complicate dynamics significantly"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n1. **Forgetting gravity compensation:**\n   PD control alone unstable at non-zero angles\n   Always add τ_gravity = m·g·L_c·sin(θ)\n\n2. **Wrong linearization point:**\n   Linearizing at θ = π (upward) gives UNSTABLE system\n   Different controller needed for upward stabilization\n\n3. **Angle wrapping issues:**\n   θ = π and θ = -π are same position\n   Controller must handle discontinuity\n\n4. **Ignoring torque saturation:**\n   Real motors have τ_max\n   Anti-windup essential for integral control\n\n5. **Insufficient discretization rate:**\n   dt too large → poor tracking, instability\n   Nyquist: Sample at least 10× natural frequency\n\n6. **Velocity estimation noise:**\n   Numerical differentiation amplifies noise\n   Use Kalman filter or low-pass filter"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#extensions",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#extensions",
    "title": "",
    "section": "Extensions:",
    "text": "Extensions:\n1. **Multi-link arm:**\n   Couple multiple single-link dynamics\n   Adds Coriolis, centrifugal terms\n\n2. **Flexible link:**\n   Model link as elastic beam\n   Infinite-dimensional system (PDE)\n\n3. **With payload:**\n   Variable mass at end-effector\n   Adaptive control needed\n\n4. **Friction models:**\n   Coulomb, Stribeck, LuGre models\n   More realistic friction behavior\n\n5. **Joint compliance:**\n   Series elastic actuator\n   Adds flexibility, impedance control\n\n6. **Cooperative manipulation:**\n   Multiple arms holding object\n   Force control, coordination"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDiscreteDoubleIntegrator : Simpler system (no gravity)\nDiscretePendulum : Similar (different notation)\nDiscreteCartPole : Underactuated extension"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#attributes",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ndamping_ratio\nDamping ratio (dimensionless).\n\n\nnatural_frequency\nNatural frequency of small oscillations around downward position [rad/s]."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteRobotArm.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_gravity_torque\nCompute gravitational torque at angle theta.\n\n\ncompute_kinetic_energy\nCompute kinetic energy.\n\n\ncompute_potential_energy\nCompute gravitational potential energy.\n\n\ncompute_total_energy\nCompute total mechanical energy.\n\n\ndefine_system\nDefine discrete-time robot arm dynamics.\n\n\ndesign_upward_controller\nDesign LQR controller for upward equilibrium stabilization.\n\n\ngenerate_quintic_trajectory\nGenerate smooth quintic polynomial trajectory.\n\n\nsetup_equilibria\nSet up equilibrium points (downward and upward).\n\n\n\n\ncompute_gravity_torque\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.compute_gravity_torque(\n    theta,\n)\nCompute gravitational torque at angle theta.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntheta\nfloat\nJoint angle [rad]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nGravitational torque [N·m]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteRobotArm()\n&gt;&gt;&gt; tau_g = system.compute_gravity_torque(np.pi/2)  # Horizontal\n&gt;&gt;&gt; print(f\"Gravity torque at horizontal: {tau_g:.2f} N·m\")\n\n\n\ncompute_kinetic_energy\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.compute_kinetic_energy(\n    omega,\n)\nCompute kinetic energy.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nomega\nfloat\nAngular velocity [rad/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nKinetic energy [J]\n\n\n\n\n\n\ncompute_potential_energy\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.compute_potential_energy(\n    theta,\n)\nCompute gravitational potential energy.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntheta\nfloat\nJoint angle [rad]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nPotential energy [J]\n\n\n\n\n\nNotes\nReference (zero potential): θ = 0 (downward)\n\n\n\ncompute_total_energy\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.compute_total_energy(\n    theta,\n    omega,\n)\nCompute total mechanical energy.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntheta\nfloat\nJoint angle [rad]\nrequired\n\n\nomega\nfloat\nAngular velocity [rad/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTotal energy [J]\n\n\n\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.define_system(\n    m=1.0,\n    L=1.0,\n    L_c=None,\n    g=9.81,\n    b=0.1,\n    dt=0.01,\n    method='zoh',\n    inertia_type='uniform_rod',\n    I_custom=None,\n)\nDefine discrete-time robot arm dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nm\nfloat\nLink mass [kg]\n1.0\n\n\nL\nfloat\nLink length [m]\n1.0\n\n\nL_c\nOptional[float]\nDistance to center of mass [m] (default: L/2)\nNone\n\n\ng\nfloat\nGravitational acceleration [m/s²]\n9.81\n\n\nb\nfloat\nViscous friction coefficient [N·m·s/rad]\n0.1\n\n\ndt\nfloat\nSampling period [s]\n0.01\n\n\nmethod\nstr\nDiscretization method (‘zoh’, ‘euler’, ‘rk4’)\n'zoh'\n\n\ninertia_type\nstr\nHow to compute inertia (‘uniform_rod’, ‘point_mass’, ‘custom’)\n'uniform_rod'\n\n\nI_custom\nOptional[float]\nCustom moment of inertia [kg·m²]\nNone\n\n\n\n\n\n\ndesign_upward_controller\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.design_upward_controller(\n)\nDesign LQR controller for upward equilibrium stabilization.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nLQR gain matrix K for upward position\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteRobotArm()\n&gt;&gt;&gt; K_up = system.design_upward_controller()\n&gt;&gt;&gt; print(f\"Upward stabilization gain: {K_up}\")\n\n\n\ngenerate_quintic_trajectory\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.generate_quintic_trajectory(\n    theta_0,\n    theta_f,\n    T,\n    n_points,\n)\nGenerate smooth quintic polynomial trajectory.\nQuintic ensures: - Smooth position, velocity, and acceleration - Zero velocity/acceleration at start and end\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntheta_0\nfloat\nInitial angle [rad]\nrequired\n\n\ntheta_f\nfloat\nFinal angle [rad]\nrequired\n\n\nT\nfloat\nTotal time [s]\nrequired\n\n\nn_points\nint\nNumber of points\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(theta_ref, omega_ref, alpha_ref) arrays\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteRobotArm(dt=0.01)\n&gt;&gt;&gt; theta_traj, omega_traj, alpha_traj = system.generate_quintic_trajectory(\n...     theta_0=0.0,\n...     theta_f=np.pi/2,\n...     T=5.0,\n...     n_points=500\n... )\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscreteRobotArm.setup_equilibria()\nSet up equilibrium points (downward and upward).\nAdds both stable (downward) and unstable (upward) equilibria."
  },
  {
    "objectID": "api/systems.base.utils.stochastic.DiffusionHandler.html",
    "href": "api/systems.base.utils.stochastic.DiffusionHandler.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.DiffusionHandler.html#examples",
    "href": "api/systems.base.utils.stochastic.DiffusionHandler.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; from sympy import symbols, Matrix\n&gt;&gt;&gt; x1, x2, u = symbols('x1 x2 u')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # State-independent (additive) noise\n&gt;&gt;&gt; diffusion = Matrix([[0.1], [0.2]])\n&gt;&gt;&gt; handler = DiffusionHandler(diffusion, [x1, x2], [u])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Automatic analysis\n&gt;&gt;&gt; print(handler.characteristics.noise_type)\nNoiseType.ADDITIVE\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(handler.characteristics.recommended_solvers('jax'))\n['sea', 'shark', 'sra1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate function with caching\n&gt;&gt;&gt; g_numpy = handler.generate_function('numpy')\n&gt;&gt;&gt; g_val = g_numpy(1.0, 0.5, 0.0)  # g(x1=1.0, x2=0.5, u=0.0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Second call returns cached\n&gt;&gt;&gt; g_numpy_cached = handler.generate_function('numpy')\n&gt;&gt;&gt; assert g_numpy is g_numpy_cached\n&gt;&gt;&gt;\n&gt;&gt;&gt; # For additive noise, get constant matrix\n&gt;&gt;&gt; if handler.characteristics.is_additive:\n...     G = handler.get_constant_noise('numpy')\n...     print(G)  # [[0.1], [0.2]] - precomputed!"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.DiffusionHandler.html#attributes",
    "href": "api/systems.base.utils.stochastic.DiffusionHandler.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ncharacteristics\nGet noise characteristics from automatic analysis."
  },
  {
    "objectID": "api/systems.base.utils.stochastic.DiffusionHandler.html#methods",
    "href": "api/systems.base.utils.stochastic.DiffusionHandler.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncan_optimize_for_additive\nCheck if additive-noise optimizations are applicable.\n\n\ncompile_all\nPre-compile diffusion functions for multiple backends.\n\n\ngenerate_function\nGenerate g(x, u) function for specified backend.\n\n\nget_constant_noise\nGet constant noise matrix for additive noise.\n\n\nget_function\nGet cached diffusion function without generating.\n\n\nget_info\nGet comprehensive information about diffusion handler state.\n\n\nget_optimization_opportunities\nIdentify optimization opportunities based on noise structure.\n\n\nget_stats\nGet generation statistics.\n\n\nhas_constant_noise\nCheck if constant noise has been computed and cached.\n\n\nis_compiled\nCheck if diffusion function is compiled for backend.\n\n\nreset_cache\nClear cached functions for specified backends.\n\n\nreset_stats\nReset generation statistics.\n\n\nwarmup\nWarm up function compilation (especially useful for JAX JIT).\n\n\n\n\ncan_optimize_for_additive\nsystems.base.utils.stochastic.DiffusionHandler.can_optimize_for_additive()\nCheck if additive-noise optimizations are applicable.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if diffusion is constant and can be precomputed\n\n\n\n\n\n\ncompile_all\nsystems.base.utils.stochastic.DiffusionHandler.compile_all(\n    backends=None,\n    verbose=False,\n    **kwargs,\n)\nPre-compile diffusion functions for multiple backends.\nMirrors CodeGenerator.compile_all() for consistency.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackends\nList[Backend]\nBackends to compile (None = all available)\nNone\n\n\nverbose\nbool\nPrint compilation progress\nFalse\n\n\n**kwargs\n\nBackend-specific options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, float]\nMapping backend → compilation_time\n\n\n\n\n\nExamples\n&gt;&gt;&gt; timings = handler.compile_all(verbose=True)\nCompiling diffusion for numpy: 0.05s\nCompiling diffusion for torch: 0.12s\nCompiling diffusion for jax: 0.08s\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(timings)\n{'numpy': 0.05, 'torch': 0.12, 'jax': 0.08}\n\n\n\ngenerate_function\nsystems.base.utils.stochastic.DiffusionHandler.generate_function(\n    backend,\n    **kwargs,\n)\nGenerate g(x, u) function for specified backend.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nTarget backend (‘numpy’, ‘torch’, ‘jax’)\nrequired\n\n\n**kwargs\n\nAdditional arguments for generate_function\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiffusionFunction\nCallable g(x, u) → diffusion matrix\n\n\n\n\n\n\nget_constant_noise\nsystems.base.utils.stochastic.DiffusionHandler.get_constant_noise(\n    backend='numpy',\n)\nGet constant noise matrix for additive noise.\nFor additive noise, diffusion doesn’t depend on state, control, or time, so it can be precomputed once and reused. This is a significant performance optimization for SDE solving.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nBackend for array type\n'numpy'\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiffusionMatrix\nConstant diffusion matrix, shape (nx, nw)\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf noise is not additive (use generate_function instead)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; if handler.characteristics.is_additive:\n...     G = handler.get_constant_noise('numpy')\n...     # G is constant - precompute once, reuse everywhere!\n...     for t in range(1000):\n...         # No need to evaluate diffusion - just use G\n...         pass\n\n\n\nget_function\nsystems.base.utils.stochastic.DiffusionHandler.get_function(backend)\nGet cached diffusion function without generating.\nMirrors CodeGenerator.get_dynamics().\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nTarget backend\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nOptional[DiffusionFunction]\nCached function or None if not yet generated\n\n\n\n\n\nExamples\n&gt;&gt;&gt; g = handler.get_function('numpy')\n&gt;&gt;&gt; if g is None:\n...     g = handler.generate_function('numpy')\n\n\n\nget_info\nsystems.base.utils.stochastic.DiffusionHandler.get_info()\nGet comprehensive information about diffusion handler state.\nMirrors CodeGenerator.get_info() for consistent API.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, any]\nStatus, characteristics, compilation state, statistics\n\n\n\n\n\nExamples\n&gt;&gt;&gt; info = handler.get_info()\n&gt;&gt;&gt; print(info)\n{\n    'dimensions': {'nx': 2, 'nw': 1},\n    'noise_type': 'additive',\n    'characteristics': {...},\n    'compiled': {'numpy': True, 'torch': False, 'jax': True},\n    'constant_noise_cached': True,\n    'statistics': {...}\n}\n\n\n\nget_optimization_opportunities\nsystems.base.utils.stochastic.DiffusionHandler.get_optimization_opportunities()\nIdentify optimization opportunities based on noise structure.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, bool]\nFlags for various optimization strategies\n\n\n\n\n\nExamples\n&gt;&gt;&gt; opts = handler.get_optimization_opportunities()\n&gt;&gt;&gt; if opts['precompute_diffusion']:\n...     G = handler.get_constant_noise()\n...     # Use G directly instead of calling diffusion(x, u)\n\n\n\nget_stats\nsystems.base.utils.stochastic.DiffusionHandler.get_stats()\nGet generation statistics.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, any]\nGeneration count, cache hits, timing\n\n\n\n\n\nExamples\n&gt;&gt;&gt; stats = handler.get_stats()\n&gt;&gt;&gt; print(f\"Cache hit rate: {stats['cache_hit_rate']:.1%}\")\n\n\n\nhas_constant_noise\nsystems.base.utils.stochastic.DiffusionHandler.has_constant_noise()\nCheck if constant noise has been computed and cached.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if any backend has cached constant noise\n\n\n\n\n\n\nis_compiled\nsystems.base.utils.stochastic.DiffusionHandler.is_compiled(backend)\nCheck if diffusion function is compiled for backend.\nMirrors CodeGenerator.is_compiled() but simpler (only one function type).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nBackend to check\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if function is cached/compiled\n\n\n\n\n\nExamples\n&gt;&gt;&gt; if not handler.is_compiled('jax'):\n...     handler.generate_function('jax')\n\n\n\nreset_cache\nsystems.base.utils.stochastic.DiffusionHandler.reset_cache(backends=None)\nClear cached functions for specified backends.\nMirrors CodeGenerator.reset_cache().\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackends\nList[Backend]\nBackends to reset (None = all)\nNone\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Clear all caches\n&gt;&gt;&gt; handler.reset_cache()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Clear only torch (e.g., after device change)\n&gt;&gt;&gt; handler.reset_cache(['torch'])\n\n\n\nreset_stats\nsystems.base.utils.stochastic.DiffusionHandler.reset_stats()\nReset generation statistics.\n\nExamples\n&gt;&gt;&gt; handler.reset_stats()\n&gt;&gt;&gt; stats = handler.get_stats()\n&gt;&gt;&gt; assert stats['generations'] == 0\n\n\n\nwarmup\nsystems.base.utils.stochastic.DiffusionHandler.warmup(backend, **kwargs)\nWarm up function compilation (especially useful for JAX JIT).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nBackend to warm up\nrequired\n\n\n**kwargs\n\nTest inputs for warmup call\n{}\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # JAX JIT warmup\n&gt;&gt;&gt; handler.warmup('jax')\n&gt;&gt;&gt; # First call compiled, subsequent calls fast"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#stochastic-differential-equation",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#stochastic-differential-equation",
    "title": "",
    "section": "Stochastic Differential Equation",
    "text": "Stochastic Differential Equation\ndX = (μ·X + u)·dt + σ·X·dW\nwhere: X(t) ∈ ℝ₊: State (price, population) μ: Drift (expected growth rate) σ &gt; 0: Volatility (noise intensity) u: Control (optional, additive) W(t): Standard Wiener process"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\n\nMultiplicative Noise: σ·X scales with state\nPositivity: X(t) &gt; 0 if X₀ &gt; 0\nLog-Normality: X(t) ~ LogNormal\nExponential Growth: E[X(t)] = X₀·exp(μ·t)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nExact Solution (u=0): X(t) = X₀·exp((μ - σ²/2)·t + σ·W(t))\nMoments: - Mean: E[X(t)] = X₀·exp(μ·t) - Variance: Var[X(t)] = X₀²·exp(2μ·t)·(exp(σ²·t) - 1) - Median: X₀·exp((μ - σ²/2)·t)\nAsymptotic Behavior: - μ &gt; σ²/2: Growth to ∞ - μ = σ²/2: Oscillates - μ &lt; σ²/2: Decay to 0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmu\nfloat\nDrift coefficient (expected growth rate) Typical: -0.1 to 0.3 for stocks\n0.1\n\n\nsigma\nfloat\nVolatility (must be positive) Typical stocks: 0.15-0.30 (15-30% annual)\n0.2"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x ∈ ℝ₊ = (0, ∞) Control: u ∈ ℝ (optional)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nNoise Type: MULTIPLICATIVE\nDiffusion: g(x) = σ·x (state-dependent)\nSDE Type: Itô (standard)\nNoise Dimension: nw = 1"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\nFinance: Stock prices, Black-Scholes model Biology: Population dynamics with noise Economics: GDP growth models Physics: Multiplicative noise processes"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nExact Scheme (Recommended): X[k+1] = X[k]·exp((μ - σ²/2)·Δt + σ·√Δt·Z[k])\nAlways positive, no discretization error."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nAssumes constant volatility\nNo jumps (continuous paths only)\nNo mean reversion\nEmpirical returns show fat tails"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nBrownianMotion : Additive noise version OrnsteinUhlenbeck : Mean-reverting process CoxIngersollRoss : Mean-reverting with multiplicative noise"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.GeometricBrownianMotion.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine geometric Brownian motion dynamics.\n\n\nget_expected_value\nCompute analytical expected value E[X(t)].\n\n\nget_variance\nCompute analytical variance Var[X(t)].\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.GeometricBrownianMotion.define_system(\n    mu=0.1,\n    sigma=0.2,\n)\nDefine geometric Brownian motion dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmu\nfloat\nDrift coefficient (growth rate) μ &gt; 0: Growth, μ = 0: Fair game, μ &lt; 0: Decay\n0.1\n\n\nsigma\nfloat\nVolatility (must be positive) Typical stocks: 0.15-0.30\n0.2\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf sigma ≤ 0\n\n\n\n\n\nNotes\nParameter Guidelines: - Large cap stocks: μ≈0.08, σ≈0.15-0.25 - Small cap stocks: μ≈0.12, σ≈0.30-0.50 - Sharpe ratio: (μ-r)/σ ≈ 0.3-0.5\nState Positivity: Multiplicative noise g(x) = σ·x ensures X(t) &gt; 0 for all t if X(0) &gt; 0.\nItô Correction: Expected log-return is μ - σ²/2, not μ, due to quadratic variation.\n\n\n\nget_expected_value\nsystems.builtin.stochastic.continuous.GeometricBrownianMotion.get_expected_value(\n    x0,\n    t,\n    u=0.0,\n)\nCompute analytical expected value E[X(t)].\nFor u=0: E[X(t)] = X₀·exp(μ·t)\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nfloat\nInitial state (must be positive)\nrequired\n\n\nt\nfloat\nTime (non-negative)\nrequired\n\n\nu\nfloat\nControl (assumed constant)\n0.0\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nExpected value E[X(t)]\n\n\n\n\n\nNotes\nMean grows exponentially at rate μ: - Doubling time: ln(2)/μ (if μ &gt; 0) - Half-life: ln(2)/|μ| (if μ &lt; 0)\n\n\nExamples\n&gt;&gt;&gt; gbm = GeometricBrownianMotion(mu=0.10, sigma=0.20)\n&gt;&gt;&gt; E_1yr = gbm.get_expected_value(x0=100, t=1.0)\n&gt;&gt;&gt; print(f\"Expected: ${E_1yr:.2f}\")  # $110.52\n\n\n\nget_variance\nsystems.builtin.stochastic.continuous.GeometricBrownianMotion.get_variance(\n    x0,\n    t,\n)\nCompute analytical variance Var[X(t)].\nVar[X(t)] = X₀²·exp(2μ·t)·(exp(σ²·t) - 1)\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nfloat\nInitial state (positive)\nrequired\n\n\nt\nfloat\nTime (non-negative)\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nVariance Var[X(t)]\n\n\n\n\n\nNotes\nCoefficient of variation grows unboundedly: CV = √(exp(σ²·t) - 1) → ∞ as t → ∞\n\n\nExamples\n&gt;&gt;&gt; gbm = GeometricBrownianMotion(mu=0.05, sigma=0.20)\n&gt;&gt;&gt; var = gbm.get_variance(x0=100, t=1.0)\n&gt;&gt;&gt; std = np.sqrt(var)\n&gt;&gt;&gt; print(f\"Std Dev: ${std:.2f}\")"
  },
  {
    "objectID": "api/types.symbolic.SymbolicJacobian.html",
    "href": "api/types.symbolic.SymbolicJacobian.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.symbolic.SymbolicJacobian.html#examples",
    "href": "api/types.symbolic.SymbolicJacobian.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; import sympy as sp\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Nonlinear system\n&gt;&gt;&gt; x, y = sp.symbols('x y')\n&gt;&gt;&gt; f = sp.Matrix([x**2 + y, x*y])\n&gt;&gt;&gt; \n&gt;&gt;&gt; J: SymbolicJacobian = f.jacobian([x, y])\n&gt;&gt;&gt; print(J)\n&gt;&gt;&gt; # Matrix([[2*x, 1],\n&gt;&gt;&gt; #         [y,   x]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Evaluate at a point\n&gt;&gt;&gt; J_at_point = J.subs({x: 1.0, y: 2.0})\n&gt;&gt;&gt; # Matrix([[2.0, 1.0],\n&gt;&gt;&gt; #         [2.0, 1.0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # For system dynamics linearization\n&gt;&gt;&gt; theta, omega = sp.symbols('theta omega', real=True)\n&gt;&gt;&gt; g, l = sp.symbols('g l', positive=True)\n&gt;&gt;&gt; \n&gt;&gt;&gt; f_dynamics = sp.Matrix([\n...     omega,\n...     -(g/l)*sp.sin(theta)\n... ])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # State Jacobian (A matrix)\n&gt;&gt;&gt; A: SymbolicJacobian = f_dynamics.jacobian([theta, omega])\n&gt;&gt;&gt; # Matrix([[0,              1],\n&gt;&gt;&gt; #         [-(g/l)*cos(theta), 0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Evaluate at upright equilibrium (theta=π, omega=0)\n&gt;&gt;&gt; A_upright = A.subs({theta: sp.pi, omega: 0})\n&gt;&gt;&gt; # Matrix([[0, 1],\n&gt;&gt;&gt; #         [g/l, 0]])  # Unstable!"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#parameters",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\nUser-provided method name (canonical or backend-specific)\nrequired\n\n\nbackend\nBackend\nTarget backend: ‘numpy’, ‘torch’, or ‘jax’\n'numpy'"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#returns",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nNormalized method name appropriate for backend"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#normalization-logic",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#normalization-logic",
    "title": "",
    "section": "Normalization Logic",
    "text": "Normalization Logic\n\nAuto-switching methods → Pass through unchanged\n\nJulia methods with parentheses (e.g., ‘AutoTsit5(Rosenbrock23())’)\n\nAlready valid for backend? → Return (with special upgrades)\n\nCheck if method is in BACKEND_METHODS[backend]\nSpecial case: lowercase euler/heun/midpoint on numpy → upgrade to Julia\nAvoids breaking SDE methods (e.g., ‘Euler’ on jax stays ‘Euler’)\n\nIn normalization map? → Map to backend-specific name\n\nCheck both exact case and lowercase versions\nHandles canonical names like ‘euler_maruyama’, ‘rk45’\nHandles explicit manual requests like ‘manual_euler’\n\nUnknown method? → Pass through unchanged\n\nWill fail at integrator level with appropriate error\nAllows custom methods to pass through"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#backend-conventions",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#backend-conventions",
    "title": "",
    "section": "Backend Conventions",
    "text": "Backend Conventions\n\nNumPy/Julia (DiffEqPy): Capitalized (e.g., ‘EM’, ‘Tsit5’, ‘SRIW1’)\nPyTorch (TorchSDE/TorchDiffEq): lowercase (e.g., ‘euler’, ‘dopri5’)\nJAX (Diffrax): PascalCase (e.g., ‘Euler’, ‘ItoMilstein’, ‘Tsit5’)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#julia-preference-for-ode-methods",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#julia-preference-for-ode-methods",
    "title": "",
    "section": "Julia Preference for ODE Methods",
    "text": "Julia Preference for ODE Methods\nOn NumPy backend, lowercase ODE methods automatically prefer Julia: - ‘euler’ → ‘Euler’ (Julia’s implementation) - ‘heun’ → ‘Heun’ (Julia’s implementation) - ‘midpoint’ → ‘Midpoint’ (Julia’s implementation)\nTo explicitly use manual implementations on NumPy: - Use ‘manual_euler’, ‘manual_heun’, ‘manual_midpoint’"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#idempotency",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#idempotency",
    "title": "",
    "section": "Idempotency",
    "text": "Idempotency\nNormalization is idempotent: &gt;&gt;&gt; normalize_method_name(normalize_method_name(‘euler_maruyama’, ‘jax’), ‘jax’) ‘Euler’\nOnce normalized, subsequent calls return the same result."
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#examples",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nCanonical SDE names → backend-specific:\n&gt;&gt;&gt; normalize_method_name('euler_maruyama', 'numpy')\n'EM'\n&gt;&gt;&gt; normalize_method_name('euler_maruyama', 'torch')\n'euler'\n&gt;&gt;&gt; normalize_method_name('euler_maruyama', 'jax')\n'Euler'\nCanonical ODE names → backend-specific:\n&gt;&gt;&gt; normalize_method_name('rk45', 'numpy')\n'RK45'\n&gt;&gt;&gt; normalize_method_name('rk45', 'torch')\n'dopri5'\n&gt;&gt;&gt; normalize_method_name('rk45', 'jax')\n'tsit5'\nJulia preference for ODE methods on NumPy:\n&gt;&gt;&gt; normalize_method_name('euler', 'numpy')\n'Euler'  # Upgraded to Julia\n&gt;&gt;&gt; normalize_method_name('heun', 'numpy')\n'Heun'   # Upgraded to Julia\n&gt;&gt;&gt; normalize_method_name('midpoint', 'numpy')\n'Midpoint'  # Upgraded to Julia\nManual implementations on NumPy:\n&gt;&gt;&gt; normalize_method_name('manual_euler', 'numpy')\n'euler'  # Explicit manual request\n&gt;&gt;&gt; normalize_method_name('manual_heun', 'numpy')\n'heun'   # Explicit manual request\nSDE methods preserved (critical for correctness):\n&gt;&gt;&gt; normalize_method_name('Euler', 'jax')\n'Euler'  # SDE method, NOT normalized to 'euler'\n&gt;&gt;&gt; normalize_method_name('Heun', 'jax')\n'Heun'   # SDE method, NOT normalized to 'heun'\nODE methods on torch/jax use manual implementations:\n&gt;&gt;&gt; normalize_method_name('euler', 'torch')\n'euler'\n&gt;&gt;&gt; normalize_method_name('heun', 'jax')\n'heun'\nCross-backend normalization (torch → jax):\n&gt;&gt;&gt; normalize_method_name('dopri5', 'jax')\n'dopri5'  # Note: 'dopri5' exists in JAX, so no mapping needed\nAlready correct for backend → unchanged:\n&gt;&gt;&gt; normalize_method_name('EM', 'numpy')\n'EM'\n&gt;&gt;&gt; normalize_method_name('ItoMilstein', 'jax')\n'ItoMilstein'\nManual implementations (portable):\n&gt;&gt;&gt; normalize_method_name('rk4', 'numpy')\n'rk4'\n&gt;&gt;&gt; normalize_method_name('rk4', 'torch')\n'rk4'\n&gt;&gt;&gt; normalize_method_name('rk4', 'jax')\n'rk4'\nUnknown method → pass through:\n&gt;&gt;&gt; normalize_method_name('my_custom_method', 'numpy')\n'my_custom_method'\n# Will be validated at integrator creation\nCase-insensitive lookup (canonical names only):\n&gt;&gt;&gt; normalize_method_name('RK45', 'torch')\n'dopri5'\n&gt;&gt;&gt; normalize_method_name('rk45', 'torch')\n'dopri5'"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#usage-in-discretizedsystem",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#usage-in-discretizedsystem",
    "title": "",
    "section": "Usage in DiscretizedSystem",
    "text": "Usage in DiscretizedSystem\n\n\n\nAutomatic normalization in init\nbackend = getattr(continuous_system, ’_default_backend’, ‘numpy’) method = normalize_method_name(user_method, backend) # Now ‘method’ is guaranteed to use backend conventions"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#notes",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nNormalization happens before any method classification\nOriginal method name should be preserved for debugging/logging\nSome canonical names map to different methods on different backends (e.g., ‘rk45’ → ‘RK45’/‘dopri5’/‘tsit5’)\nNot all methods can be perfectly mapped across backends (e.g., ‘lsoda’ doesn’t exist on PyTorch/JAX, maps to nearest equivalent)\nCritical: Methods already valid for a backend are preserved to avoid breaking SDE integration (e.g., ‘Euler’ on jax must stay ‘Euler’)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.normalize_method_name.html#see-also",
    "href": "api/systems.base.numerical_integration.normalize_method_name.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nvalidate_method : Check if method is valid for backend is_sde_method : Check if method is for stochastic systems is_fixed_step : Check if method uses fixed time stepping"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CartPole.html",
    "href": "api/systems.builtin.deterministic.continuous.CartPole.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CartPole.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.CartPole.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA pole (inverted pendulum) attached to a cart that moves horizontally. - Cart can slide freely on a horizontal track - Pole is attached to cart via a frictionless pivot - System is underactuated: 1 control input, 2 degrees of freedom - Nonlinear coupling between cart motion and pole angle"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CartPole.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.CartPole.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, θ, ẋ, θ̇] Position coordinates: - x: Cart position [m] (positive right) - θ: Pole angle from vertical [rad] * θ = 0: upright (unstable equilibrium) * θ = π: hanging down (stable equilibrium)\nVelocity coordinates:\n- ẋ (x_dot): Cart velocity [m/s]\n- θ̇ (theta_dot): Pole angular velocity [rad/s]\nControl: u = [F] - F: Horizontal force applied to cart [N] Can be positive (push right) or negative (push left)\nOutput: y = [x, θ] - Measures cart position and pole angle"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CartPole.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.CartPole.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe equations of motion (derived from Lagrangian mechanics):\nLet M = m_cart + m_pole, then:\nẍ = (F - b·ẋ + m_pole·l·θ̇²·sin(θ) - m_pole·g·sin(θ)·cos(θ)) / (M - m_pole·cos²(θ))\n\nθ̈ = (F·cos(θ) - b·ẋ·cos(θ) + m_pole·l·θ̇²·sin(θ)·cos(θ) - M·g·sin(θ)) / (l·(M - m_pole·cos²(θ)))\nPhysical interpretation: - Cart accelerates from applied force F - Pole motion creates reaction forces on cart - Centrifugal force (θ̇² term) affects both cart and pole - Gravity pulls pole down (sin(θ) term) - Friction opposes cart motion (b·ẋ)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CartPole.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.CartPole.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm_cart : float, default=1.0 Mass of the cart [kg] m_pole : float, default=0.1 Mass of the pole [kg] Typical: m_pole &lt;&lt; m_cart (light pole, heavy cart) length : float, default=0.5 Length from pivot to pole’s center of mass [m] gravity : float, default=9.81 Gravitational acceleration [m/s²] friction : float, default=0.1 Cart friction coefficient [N⋅s/m] Models bearing friction and air resistance"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CartPole.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.CartPole.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\n\nUpright (unstable): x_eq = [x*, 0, 0, 0] (any cart position, pole vertical) u_eq = 0 (no force needed)\nHanging (stable): x_eq = [x*, π, 0, 0] (any cart position, pole hanging) u_eq = 0 (no force needed)\n\nNOTE: this is a different convention than that of the SymbolicPendulum class; that system is defined with π radians being inverted/upward"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.CartPole.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.CartPole.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nSymbolicPendulum : Simpler version without cart PVTOL : Another underactuated system with similar challenges"
  },
  {
    "objectID": "api/systems.base.utils.BackendManager.html",
    "href": "api/systems.base.utils.BackendManager.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.BackendManager.html#attributes",
    "href": "api/systems.base.utils.BackendManager.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\navailable_backends\nGet list of available backends\n\n\ndefault_backend\nGet current default backend\n\n\npreferred_device\nGet current preferred device"
  },
  {
    "objectID": "api/systems.base.utils.BackendManager.html#methods",
    "href": "api/systems.base.utils.BackendManager.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncheck_available\nCheck if a backend is available.\n\n\nconvert\nConvert array to target backend with optional device placement.\n\n\ndetect\nDetect backend from array type.\n\n\nensure_type\nEnsure array is in specified backend type.\n\n\nget_extended_info\nGet extended backend information including versions.\n\n\nget_info\nGet backend configuration.\n\n\nrequire_backend\nRaise error if backend is not available.\n\n\nreset\nReset to default configuration (NumPy backend, CPU device).\n\n\nset_default\nSet default backend and optionally device.\n\n\nto_device\nSet preferred device for GPU-capable backends.\n\n\nuse_backend\nTemporarily switch to a different backend and/or device.\n\n\n\n\ncheck_available\nsystems.base.utils.BackendManager.check_available(backend)\nCheck if a backend is available.\nArgs: backend: Backend name to check\nReturns: True if backend is available, False otherwise\n\n\nconvert\nsystems.base.utils.BackendManager.convert(\n    array,\n    target_backend=None,\n    device=None,\n)\nConvert array to target backend with optional device placement.\nThis is the primary conversion method that combines backend conversion and device placement in a single operation. This method allows explicit device control.\nArgs: array: Source array (numpy.ndarray, torch.Tensor, or jax.numpy.ndarray) target_backend: Target backend (None = use default_backend) device: Target device (None = use preferred_device)\nReturns: Array in target backend format on specified device\nRaises: RuntimeError: If target backend is not available ValueError: If device is incompatible with target backend TypeError: If array type is not recognized\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; x_np = np.array([1.0, 2.0, 3.0]) &gt;&gt;&gt; &gt;&gt;&gt; # Convert to PyTorch on CPU &gt;&gt;&gt; x_torch = mgr.to_backend(x_np, ‘torch’, device=‘cpu’) &gt;&gt;&gt; &gt;&gt;&gt; # Convert to JAX (uses default device) &gt;&gt;&gt; x_jax = mgr.to_backend(x_np, ‘jax’) &gt;&gt;&gt; &gt;&gt;&gt; # Convert to default backend &gt;&gt;&gt; x_default = mgr.to_backend(x_jax) # Uses default_backend\nNote: - If target_backend is None, uses self.default_backend - If device is None, uses self.preferred_device - For numpy backend, device parameter is ignored (always CPU) - Performs no-op if array is already in target backend on correct device\n\n\ndetect\nsystems.base.utils.BackendManager.detect(array)\nDetect backend from array type.\nUses centralized type guards from utilities module for consistent backend detection across the framework.\nArgs: array: Input array/tensor\nReturns: Backend identifier (‘numpy’, ‘torch’, or ‘jax’)\nRaises: TypeError: If array type is not recognized\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; x = np.array([1.0]) &gt;&gt;&gt; mgr.detect(x) # Returns ‘numpy’ &gt;&gt;&gt; &gt;&gt;&gt; import torch &gt;&gt;&gt; x_torch = torch.tensor([1.0]) &gt;&gt;&gt; mgr.detect(x_torch) # Returns ‘torch’\n\n\nensure_type\nsystems.base.utils.BackendManager.ensure_type(arr, backend=None)\nEnsure array is in specified backend type.\nConverts array only if it’s not already the correct type. Less aggressive than convert() - preserves existing type if compatible.\nArgs: arr: Array to check/convert backend: Target backend (None = use default_backend)\nReturns: Array in correct backend type\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; x_np = np.array([1.0]) &gt;&gt;&gt; x_ensured = mgr.ensure_type(x_np, ‘numpy’) &gt;&gt;&gt; assert x_ensured is x_np # Same object (no conversion)\n\n\nget_extended_info\nsystems.base.utils.BackendManager.get_extended_info()\nGet extended backend information including versions.\nReturns: Dictionary with backend configuration and metadata\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; info = mgr.get_extended_info() &gt;&gt;&gt; print(info[‘available_backends’]) [‘numpy’, ‘torch’, ‘jax’]\n\n\nget_info\nsystems.base.utils.BackendManager.get_info()\nGet backend configuration.\nReturns: Structured backend configuration\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; config = mgr.get_info() &gt;&gt;&gt; print(config[‘backend’]) ‘numpy’\n\n\nrequire_backend\nsystems.base.utils.BackendManager.require_backend(backend)\nRaise error if backend is not available.\nArgs: backend: Backend name to check\nRaises: RuntimeError: If backend is not available\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; mgr.require_backend(‘torch’) # Raises if PyTorch not installed\n\n\nreset\nsystems.base.utils.BackendManager.reset()\nReset to default configuration (NumPy backend, CPU device).\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; mgr.set_default(‘torch’, device=‘cuda’) &gt;&gt;&gt; mgr.reset() &gt;&gt;&gt; mgr.default_backend # Returns ‘numpy’ &gt;&gt;&gt; mgr.preferred_device # Returns ‘cpu’\n\n\nset_default\nsystems.base.utils.BackendManager.set_default(backend, device=None)\nSet default backend and optionally device.\nArgs: backend: Backend name device: Device name (if None, device is not changed)\nReturns: Self for method chaining\nRaises: ValueError: If backend name is invalid or device incompatible RuntimeError: If backend is not available\n\n\nto_device\nsystems.base.utils.BackendManager.to_device(device)\nSet preferred device for GPU-capable backends.\nArgs: device: Device string (‘cpu’, ‘cuda’, ‘cuda:0’, ‘gpu:0’, etc.)\nReturns: Self for method chaining\nNote: Device is stored as a preference. Actual validation happens when backend is set or arrays are converted. This allows setting a preferred GPU device before switching to a GPU-capable backend.\nExample: &gt;&gt;&gt; mgr = BackendManager() &gt;&gt;&gt; mgr.to_device(‘cuda:0’) # Store preference &gt;&gt;&gt; mgr.set_default(‘torch’) # Now validates cuda:0 for torch\n\n\nuse_backend\nsystems.base.utils.BackendManager.use_backend(backend, device=None)\nTemporarily switch to a different backend and/or device.\nThis is a context manager that temporarily changes the default backend and device, restoring the original configuration when the context exits.\nArgs: backend: Temporary backend to use device: Optional temporary device\nReturns: Generator[BackendManager, None, None]: Context manager yielding self with temporary configuration\nExample: &gt;&gt;&gt; mgr = BackendManager(default_backend=‘numpy’) &gt;&gt;&gt; with mgr.use_backend(‘torch’, device=‘cuda’): … # Code here uses torch backend on CUDA … x = mgr.convert(x_np, mgr.default_backend) &gt;&gt;&gt; # Back to NumPy after context &gt;&gt;&gt; mgr.default_backend # Returns ‘numpy’"
  },
  {
    "objectID": "api/control.analyze_controllability.html",
    "href": "api/control.analyze_controllability.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.analyze_controllability.html#examples",
    "href": "api/control.analyze_controllability.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Fully controllable\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; B = np.array([[0], [1]])\n&gt;&gt;&gt; info = analyze_controllability(A, B)\n&gt;&gt;&gt; print(info['is_controllable'])  # True\n&gt;&gt;&gt; print(info['rank'])  # 2\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Uncontrollable system (diagonal with identical input)\n&gt;&gt;&gt; A = np.array([[1, 0], [0, 2]])\n&gt;&gt;&gt; B = np.array([[1], [1]])  # Can't control modes independently\n&gt;&gt;&gt; info = analyze_controllability(A, B)\n&gt;&gt;&gt; print(info['is_controllable'])  # False\n&gt;&gt;&gt; print(info['rank'])  # 1\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Single-input controllable\n&gt;&gt;&gt; A = np.array([[0, 1, 0], [0, 0, 1], [-1, -2, -3]])\n&gt;&gt;&gt; B = np.array([[0], [0], [1]])\n&gt;&gt;&gt; info = analyze_controllability(A, B)\n&gt;&gt;&gt; print(info['is_controllable'])  # True"
  },
  {
    "objectID": "api/control.analyze_controllability.html#notes",
    "href": "api/control.analyze_controllability.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nControllability is necessary for pole placement\nStabilizability: Unstable modes must be controllable (weaker condition)\nNumerical issues: Use SVD for better numerical stability\nFor large systems, consider PBH test or Gram matrix"
  },
  {
    "objectID": "api/control.design_kalman_filter.html",
    "href": "api/control.design_kalman_filter.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.design_kalman_filter.html#examples",
    "href": "api/control.design_kalman_filter.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Discrete Kalman filter\n&gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.95]])  # Slightly unstable\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position only\n&gt;&gt;&gt; Q = 0.01 * np.eye(2)    # Small process noise\n&gt;&gt;&gt; R = np.array([[0.1]])   # Measurement noise\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = design_kalman_filter(A, C, Q, R, system_type='discrete')\n&gt;&gt;&gt; L = result['gain']\n&gt;&gt;&gt; print(f\"Kalman gain: {L}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use in estimation loop\n&gt;&gt;&gt; x_hat = np.zeros(2)\n&gt;&gt;&gt; for k in range(N):\n...     # Prediction\n...     x_hat_pred = A @ x_hat + B @ u[k]\n...\n...     # Correction\n...     innovation = y[k] - C @ x_hat_pred\n...     x_hat = x_hat_pred + L @ innovation\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check estimator stability\n&gt;&gt;&gt; print(f\"Estimator stable: {np.all(np.abs(result['estimator_eigenvalues']) &lt; 1)}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Continuous Kalman filter\n&gt;&gt;&gt; result_c = design_kalman_filter(A, C, Q, R, system_type='continuous')\n&gt;&gt;&gt; L_c = result_c['gain']"
  },
  {
    "objectID": "api/control.design_kalman_filter.html#notes",
    "href": "api/control.design_kalman_filter.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nFor observability, (A, C) must be observable\nFor detectability, unstable modes must be observable\nQ must be positive semi-definite (process noise)\nR must be positive definite (measurement noise)\nKalman filter is optimal for linear Gaussian systems\nFor nonlinear systems, use Extended Kalman Filter (EKF) or Unscented Kalman Filter (UKF)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html",
    "href": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA one-dimensional chain of five oscillators where each element influences its neighbors through nonlinear coupling.\nEach oscillator has: - Linear restoring force (spring-like: -kx) - Linear damping (viscous: -cx) - Nonlinear coupling to neighbors via sin(x_j - x_i) - Only the first oscillator receives external control"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x₁, x₂, x₃, x₄, x₅] - x₁: State of oscillator 1 [rad or m] - x₂: State of oscillator 2 [rad or m] - x₃: State of oscillator 3 [rad or m] - x₄: State of oscillator 4 [rad or m] - x₅: State of oscillator 5 [rad or m]\nControl: u = [u] - u: External force/torque applied only to first oscillator - Influence propagates to other oscillators through coupling\nOutput: y = [x₁, x₃, x₅] - Sparse observation: only odd-numbered oscillators measured"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe equations of motion form a nearest-neighbor coupling structure:\nOscillator 1 (left boundary, receives control): dx₁/dt = -k·x₁ - c·x₁ + α·sin(x₂ - x₁) + u\nOscillator 2 (interior, coupled to neighbors): dx₂/dt = -k·x₂ - c·x₂ + α·sin(x₁ - x₂) + α·sin(x₃ - x₂)\nOscillator 3 (interior, coupled to neighbors): dx₃/dt = -k·x₃ - c·x₃ + α·sin(x₂ - x₃) + α·sin(x₄ - x₃)\nOscillator 4 (interior, coupled to neighbors): dx₄/dt = -k·x₄ - c·x₄ + α·sin(x₃ - x₄) + α·sin(x₅ - x₄)\nOscillator 5 (right boundary, no control): dx₅/dt = -k·x₅ - c·x₅ + α·sin(x₄ - x₅)\nPhysical interpretation: - Linear terms (-kx, -cx): individual oscillator wants to return to zero - Nonlinear coupling α·sin(x_j - x_i): synchronization force * When x_j &gt; x_i: positive force on i (speeds it up) * When x_j &lt; x_i: negative force on i (slows it down) * Maximum coupling at π/2 phase difference - Control u propagates through chain via coupling"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nk : float, default=1.0 Linear stiffness/restoring coefficient [1/s]. Higher k → stronger individual oscillator dynamics, weaker relative coupling influence. c : float, default=0.1 Damping coefficient [1/s]. Higher c → faster energy dissipation. Damps out transients and oscillations. alpha : float, default=0.1 Nonlinear coupling strength. Controls interaction between neighbors: - α = 0: Uncoupled oscillators - Small α: Weak coupling, local behavior dominates - Large α: Strong coupling, collective behavior emerges - α &gt; k+c: Coupling-dominated dynamics, synchronization possible"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#equilibrium",
    "href": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#equilibrium",
    "title": "",
    "section": "Equilibrium:",
    "text": "Equilibrium:\nSynchronous equilibrium (all at origin): x_eq = [0, 0, 0, 0, 0] (all oscillators aligned at zero) u_eq = 0 (no external force)\nThis equilibrium is stable due to damping. Other synchronized states (all x_i equal) are also equilibria for u=0."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.NonlinearChainSystem.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nCoupledOscillatorSystem : Smaller coupled system with different structure VanDerPolOscillator : Single nonlinear oscillator with limit cycle Lorenz : Another system with complex nonlinear dynamics"
  },
  {
    "objectID": "api/types.core.ScalarLike.html",
    "href": "api/types.core.ScalarLike.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.ScalarLike.html#examples",
    "href": "api/types.core.ScalarLike.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; dt: ScalarLike = 0.01\n&gt;&gt;&gt; learning_rate: ScalarLike = 1e-3"
  },
  {
    "objectID": "api/types.trajectories.StateTrajectory.html",
    "href": "api/types.trajectories.StateTrajectory.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.StateTrajectory.html#examples",
    "href": "api/types.trajectories.StateTrajectory.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Single trajectory from simulation\n&gt;&gt;&gt; x0 = np.array([1.0, 0.0])\n&gt;&gt;&gt; trajectory: StateTrajectory = system.simulate(x0, u_seq, steps=100)\n&gt;&gt;&gt; print(trajectory.shape)  # (101, 2) - includes initial state\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Extract position and velocity\n&gt;&gt;&gt; position = trajectory[:, 0]  # First state component\n&gt;&gt;&gt; velocity = trajectory[:, 1]  # Second state component\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Batched simulation (Monte Carlo)\n&gt;&gt;&gt; x0_batch = np.random.randn(1000, 2)  # 1000 initial conditions\n&gt;&gt;&gt; trajectories: StateTrajectory = system.simulate_batch(x0_batch, u_seq)\n&gt;&gt;&gt; print(trajectories.shape)  # (101, 1000, 2)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Multiple independent trials\n&gt;&gt;&gt; trials: StateTrajectory = np.array([\n...     system.simulate(x0, u_seq, steps=100)\n...     for _ in range(10)\n... ])\n&gt;&gt;&gt; print(trials.shape)  # (10, 101, 2)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#discrete-time-stochastic-dynamics",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#discrete-time-stochastic-dynamics",
    "title": "",
    "section": "Discrete-Time Stochastic Dynamics",
    "text": "Discrete-Time Stochastic Dynamics\nDifference equation (Euler discretization):\nC_A[k+1] = C_A[k] + [(F/V)·(C_A_feed - C_A[k]) - r[k]]·Δt + w_C[k]\nT[k+1] = T[k] + [(F/V)·(T_feed - T[k]) + q_gen[k] + q_removal[k]]·Δt + w_T[k]\nwhere: - r[k] = k₀·C_A[k]·exp(-E/T[k]): Reaction rate - q_gen = (-ΔH/ρC_p)·r: Heat generation - q_removal = (UA/VρC_p)·(T_jacket[k] - T[k]): Heat removal - w[k] ~ N(0, diag(σ_C², σ_T²)): Process noise"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nIndustrial Digital Control:\nCSTR operated with: - PLC/DCS sampling: Δt = 1-60 s typical - Concentration: Online analyzer (GC, NIR) every 1-5 min - Temperature: Fast measurement (1-10 s) - Jacket temperature: Control valve updated discretely\nProcess Noise Sources:\n\nConcentration noise (σ_C):\n\nFeed composition variations (batch-to-batch)\nSampling/analyzer uncertainty\nFlow rate fluctuations\nTypical: 0.001-0.01 mol/L per step\n\nTemperature noise (σ_T):\n\nHeat transfer coefficient variations (fouling)\nAmbient temperature changes\nFlow rate in jacket fluctuations\nMost critical: Affects rates exponentially\nTypical: 0.1-2.0 K per step\n\n\nWhy Temperature Noise Dominates:\nArrhenius: r ∝ exp(-E/T) - Small T change → large rate change - E/T² ≈ 8750/350² ≈ 0.071 K⁻¹ - 1 K noise → 7% rate change - This creates strong coupling to concentration"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#multiple-steady-states-under-noise",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#multiple-steady-states-under-noise",
    "title": "",
    "section": "Multiple Steady States Under Noise",
    "text": "Multiple Steady States Under Noise\nDeterministic: 1, 2, or 3 steady states possible\nWith Noise: - States fluctuate around deterministic equilibria - Noise can cause transitions between basins - Rare events: Escape from desired state - Metastability: Long residence time then sudden transition\nCritical for Control: - Must maintain high-conversion despite noise - Risk of noise-induced transition to low-conversion - Probability of transition depends on σ_T, distance to saddle - Requires robust control + risk management"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X[k] = [C_A[k], T[k]] - C_A[k]: Concentration at time k·Δt [mol/L] - T[k]: Temperature at time k·Δt [K] - Stochastic processes (not deterministic)\nControl: u[k] = T_jacket[k] - Jacket temperature [K] - Zero-order hold between samples\nNoise: w[k] = [w_C[k], w_T[k]] - w[k] ~ N(0, Σ_w) - Σ_w = diag(σ_C², σ_T²) - Independent, Gaussian, white"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#key-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#key-properties",
    "title": "",
    "section": "Key Properties",
    "text": "Key Properties\n1. Markov Property: Essential for dynamic programming, RL, Kalman filtering.\n2. Multiple Modes: State distribution may be multimodal (near bifurcation).\n3. Exponential Sensitivity: Temperature noise amplified exponentially by Arrhenius.\n4. Metastability: System can stay near unstable equilibrium for long time.\n5. Rare Transitions: Low probability but high consequence events."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nF\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nV\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nC_A_feed\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nT_feed\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nk0\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nE\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\ndelta_H\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nrho\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nCp\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nUA\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nsigma_C\nfloat\nProcess noise std dev for C_A [mol/L per step] - Typical: 0.001-0.01 mol/L - Smaller than batch reactor (continuous operation)\n0.001\n\n\nsigma_T\nfloat\nProcess noise std dev for T [K per step] - Typical: 0.1-2.0 K - Most critical parameter - Conversion from continuous: σ_c·√Δt\n0.5\n\n\ndt\nfloat\nSampling period [s] - CSTR typically slower than batch: 1-60 s - Faster near high-conversion (less stable) - Slower at low-conversion (more stable)\n5.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Stochastic MPC: Model Predictive Control with chance constraints: - Probabilistic safety: P(T &lt; T_max) ≥ 0.99 - Risk-sensitive objective: E[cost] + λ·Var[cost] - Scenario tree or robust tubes\n2. Particle Filter: State estimation with multiple modes: - Essential near transitions - Handles non-Gaussian distributions - Expensive but necessary\n3. Robust Startup: Transition low → high conversion despite noise: - Tube-based MPC - Barrier certificates - Risk-aware control\n4. Reliability Analysis: Assess transition probability: - Monte Carlo with importance sampling - Large deviations theory - Mean first passage time\n5. Fault Detection: Distinguish faults from noise: - Statistical tests on residuals - Anomaly detection on likelihood - Change point detection"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nMonte Carlo Ensemble:\nCritical for CSTR to characterize rare events: - N = 1,000-10,000 runs - Estimate transition probability - Identify escape paths - Design robust controllers\nSingle Trajectory:\nMay not be representative: - Could stay in one state by chance - May transition unusually fast/slow - Always report ensemble statistics"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#state-estimation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#state-estimation",
    "title": "",
    "section": "State Estimation",
    "text": "State Estimation\nRecommended Approach:\nFor high-conversion operation: 1. Use UKF or particle filter (nonlinearity) 2. Monitor distance to saddle point 3. Increase measurement rate if approaching instability 4. Switch to particle filter if bimodality detected\nFor startup/transitions: 1. Particle filter essential (multimodal) 2. Large particle count (N ≥ 1000) 3. Importance sampling toward rare events"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#comparison-with-deterministic",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#comparison-with-deterministic",
    "title": "",
    "section": "Comparison with Deterministic",
    "text": "Comparison with Deterministic\nDeterministic Discrete CSTR: - Single trajectory per IC and control - Multiple equilibria (1-3) - Bifurcations (saddle-node, Hopf)\nStochastic Discrete CSTR: - Ensemble of trajectories - Stochastic equilibria (distributions) - Stochastic bifurcations (P and D) - Noise-induced transitions\nCritical Difference: Stochastic model essential for: - Reliability assessment - Risk management - Robust control design - Safety verification"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nEuler discretization: O(Δt) error\nAdditive noise: Not multiplicative\nConstant noise: Not state/time-dependent\nWhite noise: No temporal correlation\nGaussian noise: Not heavy-tailed"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nHigher-order discretization (RK4)\nMultiplicative noise: σ_T(T)\nColored noise: Autoregressive\nJump processes: Fault events\nTime-varying parameters: Catalyst deactivation"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nContinuousStochasticCSTR : Continuous-time version DiscreteStochasticBatchReactor : Batch version DiscreteCSTR : Deterministic discrete CSTR"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticCSTR.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_damkohler_number\nCompute Damköhler number Da = k·τ.\n\n\ncompute_residence_time\nCompute residence time τ = V/F.\n\n\ndefine_system\nDefine discrete-time stochastic CSTR dynamics.\n\n\nestimate_transition_probability\nEstimate probability of transitioning to low-conversion state.\n\n\nfind_steady_states\nFind all steady states (deterministic part).\n\n\nget_process_noise_covariance\nGet process noise covariance matrix.\n\n\nsetup_equilibria\nSet up equilibrium points (deterministic part).\n\n\n\n\ncompute_damkohler_number\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR.compute_damkohler_number(\n    T,\n)\nCompute Damköhler number Da = k·τ.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT\nfloat\nTemperature [K]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nDamköhler number\n\n\n\n\n\nNotes\nDa &gt;&gt; 1: Fast reaction, high conversion Da &lt;&lt; 1: Slow reaction, low conversion\n\n\n\ncompute_residence_time\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR.compute_residence_time(\n)\nCompute residence time τ = V/F.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nResidence time [s]\n\n\n\n\n\nNotes\nNatural time scale for CSTR dynamics. Sampling period typically: dt ~ 0.5-5·τ\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR.define_system(\n    F_val=100.0,\n    V_val=100.0,\n    C_A_feed_val=1.0,\n    T_feed_val=350.0,\n    k0_val=72000000000.0,\n    E_val=8750.0,\n    delta_H_val=-50000.0,\n    rho_val=1000.0,\n    Cp_val=0.239,\n    UA_val=50000.0,\n    sigma_C=0.001,\n    sigma_T=0.5,\n    dt=5.0,\n    discretization_method='euler',\n    x_ss=None,\n    u_ss=None,\n)\nDefine discrete-time stochastic CSTR dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nF_val\nfloat\nVolumetric flow rate [L/s]\n100.0\n\n\nV_val\nfloat\nReactor volume [L]\n100.0\n\n\nC_A_feed_val\nfloat\nFeed concentration [mol/L]\n1.0\n\n\nT_feed_val\nfloat\nFeed temperature [K]\n350.0\n\n\nk0_val\nfloat\nPre-exponential factor [1/s]\n72000000000.0\n\n\nE_val\nfloat\nActivation energy [K] (dimensionless Eₐ/R)\n8750.0\n\n\ndelta_H_val\nfloat\nHeat of reaction [J/mol] (negative = exothermic)\n-50000.0\n\n\nrho_val\nfloat\nDensity [kg/L]\n1000.0\n\n\nCp_val\nfloat\nSpecific heat capacity [J/(kg·K)]\n0.239\n\n\nUA_val\nfloat\nOverall heat transfer coefficient × area [J/(s·K)]\n50000.0\n\n\nx_ss\nOptional[np.ndarray]\nSteady-state [Cₐ, T] for equilibrium setup\nNone\n\n\nu_ss\nOptional[np.ndarray]\nSteady-state [T_jacket] for equilibrium setup\nNone\n\n\nsigma_C\nfloat\nProcess noise std dev for C_A [mol/L per step] - Smaller than batch (continuous operation) - Typical: 0.001-0.01 mol/L - Feed variability, analyzer noise\n0.001\n\n\nsigma_T\nfloat\nProcess noise std dev for T [K per step] - Most critical parameter - Typical: 0.1-2.0 K - Heat transfer fluctuations, ambient changes - Conversion: σ_c·√Δt from continuous\n0.5\n\n\ndt\nfloat\nSampling period [s] - CSTR slower than batch: 1-60 s typical - Residence time: τ = V/F = 1 s (for defaults) - Guideline: dt ~ 0.5-5·τ - Faster near high-conversion (less stable)\n5.0\n\n\ndiscretization_method\nstr\n‘euler’ or ‘rk4’\n'euler'\n\n\nx_ss\nOptional[np.ndarray]\nSteady state (if known)\nNone\n\n\nu_ss\nOptional[np.ndarray]\nSteady state (if known)\nNone\n\n\n\n\n\nNotes\nNoise Scaling:\nFor continuous σ_c [state/√s]: σ_discrete = σ_c·√dt\nExample: σ_T_c = 1 K/√s, dt = 5 s → σ_T_d = 1·√5 ≈ 2.24 K per step\nTemperature Noise Criticality:\nArrhenius sensitivity: ∂r/∂T ≈ r·(E/T²) - At T = 390 K, E = 8750 K: sensitivity = 0.058 K⁻¹ - 1 K noise → 5.8% rate change - 2 K noise → 11.6% rate change - This is why σ_T most important\nSampling Time:\nTradeoffs: - Smaller dt: More accurate, faster control, but more noise samples - Larger dt: Smoother (less noise), but miss dynamics\nFor CSTR: - High-conversion: dt = 1-5 s (critical, fast control) - Low-conversion: dt = 5-30 s (stable, slower) - Startup: dt = 1-2 s (transitions critical)\nMultiple Steady States:\nCSTR can have 1-3 steady states. Use find_steady_states() to locate all equilibria for given T_jacket.\nNoise causes transitions between states! - Design σ_T small enough for reliability - Or design controller to prevent transitions\n\n\n\nestimate_transition_probability\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR.estimate_transition_probability(\n    x_initial,\n    u_sequence,\n    threshold_T,\n    n_simulations=1000,\n)\nEstimate probability of transitioning to low-conversion state.\nUses Monte Carlo simulation to estimate rare event probability.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_initial\nnp.ndarray\nInitial state (e.g., high-conversion)\nrequired\n\n\nu_sequence\nnp.ndarray\nControl sequence (n_steps, 1)\nrequired\n\n\nthreshold_T\nfloat\nTemperature threshold for transition [K] (e.g., T &lt; 370 K indicates low-conversion)\nrequired\n\n\nn_simulations\nint\nNumber of Monte Carlo runs\n1000\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nStatistics: probability, mean_time, std_time\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = DiscreteStochasticCSTR()\n&gt;&gt;&gt; x0 = np.array([0.1, 390.0])  # High-conversion\n&gt;&gt;&gt; u_seq = np.full((200, 1), 350.0)\n&gt;&gt;&gt; result = cstr.estimate_transition_probability(\n...     x0, u_seq, threshold_T=370.0, n_simulations=1000\n... )\n&gt;&gt;&gt; print(f\"P(transition) = {result['probability']:.4f}\")\n\n\n\nfind_steady_states\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR.find_steady_states(\n    T_jacket,\n    T_range=(300.0, 500.0),\n    n_points=100,\n)\nFind all steady states (deterministic part).\nUses root finding with multiple initial guesses.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT_jacket\nfloat\nJacket temperature [K]\nrequired\n\n\nT_range\ntuple\nTemperature search range [K]\n(300.0, 500.0)\n\n\nn_points\nint\nNumber of initial guesses\n100\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[Tuple[float, float]]\nList of (C_A, T) steady states\n\n\n\n\n\nNotes\nFor stochastic system, these are centers of probability distributions. Actual state fluctuates around these points.\nWith noise, transitions between states possible!\n\n\nExamples\n&gt;&gt;&gt; cstr = DiscreteStochasticCSTR()\n&gt;&gt;&gt; states = cstr.find_steady_states(T_jacket=350.0)\n&gt;&gt;&gt; for i, (C_A, T) in enumerate(states):\n...     print(f\"State {i+1}: C_A={C_A:.3f}, T={T:.1f}\")\n\n\n\nget_process_noise_covariance\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR.get_process_noise_covariance(\n)\nGet process noise covariance matrix.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\n2x2 diagonal covariance matrix\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cstr = DiscreteStochasticCSTR(sigma_C=0.001, sigma_T=0.5)\n&gt;&gt;&gt; Q = cstr.get_process_noise_covariance()\n&gt;&gt;&gt; print(f\"Process noise:\\n{Q}\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.discrete.DiscreteStochasticCSTR.setup_equilibria()\nSet up equilibrium points (deterministic part).\nNote: With process noise, system doesn’t stay at equilibrium but fluctuates around it. Multiple equilibria may exist."
  },
  {
    "objectID": "api/types.backends.BackendConfig.html",
    "href": "api/types.backends.BackendConfig.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.BackendConfig.html#attributes",
    "href": "api/types.backends.BackendConfig.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbackend\nBackend\nComputational backend\n\n\ndevice\nOptional[Device]\nHardware device\n\n\ndtype\nOptional[str]\nData type (‘float32’, ‘float64’, etc.)"
  },
  {
    "objectID": "api/types.backends.BackendConfig.html#examples",
    "href": "api/types.backends.BackendConfig.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; config: BackendConfig = {\n...     'backend': 'torch',\n...     'device': 'cuda:0',\n...     'dtype': 'float32'\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Minimal config\n&gt;&gt;&gt; config_minimal: BackendConfig = {'backend': 'numpy'}"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorFactory.html",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorFactory.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorFactory.html#examples",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorFactory.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Create integrator by backend and method\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(\n...     sde_system,\n...     backend='numpy',\n...     method='EM'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Julia solver for high accuracy\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(\n...     sde_system,\n...     backend='numpy',\n...     method='SRIW1'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # JAX for optimization\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(\n...     sde_system,\n...     backend='jax',\n...     method='Euler'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Automatic selection\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.auto(sde_system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use case-specific\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_optimization(sde_system)\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_neural_sde(neural_sde)\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_julia(sde_system, algorithm='SRA1')"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.SDEIntegratorFactory.html#methods",
    "href": "api/systems.base.numerical_integration.stochastic.SDEIntegratorFactory.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nauto\nAutomatically select best available SDE integrator.\n\n\ncreate\nCreate an SDE integrator with specified backend and method.\n\n\nfor_julia\nCreate Julia-based SDE integrator (DiffEqPy).\n\n\nfor_monte_carlo\nCreate SDE integrator optimized for Monte Carlo simulation.\n\n\nfor_neural_sde\nCreate SDE integrator for neural SDEs.\n\n\nfor_optimization\nCreate SDE integrator optimized for gradient-based optimization.\n\n\nget_info\nGet information about a specific SDE integrator configuration.\n\n\nlist_methods\nList available SDE methods for each backend.\n\n\nrecommend\nGet SDE integrator recommendation based on use case.\n\n\n\n\nauto\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.auto(\n    sde_system,\n    seed=None,\n    **options,\n)\nAutomatically select best available SDE integrator.\nTries backends in order of preference: 1. JAX (Diffrax) - best for gradients and performance 2. PyTorch (TorchSDE) - good for neural SDEs 3. NumPy (DiffEqPy) - fallback, most features\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nContinuousStochasticSystem\nSDE system to integrate\nrequired\n\n\nseed\nOptional[int]\nRandom seed for reproducibility\nNone\n\n\n**options\n\nAdditional integrator options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegratorBase\nBest available integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Auto-select based on what's installed\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.auto(sde_system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With reproducibility\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.auto(sde_system, seed=42)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.auto(autonomous_sde_system)\n\n\n\ncreate\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.create(\n    sde_system,\n    backend='numpy',\n    method=None,\n    dt=0.01,\n    step_mode=StepMode.FIXED,\n    sde_type=None,\n    convergence_type=ConvergenceType.STRONG,\n    seed=None,\n    **options,\n)\nCreate an SDE integrator with specified backend and method.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nContinuousStochasticSystem\nSDE system to integrate (controlled or autonomous)\nrequired\n\n\nbackend\nBackend\nBackend: ‘numpy’, ‘torch’, ‘jax’. Default: ‘numpy’\n'numpy'\n\n\nmethod\nOptional[SDEIntegrationMethod]\nSolver method. If None, uses backend default. - numpy: ‘EM’ (Julia Euler-Maruyama) - torch: ‘euler’ (TorchSDE euler) - jax: ‘Euler’ (Diffrax Euler)\nNone\n\n\ndt\nOptional[ScalarLike]\nTime step (default: 0.01)\n0.01\n\n\nstep_mode\nStepMode\nFIXED or ADAPTIVE stepping (most SDE solvers use FIXED)\nStepMode.FIXED\n\n\nsde_type\nOptional[SDEType]\nSDE interpretation (None = use system’s type)\nNone\n\n\nconvergence_type\nConvergenceType\nStrong or weak convergence\nConvergenceType.STRONG\n\n\nseed\nOptional[int]\nRandom seed for reproducibility\nNone\n\n\n**options\n\nAdditional integrator options (rtol, atol, adjoint, etc.)\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegratorBase\nConfigured SDE integrator\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf backend/method combination is invalid\n\n\n\nImportError\nIf required package not installed\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Use defaults (Julia EM)\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(sde_system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Julia high-accuracy solver\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(\n...     sde_system,\n...     backend='numpy',\n...     method='SRIW1',\n...     dt=0.001\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # JAX for optimization\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(\n...     sde_system,\n...     backend='jax',\n...     method='Euler',\n...     dt=0.01,\n...     seed=42\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # PyTorch for neural SDEs\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(\n...     neural_sde,\n...     backend='torch',\n...     method='euler',\n...     adjoint=True  # Memory-efficient backprop\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system (no control)\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.create(autonomous_sde_system)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n\n\n\nfor_julia\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.for_julia(\n    sde_system,\n    algorithm='SRIW1',\n    **options,\n)\nCreate Julia-based SDE integrator (DiffEqPy).\nAccess to Julia’s extensive SDE solver ecosystem.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nContinuousStochasticSystem\nSDE system to integrate\nrequired\n\n\nalgorithm\nSDEIntegrationMethod\nJulia algorithm (default: ‘SRIW1’)\n'SRIW1'\n\n\n**options\n\nAdditional integrator options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegratorBase\nJulia-powered integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # High-accuracy diagonal noise\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_julia(sde_system, algorithm='SRIW1')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simple and fast\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_julia(sde_system, algorithm='EM')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stiff drift\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_julia(\n...     stiff_sde,\n...     algorithm='ImplicitEM'\n... )\n\n\n\nfor_monte_carlo\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.for_monte_carlo(\n    sde_system,\n    noise_type='general',\n    **options,\n)\nCreate SDE integrator optimized for Monte Carlo simulation.\nUses weak convergence methods optimized for moment accuracy.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nContinuousStochasticSystem\nSDE system to integrate\nrequired\n\n\nnoise_type\nstr\n‘additive’, ‘diagonal’, or ‘general’\n'general'\n\n\n**options\n\nAdditional integrator options\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegratorBase\nMonte Carlo integrator with weak convergence\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Additive noise (fastest)\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_monte_carlo(\n...     sde_system,\n...     noise_type='additive'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # General noise\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_monte_carlo(\n...     sde_system,\n...     noise_type='general'\n... )\n\n\n\nfor_neural_sde\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.for_neural_sde(\n    sde_system,\n    adjoint=True,\n    **options,\n)\nCreate SDE integrator for neural SDEs.\nUses TorchSDE with adjoint method for memory-efficient backpropagation.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nContinuousStochasticSystem\nNeural SDE system to integrate\nrequired\n\n\nadjoint\nbool\nUse adjoint method (default: True)\nTrue\n\n\n**options\n\nAdditional integrator options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegratorBase\nNeural SDE integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Neural SDE with adjoint\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_neural_sde(neural_sde)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Without adjoint (more memory, faster forward)\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_neural_sde(\n...     neural_sde,\n...     adjoint=False\n... )\n\n\n\nfor_optimization\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.for_optimization(\n    sde_system,\n    backend=None,\n    **options,\n)\nCreate SDE integrator optimized for gradient-based optimization.\nPrefers JAX (Diffrax) for JIT compilation and autodiff, fallback to PyTorch (TorchSDE).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nContinuousStochasticSystem\nSDE system to integrate\nrequired\n\n\nbackend\nOptional[Backend]\nPreferred backend (None = auto-select)\nNone\n\n\n**options\n\nAdditional integrator options\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegratorBase\nOptimization-ready integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Auto-select best optimization backend\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_optimization(sde_system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Force specific backend\n&gt;&gt;&gt; integrator = SDEIntegratorFactory.for_optimization(\n...     sde_system,\n...     backend='jax',\n...     dt=0.001\n... )\n\n\n\nget_info\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.get_info(\n    backend,\n    method,\n)\nGet information about a specific SDE integrator configuration.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nBackend name\nrequired\n\n\nmethod\nSDEIntegrationMethod\nMethod name\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nInformation about the SDE integrator\n\n\n\n\n\nExamples\n&gt;&gt;&gt; info = SDEIntegratorFactory.get_info('jax', 'Euler')\n&gt;&gt;&gt; print(info['description'])\n'Basic Euler-Maruyama, fast and robust'\n\n\n\nlist_methods\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.list_methods(\n    backend=None,\n)\nList available SDE methods for each backend.\nDelegates to method_registry for stochastic methods.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nOptional[Backend]\nIf specified, return only methods for that backend\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict with method categories (from registry)\nIf backend specified: categories for that backend If backend None: returns methods for ‘numpy’ by default\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Specific backend\n&gt;&gt;&gt; methods = SDEIntegratorFactory.list_methods('jax')\n&gt;&gt;&gt; print(methods['sde_fixed_step'])\n['Euler', 'EulerHeun', 'Heun', 'ItoMilstein', ...]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # All methods (defaults to numpy)\n&gt;&gt;&gt; methods = SDEIntegratorFactory.list_methods()\n&gt;&gt;&gt; print(methods['sde_fixed_step'])\n['EM', 'EulerHeun', 'SRIW1', ...]\n\n\n\nrecommend\nsystems.base.numerical_integration.stochastic.SDEIntegratorFactory.recommend(\n    use_case,\n    noise_type='general',\n    has_jax=False,\n    has_torch=False,\n    has_gpu=False,\n)\nGet SDE integrator recommendation based on use case.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nuse_case\nstr\nOne of: ‘production’, ‘optimization’, ‘neural_sde’, ‘monte_carlo’, ‘prototype’, ‘simple’, ‘julia’\nrequired\n\n\nnoise_type\nstr\n‘additive’, ‘diagonal’, ‘general’\n'general'\n\n\nhas_jax\nbool\nWhether JAX is available\nFalse\n\n\nhas_torch\nbool\nWhether PyTorch is available\nFalse\n\n\nhas_gpu\nbool\nWhether GPU is available\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nRecommendation with ‘backend’, ‘method’, ‘convergence_type’\n\n\n\n\n\nExamples\n&gt;&gt;&gt; rec = SDEIntegratorFactory.recommend('production')\n&gt;&gt;&gt; print(rec)\n{'backend': 'numpy', 'method': 'SRIW1', 'convergence_type': 'STRONG'}"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#stochastic-difference-equation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#stochastic-difference-equation",
    "title": "",
    "section": "Stochastic Difference Equation",
    "text": "Stochastic Difference Equation\nAdditive noise formulation: x[k+1] = r·x[k]·(1 - x[k]) + σ·w[k]\nwhere: - x[k] ∈ [0,1]: Population fraction (normalized) - r ∈ [0,4]: Growth parameter (bifurcation parameter) - σ ≥ 0: Noise intensity (environmental stochasticity) - w[k] ~ N(0,1): Standard Gaussian white noise\nDeterministic Part: f(x) = r·x·(1 - x)\nClassic parabola with single maximum at x = 0.5.\nStochastic Part: g(x) = σ (constant, additive)\nEnvironmental noise independent of population size."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nEcological Meaning:\nx[k]: Fraction of carrying capacity - x = 0: Extinction - x = 1: At carrying capacity K - x = 0.5: Half capacity (maximum growth rate)\nr: Intrinsic growth rate per generation - r &lt; 1: Extinction (death rate &gt; birth rate) - 1 &lt; r &lt; 3: Regulated (stable equilibrium) - 3 &lt; r &lt; 3.57: Oscillations (periodic) - 3.57 &lt; r &lt; 4: Chaos (unpredictable)\nσ: Environmental variability - Weather fluctuations - Resource availability changes - Predator abundance variation - Typical: σ ~ 0.01-0.1 for small noise\nNonlinear Regulation:\nTerm (1 - x[k]) creates negative feedback: - x small: Growth approximately r·x (exponential) - x near 1: Growth slows (carrying capacity) - x &gt; 1: Negative growth (overcompensation)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#dynamical-regimes",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#dynamical-regimes",
    "title": "",
    "section": "Dynamical Regimes",
    "text": "Dynamical Regimes\nFixed Point Regime (1 &lt; r &lt; 3):\nDeterministic: - x* = (r-1)/r stable - Monotonic convergence\nWith noise: - Fluctuations around x* - Approximately Gaussian - Standard deviation ~ σ/√(1-λ²) where λ = |2-r|\nPeriod-Doubling Regime (3 &lt; r &lt; 3.57):\nDeterministic: - Period-2, 4, 8, … orbits - Feigenbaum cascade\nWith noise: - Cycles blur into bands - Noise-induced transitions between branches - Bimodal distributions\nChaotic Regime (3.57 &lt; r &lt; 4):\nDeterministic: - Sensitive dependence on initial conditions - Positive Lyapunov exponent - Bounded but unpredictable\nWith noise: - Enhanced unpredictability - Noise can fill in gaps (chaotic repellers) - Smooth invariant density\nCritical Point (r = 4):\nDeterministic: - Fully developed chaos - Analytical solution exists - Maximum entropy\nWith noise: - Prevents boundary accumulation - Regularizes singularities"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#key-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#key-properties",
    "title": "",
    "section": "Key Properties",
    "text": "Key Properties\nNonlinearity: Quadratic nonlinearity creates: - Multiple equilibria (up to 2) - Bifurcations (parameter-dependent) - Chaos (sensitivity to initial conditions)\nBoundedness: For r ≤ 4 and σ small: - Deterministic: x ∈ [0,1] preserved - With noise: Can exceed bounds (unphysical) - Solution: Truncate or use multiplicative noise\nSensitive Dependence: In chaotic regime (λ &gt; 0): - Prediction horizon: ~1/λ generations - Exponential error growth - Long-term: Ensemble forecasts only\nNoise Effects: - Smooth attractors - Induce transitions - Enhance effective Lyapunov exponent - Can create or destroy chaos"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nFixed Points (Deterministic):\nx₁* = 0 (extinction) - Stable for r &lt; 1 - Unstable for r &gt; 1\nx₂* = (r-1)/r (regulated) - Exists for r &gt; 1 - Stable for 1 &lt; r &lt; 3 - Unstable for r &gt; 3 (bifurcation)\nStability (Linearization):\nAt x: f’(x) = r·(1 - 2·x*) - |f’| &lt; 1: Stable - |f’| &gt; 1: Unstable - f’ = -1: Bifurcation\nAt x₂: f’(x₂) = 2 - r - Stable: 1 &lt; r &lt; 3 - Period-doubling: r = 3\nLyapunov Exponent:\nλ = lim(N→∞) (1/N)·Σ ln|r·(1 - 2·x[k])|\n\nλ &lt; 0: Stable (r &lt; 3)\nλ = 0: Critical (r = 3)\nλ &gt; 0: Chaos (r &gt; 3.57)\nλ_max = ln(2) at r = 4\n\nInvariant Density (r = 4):\nρ(x) = 1/(π·√(x·(1-x)))\nU-shaped: Maximum at boundaries, minimum at x = 0.5."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x ∈ [0,1] (bounded interval) - Physical constraint: population fraction - Noise can violate bounds (handle carefully)\nControl: None in basic model - Can add control: x[k+1] = r·x[k]·(1-x[k]) + u[k] - Harvest control: u &lt; 0 (remove individuals)\nNoise: w[k] ~ N(0,1) - Additive (constant intensity) - Environmental stochasticity"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr\nfloat\nGrowth parameter (bifurcation parameter) - r &lt; 1: Extinction - 1 &lt; r &lt; 3: Stable fixed point - 3 &lt; r &lt; 3.57: Periodic orbits - 3.57 &lt; r &lt; 4: Chaos - r = 3.8: Generic chaotic (default) - r &gt; 4: Escape from [0,1]\n3.8\n\n\nsigma\nfloat\nNoise intensity (environmental stochasticity) - σ = 0: Deterministic - σ ~ 0.01-0.05: Small noise (perturbative) - σ ~ 0.1-0.2: Moderate noise - σ &gt; 0.2: Large noise (dominates) - Typical: σ ~ 0.05 for biological systems\n0.05\n\n\nx0\nfloat\nInitial condition - Typically x0 = 0.5 (maximum growth rate) - Chaos: Any x0 ∈ (0,1) gives same long-term statistics\n0.5\n\n\ndt\nfloat\nGeneration time (time units per iteration) - Typically dt = 1 generation\n1.0\n\n\nenforce_bounds\nbool\nWhether to enforce x ∈ [0,1] - True: Truncate to [0,1] (prevents unphysical values) - False: Allow escape (for mathematical studies)\nTrue"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR (quadratic)\nNoise Type: ADDITIVE (constant intensity)\nChaotic: Depends on r (λ(r))\nStationary: Yes (for r &lt; 4, bounded noise)\nErgodic: Yes (in chaotic regime)\nMarkov: Yes (one-step memory)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Population Ecology: - Insect outbreak dynamics - Fish stock assessment - Pest management - Conservation biology\n2. Time Series Analysis: - Chaos detection - Nonlinear prediction - Lyapunov exponent estimation - Surrogate data testing\n3. Dynamical Systems: - Bifurcation theory - Routes to chaos - Universality classes - Renormalization group\n4. Cryptography: - Pseudorandom number generation - Secure communication - Chaos-based encryption\n5. Control Theory: - OGY method (chaos control) - Stabilizing unstable orbits - Adaptive control under uncertainty"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nDirect Iteration: x[k+1] = r·x[k]·(1 - x[k]) + σ·randn()\nExact (no discretization error).\nBoundary Handling: If enforce_bounds: x[k+1] = clip(x[k+1], 0, 1)\nLong-Term Statistics: - Run N &gt;&gt; 1000 iterations - Discard initial transient (burn-in) - Compute histogram (invariant density) - Calculate Lyapunov exponent"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#comparison-with-other-models",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#comparison-with-other-models",
    "title": "",
    "section": "Comparison with Other Models",
    "text": "Comparison with Other Models\nvs. Ricker Map: - Ricker: x[k+1] = x[k]·exp(r·(1 - x[k])) - Logistic: Polynomial, simpler - Both show period-doubling\nvs. Tent Map: - Tent: Piecewise linear, chaotic - Logistic: Smooth, more realistic - Topologically conjugate at r = 4\nvs. Continuous Logistic: - Continuous: dx/dt = r·x·(1 - x) - Discrete: Captures generation structure - Discrete: Richer dynamics (chaos possible)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nBounded state space (x ∈ [0,1])\nSingle variable (scalar)\nAdditive noise (multiplicative more realistic)\nNoise can cause boundary violations\nNo age/stage structure"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nMultiplicative noise: σ·x·(1-x)·w[k]\nTwo-dimensional: Coupled logistic maps\nSpatially extended: Lattice of coupled maps\nDiscrete-time: Ricker, Beverton-Holt\nContinuous-time: Logistic ODE"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDiscreteAR1 : Linear analog (no chaos) DiscreteRandomWalk : No regulation DiscreteStochasticPendulum : Continuous state space nonlinearity"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_bifurcation_diagram\nCompute bifurcation diagram (deterministic).\n\n\ncompute_lyapunov_exponent\nEstimate Lyapunov exponent from trajectory.\n\n\ndefine_system\nDefine stochastic logistic map dynamics.\n\n\nestimate_invariant_density\nEstimate invariant density from long trajectory.\n\n\nsetup_equilibria\nSet up equilibrium points (deterministic part).\n\n\ntheoretical_invariant_density\nCompute theoretical invariant density for r=4 (deterministic).\n\n\n\n\ncompute_bifurcation_diagram\nsystems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.compute_bifurcation_diagram(\n    r_range=(2.5, 4.0),\n    n_r_values=1000,\n    transient=500,\n    n_plot_points=100,\n)\nCompute bifurcation diagram (deterministic).\nFor each r value, iterate map and record long-term behavior.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr_range\nTuple[float, float]\nRange of r values to explore\n(2.5, 4.0)\n\n\nn_r_values\nint\nNumber of r values to sample\n1000\n\n\ntransient\nint\nIterations to discard (burn-in)\n500\n\n\nn_plot_points\nint\nNumber of points to keep per r value\n100\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[np.ndarray, np.ndarray]\n(r_values, x_values) for plotting\n\n\n\n\n\nExamples\n&gt;&gt;&gt; logistic = DiscreteStochasticLogisticMap(r=3.0, sigma=0.0)\n&gt;&gt;&gt; r_vals, x_vals = logistic.compute_bifurcation_diagram()\n&gt;&gt;&gt; plt.plot(r_vals, x_vals, ',k', alpha=0.5, markersize=0.5)\n&gt;&gt;&gt; plt.xlabel('r')\n&gt;&gt;&gt; plt.ylabel('x')\n&gt;&gt;&gt; plt.title('Bifurcation Diagram')\n\n\n\ncompute_lyapunov_exponent\nsystems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.compute_lyapunov_exponent(\n    x0=None,\n    n_iterations=10000,\n    transient=1000,\n)\nEstimate Lyapunov exponent from trajectory.\nλ = lim(N→∞) (1/N)·Σ ln|f’(x[k])|\nwhere f’(x) = r·(1 - 2·x).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nOptional[float]\nInitial condition (uses self.x0_param if None)\nNone\n\n\nn_iterations\nint\nNumber of iterations for estimation\n10000\n\n\ntransient\nint\nNumber of initial iterations to discard\n1000\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEstimated Lyapunov exponent\n\n\n\n\n\nNotes\n\nλ &lt; 0: Stable (convergence)\nλ ≈ 0: Critical (near bifurcation)\nλ &gt; 0: Chaos (sensitive dependence)\n\nThis computes the deterministic Lyapunov exponent (noise-free). With noise, use time series methods.\n\n\nExamples\n&gt;&gt;&gt; logistic = DiscreteStochasticLogisticMap(r=3.8, sigma=0.0)\n&gt;&gt;&gt; lambda_est = logistic.compute_lyapunov_exponent()\n&gt;&gt;&gt; print(f\"λ ≈ {lambda_est:.3f}\")  # Should be ~0.5\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.define_system(\n    r=3.8,\n    sigma=0.05,\n    x0=0.5,\n    dt=1.0,\n    enforce_bounds=True,\n)\nDefine stochastic logistic map dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nr\nfloat\nGrowth parameter (must be in [0,4] for boundedness) - r &lt; 1: Extinction regime - 1 &lt; r &lt; 3: Fixed point regime - r = 3: First bifurcation - 3 &lt; r &lt; 3.57: Periodic regime - 3.57 &lt; r &lt; 4: Chaotic regime - r = 3.8: Generic chaos (default)\n3.8\n\n\nsigma\nfloat\nNoise intensity - σ = 0: Deterministic - σ ~ 0.01-0.05: Small perturbations - σ ~ 0.1: Moderate noise - σ &gt; 0.2: Large noise\n0.05\n\n\nx0\nfloat\nInitial condition (must be in [0,1])\n0.5\n\n\ndt\nfloat\nGeneration time\n1.0\n\n\nenforce_bounds\nbool\nWhether to clip x to [0,1] each step\nTrue\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf r &lt; 0, r &gt; 4, or x0 not in [0,1]\n\n\n\nUserWarning\nIf r &gt; 4 (escape from domain) If r &lt; 1 (extinction regime)\n\n\n\n\n\nNotes\nParameter Selection:\nFor exploring dynamics: - Fixed point: r = 2.5, σ = 0.01 - Period-2: r = 3.2, σ = 0.02 - Chaos onset: r = 3.57, σ = 0.03 - Full chaos: r = 3.8-4.0, σ = 0.05\nNoise Scaling:\nUnlike continuous models, σ doesn’t scale with √dt because discrete-time noise is per-generation.\nBoundary Enforcement:\nIf enforce_bounds=True: - Prevents x &lt; 0 (extinction) - Prevents x &gt; 1 (exceeding capacity) - Reflects or truncates at boundaries\nIf False: - Can escape [0,1] (unphysical) - Useful for studying escape rates - Most simulations should use True\nLyapunov Exponent:\nEstimate for deterministic part: - r = 2.5: λ ≈ -0.69 (stable) - r = 3.0: λ ≈ 0 (critical) - r = 3.5: λ ≈ 0.2 (periodic) - r = 3.8: λ ≈ 0.5 (chaotic) - r = 4.0: λ = ln(2) ≈ 0.693 (maximum)\nWith noise, effective λ increases.\nPeriod-Doubling Points:\nBifurcation cascade: - r₁ = 3.0 (period 2) - r₂ ≈ 3.449 (period 4) - r₃ ≈ 3.544 (period 8) - r∞ ≈ 3.5699 (chaos onset)\nFeigenbaum ratio: δ = (rₙ₊₁ - rₙ)/(rₙ₊₂ - rₙ₊₁) → 4.669\nChaos Windows:\nPeriodic windows within chaos: - r ≈ 3.83: Period-3 window - r ≈ 3.74: Period-5 window - Many others (dense set)\n\n\n\nestimate_invariant_density\nsystems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.estimate_invariant_density(\n    n_iterations=100000,\n    transient=1000,\n    n_bins=100,\n)\nEstimate invariant density from long trajectory.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn_iterations\nint\nNumber of iterations to collect\n100000\n\n\ntransient\nint\nBurn-in period\n1000\n\n\nn_bins\nint\nNumber of histogram bins\n100\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTuple[np.ndarray, np.ndarray]\n(bin_centers, density)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; logistic = DiscreteStochasticLogisticMap(r=4.0, sigma=0.0)\n&gt;&gt;&gt; x_bins, density = logistic.estimate_invariant_density()\n&gt;&gt;&gt; plt.plot(x_bins, density)\n&gt;&gt;&gt; plt.xlabel('x')\n&gt;&gt;&gt; plt.ylabel('ρ(x)')\n&gt;&gt;&gt; # Compare with exact: ρ(x) = 1/(π·√(x·(1-x)))\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.setup_equilibria(\n)\nSet up equilibrium points (deterministic part).\nLogistic map has up to two fixed points: 1. x* = 0 (extinction) 2. x* = (r-1)/r (regulated population)\n\n\ntheoretical_invariant_density\nsystems.builtin.stochastic.discrete.DiscreteStochasticLogisticMap.theoretical_invariant_density(\n    x_values,\n)\nCompute theoretical invariant density for r=4 (deterministic).\nρ(x) = 1/(π·√(x·(1-x)))\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_values\nnp.ndarray\nPoints at which to evaluate density\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nDensity values\n\n\n\n\n\nNotes\nOnly valid for r = 4 and σ = 0. U-shaped distribution.\n\n\nExamples\n&gt;&gt;&gt; x = np.linspace(0.01, 0.99, 100)\n&gt;&gt;&gt; logistic = DiscreteStochasticLogisticMap(r=4.0, sigma=0.0)\n&gt;&gt;&gt; rho_theory = logistic.theoretical_invariant_density(x)"
  },
  {
    "objectID": "api/types.protocols.LinearizableContinuousProtocol.html",
    "href": "api/types.protocols.LinearizableContinuousProtocol.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.protocols.LinearizableContinuousProtocol.html#implementations",
    "href": "api/types.protocols.LinearizableContinuousProtocol.html#implementations",
    "title": "",
    "section": "Implementations",
    "text": "Implementations\n\nContinuousSymbolicSystem\nContinuousStochasticSystem (returns A, B, G)"
  },
  {
    "objectID": "api/types.protocols.LinearizableContinuousProtocol.html#use-cases",
    "href": "api/types.protocols.LinearizableContinuousProtocol.html#use-cases",
    "title": "",
    "section": "Use Cases",
    "text": "Use Cases\n\nContinuous LQR/LQG design\nH2/H-infinity control\nContinuous Kalman filter\nLyapunov stability analysis"
  },
  {
    "objectID": "api/types.protocols.LinearizableContinuousProtocol.html#examples",
    "href": "api/types.protocols.LinearizableContinuousProtocol.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; def continuous_lqr(\n...     system: LinearizableContinuousProtocol,\n...     Q: np.ndarray,\n...     R: np.ndarray\n... ):\n...     '''Design continuous-time LQR.'''\n...     A, B = system.linearize(np.zeros(system.nx), np.zeros(system.nu))\n...     from scipy.linalg import solve_continuous_are\n...     P = solve_continuous_are(A, B, Q, R)\n...     K = np.linalg.inv(R) @ B.T @ P\n...     return {\"K\": K, \"P\": P}"
  },
  {
    "objectID": "api/types.protocols.LinearizableContinuousProtocol.html#methods",
    "href": "api/types.protocols.LinearizableContinuousProtocol.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nlinearize\nCompute continuous-time linearization: A = ∂f/∂x, B = ∂f/∂u.\n\n\n\n\nlinearize\ntypes.protocols.LinearizableContinuousProtocol.linearize(x_eq, u_eq=None)\nCompute continuous-time linearization: A = ∂f/∂x, B = ∂f/∂u.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nLinearizationResult\nTuple (A, B) or (A, B, G) for stochastic systems"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#stochastic-differential-equation",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#stochastic-differential-equation",
    "title": "",
    "section": "Stochastic Differential Equation",
    "text": "Stochastic Differential Equation\nCentered form (mean = 0): dX = -α·X·dt + σ·dW\nWith control: dX = (-α·X + u)·dt + σ·dW\nwhere: - X(t) ∈ ℝ: State (velocity, rate, deviation) - α &gt; 0: Mean reversion rate (1/time) - σ &gt; 0: Volatility (noise intensity, state/√time) - u ∈ ℝ: External forcing/control - W(t): Standard Wiener process"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nMean Reversion: Drift term -α·X creates restoring force toward zero: - Above zero: Negative drift pushes down - Below zero: Positive drift pushes up - Strength proportional to displacement\nStationarity: Unique stationary distribution: X(∞) ~ N(u/α, σ²/(2α))\nUnlike Brownian motion or GBM, variance bounded.\nAdditive Noise: Diffusion σ constant (state-independent). Simplifies analysis and simulation.\nErgodicity: Time averages equal ensemble averages. Can estimate statistics from single long trajectory."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nExact Solution (u = 0, X(0) = X₀): X(t) = X₀·e^(-α·t) + ∫₀ᵗ σ·e^(-α·(t-s))·dW(s)\nMoments: Mean: E[X(t)] = X₀·e^(-α·t) + (u/α)·(1 - e^(-α·t))\nVariance: Var[X(t)] = (σ²/2α)·(1 - e^(-2α·t))\nAsymptotic (t → ∞): Mean: E[X(∞)] = u/α Variance: Var[X(∞)] = σ²/(2α) Distribution: N(u/α, σ²/(2α))\nAutocorrelation: For stationary process: Cov[X(t), X(t+τ)] = (σ²/2α)·e^(-α·τ)\nExponential decay with rate α."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nMean Reversion Rate α: - Controls speed of return to equilibrium - Units: [1/time] - Time constant: τ = 1/α - Half-life: t₁/₂ = ln(2)/α ≈ 0.693/α\nExamples: - α = 0.1: Slow reversion, τ = 10s - α = 1.0: Moderate, τ = 1s - α = 10.0: Fast, τ = 0.1s\nVolatility σ: - Instantaneous noise intensity - Units: [state]/√[time] - Stationary std: σ/√(2α)\nRatio σ/α: Effective noise level: - Large: Weak reversion, large fluctuations - Small: Strong reversion, tight around mean\nStationary Standard Deviation: σ_stat = σ/√(2α)\nBalance between noise injection (σ) and dissipation (α)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x ∈ ℝ (unbounded) - Can take any real value - Equilibrium at x = u/α - Fluctuates around equilibrium\nControl: u ∈ ℝ (optional) - Shifts equilibrium to u/α - Examples: External force, policy intervention"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nalpha\nfloat\nMean reversion rate (must be positive for stability) - Larger α: Faster reversion, smaller steady-state variance - Time constant τ = 1/α - Typical range: 0.1 to 10.0\n1.0\n\n\nsigma\nfloat\nVolatility (must be positive) - Controls noise intensity - Stationary std: σ/√(2α) - Typical: 0.1 to 2.0\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nNoise Type: ADDITIVE\nDiffusion: g(x) = σ (constant, state-independent)\nSDE Type: Itô (standard)\nNoise Dimension: nw = 1\nStationary: Yes (unique equilibrium distribution)\nErgodic: Yes (time averages = ensemble averages)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Physics: - Langevin equation (particle velocity in fluid) - Thermal equilibrium (velocity distribution) - Optical tweezers (trapped particle) - Molecular dynamics\n2. Finance: - Vasicek interest rate model - Commodity price spreads - Pairs trading (spread between correlated assets) - Credit spreads\n3. Neuroscience: - Neural membrane potential between spikes - Leaky integrate-and-fire neurons - Synaptic conductances\n4. Biology: - Population fluctuations around carrying capacity - Gene expression dynamics - Ecological systems with noise\n5. Control & Signal Processing: - Colored noise generation - Autoregressive processes (continuous AR(1)) - Kalman filtering benchmark"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nEuler-Maruyama: X[k+1] = (1 - α·Δt)·X[k] + u·Δt + σ·√Δt·Z[k]\nRequires α·Δt &lt; 1 for stability.\nExact Discretization (Preferred): X[k+1] = e^(-α·Δt)·X[k] + (u/α)·(1-e^(-α·Δt)) + σ_eff·Z[k]\nwhere σ_eff = √((σ²/2α)·(1-e^(-2α·Δt)))\nAdvantages: - Exact (no discretization error) - Unconditionally stable - Preserves stationary distribution"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#statistical-analysis",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#statistical-analysis",
    "title": "",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\nParameter Estimation: From discrete observations, estimate: α̂ = -ln(autocorr(Δt)) / Δt σ̂ = sample_std · √(2α̂)\nModel Validation: - Check exponential autocorrelation - Verify Gaussian residuals - Test stationarity (KPSS) - Test mean reversion (ADF unit root)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#comparison-with-other-processes",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#comparison-with-other-processes",
    "title": "",
    "section": "Comparison with Other Processes",
    "text": "Comparison with Other Processes\nvs. Brownian Motion: - BM: No reversion (non-stationary) - OU: Mean-reverting (stationary)\nvs. Geometric Brownian Motion: - GBM: Multiplicative noise, for prices - OU: Additive noise, for rates/deviations\nvs. CIR Process: - CIR: Multiplicative noise √X (stays positive) - OU: Additive noise (can be negative)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nCan be negative (problem for rates/prices)\nConstant volatility (unrealistic for some applications)\nLinear mean reversion (may be non-linear in reality)\nGaussian (real data may have fat tails)\n\nSolutions: - CIR for positive quantities - State-dependent diffusion - Non-linear drift functions - Jump extensions"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nBrownianMotion : No mean reversion (α=0 limit) GeometricBrownianMotion : Multiplicative noise CoxIngersollRoss : Mean-reverting with √X diffusion"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.OrnsteinUhlenbeck.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine Ornstein-Uhlenbeck process dynamics.\n\n\nget_half_life\nGet half-life t₁/₂ = ln(2)/α ≈ 0.693/α.\n\n\nget_stationary_std\nCompute theoretical stationary standard deviation.\n\n\nget_time_constant\nGet mean reversion time constant τ = 1/α.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.OrnsteinUhlenbeck.define_system(\n    alpha=1.0,\n    sigma=1.0,\n)\nDefine Ornstein-Uhlenbeck process dynamics.\nSets up the stochastic differential equation: dX = (-α·X + u)·dt + σ·dW\nwith mean reversion and additive noise.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nalpha\nfloat\nMean reversion rate (should be positive) - α &gt; 0: Stable (mean-reverting) - α = 0: Brownian motion (no reversion) - α &lt; 0: Unstable (explosive)\n1.0\n\n\nsigma\nfloat\nVolatility (must be positive) - Controls noise intensity - Stationary std: σ/√(2α)\n1.0\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf sigma ≤ 0\n\n\n\nUserWarning\nIf alpha ≤ 0 (unstable/non-reverting)\n\n\n\n\n\nNotes\nStability Condition: Require α &gt; 0 for mean reversion and stationarity. - α &gt; 0: Process stable, reverts to mean - α = 0: Becomes Brownian motion - α &lt; 0: Unstable, diverges exponentially\nTime Scales: - Time constant: τ = 1/α - Half-life: t₁/₂ = ln(2)/α ≈ 0.693/α - Settling time: t_settle ≈ 5/α (1% of initial deviation)\nAfter time τ: Deviation reduced by factor e ≈ 0.368 After time 5τ: Deviation reduced by factor e⁻⁵ ≈ 0.007 (~99% reverted)\nStationary Statistics: For u = 0: - Mean: E[X(∞)] = 0 - Variance: Var[X(∞)] = σ²/(2α) - Std: σ/√(2α)\nFor u ≠ 0: - Mean: E[X(∞)] = u/α - Variance: σ²/(2α) (same)\nParameter Selection: - Fast reversion: α = 5-10 (τ = 0.1-0.2s) - Moderate: α = 1-2 (τ = 0.5-1s) - Slow: α = 0.1-0.5 (τ = 2-10s)\nNoise Level: Effective noise (stationary std): σ/√(2α) - To achieve desired std s: set σ = s·√(2α)\nFluctuation-Dissipation: In physical systems at temperature T: σ² = 2α·kᵦ·T/m Balance between thermal noise and friction.\n\n\n\nget_half_life\nsystems.builtin.stochastic.continuous.OrnsteinUhlenbeck.get_half_life()\nGet half-life t₁/₂ = ln(2)/α ≈ 0.693/α.\nTime for deviation from mean to reduce by 50%. More intuitive than time constant for some applications.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nHalf-life [time units]\n\n\n\n\n\n\nget_stationary_std\nsystems.builtin.stochastic.continuous.OrnsteinUhlenbeck.get_stationary_std()\nCompute theoretical stationary standard deviation.\nFor OU process, stationary distribution is: X(∞) ~ N(u/α, σ²/(2α))\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nStationary standard deviation: σ/√(2α)\n\n\n\n\n\nNotes\nInterpretation: This is the long-term standard deviation around the mean, reached after transient dies out (t &gt;&gt; 1/α).\nRelationship to Parameters: - Increases with σ (more noise) - Decreases with α (stronger reversion) - Ratio σ/α sets scale\nComparison with σ: - σ: Instantaneous noise intensity - σ/√(2α): Accumulated noise effect - Always: σ_stat &lt; σ (for α &gt; 0.5)\nDesign: To achieve target std s: σ = s · √(2α)\n\n\n\nget_time_constant\nsystems.builtin.stochastic.continuous.OrnsteinUhlenbeck.get_time_constant()\nGet mean reversion time constant τ = 1/α.\nThe time constant is the characteristic time scale for the process to revert to its mean. After time τ, the deviation from mean is reduced by factor e ≈ 0.368.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTime constant [time units]\n\n\n\n\n\nNotes\nPhysical Meaning: - Time to reduce deviation by ~63% - Reciprocal of mean reversion rate - Sets time scale of dynamics\nRelated Quantities: - Half-life: t₁/₂ = ln(2)·τ ≈ 0.693·τ - 99% settling: t_99 ≈ 5·τ - 1% settling: t_01 ≈ 0.01·τ\nRule of Thumb: Process reaches stationarity after 3-5 time constants. - t &lt; τ: Still in transient - t ≈ 5τ: Essentially stationary\nExamples: - τ = 0.1s: Fast dynamics (α = 10) - τ = 1.0s: Moderate (α = 1) - τ = 10s: Slow (α = 0.1)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html",
    "href": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html#parameters",
    "href": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\njax.random.PRNGKey\nRandom key (used if dW is None)\nrequired\n\n\nt0\nScalarLike\nStart time\nrequired\n\n\nt1\nScalarLike\nEnd time\nrequired\n\n\nshape\ntuple\nNoise shape (nw,)\nrequired\n\n\ndW\nOptional[ArrayLike]\nCustom Brownian increment. If None, generates random.\nNone"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html#returns",
    "href": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nBrownian motion object for Diffrax"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html#examples",
    "href": "api/systems.base.numerical_integration.stochastic.create_custom_or_random_brownian.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Random noise\n&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; brownian = create_custom_or_random_brownian(key, 0, 0.01, (1,))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom noise (deterministic)\n&gt;&gt;&gt; dW = jnp.array([0.5])\n&gt;&gt;&gt; brownian = create_custom_or_random_brownian(key, 0, 0.01, (1,), dW=dW)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#queue-dynamics",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#queue-dynamics",
    "title": "",
    "section": "Queue Dynamics",
    "text": "Queue Dynamics\nBasic queue evolution: Q[k+1] = max(0, Q[k] + A[k] - S[k])\nwhere: - Q[k]: Queue length (number in system) at time k - A[k]: Arrivals during slot k (random, ≥ 0) - S[k]: Service completions during slot k (random, ≤ Q[k]) - max(0, …): Queue cannot be negative\nLinearized (around equilibrium Q̄): Q[k+1] ≈ Q[k] + (λ - μ) + w_A[k] - w_S[k]\nwhere w_A, w_S represent arrival and service noise.\nState-Space (Simplified Diffusion Approximation): Q[k+1] = Q[k] + (λ - μ)·Δt + σ_net·w[k]\nwhere σ_net combines arrival and service variability."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nQueue Length Q[k]: - Number of customers/packets/jobs in system - Q = 0: Empty (idle server) - Large Q: Congestion (long waits)\nArrivals A[k]: - New customers entering system - Distribution: Poisson (λ parameter), binomial, general - Typical: 0-10 per slot (depends on λ·Δt)\nService S[k]: - Completions (customers leaving) - Depends on Q: Can’t serve more than present - Capacity: μ (maximum service rate)\nTraffic Intensity: ρ = λ/μ\nCritical parameter: - ρ &lt; 1: Stable (queue bounded on average) - ρ = 1: Critical (marginal) - ρ &gt; 1: Unstable (queue grows to infinity)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nNon-Negativity: Q ≥ 0 enforced via max(0, …) operation.\nStability Threshold: ρ = λ/μ determines long-run behavior.\nState-Dependent Service: When Q = 0, no service possible (idle server).\nStochastic Fluctuations: Even stable queue (ρ &lt; 1) exhibits large fluctuations.\nHeavy Traffic: Near ρ = 1, queue becomes very sensitive to perturbations."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nStability: For ρ &lt; 1, queue has stationary distribution.\nMean Queue Length (Steady-State): Approximate (diffusion limit): E[Q] ≈ ρ/(1-ρ) (for M/M/1 analog)\nWaiting Time: Little’s Law (exact): E[W] = E[Q]/λ\nAverage waiting time = average queue / arrival rate.\nVariance: Queue length variance high near ρ = 1.\nDistribution: For M/M/1 continuous analog: P(Q = n) = (1-ρ)·ρⁿ (geometric)\nDiscrete-time: Similar but modified."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nArrival Rate λ: - Units: [customers/time] - Average arrivals per unit time - Typical: 0.1-10 depending on system\nService Rate μ: - Units: [customers/time] - Average service capacity - Must be μ &gt; λ for stability\nTraffic Intensity ρ = λ/μ: - Dimensionless (utilization) - ρ = 0.5: 50% utilized (stable, low wait) - ρ = 0.8: 80% utilized (moderate wait) - ρ = 0.95: 95% utilized (high wait, fragile) - ρ &gt; 1: Overloaded (unstable)\nDesign Rule: Keep ρ &lt; 0.8 for reliable operation. - Buffer for variability - Acceptable waiting times - Robustness to perturbations"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: Q ∈ ℤ₊ = {0, 1, 2, …} - Non-negative integer (count of items) - Unbounded (unless capacity limit)\nControl: u (optional) - Admission control (reject arrivals) - Service rate adjustment - Server allocation\nNoise: w_A, w_S - Arrival noise (Poisson fluctuations) - Service noise (randomness in completion)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlambda_rate\nfloat\nMean arrival rate [customers/slot] - Must be positive - Typical: 0.1-10\n0.8\n\n\nmu_rate\nfloat\nMean service rate [customers/slot] - Must be positive - Must have μ &gt; λ for stability\n1.0\n\n\nsigma_arrival\nfloat\nArrival noise std dev [customers/slot] - From Poisson: σ_A ≈ √λ - Can be different (overdispersion)\n0.3\n\n\nsigma_service\nfloat\nService noise std dev [customers/slot] - Variability in service times - Typical: 0.1-1.0\n0.3\n\n\ndt\nfloat\nTime slot duration [s]\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR (max operator)\nNoise Type: ADDITIVE (approximate)\nState: Discrete (integer-valued ideally)\nStationary: If ρ &lt; 1\nHeavy Tails: Geometric distribution (M/M/1 analog)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Network Engineering: - Router queue sizing - Bandwidth provisioning - QoS guarantees\n2. Call Centers: - Staffing optimization - Service level targets - Abandonment modeling\n3. Manufacturing: - WIP inventory control - Buffer sizing - Throughput analysis\n4. Healthcare: - ER capacity planning - Surgery scheduling - Bed management\n5. Cloud Computing: - Auto-scaling triggers - Load balancing - SLA compliance"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nDirect Simulation:\nQ = np.zeros(N+1)\nQ[0] = Q0\n\nfor k in range(N):\n    A_k = np.random.poisson(lambda_rate)\n    S_k = np.random.poisson(min(Q[k], mu_rate))\n    Q[k+1] = max(0, Q[k] + A_k - S_k)\nIssues: - Integer-valued (exact Poisson) - Max operator (non-smooth) - State-dependent service\nDiffusion Approximation: For large λ, μ, treat as continuous: Q[k+1] ≈ Q[k] + (λ-μ)·Δt + σ_net·w[k]\nSmoother, easier analysis."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#performance-metrics",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#performance-metrics",
    "title": "",
    "section": "Performance Metrics",
    "text": "Performance Metrics\nMean Queue Length: E[Q] (average number waiting)\nMean Waiting Time: E[W] = E[Q]/λ (Little’s Law)\nServer Utilization: ρ = λ/μ (fraction time busy)\nProbability of Delay: P(Q &gt; 0) (chance of waiting)\nPercentiles: P(Q ≤ q_95) = 0.95 (95th percentile)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#comparison-with-mm1",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#comparison-with-mm1",
    "title": "",
    "section": "Comparison with M/M/1",
    "text": "Comparison with M/M/1\nM/M/1 (Continuous-Time): - Poisson arrivals (rate λ) - Exponential service (rate μ) - Analytical formulas\nDiscrete Queue: - Arrivals per slot (mean λ·Δt) - Service per slot (mean μ·Δt) - Numerical/simulation\nConvergence: As Δt → 0, discrete → continuous M/M/1."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nSingle server (extend to M/M/c)\nInfinite capacity (no buffer limit)\nFIFO discipline (no priorities)\nStationary (time-invariant λ, μ)\nIndependence (no batch arrivals)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nM/M/c: Multiple servers\nFinite capacity: M/M/1/K\nPriority queues\nTime-varying rates: λ(t), μ(t)\nNetwork of queues (Jackson networks)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDiscreteAR1 : Simpler linear stochastic system DiscreteRandomWalk : No bounds (queue has Q ≥ 0)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticQueue.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine discrete stochastic queue dynamics.\n\n\nget_mean_queue_length\nGet theoretical mean queue length E[Q] ≈ ρ/(1-ρ).\n\n\nget_mean_waiting_time\nGet mean waiting time via Little’s Law: E[W] = E[Q]/λ.\n\n\nget_utilization\nGet server utilization (traffic intensity) ρ = λ/μ.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteStochasticQueue.define_system(\n    lambda_rate=0.8,\n    mu_rate=1.0,\n    sigma_arrival=0.3,\n    sigma_service=0.3,\n    dt=1.0,\n)\nDefine discrete stochastic queue dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlambda_rate\nfloat\nMean arrival rate [customers/slot] - Must be positive - Typical: 0.1-10\n0.8\n\n\nmu_rate\nfloat\nMean service rate [customers/slot] - Must be positive - Must have μ &gt; λ for stability\n1.0\n\n\nsigma_arrival\nfloat\nArrival noise std dev - For Poisson: σ_A = √λ - Can differ (overdispersion)\n0.3\n\n\nsigma_service\nfloat\nService noise std dev\n0.3\n\n\ndt\nfloat\nTime slot duration [s]\n1.0\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf λ ≤ 0, μ ≤ 0, or ρ ≥ 1\n\n\n\nUserWarning\nIf ρ &gt; 0.9 (near critical, fragile)\n\n\n\n\n\nNotes\nTraffic Intensity: ρ = λ/μ\nStability: - ρ &lt; 1: Stable (queue finite on average) - ρ ≥ 1: Unstable (queue → ∞)\nMean Queue (Approximate): E[Q] ≈ ρ/(1-ρ)\nFor ρ = 0.8: E[Q] ≈ 4 For ρ = 0.9: E[Q] ≈ 9 For ρ = 0.95: E[Q] ≈ 19\nDesign Guideline: Keep ρ &lt; 0.8 for good performance: - Reasonable wait times - Robustness to variability - Avoid heavy traffic regime\nNoise Structure:\nArrival noise: From Poisson statistics σ_A ≈ √λ (for Poisson)\nService noise: From variability σ_S depends on distribution\nNet noise: σ_net = √(σ_A² + σ_S²)\nSimplified Model:\nThis uses diffusion approximation: Q[k+1] = max(0, Q[k] + (λ-μ) + w[k])\nwhere w[k] ~ N(0, σ_net²).\nMore accurate: Exact Poisson simulation (Gillespie-like).\n\n\n\nget_mean_queue_length\nsystems.builtin.stochastic.discrete.DiscreteStochasticQueue.get_mean_queue_length(\n)\nGet theoretical mean queue length E[Q] ≈ ρ/(1-ρ).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nMean queue length (steady-state)\n\n\n\n\n\nNotes\nApproximate formula (diffusion/M/M/1 analog).\n\n\nExamples\n&gt;&gt;&gt; queue = DiscreteStochasticQueue(lambda_rate=0.8, mu_rate=1.0)\n&gt;&gt;&gt; E_Q = queue.get_mean_queue_length()\n&gt;&gt;&gt; print(f\"Mean queue: {E_Q:.2f}\")\n\n\n\nget_mean_waiting_time\nsystems.builtin.stochastic.discrete.DiscreteStochasticQueue.get_mean_waiting_time(\n)\nGet mean waiting time via Little’s Law: E[W] = E[Q]/λ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nMean waiting time [slots]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; queue = DiscreteStochasticQueue(lambda_rate=0.8, mu_rate=1.0)\n&gt;&gt;&gt; E_W = queue.get_mean_waiting_time()\n&gt;&gt;&gt; print(f\"Mean wait: {E_W:.2f} slots\")\n\n\n\nget_utilization\nsystems.builtin.stochastic.discrete.DiscreteStochasticQueue.get_utilization()\nGet server utilization (traffic intensity) ρ = λ/μ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nUtilization (0 to 1)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; queue = DiscreteStochasticQueue(lambda_rate=0.8, mu_rate=1.0)\n&gt;&gt;&gt; util = queue.get_utilization()\n&gt;&gt;&gt; print(f\"Utilization: {util:.1%}\")"
  },
  {
    "objectID": "api/types.backends.Device.html",
    "href": "api/types.backends.Device.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.Device.html#examples",
    "href": "api/types.backends.Device.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; device: Device = 'cuda:0'\n&gt;&gt;&gt; system.set_preferred_device('cpu')\n&gt;&gt;&gt; \n&gt;&gt;&gt; # PyTorch usage\n&gt;&gt;&gt; import torch\n&gt;&gt;&gt; tensor = torch.tensor(data, device='cuda')\n&gt;&gt;&gt; \n&gt;&gt;&gt; # JAX usage (via jax.devices)\n&gt;&gt;&gt; import jax\n&gt;&gt;&gt; device = jax.devices('gpu')[0]"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#stochastic-differential-equation",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#stochastic-differential-equation",
    "title": "",
    "section": "Stochastic Differential Equation",
    "text": "Stochastic Differential Equation\nVector SDE: dX = A·X·dt + Σ·dW\nWith control: dX = (A·X + B·u)·dt + Σ·dW\nwhere: - X ∈ ℝⁿ: State vector - A ∈ ℝⁿˣⁿ: Drift matrix (coupling + mean reversion) - B ∈ ℝⁿˣᵖ: Control matrix - u ∈ ℝᵖ: Control input - Σ ∈ ℝⁿˣᵐ: Diffusion matrix - W ∈ ℝᵐ: Vector Wiener process (m noise sources) - dW ~ N(0, I_m·dt): Independent increments\nMatrix Dimensions: - n states - m noise sources (typically m ≤ n) - p control inputs"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nDrift Matrix A:\nDiagonal elements A_ii: - Mean reversion for X_i - Must be negative for stability: A_ii &lt; 0 - Time constant: τ_i = -1/A_ii\nOff-diagonal elements A_ij (i ≠ j): - Coupling from X_j to dX_i/dt - Positive: X_j increases → X_i increases (co-movement) - Negative: X_j increases → X_i decreases (opposition) - Zero: No direct coupling\nExample (2D): A = [-α₁ γ ] [ γ -α₂ ]\n\nOwn reversion: -α₁, -α₂ (diagonal)\nCross-coupling: γ (off-diagonal)\nSymmetric: Bidirectional coupling\n\nDiffusion Matrix Σ:\nEach row Σ_i,· determines noise for X_i: - If m = n and Σ diagonal: Independent noise per component - If m &lt; n: Common factors (dimension reduction) - Non-diagonal: Correlated noise sources\nNoise Covariance: Q = Σ·Σᵀ ∈ ℝⁿˣⁿ\nInstantaneous noise covariance: - Q_ii: Variance rate for X_i - Q_ij: Covariance rate between X_i and X_j"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nCoupling: Components interact via drift matrix A. Creates rich dynamics impossible in independent processes.\nCorrelation: Noise sources can be correlated via Σ. Models common shocks affecting multiple variables.\nStability: Stable if all eigenvalues of A have Re(λ) &lt; 0.\nStationary Distribution: X(∞) ~ N(-A^(-1)·B·u, Σ_∞)\nwhere Σ_∞ from Lyapunov equation.\nGaussian: Linear dynamics preserve multivariate Gaussianity.\nDimension Reduction: If m &lt; n, dynamics driven by m &lt; n factors. Used in factor models (finance)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nStationary Covariance:\nLyapunov equation: A·Σ_∞ + Σ_∞·Aᵀ + Q = 0\nwhere Q = Σ·Σᵀ.\nSolutions: - Direct: Analytical (small n) - Numerical: scipy.linalg.solve_continuous_lyapunov - Eigenvalue: Via eigendecomposition of A\nAutocorrelation: Cov[X(t), X(t+τ)] = Σ_∞·exp(Aᵀτ)\nMatrix exponential decay.\nEigenvalue Decomposition: A = V·Λ·V^(-1)\nSolution in eigenbasis: Y = V^(-1)·X (modal coordinates) Y_i(t) = Y_i(0)·exp(λ_i·t) + noise\nEach mode independent OU with rate λ_i.\nCross-Correlation Structure:\nFor components i, j: Corr[X_i(t), X_j(t+τ)] = (Σ_∞)_ij·exp(dominant eigenvalue·τ)\nDetermined by slowest (least negative) eigenvalue."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nTwo-Asset Example:\nConsider two correlated assets: dX₁ = -α₁·X₁·dt + γ·X₂·dt + σ₁·dW₁ dX₂ = γ·X₁·dt - α₂·X₂·dt + σ₂·dW₂\nInterpretation: - -α_i·X_i: Own mean reversion - γ·X_j: Spillover from other asset - σ_i·dW_i: Idiosyncratic shocks\nYield Curve Example:\nInterest rates at different maturities: dr_short = -κ_s·r_short·dt + … dr_long = -κ_l·r_long·dt + coupling·dr_short·dt + …\nShort rate affects long rate (term structure)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X ∈ ℝⁿ - Vector of coupled variables - Unbounded (Gaussian) - Equilibrium at -A^(-1)·B·u\nControl: u ∈ ℝᵖ (optional) - Vector control input - Can be state feedback: u = u(X)\nNoise: W ∈ ℝᵐ - m independent Wiener processes - m ≤ n typically (factor structure)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\n(np.ndarray or list, shape(n, n))\nDrift matrix (must have eigenvalues with Re(λ) &lt; 0 for stability) - Diagonal: Own mean reversion - Off-diagonal: Coupling\nrequired\n\n\nSigma\n(np.ndarray or list, shape(n, m))\nDiffusion matrix - Each row: Noise coefficients for one state - Can be square (m=n) or rectangular (m&lt;n)\nrequired\n\n\nB\n(Optional[np.ndarray], shape(n, p))\nControl matrix (if system is controlled)\nrequired"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: LINEAR\nNoise Type: ADDITIVE (constant Σ)\nSDE Type: Itô\nNoise Dimension: nw = m\nStationary: Yes (if A stable)\nErgodic: Yes (if A stable)\nGaussian: Yes (always)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Finance: - Multi-factor interest rate models - Correlated asset dynamics - Yield curve modeling - Portfolio optimization\n2. Physics: - Coupled Langevin equations - Multiple particles in potential - Collective modes\n3. Economics: - Multi-country VAR models - Spillover effects - Policy transmission\n4. Neuroscience: - Neural population dynamics - Synaptic coupling - Network oscillations\n5. Climate: - Multi-region temperatures - Heat transport coupling\n6. Control: - Multi-variable LQG - Coordinated control - Decentralized vs centralized"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nEuler-Maruyama: X[k+1] = X[k] + A·X[k]·Δt + Σ·√Δt·Z[k]\nExact Discretization: X[k+1] = Φ·X[k] + w[k]\nwhere Φ = exp(A·Δt) (matrix exponential).\nRecommended: Exact for moderate n (fast matrix exponential)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#eigenvalue-analysis",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#eigenvalue-analysis",
    "title": "",
    "section": "Eigenvalue Analysis",
    "text": "Eigenvalue Analysis\nStability Check: eigenvalues, eigenvectors = np.linalg.eig(A) stable = np.all(np.real(eigenvalues) &lt; 0)\nTime Scales: time_constants = -1 / np.real(eigenvalues)\nOscillatory Modes: frequencies = np.imag(eigenvalues) / (2*np.pi)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#comparison-with-scalar-ou",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#comparison-with-scalar-ou",
    "title": "",
    "section": "Comparison with Scalar OU",
    "text": "Comparison with Scalar OU\nScalar OU: - 1D, no coupling - Single time constant - Exponential correlation\nMultivariate OU: - nD, with coupling - Multiple time scales - Complex correlation structure\nWhen Coupling Matters: - Asset correlations (portfolio risk) - Spillover effects (contagion) - Coordinated control (multi-agent)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nLinear dynamics only\nConstant A, Σ\nGaussian distribution\nNo jumps\nStationary assumptions"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nNonlinear: dX = f(X)·dt + Σ·dW\nTime-varying: A(t), Σ(t)\nRegime-switching: Parameters switch\nInfinite-dimensional: SPDE"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nOrnsteinUhlenbeck : Scalar version VectorAutoRegressive : Discrete-time analog"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine multivariate OU process dynamics.\n\n\nget_correlation_matrix\nGet stationary correlation matrix.\n\n\nget_diffusion_matrix\nGet diffusion matrix Σ.\n\n\nget_drift_matrix\nGet drift matrix A.\n\n\nget_eigenvalues\nGet eigenvalues of drift matrix A.\n\n\nget_noise_covariance\nGet instantaneous noise covariance Q = Σ·Σᵀ.\n\n\nget_stationary_covariance\nCompute stationary covariance Σ_∞.\n\n\nget_time_constants\nGet time constants from eigenvalues: τ_i = -1/Re(λ_i).\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.define_system(\n    A,\n    Sigma,\n    B=None,\n)\nDefine multivariate OU process dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\n(np.ndarray or list, shape(n, n))\nDrift matrix - Diagonal: Mean reversion rates (must be negative) - Off-diagonal: Coupling strengths - Must be stable: All Re(λ) &lt; 0\nrequired\n\n\nSigma\n(np.ndarray or list, shape(n, m))\nDiffusion matrix - n states, m noise sources - Can be square (m=n) or rectangular (m&lt;n) - Q = Σ·Σᵀ is noise covariance\nrequired\n\n\nB\n(Optional[np.ndarray], shape(n, p))\nControl matrix (if controlled system) - p control inputs - If None, system is autonomous\nNone\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf A is not square, or dimensions incompatible\n\n\n\nUserWarning\nIf A has eigenvalues with Re(λ) ≥ 0 (unstable)\n\n\n\n\n\nNotes\nStability Requirement:\nFor stationary distribution, A must be stable: All eigenvalues: Re(λ) &lt; 0\nCheck: eigenvalues, _ = np.linalg.eig(A)\nCoupling Structure:\nA encodes interactions: - Diagonal elements: Self-dynamics (must be negative) - Off-diagonal: Cross-effects - Symmetric A: Detailed balance (reversible) - Asymmetric A: Non-reversible (cycles possible)\nNoise Structure:\nCommon configurations: 1. Independent (m=n, Σ diagonal): Each component has own noise source\n\nFactor model (m&lt;n): States driven by fewer factors Example: n=10 rates, m=3 factors (level, slope, curvature)\nCorrelated (Σ non-diagonal): Common shocks affect multiple components\n\nStationary Covariance:\nSolve Lyapunov equation: A·Σ_∞ + Σ_∞·Aᵀ + Σ·Σᵀ = 0\nGives long-term covariance structure.\nDimension Guidelines: - Small (n ≤ 5): Fully coupled, dense A - Medium (n = 5-20): Sparse A (limited coupling) - Large (n &gt; 20): Factor structure (m &lt;&lt; n)\n\n\nExamples\n&gt;&gt;&gt; # 2D coupled OU\n&gt;&gt;&gt; A = [[-1.0, 0.2],    # X₂ pulls on X₁\n...      [0.3, -2.0]]    # X₁ pulls on X₂\n&gt;&gt;&gt; Sigma = [[0.5, 0.0],\n...          [0.0, 1.0]]\n&gt;&gt;&gt;\n&gt;&gt;&gt; mou = MultivariateOrnsteinUhlenbeck(A=A, Sigma=Sigma)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check stability\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(np.array(A))\n&gt;&gt;&gt; print(f\"Eigenvalues: {eigenvalues}\")\n&gt;&gt;&gt; print(f\"Stable: {np.all(np.real(eigenvalues) &lt; 0)}\")\n\n\n\nget_correlation_matrix\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.get_correlation_matrix(\n)\nGet stationary correlation matrix.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nCorrelation matrix (n, n) with 1s on diagonal\n\n\n\n\n\nExamples\n&gt;&gt;&gt; mou = MultivariateOrnsteinUhlenbeck(\n...     A=[[-1, 0.5], [0.5, -1]],\n...     Sigma=[[1, 0], [0, 1]]\n... )\n&gt;&gt;&gt; rho = mou.get_correlation_matrix()\n&gt;&gt;&gt; print(f\"Correlation:\\n{rho}\")\n\n\n\nget_diffusion_matrix\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.get_diffusion_matrix(\n)\nGet diffusion matrix Σ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nDiffusion matrix (n, m)\n\n\n\n\n\n\nget_drift_matrix\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.get_drift_matrix(\n)\nGet drift matrix A.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nDrift matrix (n, n)\n\n\n\n\n\n\nget_eigenvalues\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.get_eigenvalues(\n)\nGet eigenvalues of drift matrix A.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nEigenvalues (may be complex)\n\n\n\n\n\nNotes\nEigenvalues determine: - Stability: All Re(λ) &lt; 0 required - Time scales: τ_i = -1/Re(λ_i) - Oscillations: Im(λ) ≠ 0 → periodic components\n\n\nExamples\n&gt;&gt;&gt; mou = MultivariateOrnsteinUhlenbeck(\n...     A=[[-1, 2], [-2, -1]],\n...     Sigma=[[1, 0], [0, 1]]\n... )\n&gt;&gt;&gt; eigs = mou.get_eigenvalues()\n&gt;&gt;&gt; print(f\"Eigenvalues: {eigs}\")\n&gt;&gt;&gt; if np.any(np.imag(eigs) != 0):\n...     print(\"System has oscillatory modes\")\n\n\n\nget_noise_covariance\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.get_noise_covariance(\n)\nGet instantaneous noise covariance Q = Σ·Σᵀ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nNoise covariance (n, n)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; mou = MultivariateOrnsteinUhlenbeck(\n...     A=[[-1, 0], [0, -2]],\n...     Sigma=[[1, 0], [0, 2]]\n... )\n&gt;&gt;&gt; Q = mou.get_noise_covariance()\n&gt;&gt;&gt; print(f\"Noise covariance:\\n{Q}\")\n\n\n\nget_stationary_covariance\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.get_stationary_covariance(\n)\nCompute stationary covariance Σ_∞.\nSolves Lyapunov equation: A·Σ_∞ + Σ_∞·Aᵀ + Q = 0\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nStationary covariance (n, n)\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf A is unstable (no stationary distribution)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; mou = MultivariateOrnsteinUhlenbeck(\n...     A=[[-1, 0], [0, -2]],\n...     Sigma=[[1, 0], [0, 1]]\n... )\n&gt;&gt;&gt; Sigma_inf = mou.get_stationary_covariance()\n&gt;&gt;&gt; print(f\"Stationary covariance:\\n{Sigma_inf}\")\n\n\n\nget_time_constants\nsystems.builtin.stochastic.continuous.MultivariateOrnsteinUhlenbeck.get_time_constants(\n)\nGet time constants from eigenvalues: τ_i = -1/Re(λ_i).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nTime constants [s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; mou = MultivariateOrnsteinUhlenbeck(\n...     A=[[-1, 0], [0, -5]],\n...     Sigma=[[1, 0], [0, 1]]\n... )\n&gt;&gt;&gt; tau = mou.get_time_constants()\n&gt;&gt;&gt; print(f\"Time constants: {tau}\")  # [1.0, 0.2]"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_implementing_library.html",
    "href": "api/systems.base.numerical_integration.get_implementing_library.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_implementing_library.html#returns",
    "href": "api/systems.base.numerical_integration.get_implementing_library.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nOne of: ‘scipy’, ‘diffeqpy’, ‘torchdiffeq’, ‘torchsde’, ‘diffrax’, ‘manual’, ‘unknown’"
  },
  {
    "objectID": "api/systems.base.numerical_integration.get_implementing_library.html#examples",
    "href": "api/systems.base.numerical_integration.get_implementing_library.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; get_implementing_library('LSODA', 'numpy', is_stochastic=False)\n'scipy'\n&gt;&gt;&gt; get_implementing_library('Tsit5', 'numpy', is_stochastic=False)\n'diffeqpy'\n&gt;&gt;&gt; get_implementing_library('euler', 'torch', is_stochastic=True)\n'torchsde'\n&gt;&gt;&gt; get_implementing_library('euler', 'numpy', is_stochastic=False)\n'manual'\n&gt;&gt;&gt; get_implementing_library('rk4', 'jax', is_stochastic=False)\n'manual'"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#discrete-time-stochastic-dynamics",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#discrete-time-stochastic-dynamics",
    "title": "",
    "section": "Discrete-Time Stochastic Dynamics",
    "text": "Discrete-Time Stochastic Dynamics\nDifference equation (Euler discretization):\nC_A[k+1] = C_A[k] - r₁(X[k])·Δt + w_A[k]\nC_B[k+1] = C_B[k] + (r₁(X[k]) - r₂(X[k]))·Δt + w_B[k]\nT[k+1] = T[k] + (Q[k] - α·(T[k] - T_amb))·Δt + w_T[k]\nwhere: - X[k] = [C_A[k], C_B[k], T[k]]: State at time step k - r₁, r₂: Reaction rates (Arrhenius kinetics) - w[k] = [w_A[k], w_B[k], w_T[k]]: Process noise - w[k] ~ N(0, diag(σ_A², σ_B², σ_T²)) - Δt: Sampling period"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nDiscrete-Time Operation:\nIndustrial batch reactors operate with digital control: - Sensors sampled every Δt seconds (PLC scan rate) - Control computed and applied at discrete intervals - Zero-order hold: Q[k] constant during [k·Δt, (k+1)·Δt] - Measurements: y[k] available at t = k·Δt\nProcess Noise Sources:\nw[k] represents accumulated disturbances over sampling interval: 1. Concentration noise: Feed variations, mixing imperfections 2. Temperature noise: Heat transfer fluctuations, ambient changes 3. Model uncertainty: Discretization errors, parameter drift\nNoise Scaling from Continuous:\nIf continuous noise intensity is σ_c [state/√time]: σ_discrete = σ_c·√Δt [state]\nExample: σ_T = 1 K/√s continuous, Δt = 1 s → σ_T_discrete = 1·√1 = 1 K per time step"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X[k] = [C_A[k], C_B[k], T[k]] Discrete-time samples of concentrations and temperature: - C_A[k]: Concentration of A at time k·Δt [mol/L] - C_B[k]: Concentration of B at time k·Δt [mol/L] - T[k]: Temperature at time k·Δt [K]\nControl: u[k] = Q[k] - Q[k]: Heating rate during interval [k·Δt, (k+1)·Δt] [K/s] - Zero-order hold: Constant between samples\nNoise: w[k] = [w_A[k], w_B[k], w_T[k]] - Gaussian white noise: w[k] ~ N(0, Σ_w) - Independent over time: w[k] ⊥ w[j] for k ≠ j - Diagonal covariance: Σ_w = diag(σ_A², σ_B², σ_T²)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#key-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#key-properties",
    "title": "",
    "section": "Key Properties",
    "text": "Key Properties\nMarkov Property: X[k+1] depends only on X[k], enabling: - Dynamic programming - Kalman filtering - Reinforcement learning\nTime-Invariant: Dynamics f same at all time steps (constant parameters).\nGaussian Noise: Enables analytical Kalman filter (optimal for Gaussian).\nAdditive Noise: Simplifies estimation (linearity in noise).\nDiscrete-Time Native: Exact for digital control (no continuous-time approximation)."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk1\nfloat\nPre-exponential factor for A→B reaction [1/s]\nrequired\n\n\nk2\nfloat\nPre-exponential factor for B→C reaction [1/s]\nrequired\n\n\nE1\nfloat\nActivation energy for reaction 1 [K]\nrequired\n\n\nE2\nfloat\nActivation energy for reaction 2 [K]\nrequired\n\n\nalpha\nfloat\nHeat transfer coefficient [1/s]\nrequired\n\n\nT_amb\nfloat\nAmbient temperature [K]\nrequired\n\n\nC_A0\nOptional[float]\nInitial concentration of A for equilibrium setup [mol/L]\nrequired\n\n\nT0\nOptional[float]\nInitial temperature for equilibrium setup [K]\nrequired\n\n\nsigma_A\nfloat\nProcess noise std dev for C_A [mol/L per step] - Typical: 0.001-0.1 mol/L - Conversion from continuous: σ_c·√Δt\n0.01\n\n\nsigma_B\nfloat\nProcess noise std dev for C_B [mol/L per step]\n0.01\n\n\nsigma_T\nfloat\nProcess noise std dev for T [K per step] - Typical: 0.1-5.0 K - Conversion from continuous: σ_c·√Δt\n1.0\n\n\ndt\nfloat\nSampling period [s] - Typical: 0.1-10 s for batch reactors - Smaller dt → more accurate, more computation - Must satisfy Nyquist: dt &lt; 1/(2·f_max)\n1.0\n\n\ndiscretization_method\nstr\nDiscretization method for continuous dynamics - ‘euler’: Forward Euler (first-order) - ‘rk4’: Runge-Kutta 4 (fourth-order) - ‘exact’: Exact for linear parts\n'euler'"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Discrete-Time MPC: Model Predictive Control with constraints: - Optimization horizon: N steps - Constraints: X_min ≤ X[k] ≤ X_max - Receding horizon: Solve at each k\n2. Discrete Kalman Filter: Optimal state estimation: - Process model: This discrete stochastic system - Measurement model: y[k] = h(X[k]) + v[k] - Extended or Unscented KF for nonlinearity\n3. LQG Control: Linear-Quadratic-Gaussian: - Kalman filter for state estimation - LQR for optimal control - Certainty equivalence principle\n4. Reinforcement Learning: Discrete-time RL algorithms: - Q-learning: Discrete state/action - Policy gradient: Episodic updates - Model-based RL: Use this as forward model\n5. Batch-to-Batch Optimization: Iterative learning control: - Update policy based on previous batches - Stochastic gradient descent - Safe learning with constraints"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nDirect Simulation: No integration needed - direct evaluation: for k in range(N): X[k+1] = f(X[k], u[k]) + w[k]\nwhere w[k] ~ N(0, Σ_w).\nMonte Carlo Ensemble: Run multiple simulations to characterize stochasticity: - Mean trajectory - Variance growth - Confidence intervals\nDeterministic Part: Set σ_A = σ_B = σ_T = 0 to recover deterministic discrete system."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#comparison-with-continuous-stochastic",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#comparison-with-continuous-stochastic",
    "title": "",
    "section": "Comparison with Continuous Stochastic",
    "text": "Comparison with Continuous Stochastic\nContinuous Stochastic: - SDE: dX = f·dt + g·dW - Requires SDE integration - Theoretical foundation - Noise intensity in [state]/√[time]\nDiscrete Stochastic: - Difference equation: X[k+1] = f + w[k] - Direct evaluation (no integration) - Implementation ready - Noise variance in [state]²\nConversion: σ_discrete = σ_continuous·√Δt"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#discrete-kalman-filter-usage",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#discrete-kalman-filter-usage",
    "title": "",
    "section": "Discrete Kalman Filter Usage",
    "text": "Discrete Kalman Filter Usage\nThis system provides process model for EKF:\n# Process model\nX_pred = reactor.step(X_est, u[k])\nF = reactor.linearize(X_est, u[k])[0]  # Jacobian\nP_pred = F @ P @ F.T + Q\n\n# Measurement update (if measurement available)\ny_pred = h(X_pred)\nH = jacobian(h, X_pred)\nK = P_pred @ H.T @ inv(H @ P_pred @ H.T + R)\nX_est = X_pred + K @ (y[k] - y_pred)\nP = (I - K @ H) @ P_pred"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nEuler discretization: O(Δt) error\nAdditive noise only (not multiplicative)\nConstant noise variance (not state-dependent)\nIndependent noise (no correlation)\nWhite noise (no temporal correlation)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nHigher-order discretization (RK4)\nMultiplicative noise: w[k] depends on X[k]\nColored noise: w[k] correlated over time\nMeasurement delays: y[k] = h(X[k-d]) + v[k]\nTime-varying parameters: θ[k+1] = θ[k] + ε[k]"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nconvert_from_continuous_noise\nConvert continuous noise intensities to discrete.\n\n\ndefine_system\nDefine discrete-time stochastic batch reactor dynamics.\n\n\nestimate_discretization_error\nEstimate discretization error (Euler vs exact).\n\n\nget_process_noise_covariance\nGet process noise covariance matrix Σ_w.\n\n\nsetup_equilibria\nSet up equilibrium points (for deterministic part).\n\n\n\n\nconvert_from_continuous_noise\nsystems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.convert_from_continuous_noise(\n    sigma_A_continuous,\n    sigma_B_continuous,\n    sigma_T_continuous,\n)\nConvert continuous noise intensities to discrete.\nFor continuous noise σ_c [state/√s], discrete noise is: σ_d = σ_c·√dt\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma_A_continuous\nfloat\nContinuous noise intensity for C_A [mol/(L·√s)]\nrequired\n\n\nsigma_B_continuous\nfloat\nContinuous noise intensity for C_B [mol/(L·√s)]\nrequired\n\n\nsigma_T_continuous\nfloat\nContinuous noise intensity for T [K/√s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDiscrete noise parameters\n\n\n\n\n\nExamples\n&gt;&gt;&gt; reactor = DiscreteStochasticBatchReactor(dt=1.0)\n&gt;&gt;&gt; discrete_noise = reactor.convert_from_continuous_noise(\n...     sigma_A_continuous=0.01,\n...     sigma_B_continuous=0.01,\n...     sigma_T_continuous=1.0\n... )\n&gt;&gt;&gt; print(f\"Discrete σ_A: {discrete_noise['sigma_A']:.4f}\")\n&gt;&gt;&gt; print(f\"Discrete σ_T: {discrete_noise['sigma_T']:.4f}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.define_system(\n    k1_val=0.5,\n    k2_val=0.3,\n    E1_val=1000.0,\n    E2_val=1500.0,\n    alpha_val=0.1,\n    T_amb_val=300.0,\n    sigma_A=0.01,\n    sigma_B=0.01,\n    sigma_T=1.0,\n    dt=1.0,\n    discretization_method='euler',\n    C_A0=None,\n    T0=None,\n)\nDefine discrete-time stochastic batch reactor dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk1_val\nfloat\nPre-exponential factor for A→B reaction [1/s]\n0.5\n\n\nk2_val\nfloat\nPre-exponential factor for B→C reaction [1/s]\n0.3\n\n\nE1_val\nfloat\nActivation energy for reaction 1 [K]\n1000.0\n\n\nE2_val\nfloat\nActivation energy for reaction 2 [K]\n1500.0\n\n\nalpha_val\nfloat\nHeat transfer coefficient [1/s]\n0.1\n\n\nT_amb_val\nfloat\nAmbient temperature [K]\n300.0\n\n\nsigma_A\nfloat\nProcess noise std dev for C_A [mol/L per step] - For conversion from continuous: σ_d = σ_c·√dt - Typical: 0.001-0.1 mol/L\n0.01\n\n\nsigma_B\nfloat\nProcess noise std dev for C_B [mol/L per step]\n0.01\n\n\nsigma_T\nfloat\nProcess noise std dev for T [K per step] - For conversion from continuous: σ_d = σ_c·√dt - Typical: 0.1-5.0 K\n1.0\n\n\ndt\nfloat\nSampling period [s] - Typical: 0.1-10 s for batch reactors - Rule: dt &lt; τ_system/10 - Affects both dynamics and noise\n1.0\n\n\ndiscretization_method\nstr\nDiscretization method: - ‘euler’: Forward Euler (simple, first-order) - ‘rk4’: Runge-Kutta 4 (accurate, fourth-order)\n'euler'\n\n\nC_A0\nOptional[float]\nInitial conditions for equilibrium setup\nNone\n\n\nT0\nOptional[float]\nInitial conditions for equilibrium setup\nNone\n\n\n\n\n\nNotes\nDiscretization (Euler):\nContinuous: dx/dt = f(x, u) Discrete: x[k+1] = x[k] + f(x[k], u[k])·dt\nFor reactions: C_A[k+1] = C_A[k] - r₁·dt C_B[k+1] = C_B[k] + (r₁ - r₂)·dt T[k+1] = T[k] + (Q - α·(T - T_amb))·dt\nProcess Noise:\nAdditive Gaussian white noise: w[k] ~ N(0, Σ_w) Σ_w = diag(σ_A², σ_B², σ_T²)\nNoise Scaling:\nFrom continuous σ_c [state/√s]: σ_discrete = σ_c·√dt\nExample: σ_T_c = 1 K/√s, dt = 1 s → σ_T_d = 1·√1 = 1 K per step\nExample: σ_T_c = 1 K/√s, dt = 0.1 s → σ_T_d = 1·√0.1 ≈ 0.316 K per step\nSampling Period Selection:\nGuidelines: 1. Nyquist: dt &lt; 1/(2·f_max) 2. Control: dt &lt; τ_cl/10 (closed-loop time constant) 3. Reactor: dt &lt; τ_reaction/5\nFor typical batch reactor: - Fast control: dt = 0.1-0.5 s - Moderate: dt = 1.0-5.0 s - Slow: dt = 5.0-10.0 s\nDiscretization Method:\nEuler (default): - Simple, explicit - O(dt) accuracy - May need small dt for accuracy - Most common in industrial control\nRK4 (optional): - More accurate: O(dt⁴) - Can use larger dt - More computation per step - Better for simulation studies\nValidation:\nCheck discretization accuracy: 1. Compare with continuous simulation 2. Verify mass conservation (approximately) 3. Check final concentrations converge as dt → 0\n\n\n\nestimate_discretization_error\nsystems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.estimate_discretization_error(\n    x,\n    u,\n)\nEstimate discretization error (Euler vs exact).\nReturns approximate relative error in state update.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nCurrent state\nrequired\n\n\nu\nnp.ndarray\nControl input\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEstimated relative error (dimensionless)\n\n\n\n\n\nNotes\nEuler discretization has O(dt) error. Error estimate: ||f(x)||·dt²/||x||\nLarge error → Consider smaller dt or higher-order method.\n\n\nExamples\n&gt;&gt;&gt; reactor = DiscreteStochasticBatchReactor(dt=1.0)\n&gt;&gt;&gt; x = np.array([0.5, 0.3, 360.0])\n&gt;&gt;&gt; u = np.array([10.0])\n&gt;&gt;&gt; error = reactor.estimate_discretization_error(x, u)\n&gt;&gt;&gt; print(f\"Estimated error: {error:.2e}\")\n\n\n\nget_process_noise_covariance\nsystems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.get_process_noise_covariance(\n)\nGet process noise covariance matrix Σ_w.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\n3x3 diagonal covariance matrix\n\n\n\n\n\nNotes\nΣ_w = diag(σ_A², σ_B², σ_T²)\nDiagonal → independent noise sources.\n\n\nExamples\n&gt;&gt;&gt; reactor = DiscreteStochasticBatchReactor(\n...     sigma_A=0.01, sigma_B=0.01, sigma_T=1.0\n... )\n&gt;&gt;&gt; Q = reactor.get_process_noise_covariance()\n&gt;&gt;&gt; print(f\"Process noise covariance:\\n{Q}\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.discrete.DiscreteStochasticBatchReactor.setup_equilibria(\n)\nSet up equilibrium points (for deterministic part).\nNote: In discrete time, equilibria are fixed points of f: x_eq = f(x_eq, u_eq)"
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html",
    "href": "api/types.protocols.DiscreteSystemProtocol.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#implementations",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#implementations",
    "title": "",
    "section": "Implementations",
    "text": "Implementations\nConcrete classes that satisfy this protocol: - DiscreteSymbolicSystem: Symbolic discrete-time system - DiscreteStochasticSystem: Stochastic discrete-time system - DiscretizedSystem: Numerical discretization of continuous system - NeuralDiscreteSystem: Neural network dynamics (future) - DataDrivenDiscreteSystem: Learned from data (future)"
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#required-attributes",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#required-attributes",
    "title": "",
    "section": "Required Attributes",
    "text": "Required Attributes\ndt : float Sampling period in seconds nx : int Number of state variables nu : int Number of control inputs"
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#required-methods",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#required-methods",
    "title": "",
    "section": "Required Methods",
    "text": "Required Methods\nstep(x, u, k) -&gt; x_next Single time step update: x[k+1] = f(x[k], u[k]) simulate(x0, u_sequence, n_steps) -&gt; result Multi-step simulation"
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#use-cases",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#use-cases",
    "title": "",
    "section": "Use Cases",
    "text": "Use Cases\n\nMonte Carlo simulation\nTrajectory collection for learning\nRollout with exploration policies\nBasic dynamics analysis"
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#examples",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nFunction accepting any discrete system:\n&gt;&gt;&gt; def collect_trajectories(\n...     system: DiscreteSystemProtocol,\n...     n_trials: int = 100\n... ) -&gt; List[DiscreteSimulationResult]:\n...     '''Collect random trajectories from any discrete system.'''\n...     trajectories = []\n...     for _ in range(n_trials):\n...         x0 = np.random.randn(system.nx)\n...         u_seq = np.random.randn(100, system.nu)\n...         result = system.simulate(x0, u_seq, n_steps=100)\n...         trajectories.append(result)\n...     return trajectories\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Works with any discrete system:\n&gt;&gt;&gt; trajs1 = collect_trajectories(DiscreteSymbolicSystem(...))  # ✓\n&gt;&gt;&gt; trajs2 = collect_trajectories(DiscretizedSystem(...))       # ✓\nReinforcement learning rollout:\n&gt;&gt;&gt; def evaluate_policy(\n...     system: DiscreteSystemProtocol,\n...     policy: Callable,\n...     n_episodes: int\n... ) -&gt; float:\n...     '''Evaluate policy on system.'''\n...     total_reward = 0.0\n...     for _ in range(n_episodes):\n...         x = np.random.randn(system.nx)\n...         for k in range(100):\n...             u = policy(x, k)\n...             x = system.step(x, u, k)\n...             total_reward += reward_function(x, u)\n...     return total_reward / n_episodes\nType checking example:\n&gt;&gt;&gt; def bad_function(system: DiscreteSystemProtocol):\n...     system.linearize(...)  # ✗ mypy error: not in protocol!\n&gt;&gt;&gt;\n&gt;&gt;&gt; def good_function(system: LinearizableDiscreteProtocol):\n...     system.linearize(...)  # ✓ OK: protocol includes this"
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#notes",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nThe runtime_checkable? decorator allows isinstance() checks, but this should be used sparingly. Prefer static type checking at development time."
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#attributes",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ndt\nSampling period in seconds.\n\n\nnu\nNumber of control inputs.\n\n\nnx\nNumber of state variables."
  },
  {
    "objectID": "api/types.protocols.DiscreteSystemProtocol.html#methods",
    "href": "api/types.protocols.DiscreteSystemProtocol.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nsimulate\nSimulate system for multiple steps.\n\n\nstep\nCompute next state: x[k+1] = f(x[k], u[k]).\n\n\n\n\nsimulate\ntypes.protocols.DiscreteSystemProtocol.simulate(x0, u_sequence, n_steps)\nSimulate system for multiple steps.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_sequence\nDiscreteControlInput\nControl sequence (various formats supported)\nrequired\n\n\nn_steps\nint\nNumber of steps to simulate\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteSimulationResult\nTrajectory data including states, controls, time indices\n\n\n\n\n\n\nstep\ntypes.protocols.DiscreteSystemProtocol.step(x, u=None, k=0)\nCompute next state: x[k+1] = f(x[k], u[k]).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input (nu,), None for autonomous/zero control\nNone\n\n\nk\nint\nTime step index (for time-varying systems)\n0\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x[k+1]"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nOriginally meant to model electronic oscillator circuits. The system exhibits self-sustained oscillations.\nThe key feature is nonlinear damping: - Near origin: negative damping (pumps energy in) - Far from origin: positive damping (dissipates energy) - Result: stable limit cycle (periodic orbit)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [x, y] - x: Primary variable [V or dimensionless] * In electrical circuit: voltage or current * In general: oscillating quantity\n- y: Derivative-related variable [V/s or dimensionless]\n  * y ≈ ẋ for μ → 0\n  * Not exactly velocity for μ &gt; 0 (includes nonlinear term)\nControl: u = [u] - u: External forcing/input [V or dimensionless] - Can perturb the natural oscillation - Can be used for synchronization or frequency control\nOutput: y_out = [x] - Measures only x (the oscillating variable) - Partial observation (y not directly measured)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe Van der Pol equation in standard form:\nẋ = y\nẏ = μ(1 - x²)y - x + u\nOr as a second-order ODE: ẍ - μ(1 - x²)ẋ + x = u\nFirst equation: Simply defines y ≈ ẋ\nSecond equation: - μ(1 - x²)y: Nonlinear damping (Van der Pol term) * When |x| &lt; 1: (1 - x²) &gt; 0 → negative damping (adds energy) * When |x| &gt; 1: (1 - x²) &lt; 0 → positive damping (removes energy) * Balance creates stable limit cycle\n\n-x: Linear restoring force (like harmonic oscillator)\n\nProvides natural frequency ω₀ ≈ 1\n\nu: External forcing/control"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nmu : float, default=1.0 Nonlinearity parameter [dimensionless]. Controls strength of nonlinear damping and oscillation shape:\n- **μ → 0**: Nearly sinusoidal (harmonic oscillator)\n  * Period T ≈ 2π\n  * Smooth, sinusoidal limit cycle\n\n- **μ = 1**: Standard Van der Pol\n  * Period T ≈ 6.7\n  * Mildly distorted sinusoid\n\n- **μ &gt;&gt; 1**: Relaxation oscillations\n  * Period T ≈ (3 - 2ln(2))μ ≈ 1.614μ\n  * Sharp \"fast\" and \"slow\" phases\n  * Almost discontinuous (spikes and plateaus)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#behavior-regimes",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#behavior-regimes",
    "title": "",
    "section": "Behavior Regimes:",
    "text": "Behavior Regimes:\n1. Small μ (μ &lt; 0.1): Harmonic-like - Nearly sinusoidal oscillations - Frequency ≈ 1 rad/s - Smooth limit cycle - Weak nonlinearity\n2. Moderate μ (0.1 &lt; μ &lt; 3): Nonlinear oscillations - Visible waveform distortion - Frequency slightly reduced - Standard Van der Pol behavior\n3. Large μ (μ &gt; 3): Relaxation oscillations - Two-timescale dynamics - Fast jumps between slow plateaus - Very non-sinusoidal - Period proportional to μ"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#equilibrium",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#equilibrium",
    "title": "",
    "section": "Equilibrium:",
    "text": "Equilibrium:\nOrigin (unstable): x_eq = [0, 0] u_eq = 0\nFor u = 0, the origin is: - Unstable focus (spiral): trajectories spiral outward - All trajectories (except origin) approach the limit cycle - Eigenvalues: λ = μ/2 ± i√(4-μ²)/2 * Real part positive (unstable) * Imaginary part gives oscillation frequency"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#limit-cycle",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#limit-cycle",
    "title": "",
    "section": "Limit Cycle:",
    "text": "Limit Cycle:\nFor u = 0, the system has a unique stable limit cycle:\nProperties: - Globally attracting (except from origin) - Isolated (no nearby periodic orbits) - Amplitude ≈ 2 for all μ (approximately) - Period depends on μ: * μ → 0: T → 2π (harmonic) * μ = 1: T ≈ 6.7 * μ &gt;&gt; 1: T ≈ 1.614μ\nBasin of attraction: Entire plane except origin - Any non-zero initial condition → limit cycle - Time to converge depends on distance from cycle"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#relaxation-oscillations-μ-1",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#relaxation-oscillations-μ-1",
    "title": "",
    "section": "Relaxation Oscillations (μ >> 1):",
    "text": "Relaxation Oscillations (μ &gt;&gt; 1):\nFor large μ, the system exhibits relaxation oscillations:\nMechanism: 1. Slow phase: x grows slowly along stable manifold 2. Jump: At x ≈ 1, rapid transition (fast manifold) 3. Slow phase: x decreases slowly along stable manifold 4. Jump: At x ≈ -1, rapid transition back 5. Repeat\nCharacteristics: - Distinct timescales (ε = 1/μ is small parameter) - Almost piecewise linear trajectory - Useful model for on-off systems (heart beats, neurons)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.ControlledVanDerPolOscillator.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDuffingOscillator : Another nonlinear oscillator (can be chaotic) Lorenz : 3D system that exhibits chaos NonlinearChainSystem : Multiple coupled oscillators"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\na11\nfloat\nState matrix coefficients\nrequired\n\n\na12\nfloat\nState matrix coefficients\nrequired\n\n\na21\nfloat\nState matrix coefficients\nrequired\n\n\na22\nfloat\nState matrix coefficients\nrequired\n\n\nb1\nfloat\nControl gain coefficients\nrequired\n\n\nb2\nfloat\nControl gain coefficients\nrequired"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html#examples",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Stable spiral\n&gt;&gt;&gt; system = LinearSystem2D(\n...     a11=-1, a12=2, a21=-2, a22=-1, b1=1, b2=0\n... )\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(np.array([[-1, 2], [-2, -1]]))\n&gt;&gt;&gt; # λ = -1 ± 2j (stable spiral)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html#methods",
    "href": "api/systems.builtin.deterministic.continuous.LinearSystem2D.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine 2D linear dynamics.\n\n\n\n\ndefine_system\nsystems.builtin.deterministic.continuous.LinearSystem2D.define_system(\n    a11=-1.0,\n    a12=0.0,\n    a21=0.0,\n    a22=-1.0,\n    b1=1.0,\n    b2=0.0,\n)\nDefine 2D linear dynamics."
  },
  {
    "objectID": "api/types.control_advanced.HInfControlResult.html",
    "href": "api/types.control_advanced.HInfControlResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_advanced.HInfControlResult.html#fields",
    "href": "api/types.control_advanced.HInfControlResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ngain : GainMatrix H∞ controller gain K (nu, nx) hinf_norm : float Achieved H∞ norm ‖G‖∞ gamma : float Performance bound γ (hinf_norm ≤ γ) central_solution : CovarianceMatrix Central Riccati solution (nx, nx) feasible : bool Whether γ was achievable robustness_margin : float Stability margin (how much uncertainty tolerated)"
  },
  {
    "objectID": "api/types.control_advanced.HInfControlResult.html#examples",
    "href": "api/types.control_advanced.HInfControlResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Design H∞ controller with γ = 2.0\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; B = np.array([[0], [1]])\n&gt;&gt;&gt; C_z = np.eye(2)\n&gt;&gt;&gt; D_zu = np.zeros((2, 1))\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: HInfControlResult = design_hinf_controller(\n...     A, B, C_z, D_zu, gamma=2.0\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['feasible']:\n...     K = result['gain']\n...     print(f\"Achieved γ: {result['hinf_norm']:.3f}\")\n...     print(f\"Robustness margin: {result['robustness_margin']:.3f}\")\n... else:\n...     print(\"γ = 2.0 not achievable, try larger γ\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Verify worst-case performance\n&gt;&gt;&gt; # ‖G_cl‖∞ ≤ γ guarantees robustness to uncertainties"
  },
  {
    "objectID": "api/types.control_classical.LQGResult.html",
    "href": "api/types.control_classical.LQGResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.LQGResult.html#fields",
    "href": "api/types.control_classical.LQGResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ncontrol_gain : GainMatrix LQR feedback gain K (nu, nx) estimator_gain : GainMatrix Kalman gain L (nx, ny) control_cost_to_go : CovarianceMatrix Controller Riccati solution P_control estimation_error_covariance : CovarianceMatrix Estimator Riccati solution P_estimate separation_verified : bool Confirms separation principle holds closed_loop_stable : bool Combined controller-estimator system is stable controller_eigenvalues : np.ndarray Eigenvalues of (A - BK) - control loop estimator_eigenvalues : np.ndarray Eigenvalues of (A - LC) - estimation loop"
  },
  {
    "objectID": "api/types.control_classical.LQGResult.html#examples",
    "href": "api/types.control_classical.LQGResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # System matrices\n&gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.9]])\n&gt;&gt;&gt; B = np.array([[0], [0.1]])\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position only\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design weights\n&gt;&gt;&gt; Q_control = np.diag([10, 1])   # State cost\n&gt;&gt;&gt; R_control = np.array([[0.1]])  # Control cost\n&gt;&gt;&gt; Q_process = 0.01 * np.eye(2)   # Process noise\n&gt;&gt;&gt; R_meas = 0.1 * np.eye(1)       # Measurement noise\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: LQGResult = design_lqg(A, B, C, Q_control, R_control, Q_process, R_meas)\n&gt;&gt;&gt;\n&gt;&gt;&gt; K = result['control_gain']\n&gt;&gt;&gt; L = result['estimator_gain']\n&gt;&gt;&gt; print(result['closed_loop_stable'])  # True\n&gt;&gt;&gt; print(result['separation_verified'])  # True\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Implement LQG controller\n&gt;&gt;&gt; x_hat = np.zeros(2)  # Initial estimate\n&gt;&gt;&gt; for k in range(N):\n...     # Control (certainty equivalence)\n...     u[k] = -K @ x_hat\n...\n...     # Prediction\n...     x_hat = A @ x_hat + B @ u[k]\n...\n...     # Measurement update\n...     innovation = y[k] - C @ x_hat\n...     x_hat = x_hat + L @ innovation\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check eigenvalues\n&gt;&gt;&gt; print(\"Controller poles:\", result['controller_eigenvalues'])\n&gt;&gt;&gt; print(\"Estimator poles:\", result['estimator_eigenvalues'])"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_sde_method.html",
    "href": "api/systems.base.numerical_integration.is_sde_method.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_sde_method.html#parameters",
    "href": "api/systems.base.numerical_integration.is_sde_method.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\nIntegration method name (normalized or original)\nrequired"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_sde_method.html#returns",
    "href": "api/systems.base.numerical_integration.is_sde_method.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if method is for stochastic systems (SDE), False otherwise"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_sde_method.html#notes",
    "href": "api/systems.base.numerical_integration.is_sde_method.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nChecks against SDE_METHODS frozenset (union of fixed-step and adaptive)\nWorks with both canonical names (‘euler_maruyama’) and backend-specific names (‘EM’, ‘euler’, ‘Euler’)\nMethod name should ideally be normalized first, but works with any name in the SDE_METHODS set\nReturns False for deterministic methods (euler, rk4, RK45, etc.)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_sde_method.html#ambiguous-cases",
    "href": "api/systems.base.numerical_integration.is_sde_method.html#ambiguous-cases",
    "title": "",
    "section": "Ambiguous Cases",
    "text": "Ambiguous Cases\nSome method names appear in both deterministic and stochastic contexts:\n\n‘euler’: Both a deterministic method (Forward Euler) and SDE method (Euler-Maruyama for PyTorch/TorchSDE). In SDE_METHODS, so returns True.\n‘midpoint’: Similar ambiguity. Returns True (in SDE_METHODS).\n\nFor these cases, normalization to canonical names (‘euler_maruyama’ vs ‘rk4’) is recommended before calling this function."
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_sde_method.html#examples",
    "href": "api/systems.base.numerical_integration.is_sde_method.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Canonical SDE names\n&gt;&gt;&gt; is_sde_method('euler_maruyama')\nTrue\n&gt;&gt;&gt; is_sde_method('milstein')\nTrue\n&gt;&gt;&gt; # Backend-specific SDE names\n&gt;&gt;&gt; is_sde_method('EM')  # NumPy/Julia\nTrue\n&gt;&gt;&gt; is_sde_method('euler')  # PyTorch (ambiguous!)\nTrue\n&gt;&gt;&gt; is_sde_method('ItoMilstein')  # JAX\nTrue\n&gt;&gt;&gt; # Deterministic methods\n&gt;&gt;&gt; is_sde_method('rk4')\nFalse\n&gt;&gt;&gt; is_sde_method('RK45')\nFalse\n&gt;&gt;&gt; is_sde_method('dopri5')\nFalse\n&gt;&gt;&gt; # Unknown methods\n&gt;&gt;&gt; is_sde_method('my_custom_method')\nFalse"
  },
  {
    "objectID": "api/systems.base.numerical_integration.is_sde_method.html#see-also",
    "href": "api/systems.base.numerical_integration.is_sde_method.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nis_fixed_step : Classify method by time-stepping strategy normalize_method_name : Convert canonical names to backend-specific"
  },
  {
    "objectID": "api/types.core.ArrayLike.html",
    "href": "api/types.core.ArrayLike.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.ArrayLike.html#examples",
    "href": "api/types.core.ArrayLike.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; def process(data: ArrayLike) -&gt; ArrayLike:\n...     # Works with all backends\n...     return data * 2"
  },
  {
    "objectID": "api/types.backends.NoiseType.html",
    "href": "api/types.backends.NoiseType.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\ntypes.backends.NoiseType\ntypes.backends.NoiseType()\nNoise structure classification for stochastic systems.\nCategories: - ‘additive’: g(x,u,t) = constant (state-independent) * Most efficient - can precompute * Example: dx = f(x)dt + σ*dW\n\n‘multiplicative’: g(x,u,t) depends on state\nState-dependent noise intensity\nExample: dx = f(x)dt + σxdW (Geometric Brownian Motion)\n‘diagonal’: g(x,u,t) is diagonal matrix\nIndependent noise sources\nEnables element-wise solvers\n‘scalar’: Single noise source (nw=1)\nSimplest stochastic case\nOne Wiener process\n‘general’: Full coupling, no special structure\nMost general, least efficient"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA mobile robot with two independently driven wheels on a common axle, plus one or more passive casters for stability. Control is achieved by varying the velocities of the left and right wheels.\nThe robot configuration: - Two drive wheels separated by distance 2L (wheelbase) - Each wheel can be controlled independently - Robot body is rigid (no deformation) - Wheels roll without slipping (nonholonomic constraint) - Position (x, y) in global frame - Orientation θ (heading angle)\nNonholonomic Constraint: The key feature is the “rolling without slipping” constraint: The robot CANNOT move sideways (perpendicular to heading).\nMathematically: ẋ·sin(θ) - ẏ·cos(θ) = 0\nThis means the robot has only 2 velocity degrees of freedom (forward, turn) despite having 3 configuration variables (x, y, θ).\nKinematic Model: The robot velocity is determined by wheel velocities: v = (v_L + v_R) / 2 (forward velocity) ω = (v_R - v_L) / (2L) (angular velocity)\nWhere: v_L: Left wheel velocity [m/s] v_R: Right wheel velocity [m/s] L: Half of wheelbase [m]\nThe robot motion in global frame: ẋ = v·cos(θ) ẏ = v·sin(θ) θ̇ = ω\nDiscrete-Time Dynamics: Exact discretization (assuming constant wheel velocities): x[k+1] = x[k] + dt·v[k]·cos(θ[k]) y[k+1] = y[k] + dt·v[k]·sin(θ[k]) θ[k+1] = θ[k] + dt·ω[k]\nOr directly in terms of wheel velocities: x[k+1] = x[k] + dt·(v_L + v_R)/2·cos(θ[k]) y[k+1] = y[k] + dt·(v_L + v_R)/2·sin(θ[k]) θ[k+1] = θ[k] + dt·(v_R - v_L)/(2L)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] = [x[k], y[k], θ[k]] Position coordinates (global frame): - x: Position along world x-axis [m] * Unbounded: -∞ &lt; x &lt; ∞ * Typically confined to workspace * Can be arbitrarily large\n- y: Position along world y-axis [m]\n  * Unbounded: -∞ &lt; y &lt; ∞\n  * Typically confined to workspace\n  * Can be arbitrarily large\n\nHeading angle:\n- θ: Orientation/heading angle [rad]\n  * θ = 0: Facing along +x axis (East)\n  * θ = π/2: Facing along +y axis (North)\n  * θ = π: Facing along -x axis (West)\n  * θ = 3π/2 or -π/2: Facing along -y axis (South)\n  * Periodic: θ and θ + 2π are equivalent\n  * Can be wrapped to [-π, π] or [0, 2π]\nControl: u[k] = [v_L[k], v_R[k]] Wheel velocities (independent control): - v_L: Left wheel velocity [m/s] * v_L &gt; 0: Left wheel forward * v_L &lt; 0: Left wheel backward * Bounded: |v_L| ≤ v_max\n- v_R: Right wheel velocity [m/s]\n  * v_R &gt; 0: Right wheel forward\n  * v_R &lt; 0: Right wheel backward\n  * Bounded: |v_R| ≤ v_max\nControl Modes (derived from v_L, v_R):\n\nStraight line (v_L = v_R = v):\n\nRobot moves forward/backward\nNo turning\nFastest point-to-point if aligned\n\nPure rotation (v_L = -v_R):\n\nRobot spins in place\nNo translation\nUsed for reorientation\n\nArc motion (v_L ≠ v_R):\n\nRobot follows circular arc\nRadius: R = L·(v_L + v_R)/(v_R - v_L)\nMost general motion\n\nStop (v_L = v_R = 0):\n\nRobot stationary\nMaintain position\n\n\nOutput: y[k] = [x[k], y[k], θ[k]] - Full state measurement (typical for indoor robots) - x, y from wheel odometry or external localization - θ from IMU/gyroscope or magnetometer - In practice: odometry has drift, requires sensor fusion"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#dynamics-kinematic-model",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#dynamics-kinematic-model",
    "title": "",
    "section": "Dynamics (Kinematic Model):",
    "text": "Dynamics (Kinematic Model):\nThe discrete dynamics are:\nx[k+1] = x[k] + dt·(v_L[k] + v_R[k])/2·cos(θ[k])\ny[k+1] = y[k] + dt·(v_L[k] + v_R[k])/2·sin(θ[k])\nθ[k+1] = θ[k] + dt·(v_R[k] - v_L[k])/(2L)\nAlternative Control Parametrization: Can also use (v, ω) as control: v = (v_L + v_R) / 2 (linear velocity) ω = (v_R - v_L) / (2L) (angular velocity)\nThen: x[k+1] = x[k] + dt·v[k]·cos(θ[k]) y[k+1] = y[k] + dt·v[k]·sin(θ[k]) θ[k+1] = θ[k] + dt·ω[k]\nThis is the unicycle model - mathematically equivalent.\nMotion Primitives:\nForward: v_L = v_R = v_desired Result: Straight line in current heading direction\nBackward: v_L = v_R = -v_desired Result: Straight line backward\nTurn in place (left): v_L = -v_turn, v_R = +v_turn Result: Counterclockwise rotation about center\nTurn in place (right): v_L = +v_turn, v_R = -v_turn Result: Clockwise rotation about center\nArc (general): v_L ≠ v_R Result: Circular arc with radius R"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nL : float, default=0.5 Half-width of wheelbase [m] - Distance from center to each wheel - Total wheelbase = 2L - Typical values: 0.1-0.5 m - Larger L → larger turning radius - Affects maneuverability\ndt : float, default=0.1 Sampling period [s] - Control update rate - Sensor measurement period - Typical: 0.01-0.1 s (10-100 Hz) - Affects trajectory smoothness\nmax_wheel_velocity : Optional[float] Maximum wheel velocity [m/s] - Physical motor speed limit - Typical: 0.5-5.0 m/s - Affects reachable velocities\ncontrol_mode : str, default=‘wheel_velocities’ Control input type: - ‘wheel_velocities’: u = [v_L, v_R] - ‘unicycle’: u = [v, ω] (linear and angular velocity)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nNo traditional equilibria exist!\nUnlike typical dynamical systems, the differential drive robot has NO equilibrium points in the usual sense: - Every state (x, y, θ) with v_L = v_R = 0 is an “equilibrium” - These form a 3D manifold (entire configuration space) - The robot can stop at any position and orientation\nThis is characteristic of kinematic systems without restoring forces.\nConfiguration Space: The set of all possible poses: SE(2) = ℝ² × S¹ - ℝ²: Position (x, y) - S¹: Orientation θ (circle)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#controllability-nonholonomic",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#controllability-nonholonomic",
    "title": "",
    "section": "Controllability (Nonholonomic):",
    "text": "Controllability (Nonholonomic):\nControllability vs Nonholonomic Constraints:\nThe differential drive robot is: - Controllable: Can reach any configuration (x, y, θ) from any other - Nonholonomic: Cannot move in all directions instantaneously\nThis seems contradictory but isn’t: - Can reach any point, but must follow curved path - Cannot drive sideways or diagonally - Requires sequences of forward/turn motions\nChow’s Theorem (Controllability of Nonholonomic Systems): The system is controllable if Lie brackets of control vector fields span the tangent space. For differential drive:\nVector fields: f₁ = [cos(θ), sin(θ), 0]ᵀ (forward motion) f₂ = [0, 0, 1]ᵀ (pure rotation)\nLie bracket: [f₁, f₂] = [sin(θ), -cos(θ), 0]ᵀ (sideways motion!)\nThis shows sideways motion achievable via sequences, proving controllability.\nMinimum Maneuvers: To reach any (x_f, y_f, θ_f) from (x₀, y₀, θ₀): - At most 3 motion primitives needed (Dubins paths) - Types: CSC (Curve-Straight-Curve), CCC (Curve-Curve-Curve) - Minimum turning radius: R_min = v_max·L/v_max = L\nReeds-Shepp Paths (with reverse): If backward motion allowed, even more efficient paths exist."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#observability",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#observability",
    "title": "",
    "section": "Observability:",
    "text": "Observability:\nFull state measurement: Trivially observable - directly measure (x, y, θ).\nPartial observations: - GPS only: (x, y) measured, θ must be estimated - Compass only: θ measured, position must be integrated - Wheel odometry: Integrate wheel velocities (drift over time)\nSensor Fusion: In practice, combine multiple sensors: - Wheel encoders (dead reckoning) - IMU (gyroscope for θ̇, accelerometer for validation) - GPS/external localization (absolute position) - Kalman filter or particle filter for fusion"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\n1. Point-to-Point Navigation: Goal: Move from (x₀, y₀, θ₀) to (x_f, y_f, θ_f) Methods: - Feedback linearization (near goal) - Pure pursuit (follow carrot point) - Potential field methods - Sampling-based planning (RRT)\n2. Trajectory Tracking: Goal: Follow reference path (x_ref(t), y_ref(t), θ_ref(t)) Control laws: - Kinematic controller (backstepping) - Input-output linearization - Model predictive control (MPC) Applications: Warehouse navigation, assembly lines\n3. Path Following: Goal: Converge to and follow geometric path - Less strict than tracking (no time parametrization) - Pure pursuit, Stanley controller, LOS guidance - Applications: Lane following, contour tracking\n4. Formation Control: Goal: Maintain relative positions with other robots - Leader-follower, virtual structure, behavioral - Applications: Multi-robot coordination, swarms\n5. Obstacle Avoidance: Goal: Reach target while avoiding obstacles - Dynamic window approach (DWA) - Velocity obstacles - Artificial potential fields"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\n1. Workspace Boundaries: (x, y) ∈ Workspace ⊂ ℝ² - Room boundaries, allowed regions - Avoid obstacles, walls, hazards\n2. Velocity Limits: |v_L|, |v_R| ≤ v_max - Motor speed limitations - Typical: v_max = 0.5-2.0 m/s\n3. Acceleration Limits: |v_L[k+1] - v_L[k]|/dt ≤ a_max |v_R[k+1] - v_R[k]|/dt ≤ a_max - Motor acceleration capacity - Prevents wheel slip - Typical: a_max = 1-5 m/s²\n4. Curvature/Turning Radius: |ω/v| ≤ 1/R_min - Minimum turning radius: R_min - Depends on wheelbase and velocity limits - R_min = L·v_max/v_max = L (at maximum speeds)\n5. Nonholonomic Constraint: Velocity perpendicular to heading = 0 - Cannot move sideways - Must follow curved paths - Restricts instantaneous motion"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\nAngle Wrapping: Heading angle θ should be wrapped to [-π, π]: θ_wrapped = atan2(sin(θ), cos(θ))\nPrevents numerical overflow and simplifies control.\nOdometry Drift: Integrating wheel velocities accumulates errors: - Wheel slip (especially on turns) - Uneven surfaces - Wheelbase calibration errors - Typical drift: 5-10% of distance traveled\nPrevention: Use external localization (GPS, SLAM, markers).\nSingularities: - No kinematic singularities (well-defined everywhere) - Control singularity at v = 0 for some controllers - Planning singularity for backward motion (if not allowed)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate differential drive robot\nrobot = DifferentialDriveRobot( … L=0.15, # 30cm wheelbase … dt=0.1, # 10 Hz control … max_wheel_velocity=1.0 … )\nInitial pose: origin, facing East\nx0 = np.array([0.0, 0.0, 0.0]) # [x, y, θ]\nDrive straight forward\nv_forward = 0.5 # 0.5 m/s u_forward = np.array([v_forward, v_forward])\nresult_straight = robot.simulate( … x0=x0, … u_sequence=u_forward, # Constant velocity … n_steps=50 … )\nprint(f”Final position: ({result_straight[‘states’][-1, 0]:.2f}, ” … f”{result_straight[‘states’][-1, 1]:.2f})“) # Should be approximately (2.5, 0) after 5 seconds at 0.5 m/s\nTurn in place (spin)\nomega_spin = 1.0 # 1 rad/s v_L_spin = -omega_spin * robot.L v_R_spin = +omega_spin * robot.L u_spin = np.array([v_L_spin, v_R_spin])\nresult_spin = robot.simulate( … x0=x0, … u_sequence=u_spin, … n_steps=31 # π/ω seconds ≈ 3.14s )\nprint(f”Final heading: {result_spin[‘states’][-1, 2]:.2f} rad”) # Should be approximately π (180° turn)\nCircular arc motion\nv_circle = 0.5 # m/s omega_circle = 0.5 # rad/s radius = v_circle / omega_circle print(f”Circle radius: {radius:.2f} m”)\nv_L_circle = v_circle - omega_circle * robot.L v_R_circle = v_circle + omega_circle * robot.L u_circle = np.array([v_L_circle, v_R_circle])\nresult_circle = robot.simulate( … x0=x0, … u_sequence=u_circle, … n_steps=100 … )\nPlot trajectory\nimport plotly.graph_objects as go fig = go.Figure() fig.add_trace(go.Scatter( … x=result_circle[‘states’][:, 0], … y=result_circle[‘states’][:, 1], … mode=‘lines+markers’, … name=‘Robot path’, … marker=dict(size=3) … ))\nAdd orientation arrows\nfor i in range(0, len(result_circle[‘states’]), 10): … x_i, y_i, theta_i = result_circle[‘states’][i] … dx = 0.1 * np.cos(theta_i) … dy = 0.1 * np.sin(theta_i) … fig.add_annotation( … x=x_i, y=y_i, … ax=x_i + dx, ay=y_i + dy, … xref=‘x’, yref=‘y’, … axref=‘x’, ayref=‘y’, … showarrow=True, … arrowhead=2, … arrowsize=1, … arrowwidth=2, … arrowcolor=‘red’ … )\nfig.update_layout( … title=‘Differential Drive Robot Trajectory’, … xaxis_title=‘x [m]’, … yaxis_title=‘y [m]’, … yaxis_scaleanchor=‘x’, … width=800, … height=800 … ) fig.show()\nPoint-to-point controller\ndef goto_controller(x, k): … # Current pose … x_curr, y_curr, theta_curr = x … … # Target … x_target, y_target, theta_target = 5.0, 3.0, np.pi/4 … … # Distance and angle to target … dx = x_target - x_curr … dy = y_target - y_curr … distance = np.sqrt(dx2 + dy2) … angle_to_target = np.arctan2(dy, dx) … … # Heading error … theta_error = angle_to_target - theta_curr … # Wrap to [-π, π] … theta_error = np.arctan2(np.sin(theta_error), np.cos(theta_error)) … … # If far from target, move toward it … if distance &gt; 0.1: … # Proportional control … v = min(0.5, 2.0 * distance) # Slow down near target … omega = 3.0 * theta_error # Turn to face target … else: … # Near target, just adjust orientation … v = 0.0 … final_theta_error = theta_target - theta_curr … final_theta_error = np.arctan2(np.sin(final_theta_error), … np.cos(final_theta_error)) … omega = 2.0 * final_theta_error … … # Convert to wheel velocities … v_L = v - omega * robot.L … v_R = v + omega * robot.L … … return np.array([v_L, v_R])\nresult_goto = robot.rollout( … x0=np.array([0.0, 0.0, 0.0]), … policy=goto_controller, … n_steps=200 … )\nVisualize with goal\nfig_goto = robot.plot_trajectory_with_robot(result_goto) fig_goto.add_trace(go.Scatter( … x=[5.0], y=[3.0], … mode=‘markers’, … marker=dict(size=20, color=‘red’, symbol=‘star’), … name=‘Goal’ … )) fig_goto.show()\ndef path_following_controller(x, k): … # Current pose … x_curr, y_curr, theta_curr = x … … # Current time … t = k * robot.dt … … # Desired position on path … x_des, y_des = lemniscate_path(0.5 * t) … … # Lookahead point (pure pursuit) … lookahead = 0.3 # meters … t_lookahead = t + lookahead / 0.5 … x_look, y_look = lemniscate_path(0.5 * t_lookahead) … … # Control toward lookahead … dx = x_look - x_curr … dy = y_look - y_curr … distance = np.sqrt(dx2 + dy2) … angle_to_lookahead = np.arctan2(dy, dx) … … theta_error = angle_to_lookahead - theta_curr … theta_error = np.arctan2(np.sin(theta_error), np.cos(theta_error)) … … # Pure pursuit control … v = 0.5 # Constant forward velocity … omega = 2.0 * v * np.sin(theta_error) / lookahead … … v_L = v - omega * robot.L … v_R = v + omega * robot.L … … return np.array([v_L, v_R])\nresult_path = robot.rollout( … x0=np.array([0.0, 0.0, 0.0]), … policy=path_following_controller, … n_steps=800 … )\nPlot path following\nt_plot = np.linspace(0, 40, 1000) x_path, y_path = lemniscate_path(0.5 * t_plot)\nfig_path = go.Figure() fig_path.add_trace(go.Scatter( … x=x_path, y=y_path, … mode=‘lines’, … line=dict(dash=‘dash’, color=‘gray’, width=2), … name=‘Desired path’ … )) fig_path.add_trace(go.Scatter( … x=result_path[‘states’][:, 0], … y=result_path[‘states’][:, 1], … mode=‘lines’, … line=dict(color=‘blue’, width=2), … name=‘Actual path’ … )) fig_path.update_layout( … title=‘Figure-8 Path Following’, … xaxis_title=‘x [m]’, … yaxis_title=‘y [m]’, … yaxis_scaleanchor=‘x’ … ) fig_path.show()"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nNonholonomic Constraints Explained: A car cannot move sideways because wheels enforce “rolling without slipping”. This is a velocity constraint (not a position constraint): - Instantaneous motion restricted - But can reach any configuration via maneuvers - Like parallel parking: can’t move sideways, but can reach any spot\nDifferential Drive Advantages: - Simple mechanical design (two motors) - Can turn in place (zero turning radius) - Good maneuverability in tight spaces - Easy to control (decoupled v and ω)\nDifferential Drive Disadvantages: - Cannot move sideways (nonholonomic) - Sensitive to wheel diameter differences - Odometry drift from wheel slip - Poor traction on uneven terrain\nKinematic vs Dynamic Models: This is a KINEMATIC model (velocities → positions).\nDynamic model would include: - Motor dynamics (voltage → wheel velocity) - Friction forces - Inertia effects - Slip dynamics\nKinematic model assumes: - Instantaneous velocity changes (infinite acceleration) - Perfect velocity tracking by motors - No slip, no dynamics\nValid when: - Velocities change slowly (quasi-static) - Motor control bandwidth &gt;&gt; motion bandwidth - Low speeds (slip negligible)\nDubins Paths (Shortest Paths): For car-like robots (forward only, bounded curvature), shortest paths between poses are combinations of: - L: Left turn (maximum curvature) - R: Right turn (maximum curvature) - S: Straight line\nSix types: LSL, LSR, RSL, RSR, RLR, LRL\nReeds-Shepp Paths (with reverse): If backward motion allowed, 48 possible path types! Often shorter than Dubins paths."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n\nForgetting nonholonomic constraint: Cannot use methods for holonomic systems Cannot command arbitrary (ẋ, ẏ, θ̇)\nDirect position control: Cannot directly control x, y independently Must go through velocity → position\nLinearization limitations: System is NOT feedback linearizable everywhere Linearization fails at v = 0\nOdometry as ground truth: Wheel odometry drifts significantly Always validate with external sensors\nIgnoring wheel velocity limits: Commanded v_L, v_R may exceed limits Must saturate or use MPC with constraints\nBackward motion confusion: Some controllers assume forward-only Backward motion requires sign handling"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#extensions",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#extensions",
    "title": "",
    "section": "Extensions:",
    "text": "Extensions:\n\nCar-like (Ackermann steering): Front wheels steer, rear wheels drive Different kinematics, cannot turn in place\nOmnidirectional (mecanum/swerve): Can move in any direction instantly Holonomic (no constraint)\nDynamic model: Include motor dynamics, slip, inertia Second-order system\nSkid-steering: Four or six wheels, intentional slip More complex dynamics\nTracked vehicle: Tank-like, continuous contact Slip modeling essential\nMulti-robot system: Fleet coordination, formation control"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DifferentialDriveRobot.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_instantaneous_radius\nCompute instantaneous radius of curvature.\n\n\ncompute_minimum_turning_radius\nCompute minimum turning radius.\n\n\nconvert_unicycle_to_wheel\nConvert unicycle controls (v, ω) to wheel velocities (v_L, v_R).\n\n\nconvert_wheel_to_unicycle\nConvert wheel velocities (v_L, v_R) to unicycle controls (v, ω).\n\n\ndefine_system\nDefine discrete-time differential drive robot kinematics.\n\n\nsetup_equilibria\nSet up reference configurations.\n\n\n\n\ncompute_instantaneous_radius\nsystems.builtin.deterministic.discrete.DifferentialDriveRobot.compute_instantaneous_radius(\n    v_L,\n    v_R,\n)\nCompute instantaneous radius of curvature.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv_L\nfloat\nLeft wheel velocity [m/s]\nrequired\n\n\nv_R\nfloat\nRight wheel velocity [m/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat or None\nRadius of curvature [m], None if straight line\n\n\n\n\n\nNotes\nR = L·(v_L + v_R)/(v_R - v_L)\nSpecial cases: - v_L = v_R: R = ∞ (straight line) - v_L = -v_R: R = 0 (turn in place)\n\n\nExamples\n&gt;&gt;&gt; robot = DifferentialDriveRobot(L=0.2)\n&gt;&gt;&gt; R = robot.compute_instantaneous_radius(v_L=0.8, v_R=1.2)\n&gt;&gt;&gt; print(f\"Turning radius: {R:.2f} m\")\n\n\n\ncompute_minimum_turning_radius\nsystems.builtin.deterministic.discrete.DifferentialDriveRobot.compute_minimum_turning_radius(\n    v_max=None,\n)\nCompute minimum turning radius.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv_max\nOptional[float]\nMaximum wheel velocity (default: use stored value)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nMinimum radius [m]\n\n\n\n\n\nNotes\nMinimum radius when one wheel at +v_max, other at -v_max: R_min = L·(v_max - (-v_max))/(v_max - (-v_max)) = L\nActually, for differential drive: R_min → 0 (can spin in place!) But at max forward speed: R_min = L·v_max/v_max = L\n\n\nExamples\n&gt;&gt;&gt; robot = DifferentialDriveRobot(L=0.2)\n&gt;&gt;&gt; R_min = robot.compute_minimum_turning_radius(v_max=1.0)\n&gt;&gt;&gt; print(f\"Min turning radius at full speed: {R_min:.2f} m\")\n\n\n\nconvert_unicycle_to_wheel\nsystems.builtin.deterministic.discrete.DifferentialDriveRobot.convert_unicycle_to_wheel(\n    v,\n    omega,\n)\nConvert unicycle controls (v, ω) to wheel velocities (v_L, v_R).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv\nfloat\nLinear velocity [m/s]\nrequired\n\n\nomega\nfloat\nAngular velocity [rad/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(v_L, v_R) wheel velocities [m/s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; robot = DifferentialDriveRobot(L=0.2)\n&gt;&gt;&gt; v_L, v_R = robot.convert_unicycle_to_wheel(v=1.0, omega=0.5)\n&gt;&gt;&gt; print(f\"Left: {v_L:.2f}, Right: {v_R:.2f}\")\n\n\n\nconvert_wheel_to_unicycle\nsystems.builtin.deterministic.discrete.DifferentialDriveRobot.convert_wheel_to_unicycle(\n    v_L,\n    v_R,\n)\nConvert wheel velocities (v_L, v_R) to unicycle controls (v, ω).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nv_L\nfloat\nLeft wheel velocity [m/s]\nrequired\n\n\nv_R\nfloat\nRight wheel velocity [m/s]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(v, ω) linear and angular velocities\n\n\n\n\n\nExamples\n&gt;&gt;&gt; robot = DifferentialDriveRobot(L=0.2)\n&gt;&gt;&gt; v, omega = robot.convert_wheel_to_unicycle(v_L=0.8, v_R=1.2)\n&gt;&gt;&gt; print(f\"Linear: {v:.2f} m/s, Angular: {omega:.2f} rad/s\")\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DifferentialDriveRobot.define_system(\n    L=0.5,\n    dt=0.1,\n    method='euler',\n    max_wheel_velocity=None,\n    control_mode='wheel_velocities',\n)\nDefine discrete-time differential drive robot kinematics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nL\nfloat\nHalf of wheelbase [m] (distance from center to wheel)\n0.5\n\n\ndt\nfloat\nSampling period [s]\n0.1\n\n\nmax_wheel_velocity\nOptional[float]\nMaximum wheel velocity [m/s]\nNone\n\n\ncontrol_mode\nstr\n‘wheel_velocities’ or ‘unicycle’\n'wheel_velocities'\n\n\n\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DifferentialDriveRobot.setup_equilibria()\nSet up reference configurations.\nNote: No true equilibria exist (can stop anywhere)."
  },
  {
    "objectID": "api/types.core.DiffusionMatrix.html",
    "href": "api/types.core.DiffusionMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.DiffusionMatrix.html#examples",
    "href": "api/types.core.DiffusionMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Continuous SDE\n&gt;&gt;&gt; Gc: DiffusionMatrix = np.array([[0.1], [0.2]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Discrete (Euler-Maruyama)\n&gt;&gt;&gt; Gd: DiffusionMatrix = np.sqrt(dt) * Gc\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Additive noise (constant)\n&gt;&gt;&gt; G_additive: DiffusionMatrix = 0.1 * np.eye(nx)"
  },
  {
    "objectID": "api/types.backends.DiscretizerConfig.html",
    "href": "api/types.backends.DiscretizerConfig.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.DiscretizerConfig.html#attributes",
    "href": "api/types.backends.DiscretizerConfig.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndt\nfloat\nTime step (sampling period)\n\n\nmethod\nDiscretizationMethod\nDiscretization algorithm\n\n\nbackend\nBackend\nBackend for discrete system\n\n\norder\nint\nApproximation order (for taylor-based methods)\n\n\npreserve_stability\nbool\nWhether to preserve continuous-time stability"
  },
  {
    "objectID": "api/types.backends.DiscretizerConfig.html#examples",
    "href": "api/types.backends.DiscretizerConfig.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Standard configuration\n&gt;&gt;&gt; config: DiscretizerConfig = {\n...     'dt': 0.01,\n...     'method': 'exact',\n...     'backend': 'numpy'\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Digital control design\n&gt;&gt;&gt; config_control: DiscretizerConfig = {\n...     'dt': 0.01,\n...     'method': 'zoh',\n...     'preserve_stability': True\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Fast simulation\n&gt;&gt;&gt; config_fast: DiscretizerConfig = {\n...     'dt': 0.001,\n...     'method': 'euler',\n...     'backend': 'torch'\n... }"
  },
  {
    "objectID": "api/types.backends.IntegratorConfig.html",
    "href": "api/types.backends.IntegratorConfig.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.IntegratorConfig.html#attributes",
    "href": "api/types.backends.IntegratorConfig.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nmethod\nIntegrationMethod\nIntegration algorithm\n\n\nrtol\nfloat\nRelative tolerance\n\n\natol\nfloat\nAbsolute tolerance\n\n\nmax_step\nfloat\nMaximum allowed time step\n\n\nfirst_step\nOptional[float]\nInitial step size (adaptive methods)\n\n\nvectorized\nbool\nWhether dynamics function is vectorized\n\n\ndense_output\nbool\nCompute dense output (for interpolation)"
  },
  {
    "objectID": "api/types.backends.IntegratorConfig.html#examples",
    "href": "api/types.backends.IntegratorConfig.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Standard configuration\n&gt;&gt;&gt; config: IntegratorConfig = {\n...     'method': 'RK45',\n...     'rtol': 1e-6,\n...     'atol': 1e-9,\n...     'max_step': 0.1\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # High accuracy configuration\n&gt;&gt;&gt; config_accurate: IntegratorConfig = {\n...     'method': 'DOP853',\n...     'rtol': 1e-10,\n...     'atol': 1e-12,\n...     'dense_output': True\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stiff system configuration\n&gt;&gt;&gt; config_stiff: IntegratorConfig = {\n...     'method': 'Radau',\n...     'rtol': 1e-6,\n...     'atol': 1e-8,\n... }"
  },
  {
    "objectID": "api/types.control_classical.ControllabilityInfo.html",
    "href": "api/types.control_classical.ControllabilityInfo.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.ControllabilityInfo.html#fields",
    "href": "api/types.control_classical.ControllabilityInfo.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ncontrollability_matrix : ControllabilityMatrix C = [B, AB, A²B, …, Aⁿ⁻¹B] of shape (nx, nx*nu) rank : int Rank of controllability matrix is_controllable : bool True if rank == nx (full rank) uncontrollable_modes : Optional[np.ndarray] Eigenvalues of uncontrollable subsystem (if any)"
  },
  {
    "objectID": "api/types.control_classical.ControllabilityInfo.html#examples",
    "href": "api/types.control_classical.ControllabilityInfo.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; B = np.array([[0], [1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; info: ControllabilityInfo = analyze_controllability(A, B)\n&gt;&gt;&gt; print(info['is_controllable'])  # True\n&gt;&gt;&gt; print(info['rank'])  # 2\n&gt;&gt;&gt; print(info['controllability_matrix'].shape)  # (2, 2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Uncontrollable system\n&gt;&gt;&gt; B_bad = np.array([[1], [1]])  # Both states affected equally\n&gt;&gt;&gt; A_diag = np.array([[1, 0], [0, 2]])\n&gt;&gt;&gt; info: ControllabilityInfo = analyze_controllability(A_diag, B_bad)\n&gt;&gt;&gt; print(info['is_controllable'])  # False\n&gt;&gt;&gt; print(info['uncontrollable_modes'])  # Some eigenvalues"
  },
  {
    "objectID": "api/systems.base.core.DiscretizedSystem.html",
    "href": "api/systems.base.core.DiscretizedSystem.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.DiscretizedSystem.html#protocol-satisfaction",
    "href": "api/systems.base.core.DiscretizedSystem.html#protocol-satisfaction",
    "title": "",
    "section": "Protocol Satisfaction",
    "text": "Protocol Satisfaction\nThis class satisfies: - DiscreteSystemProtocol: Has step(), simulate(), dt, nx, nu - LinearizableDiscreteProtocol: Has linearize() (wraps continuous)\nDoes NOT satisfy: - SymbolicDiscreteProtocol: No symbolic machinery (purely numerical)\nThis means it can be used in: - ✓ Any function expecting DiscreteSystemProtocol - ✓ Control design (LQR, MPC) expecting LinearizableDiscreteProtocol - ✗ Code generation expecting SymbolicDiscreteProtocol"
  },
  {
    "objectID": "api/systems.base.core.DiscretizedSystem.html#examples",
    "href": "api/systems.base.core.DiscretizedSystem.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; from controldesymulation.types.protocols import LinearizableDiscreteProtocol\n&gt;&gt;&gt;\n&gt;&gt;&gt; def lqr_design(system: LinearizableDiscreteProtocol, Q, R):\n...     Ad, Bd = system.linearize(np.zeros(system.nx), np.zeros(system.nu))\n...     # ... LQR computation\n&gt;&gt;&gt;\n&gt;&gt;&gt; # DiscretizedSystem works here:\n&gt;&gt;&gt; continuous = Pendulum(m=1.0, l=0.5)\n&gt;&gt;&gt; discrete = DiscretizedSystem(continuous, dt=0.01)\n&gt;&gt;&gt; K = lqr_design(discrete, Q, R)  # ✓ Type checks pass!"
  },
  {
    "objectID": "api/systems.base.core.DiscretizedSystem.html#methods",
    "href": "api/systems.base.core.DiscretizedSystem.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nchange_method\nCreate new DiscretizedSystem with different method.\n\n\nget_available_methods\nGet available integration methods for a backend.\n\n\nget_info\nGet comprehensive discretization information and configuration.\n\n\nprint_info\nPrint formatted discretization information.\n\n\nsimulate_stochastic\nSimulate stochastic system with multiple Monte Carlo trajectories.\n\n\n\n\nchange_method\nsystems.base.core.DiscretizedSystem.change_method(new_method, **new_kwargs)\nCreate new DiscretizedSystem with different method.\n\n\nget_available_methods\nsystems.base.core.DiscretizedSystem.get_available_methods(\n    backend='numpy',\n    method_type='all',\n)\nGet available integration methods for a backend.\nDelegates to method_registry.get_available_methods() for the canonical source of truth about method availability.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nBackend to query: ‘numpy’, ‘torch’, or ‘jax’\n'numpy'\n\n\nmethod_type\nstr\nFilter by method type: - ‘all’: All methods (default) - ‘deterministic’: Only ODE methods - ‘stochastic’: Only SDE methods - ‘fixed_step’: Only fixed-step methods (both ODE and SDE) - ‘adaptive’: Only adaptive methods (both ODE and SDE)\n'all'\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with method categories and their available methods\n\n\n\n\n\nExamples\n&gt;&gt;&gt; methods = DiscretizedSystem.get_available_methods('torch', 'stochastic')\n&gt;&gt;&gt; print(methods['sde_fixed_step'])\n['euler', 'milstein', 'srk', 'midpoint']\n&gt;&gt;&gt; print(methods['canonical_aliases'])\n['euler_maruyama', 'milstein', 'sra1', 'reversible_heun', 'rk45', ...]\n\n\nSee Also\nmethod_registry.get_available_methods : Implementation details\n\n\n\nget_info\nsystems.base.core.DiscretizedSystem.get_info()\nGet comprehensive discretization information and configuration.\n\n\nprint_info\nsystems.base.core.DiscretizedSystem.print_info()\nPrint formatted discretization information.\n\n\nsimulate_stochastic\nsystems.base.core.DiscretizedSystem.simulate_stochastic(\n    x0,\n    u_sequence=None,\n    n_steps=100,\n    n_trajectories=100,\n    **kwargs,\n)\nSimulate stochastic system with multiple Monte Carlo trajectories."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nThe double integrator models the simplest mechanical system: a point mass that can be directly controlled by force or acceleration. It represents the discretized continuous-time system:\nd²p/dt² = u  (continuous time)\nwhere p is position and u is acceleration (force/mass). The discrete-time approximation depends on the discretization method:\nZero-Order Hold (ZOH) - Exact Discretization: Assumes control input is held constant between samples, leading to: p[k+1] = p[k] + dt·v[k] + 0.5·dt²·u[k] v[k+1] = v[k] + dt·u[k]\nThis is the EXACT solution to the continuous system with piecewise-constant control, making it the preferred discretization for control design.\nForward Euler - First-Order Approximation: Simple but less accurate: p[k+1] = p[k] + dt·v[k] v[k+1] = v[k] + dt·u[k]\nBackward Euler - Implicit Method: More stable but requires solving implicit equation: p[k+1] = p[k] + dt·v[k+1] v[k+1] = v[k] + dt·u[k]\nTustin/Trapezoidal - Second-Order Accurate: Bilinear transform, preserves frequency response: p[k+1] = p[k] + dt·(v[k] + v[k+1])/2 v[k+1] = v[k] + dt·u[k]\nThis class uses ZOH by default as it’s exact and most common in control."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] = [p[k], v[k]] Position state: - p: Position [m] (or [rad] for rotational systems) * Can be unbounded: -∞ &lt; p &lt; ∞ * Typically constrained in practice: p_min ≤ p ≤ p_max * Examples: cart position, joint angle, satellite position\nVelocity state:\n- v: Velocity [m/s] (or [rad/s] for rotational)\n  * Can be unbounded: -∞ &lt; v &lt; ∞\n  * Typically constrained: v_min ≤ v ≤ v_max (actuator limits)\n  * Examples: cart speed, joint angular velocity, satellite velocity\nControl: u[k] = [a[k]] - a: Acceleration [m/s²] (or angular acceleration [rad/s²]) * Proportional to applied force: a = F/m * Bounded by actuator capacity: a_min ≤ a ≤ a_max * Typical range: -10 to +10 m/s² for mechanical systems * For satellite: ±0.01 rad/s² (small thrusters) * For robot joint: ±100 rad/s² (powerful servos)\nOutput: y[k] = [p[k]] or [p[k], v[k]] - Position-only measurement (most common): y[k] = p[k] Examples: encoder, GPS, camera - Full state measurement: y[k] = [p[k], v[k]] Examples: encoder + tachometer, IMU"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#dynamics-zero-order-hold",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#dynamics-zero-order-hold",
    "title": "",
    "section": "Dynamics (Zero-Order Hold):",
    "text": "Dynamics (Zero-Order Hold):\nThe ZOH discretization gives EXACT discrete-time dynamics:\np[k+1] = p[k] + dt·v[k] + 0.5·dt²·u[k]\nv[k+1] = v[k] + dt·u[k]\nMatrix Form: x[k+1] = Ad·x[k] + Bd·u[k]\nwhere: Ad = [1 dt ] (State transition matrix) [0 1 ]\nBd = [0.5·dt²]    (Control input matrix)\n     [  dt   ]\nPhysical Interpretation:\nPosition update: - Current position: p[k] - Displacement due to velocity: dt·v[k] (drift term) - Displacement due to acceleration: 0.5·dt²·u[k] (control term) - New position: p[k+1]\nThe 0.5·dt² factor comes from integration: ∫₀^dt ∫₀^τ u dσ dτ = 0.5·dt²·u\nVelocity update: - Current velocity: v[k] - Change due to acceleration: dt·u[k] - New velocity: v[k+1]\nLinearity: The double integrator is LINEAR - superposition applies: f(αx₁ + βx₂, αu₁ + βu₂) = αf(x₁, u₁) + βf(x₂, u₂)\nThis makes it ideal for: - Linear control design (LQR, pole placement) - Analytical stability analysis - Frequency domain analysis - Teaching/learning control theory"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\ndt : float, default=0.1 Sampling/discretization time step [s] Critical parameter affecting: - System dynamics approximation accuracy - Control bandwidth and performance - Computational requirements - Stability margins\nGuidelines:\n- Nyquist: dt &lt; π/ω_max (sample faster than fastest frequency)\n- Shannon: dt &lt; 1/(2·f_bandwidth)\n- Rule of thumb: 10-20 samples per desired closed-loop rise time\n- Typical values: 0.001-0.1 s for mechanical systems\nmethod : str, default=‘zoh’ Discretization method: - ‘zoh’: Zero-order hold (exact, recommended) - ‘euler’: Forward Euler (simple, less accurate) - ‘backward_euler’: Implicit (more stable) - ‘tustin’: Trapezoidal/bilinear (frequency-preserving)\nmass : float, default=1.0 Mass of the system [kg] Only used if control is force (not acceleration) Affects control authority: a = F/m Typical: 0.1-1000 kg depending on application\nuse_force_input : bool, default=False If True, control input is force F [N] instead of acceleration Dynamics become: x[k+1] = Ad·x[k] + Bd·(u[k]/m) Useful for systems where force is the natural actuator variable"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nOrigin (zero position, zero velocity): x_eq = [0, 0] u_eq = 0\nThis is a MARGINALLY STABLE equilibrium: - Not asymptotically stable (doesn’t return to origin naturally) - Any initial displacement persists forever (constant velocity) - Requires feedback control for stabilization\nEigenvalue Analysis: The system matrix Ad has eigenvalues: λ₁ = 1, λ₂ = 1\nBoth eigenvalues are on the unit circle (|λ| = 1), confirming marginal stability. - |λ| &lt; 1 would be stable (decays to zero) - |λ| &gt; 1 would be unstable (grows unbounded) - |λ| = 1 means neutral stability (persists)\nAny constant velocity is an equilibrium: x_eq = [p, v] for any p, v u_eq = 0\nThese form a family of equilibria parameterized by v*. The system naturally preserves any velocity when no control is applied (Newton’s first law)."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#controllability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#controllability",
    "title": "",
    "section": "Controllability:",
    "text": "Controllability:\nThe discrete double integrator is COMPLETELY CONTROLLABLE from any state to any other state in finite time.\nControllability Matrix: C = [Bd, Ad·Bd] = [0.5·dt² 0.5·dt³] [ dt dt² ]\nControllability Test: rank(C) = 2 = nx ✓ Fully controllable\nPhysical Meaning: - Can reach ANY position and velocity from ANY initial condition - Requires at most 2 time steps with unbounded control - With bounded control |u| ≤ u_max, requires more time - Minimum time to reach (p_target, 0) from (0, 0): t_min = √(2·|p_target|/u_max)\nBang-Bang Control: Time-optimal control is bang-bang (maximum effort switching once): 1. Apply u = +u_max until midpoint 2. Switch to u = -u_max to brake 3. Arrive at target with v = 0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#observability",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#observability",
    "title": "",
    "section": "Observability:",
    "text": "Observability:\nPosition-only measurement: y[k] = p[k] C = [1 0]\nObservability matrix:\nO = [C   ] = [1   0 ]\n    [C·Ad]   [1   dt]\n\nrank(O) = 2 = nx  ✓ Fully observable\nCan reconstruct full state (position AND velocity) from position measurements over time. Velocity is estimated from position differences.\nFull state measurement: y[k] = [p[k], v[k]] C = [1 0] [0 1]\nTrivially observable - direct measurement of all states."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\nCommon control goals for double integrator:\n\nRegulation: Drive to origin Goal: x → [0, 0] LQR optimal control: u[k] = -K·x[k] K = [k_p, k_d] (PD-like gains)\nClosed-loop dynamics: x[k+1] = (Ad - Bd·K)·x[k]\nDesign K to place eigenvalues inside unit circle.\nTracking: Follow reference trajectory Goal: x[k] → x_ref[k] Control law: u[k] = -K·(x[k] - x_ref[k]) + u_ff[k]\nFeedforward term: u_ff[k] = (x_ref[k+1] - Ad·x_ref[k]) / Bd\nPoint-to-point motion: (0,0) → (p_target, 0) Goal: Move to target position with zero final velocity Minimum-time control: bang-bang Minimum-energy control: sinusoidal profile\nSetpoint stabilization: p → p_target Goal: Regulate position while allowing nonzero velocity Requires integral action or feedforward: u[k] = -K·[p[k]-p_target, v[k]] + u_ss\nVelocity regulation: v → v_target Goal: Maintain constant velocity (cruise control) Simple proportional control: u[k] = k_v·(v_target - v[k])"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\nPhysical constraints that must be enforced:\n\nPosition limits: p_min ≤ p[k] ≤ p_max\n\nPhysical workspace boundaries\nTrack length, joint angle limits\nMust be respected by controller\nModel Predictive Control (MPC) handles naturally\n\nVelocity limits: v_min ≤ v[k] ≤ v_max\n\nActuator/motor speed limits\nSafety considerations\nEnergy/power constraints\nTypical: |v| ≤ 10 m/s for cart, |v| ≤ 100 rad/s for motor\n\nAcceleration limits: a_min ≤ u[k] ≤ a_max\n\nActuator force/torque saturation\nMost critical practical constraint\nCauses nonlinearity (saturation)\nAnti-windup required for integral control\nTypical: |u| ≤ 10 m/s² for cart, |u| ≤ 100 rad/s² for servo\n\nJerk limits: |u[k+1] - u[k]|/dt ≤ jerk_max (advanced)\n\nSmoothness requirement\nReduces mechanical wear\nPassenger comfort (elevators, vehicles)\nRequires higher-order planning"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\nStability: The ZOH discretization is EXACT - no numerical stability issues regardless of dt (assuming arithmetic precision).\nFor other methods: - Euler: Stable for any dt (system is already stable) - Backward Euler: Always stable (A-stable method) - Tustin: Stable for any dt\nAccuracy: - ZOH: Exact for piecewise-constant control - Euler: O(dt) error (first-order) - Tustin: O(dt²) error (second-order)\nFor control design, ZOH is preferred because: - Matches real digital control (sample-and-hold) - Preserves controllability exactly - No approximation error in discrete control law\nConditioning: For very small dt, the controllability matrix becomes ill-conditioned: cond(C) ≈ O(1/dt²)\nThis is rarely a problem in practice since dt is typically 0.001-0.1 s.\nComputation: State update is trivial - just 2 additions and 3 multiplications per step. This makes it ideal for real-time control on embedded systems."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#control-design-examples",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#control-design-examples",
    "title": "",
    "section": "Control Design Examples:",
    "text": "Control Design Examples:\n1. Pole Placement (Deadbeat Control - Fastest Response): Place both eigenvalues at origin → reaches target in 2 steps\nDesired characteristic equation: z² = 0\nControl law: u[k] = -K·x[k]\nGain: K = [1/dt², 2/dt]\n\nFor dt = 0.1: K = [100, 20]\n\nWarning: Requires very large control effort!\n2. LQR (Optimal Quadratic Cost): Minimize: J = Σ (x’·Q·x + u’·R·u)\nChoose Q, R to balance:\n- Q large: Fast response, aggressive control\n- R large: Smooth control, slower response\n\nExample: Q = diag([10, 1]), R = 1\nResult: K ≈ [3.2, 2.6] for dt = 0.1\n\nThis gives good compromise between speed and control effort.\n3. PD-Like Control (Intuitive): u[k] = -k_p·p[k] - k_d·v[k]\n- k_p: Position gain (stiffness)\n- k_d: Velocity gain (damping)\n\nDesign rules:\n- Larger k_p → faster position correction\n- Larger k_d → more damping (less overshoot)\n- Critical damping: k_d = 2·√k_p\n- Under-damped: k_d &lt; 2·√k_p (oscillatory)\n- Over-damped: k_d &gt; 2·√k_p (sluggish)\n4. Model Predictive Control (MPC): Solve optimization at each step: min_{u[k:k+N]} Σ (‖x[i]-x_ref[i]‖² + R‖u[i]‖²) subject to: x[i+1] = Ad·x[i] + Bd·u[i] x_min ≤ x[i] ≤ x_max u_min ≤ u[i] ≤ u_max\nAdvantages:\n- Handles constraints explicitly\n- Optimal preview control\n- Can incorporate feedforward\n\nDisadvantage: Requires online optimization (computational cost)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate double integrator with 10 Hz sampling (dt=0.1s)\nsystem = DiscreteDoubleIntegrator(dt=0.1)\nInitial condition: 1m displaced, at rest\nx0 = np.array([1.0, 0.0]) # [position, velocity]\nOpen-loop simulation (no control)\nresult = system.simulate( … x0=x0, … u_sequence=np.zeros(100), # No control … n_steps=100 … ) # Result: constant position at p=1.0 (neutral stability)\nDesign LQR controller for regulation\nAd, Bd = system.linearize(np.zeros(2), np.zeros(1)) Q = np.diag([10.0, 1.0]) # Care more about position R = np.array([[1.0]]) lqr_result = system.control.design_lqr( … Ad, Bd, Q, R, system_type=‘discrete’ … ) K = lqr_result[‘gain’] print(f”LQR gain: K = {K}“)\nClosed-loop eigenvalues (should be inside unit circle)\neigenvalues = lqr_result[‘closed_loop_eigenvalues’] print(f”Closed-loop eigenvalues: {eigenvalues}“) print(f”Stable: {np.all(np.abs(eigenvalues) &lt; 1)}“)\nSimulate with LQR control\ndef lqr_controller(x, k): … return -K @ x\nresult_lqr = system.rollout(x0, lqr_controller, n_steps=100)\nPlot results\nimport matplotlib.pyplot as plt fig, axes = plt.subplots(3, 1, figsize=(10, 8))\nPosition\naxes[0].plot(result_lqr[‘time_steps’] * system.dt, … result_lqr[‘states’][:, 0]) axes[0].set_ylabel(‘Position [m]’) axes[0].axhline(0, color=‘r’, linestyle=‘–’, label=‘Target’) axes[0].legend() axes[0].grid()\nVelocity\naxes[1].plot(result_lqr[‘time_steps’] * system.dt, … result_lqr[‘states’][:, 1]) axes[1].set_ylabel(‘Velocity [m/s]’) axes[1].axhline(0, color=‘r’, linestyle=‘–’) axes[1].grid()\nControl effort\naxes[2].plot(result_lqr[‘time_steps’][:-1] * system.dt, … result_lqr[‘controls’]) axes[2].set_ylabel(‘Acceleration [m/s²]’) axes[2].set_xlabel(‘Time [s]’) axes[2].grid()\nplt.tight_layout() plt.show()\nPoint-to-point motion with MPC\nfrom scipy.optimize import minimize\ndef mpc_controller(x, k): … ’‘’Simple MPC with horizon N=10’’’ … N = 10 # Prediction horizon … p_target = 2.0 # Target position … u_max = 5.0 # Acceleration limit … … def cost(u_seq): … x_pred = x.copy() … total_cost = 0.0 … for i in range(N): … u_i = u_seq[i] … # State update … x_pred = Ad @ x_pred + Bd * u_i … # Stage cost … error = x_pred[0] - p_target … total_cost += 10error2 + x_pred[1]2 + 0.1u_i**2 … return total_cost … … # Optimize … u_init = np.zeros(N) … bounds = [(-u_max, u_max)] * N … result = minimize(cost, u_init, bounds=bounds, method=‘SLSQP’) … … return result.x[0] # Return first control action\nresult_mpc = system.rollout(x0, mpc_controller, n_steps=50)\nCheck trajectory constraints\nprint(f”Max velocity: {np.max(np.abs(result_mpc[‘states’][:, 1])):.2f} m/s”) print(f”Max acceleration: {np.max(np.abs(result_mpc[‘controls’])):.2f} m/s²”) print(f”Final position error: {result_mpc[‘states’][-1, 0] - 2.0:.4f} m”)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nNewton’s First Law: The double integrator embodies inertia - objects in motion stay in motion unless acted upon by a force (control). This is why it’s marginally stable: any velocity persists forever without control.\nMinimum-Time Control: To move from (0, 0) to (p_target, 0) in minimum time with |u| ≤ u_max:\n\nAccelerate at u_max for time t₁\nDecelerate at -u_max for time t₂\nArrive at target with v = 0\n\nSolution: t₁ = t₂ = √(|p_target|/u_max) Total time: t_total = 2·√(|p_target|/u_max)\nThis creates a parabolic position profile (constant acceleration).\nEnergy Considerations: Kinetic energy: E_k = 0.5·m·v² Control energy: E_c = ∫ u² dt\nLQR with R &gt; 0 trades off reaching target quickly (minimize E_k) versus using less control effort (minimize E_c).\nFrequency Response: For continuous system (ω = frequency): H(s) = 1/s² → |H(jω)| = 1/ω² (-40 dB/decade)\nThis is a double integrator in frequency domain: - Integrates input twice to get output - Phase lag: -180° (always lags by half cycle) - Very sensitive to low frequencies (drift) - Requires feedback for stability\nDiscrete Frequency Response: For discrete system: H(z) = Bd / (z - 1)²\nResonance at z = 1 (ω = 0) - infinite DC gain without feedback.\nRelationship to Other Systems: - Cart on frictionless track - Satellite position (1D) - Inverted pendulum (linearized about upright) - Mass-spring system (with k = 0, b = 0) - Robot joint (simplified, no gravity or friction)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n\nForgetting the 0.5 factor: p[k+1] = p[k] + dt·v[k] + 0.5·dt²·u[k] ✓ NOT: p[k+1] = p[k] + dt·v[k] + dt²·u[k] ✗\nIgnoring actuator saturation: Real actuators saturate! Linear control assumes unlimited u. Use anti-windup or MPC for constrained control.\nToo small dt for available computation: Faster sampling requires faster computation. Ensure control law executes within dt.\nForgetting neutral stability: Without control, ANY velocity persists forever. Always close the loop for practical systems.\nNot handling measurement noise: Real position sensors have noise. Use Kalman filter to estimate velocity from noisy position."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#extensions",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#extensions",
    "title": "",
    "section": "Extensions:",
    "text": "Extensions:\nThis basic double integrator can be extended to:\n\nDamped double integrator: Add friction/drag term: v[k+1] = v[k] + dt·(u[k] - b·v[k]) Now asymptotically stable even without control\nMass-spring-damper: Add spring force: p[k+1] includes -k·p[k] term Creates oscillatory dynamics\nMulti-dimensional: 3D motion: x[k] = [p_x, v_x, p_y, v_y, p_z, v_z] Each axis is independent double integrator\nCoupled system: Multiple masses connected by springs Creates higher-order system\nWith disturbances: Add process noise: x[k+1] = Ad·x[k] + Bd·u[k] + w[k] Requires stochastic control (LQG)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nContinuousDoubleIntegrator : Continuous-time version DiscreteOscillator : With spring force added DiscreteDampedIntegrator : With friction InvertedPendulum : Nonlinear extension (with sin(θ))"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_controllability_matrix\nCompute controllability matrix C = [Bd, Ad·Bd].\n\n\ncompute_minimum_time\nCompute minimum time to reach target position from origin with bounded control.\n\n\ncompute_observability_matrix\nCompute observability matrix O = [C; C·Ad].\n\n\ncompute_system_matrices\nCompute discrete-time state-space matrices Ad, Bd.\n\n\ndefine_system\nDefine discrete-time double integrator dynamics.\n\n\ndesign_deadbeat_controller\nDesign deadbeat controller (fastest possible response).\n\n\ndesign_pd_controller\nDesign PD (proportional-derivative) controller.\n\n\ngenerate_minimum_energy_control\nGenerate minimum-energy control sequence for given time.\n\n\ngenerate_minimum_time_control\nGenerate minimum-time control sequence (bang-bang).\n\n\nsetup_equilibria\nSet up equilibrium points.\n\n\n\n\ncompute_controllability_matrix\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.compute_controllability_matrix(\n)\nCompute controllability matrix C = [Bd, Ad·Bd].\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nControllability matrix (2×2)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; C = system.compute_controllability_matrix()\n&gt;&gt;&gt; rank = np.linalg.matrix_rank(C)\n&gt;&gt;&gt; print(f\"Controllability matrix rank: {rank}\")\n&gt;&gt;&gt; print(f\"System is controllable: {rank == 2}\")\n\n\nNotes\nThe double integrator is always completely controllable. rank(C) = 2 for any dt &gt; 0.\n\n\n\ncompute_minimum_time\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.compute_minimum_time(\n    p_target,\n    u_max,\n)\nCompute minimum time to reach target position from origin with bounded control.\nFor bang-bang control: |u| ≤ u_max\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np_target\nfloat\nTarget position [m]\nrequired\n\n\nu_max\nfloat\nMaximum acceleration [m/s²]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nMinimum time [s]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; t_min = system.compute_minimum_time(p_target=10.0, u_max=2.0)\n&gt;&gt;&gt; print(f\"Minimum time to reach 10m with 2 m/s² limit: {t_min:.2f} s\")\n\n\nNotes\nMinimum-time trajectory is bang-bang: 1. Accelerate at u_max until midpoint 2. Decelerate at -u_max until target 3. Arrive with v = 0\nTime to reach target: t_min = 2·√(|p_target|/u_max)\nThis assumes starting from rest: (p, v) = (0, 0) → (p_target, 0)\n\n\n\ncompute_observability_matrix\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.compute_observability_matrix(\n    C_output=None,\n)\nCompute observability matrix O = [C; C·Ad].\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_output\nOptional[np.ndarray]\nOutput matrix (1×2 or 2×2) If None, uses position-only measurement: C = [1, 0]\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nObservability matrix\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; # Position-only measurement\n&gt;&gt;&gt; O = system.compute_observability_matrix()\n&gt;&gt;&gt; rank = np.linalg.matrix_rank(O)\n&gt;&gt;&gt; print(f\"Observable: {rank == 2}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Full state measurement\n&gt;&gt;&gt; C_full = np.eye(2)\n&gt;&gt;&gt; O_full = system.compute_observability_matrix(C_full)\n\n\nNotes\nFor position-only measurement C = [1, 0]: O = [1 0 ] [1 dt ]\nrank(O) = 2 → fully observable (can estimate velocity from position)\n\n\n\ncompute_system_matrices\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.compute_system_matrices(\n)\nCompute discrete-time state-space matrices Ad, Bd.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(Ad, Bd) where: - Ad: State transition matrix (2×2) - Bd: Control input matrix (2×1)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; Ad, Bd = system.compute_system_matrices()\n&gt;&gt;&gt; print(f\"Ad =\\n{Ad}\")\n&gt;&gt;&gt; print(f\"Bd =\\n{Bd}\")\n\n\nNotes\nFor ZOH discretization: Ad = [1 dt] [0 1 ]\nBd = [0.5*dt²]\n     [  dt   ]\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.define_system(\n    dt=0.1,\n    method='zoh',\n    mass=1.0,\n    use_force_input=False,\n)\nDefine discrete-time double integrator dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndt\nfloat\nSampling time step [s]\n0.1\n\n\nmethod\nstr\nDiscretization method: - ‘zoh’: Zero-order hold (exact, recommended) - ‘euler’: Forward Euler (simple) - ‘backward_euler’: Backward Euler (implicit) - ‘tustin’: Trapezoidal/bilinear transform\n'zoh'\n\n\nmass\nfloat\nSystem mass [kg] (only used if use_force_input=True)\n1.0\n\n\nuse_force_input\nbool\nIf True, control input is force [N] instead of acceleration [m/s²]\nFalse\n\n\n\n\n\n\ndesign_deadbeat_controller\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.design_deadbeat_controller(\n)\nDesign deadbeat controller (fastest possible response).\nPlaces both closed-loop eigenvalues at origin, giving finite-time settling in 2 steps.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nDeadbeat control gain K (1×2)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; K_db = system.design_deadbeat_controller()\n&gt;&gt;&gt; print(f\"Deadbeat gain: K = {K_db}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simulate\n&gt;&gt;&gt; def deadbeat_control(x, k):\n...     return -K_db @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; x0 = np.array([1.0, 0.0])\n&gt;&gt;&gt; result = system.rollout(x0, deadbeat_control, n_steps=10)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check settling time\n&gt;&gt;&gt; settling_idx = np.where(np.abs(result['states'][:, 0]) &lt; 0.01)[0]\n&gt;&gt;&gt; print(f\"Settled in {settling_idx[0]} steps\")\n\n\nNotes\nDeadbeat control gives fastest response but requires VERY large control effort. The gain magnitude scales as 1/dt², so smaller time steps require exponentially larger control.\nFor dt = 0.1: K ≈ [100, 20] For dt = 0.01: K ≈ [10000, 200]\nUse with caution in systems with actuator limits!\n\n\n\ndesign_pd_controller\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.design_pd_controller(\n    k_p,\n    k_d=None,\n    damping_ratio=1.0,\n)\nDesign PD (proportional-derivative) controller.\nControl law: u[k] = -k_p·p[k] - k_d·v[k]\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk_p\nfloat\nPosition gain (stiffness) Larger k_p → faster position response\nrequired\n\n\nk_d\nOptional[float]\nVelocity gain (damping) If None, computed from damping_ratio\nNone\n\n\ndamping_ratio\nfloat\nDesired damping ratio (only used if k_d is None) - ζ = 1.0: Critical damping (no overshoot) - ζ &lt; 1.0: Under-damped (oscillatory) - ζ &gt; 1.0: Over-damped (sluggish)\n1.0\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nPD gain matrix K = [k_p, k_d]\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Critical damping (no overshoot)\n&gt;&gt;&gt; K_critical = system.design_pd_controller(k_p=10.0, damping_ratio=1.0)\n&gt;&gt;&gt; print(f\"Critical damping: K = {K_critical}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Under-damped (faster but oscillatory)\n&gt;&gt;&gt; K_underdamped = system.design_pd_controller(k_p=10.0, damping_ratio=0.5)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Over-damped (slow but smooth)\n&gt;&gt;&gt; K_overdamped = system.design_pd_controller(k_p=10.0, damping_ratio=2.0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Manual k_d specification\n&gt;&gt;&gt; K_manual = system.design_pd_controller(k_p=10.0, k_d=5.0)\n\n\nNotes\nThe relationship between continuous and discrete PD gains: Continuous: k_d = 2·ζ·√k_p (for ζ = 1: k_d = 2√k_p) Discrete: Similar but depends on dt\nFor discrete double integrator, the closed-loop poles are: z = 1 - k_p·dt²/2 ± √((k_p·dt²/2)² - k_d·dt·k_p·dt²/2)\n\n\n\ngenerate_minimum_energy_control\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.generate_minimum_energy_control(\n    p_target,\n    t_final,\n    n_steps,\n)\nGenerate minimum-energy control sequence for given time.\nMinimizes ∫ u² dt subject to reaching target at t_final.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np_target\nfloat\nTarget position [m]\nrequired\n\n\nt_final\nfloat\nFinal time [s]\nrequired\n\n\nn_steps\nint\nNumber of discrete steps\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nControl sequence (n_steps,)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; u_seq = system.generate_minimum_energy_control(\n...     p_target=10.0,\n...     t_final=10.0,\n...     n_steps=100\n... )\n\n\nNotes\nFor double integrator, minimum-energy control is sinusoidal: u(t) = A·sin(πt/t_final)\nwhere A is chosen to reach p_target at t_final.\n\n\n\ngenerate_minimum_time_control\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.generate_minimum_time_control(\n    p_target,\n    u_max,\n    n_steps,\n)\nGenerate minimum-time control sequence (bang-bang).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\np_target\nfloat\nTarget position [m]\nrequired\n\n\nu_max\nfloat\nMaximum acceleration [m/s²]\nrequired\n\n\nn_steps\nint\nNumber of discrete time steps\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nControl sequence (n_steps,)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = DiscreteDoubleIntegrator(dt=0.1)\n&gt;&gt;&gt; u_seq = system.generate_minimum_time_control(\n...     p_target=10.0,\n...     u_max=2.0,\n...     n_steps=100\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simulate with bang-bang control\n&gt;&gt;&gt; result = system.simulate(\n...     x0=np.zeros(2),\n...     u_sequence=u_seq,\n...     n_steps=100\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"Final position: {result['states'][-1, 0]:.2f} m\")\n&gt;&gt;&gt; print(f\"Final velocity: {result['states'][-1, 1]:.2f} m/s\")\n\n\nNotes\nThe switching time occurs at the midpoint: t_switch = √(|p_target|/u_max)\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscreteDoubleIntegrator.setup_equilibria(\n)\nSet up equilibrium points.\nAdds the origin (zero position, zero velocity) as default equilibrium. Note: ANY constant velocity is technically an equilibrium with u=0, but we only add the origin for simplicity."
  },
  {
    "objectID": "api/types.trajectories.TimePoints.html",
    "href": "api/types.trajectories.TimePoints.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.TimePoints.html#examples",
    "href": "api/types.trajectories.TimePoints.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Regular time grid\n&gt;&gt;&gt; t: TimePoints = np.linspace(0, 10, 101)\n&gt;&gt;&gt; dt = t[1] - t[0]\n&gt;&gt;&gt; print(f\"dt = {dt:.3f}\")  # 0.100\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Irregular time grid\n&gt;&gt;&gt; t: TimePoints = np.array([0, 0.1, 0.15, 0.5, 1.0, 2.0, 5.0, 10.0])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Logarithmic spacing (for stiff systems)\n&gt;&gt;&gt; t: TimePoints = np.logspace(-3, 1, 100)  # 0.001 to 10\n&gt;&gt;&gt; \n&gt;&gt;&gt; # From simulation result\n&gt;&gt;&gt; result: IntegrationResult = integrator.solve(x0, u, t_span)\n&gt;&gt;&gt; t: TimePoints = result['t']\n&gt;&gt;&gt; trajectory: StateTrajectory = result['y']\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Discrete-time steps (as floats)\n&gt;&gt;&gt; k = np.arange(0, 100)\n&gt;&gt;&gt; t: TimePoints = k * dt  # Convert to continuous time"
  },
  {
    "objectID": "api/control.SystemAnalysis.html",
    "href": "api/control.SystemAnalysis.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.SystemAnalysis.html#attributes",
    "href": "api/control.SystemAnalysis.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nbackend\nBackend\nComputational backend (‘numpy’, ‘torch’, ‘jax’)"
  },
  {
    "objectID": "api/control.SystemAnalysis.html#examples",
    "href": "api/control.SystemAnalysis.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Via system composition (typical usage)\n&gt;&gt;&gt; system = Pendulum()\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check stability\n&gt;&gt;&gt; stability = system.analysis.stability(A, system_type='continuous')\n&gt;&gt;&gt; if stability['is_stable']:\n...     print(f\"Stable with eigenvalues: {stability['eigenvalues']}\")\n...     print(f\"Stability margin: {stability['stability_margin']:.3f}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check controllability\n&gt;&gt;&gt; ctrl_info = system.analysis.controllability(A, B)\n&gt;&gt;&gt; if not ctrl_info['is_controllable']:\n...     print(\"Warning: System is not fully controllable\")\n...     print(f\"Controllable subspace dimension: {ctrl_info['rank']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check observability\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure first state only\n&gt;&gt;&gt; obs_info = system.analysis.observability(A, C)\n&gt;&gt;&gt; if obs_info['is_observable']:\n...     print(\"Full state can be estimated from measurements\")"
  },
  {
    "objectID": "api/control.SystemAnalysis.html#notes",
    "href": "api/control.SystemAnalysis.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nThis is a thin wrapper - all algorithms are in classical.py. The wrapper only provides: 1. Backend consistency with parent system 2. Clean composition interface 3. Convenience for system integration"
  },
  {
    "objectID": "api/control.SystemAnalysis.html#methods",
    "href": "api/control.SystemAnalysis.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nanalyze_linearization\nComprehensive analysis of linearized system.\n\n\ncontrollability\nTest controllability of linear system (A, B).\n\n\nobservability\nTest observability of linear system (A, C).\n\n\nstability\nAnalyze system stability via eigenvalue analysis.\n\n\n\n\nanalyze_linearization\ncontrol.SystemAnalysis.analyze_linearization(A, B, C, system_type='continuous')\nComprehensive analysis of linearized system.\nConvenience method that runs stability, controllability, and observability analysis in one call.\nArgs: A: State matrix (nx, nx) B: Input matrix (nx, nu) C: Output matrix (ny, nx) system_type: ‘continuous’ or ‘discrete’\nReturns: Dictionary containing: - stability: StabilityInfo - controllability: ControllabilityInfo - observability: ObservabilityInfo - summary: Dict with combined assessment\n\nExamples\n&gt;&gt;&gt; # Complete analysis of linearized system\n&gt;&gt;&gt; system = Pendulum()\n&gt;&gt;&gt; x_eq = np.array([np.pi, 0])  # Upright\n&gt;&gt;&gt; u_eq = np.zeros(1)\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position\n&gt;&gt;&gt;\n&gt;&gt;&gt; analysis = system.analysis.analyze_linearization(\n...     A, B, C,\n...     system_type='continuous'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check results\n&gt;&gt;&gt; print(f\"Stable: {analysis['stability']['is_stable']}\")\n&gt;&gt;&gt; print(f\"Controllable: {analysis['controllability']['is_controllable']}\")\n&gt;&gt;&gt; print(f\"Observable: {analysis['observability']['is_observable']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Summary assessment\n&gt;&gt;&gt; summary = analysis['summary']\n&gt;&gt;&gt; if summary['ready_for_lqr']:\n...     print(\"System is stabilizable via LQR\")\n&gt;&gt;&gt; if summary['ready_for_kalman']:\n...     print(\"State estimation possible via Kalman filter\")\n&gt;&gt;&gt; if summary['ready_for_lqg']:\n...     print(\"Full LQG controller can be designed\")\n\n\nNotes\nThis is a convenience method for comprehensive system analysis. Use individual methods (stability, controllability, observability) if you only need specific information.\n\n\n\ncontrollability\ncontrol.SystemAnalysis.controllability(A, B, tolerance=1e-10)\nTest controllability of linear system (A, B).\nRoutes to classical.analyze_controllability().\nA system is controllable if all states can be driven to any desired value in finite time using appropriate control inputs.\nControllability test: rank([B AB A²B … A^(n-1)B]) = n\nArgs: A: State matrix (nx, nx) B: Input matrix (nx, nu) tolerance: Tolerance for rank computation\nReturns: ControllabilityInfo with controllability matrix, rank, and flag\n\nExamples\n&gt;&gt;&gt; # Test controllability of linearized system\n&gt;&gt;&gt; system = Pendulum()\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt;\n&gt;&gt;&gt; ctrl_info = system.analysis.controllability(A, B)\n&gt;&gt;&gt; print(f\"Controllable: {ctrl_info['is_controllable']}\")\n&gt;&gt;&gt; print(f\"Controllability matrix rank: {ctrl_info['rank']}/{A.shape[0]}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; if ctrl_info['is_controllable']:\n...     print(\"All states can be controlled\")\n...     # Can design pole placement, LQR, etc.\n...     lqr_result = system.design_lqr(Q, R)\n... else:\n...     print(f\"Only {ctrl_info['rank']} states are controllable\")\n...     print(\"Cannot use pole placement or LQR for full state\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example: Uncontrollable system\n&gt;&gt;&gt; A_diag = np.array([[1, 0], [0, 2]])\n&gt;&gt;&gt; B_identical = np.array([[1], [1]])  # Same input to both states\n&gt;&gt;&gt; ctrl_info = system.analysis.controllability(A_diag, B_identical)\n&gt;&gt;&gt; print(f\"Controllable: {ctrl_info['is_controllable']}\")  # False\n\n\nNotes\n\nControllability required for arbitrary pole placement\nStabilizability (weaker): Unstable modes must be controllable\nSingle-input systems: Often fully controllable with proper structure\nMulti-input systems: Provides more design freedom\nNumerical issues: Use tolerance for near-singular systems\n\n\n\nSee Also\nobservability : Dual concept for state estimation stability : Check stability of linearized system\n\n\n\nobservability\ncontrol.SystemAnalysis.observability(A, C, tolerance=1e-10)\nTest observability of linear system (A, C).\nRoutes to classical.analyze_observability().\nA system is observable if the initial state can be determined from output measurements over a finite time interval.\nObservability test: rank([C; CA; CA²; …; CA^(n-1)]) = n\nArgs: A: State matrix (nx, nx) C: Output matrix (ny, nx) tolerance: Tolerance for rank computation\nReturns: ObservabilityInfo with observability matrix, rank, and flag\n\nExamples\n&gt;&gt;&gt; # Test observability with partial state measurement\n&gt;&gt;&gt; system = Pendulum()\n&gt;&gt;&gt; A, _ = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position only, not velocity\n&gt;&gt;&gt;\n&gt;&gt;&gt; obs_info = system.analysis.observability(A, C)\n&gt;&gt;&gt; print(f\"Observable: {obs_info['is_observable']}\")\n&gt;&gt;&gt; print(f\"Observability matrix rank: {obs_info['rank']}/{A.shape[0]}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; if obs_info['is_observable']:\n...     print(\"Full state can be estimated from position measurement\")\n...     # Can design Kalman filter, observer, etc.\n...     kalman = system.control.design_kalman(A, C, Q_proc, R_meas)\n... else:\n...     print(f\"Only {obs_info['rank']} states are observable\")\n...     print(\"Need additional measurements for full state estimation\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example: Full state measurement\n&gt;&gt;&gt; C_full = np.eye(2)  # Measure both position and velocity\n&gt;&gt;&gt; obs_full = system.analysis.observability(A, C_full)\n&gt;&gt;&gt; print(f\"Observable: {obs_full['is_observable']}\")  # True\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example: Unobservable system\n&gt;&gt;&gt; A_diag = np.array([[1, 0], [0, 2]])\n&gt;&gt;&gt; C_sum = np.array([[1, 1]])  # Can't distinguish individual states\n&gt;&gt;&gt; obs_info = system.analysis.observability(A_diag, C_sum)\n&gt;&gt;&gt; print(f\"Observable: {obs_info['is_observable']}\")  # False\n\n\nNotes\n\nObservability required for state estimation (Kalman filter)\nDetectability (weaker): Unstable modes must be observable\nDual to controllability: (A,C) observable ⟺ (A’,C’) controllable\nMore outputs generally → better observability\nTrade-off: More sensors vs. complexity/cost\n\n\n\nSee Also\ncontrollability : Dual concept for control design stability : Check stability of observer dynamics\n\n\n\nstability\ncontrol.SystemAnalysis.stability(A, system_type='continuous', tolerance=1e-10)\nAnalyze system stability via eigenvalue analysis.\nRoutes to classical.analyze_stability().\nStability criteria: Continuous: All Re(λ) &lt; 0 (left half-plane) Discrete: All |λ| &lt; 1 (inside unit circle)\nArgs: A: State matrix (nx, nx) system_type: ‘continuous’ or ‘discrete’ tolerance: Tolerance for marginal stability detection\nReturns: StabilityInfo with eigenvalues, magnitudes, and stability flags\n\nExamples\n&gt;&gt;&gt; # Analyze linearized system\n&gt;&gt;&gt; system = Pendulum()\n&gt;&gt;&gt; x_eq = np.array([np.pi, 0])  # Upright equilibrium\n&gt;&gt;&gt; u_eq = np.zeros(1)\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check stability\n&gt;&gt;&gt; stability = system.analysis.stability(A, system_type='continuous')\n&gt;&gt;&gt; print(f\"Stable: {stability['is_stable']}\")\n&gt;&gt;&gt; print(f\"Eigenvalues: {stability['eigenvalues']}\")\n&gt;&gt;&gt; print(f\"Max magnitude: {stability['max_magnitude']:.3f}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check if marginal (on boundary)\n&gt;&gt;&gt; if stability['is_marginally_stable']:\n...     print(\"System is critically stable (eigenvalues on boundary)\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discrete system\n&gt;&gt;&gt; discrete_system = DiscreteSystem()\n&gt;&gt;&gt; Ad, Bd = discrete_system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; stability_d = discrete_system.analysis.stability(Ad, system_type='discrete')\n&gt;&gt;&gt; print(f\"Spectral radius: {stability_d['spectral_radius']:.3f}\")\n&gt;&gt;&gt; print(f\"Stable (|λ| &lt; 1): {stability_d['is_stable']}\")\n\n\nNotes\n\nContinuous systems: Stable if all eigenvalues in left half-plane\nDiscrete systems: Stable if all eigenvalues inside unit circle\nMarginal stability: Eigenvalues on stability boundary\nAsymptotic stability: All trajectories converge to equilibrium\nFor nonlinear systems, this only gives local stability around equilibrium\n\n\n\nSee Also\ncontrollability : Check if system is controllable observability : Check if system is observable"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA planar robot arm with two revolute joints, each driven by a motor that applies torque.\nThe system consists of: - Two rigid links connected in series - Two revolute (rotational) joints at base and elbow - Actuators (motors) at each joint providing control torques - Gravity acting downward - Joint friction opposing motion"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#configuration",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#configuration",
    "title": "",
    "section": "Configuration:",
    "text": "Configuration:\n\nLink 1: Attached to fixed base, length l₁, mass m₁\nLink 2: Attached to end of link 1, length l₂, mass m₂\nJoint 1 (base): Angle q₁ from horizontal\nJoint 2 (elbow): Angle q₂ relative to link 1"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [q₁, q₂, q̇₁, q̇₂] Joint angles (configuration): - q₁: Base joint angle [rad] * q₁ = 0: link 1 horizontal to the right * q₁ = π/2: link 1 pointing up - q₂: Elbow joint angle [rad] * q₂ = 0: links aligned (straight arm) * q₂ = π: fully bent (folded back)\nJoint velocities:\n- q̇₁: Base angular velocity [rad/s]\n- q̇₂: Elbow angular velocity [rad/s]\nControl: u = [τ₁, τ₂] - τ₁: Torque applied at base joint [N·m] - τ₂: Torque applied at elbow joint [N·m]\nOutput: y = [q₁, q₂] - Measures joint angles (typical for robots with encoders) - Does not directly measure end-effector position"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe manipulator dynamics follow the standard robot equation: M(q)q̈ + C(q,q̇)q̇ + G(q) + F(q̇) = τ\nwhere: - M(q): Configuration-dependent inertia matrix (2×2) - C(q,q̇): Coriolis and centrifugal terms - G(q): Gravity terms - F(q̇): Friction terms - τ: Applied joint torques (control)\nInertia Matrix M(q): The inertia matrix captures how joint accelerations relate to torques. It depends on configuration due to changing mass distribution:\nM₁₁ = m₁·lc₁² + m₂·(l₁² + lc₂² + 2·l₁·lc₂·cos(q₂)) + I₁ + I₂\nM₁₂ = m₂·(lc₂² + l₁·lc₂·cos(q₂)) + I₂\nM₂₁ = M₁₂  (symmetric)\nM₂₂ = m₂·lc₂² + I₂\nKey features: - M is symmetric and positive definite - Diagonal terms: self-inertia of each joint - Off-diagonal: coupling between joints - M₁₁ maximized when arm is extended (q₂ = 0)\nCoriolis and Centrifugal Terms C(q,q̇): These arise from coordinate system rotation and create coupling:\nh = -m₂·l₁·lc₂·sin(q₂)\nC₁ = h·(2·q̇₁·q̇₂ + q̇₂²)\nC₂ = -h·q̇₁²\nPhysical interpretation: - When joint 2 moves, it creates forces on joint 1 (and vice versa) - Centrifugal: pushing outward when rotating - Coriolis: deflection perpendicular to motion\nGravity Terms G(q): Gravitational torques trying to pull arm downward:\nG₁ = (m₁·lc₁ + m₂·l₁)·g·cos(q₁) + m₂·lc₂·g·cos(q₁ + q₂)\nG₂ = m₂·lc₂·g·cos(q₁ + q₂)\nKey features: - Maximum when arm horizontal (cos = 1) - Zero when arm vertical (cos = 0) - Both links contribute to joint 1 torque - Only link 2 affects joint 2 torque\nFriction F(q̇): Simple viscous friction model:\nF₁ = b₁·q̇₁\nF₂ = b₂·q̇₂\nSolving for Accelerations: The forward dynamics gives: q̈ = M⁻¹(τ - C - G - F)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nm1 : float, default=1.0 Mass of link 1 [kg]. Affects inertia and gravity torques. m2 : float, default=1.0 Mass of link 2 [kg]. Lighter distal link → faster motion. l1 : float, default=1.0 Length of link 1 [m]. Distance from base to elbow. l2 : float, default=1.0 Length of link 2 [m]. Distance from elbow to end-effector. lc1 : float, default=0.5 Distance from base joint to center of mass of link 1 [m]. Typically lc₁ = l₁/2 for uniform link. lc2 : float, default=0.5 Distance from elbow joint to center of mass of link 2 [m]. Typically lc₂ = l₂/2 for uniform link. I1 : float, default=0.1 Moment of inertia of link 1 about its center of mass [kg·m²]. For uniform rod: I = (1/12)·m·l² I2 : float, default=0.1 Moment of inertia of link 2 about its center of mass [kg·m²]. gravity : float, default=9.81 Gravitational acceleration [m/s²]. friction1 : float, default=0.1 Viscous friction coefficient at joint 1 [N·m·s/rad]. friction2 : float, default=0.1 Viscous friction coefficient at joint 2 [N·m·s/rad]."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nHanging down (stable): q_eq = [π, 0] (link 1 down, link 2 aligned) q̇_eq = [0, 0] (at rest) τ_eq = [0, 0] (gravity balances)\nHorizontal (unstable without control): q_eq = [0, 0] (both links horizontal) Requires active control due to gravity\nUpright (highly unstable): q_eq = [π/2, 0] (both links pointing up) Requires fast, precise control"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#forward-kinematics",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#forward-kinematics",
    "title": "",
    "section": "Forward Kinematics:",
    "text": "Forward Kinematics:\nEnd-effector position in Cartesian space: x_ee = l₁·cos(q₁) + l₂·cos(q₁ + q₂) y_ee = l₁·sin(q₁) + l₂·sin(q₁ + q₂)\nWorkspace: - Circle of radius l₁ + l₂ (maximum reach) - Inner circle of radius |l₁ - l₂| (unreachable) - Singularities when arm fully extended or folded"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.Manipulator2Link.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nCartPole : Similar dynamics but with prismatic (sliding) joint SymbolicPendulum2ndOrder : Single-link version PVTOL : Flying robot with similar multi-body coupling"
  },
  {
    "objectID": "api/types.core.NoiseVector.html",
    "href": "api/types.core.NoiseVector.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.NoiseVector.html#examples",
    "href": "api/types.core.NoiseVector.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Standard normal noise\n&gt;&gt;&gt; w: NoiseVector = np.random.randn(2)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Brownian increment (continuous)\n&gt;&gt;&gt; dW: NoiseVector = np.random.randn(2) * np.sqrt(dt)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Discrete-time IID noise\n&gt;&gt;&gt; w_k: NoiseVector = np.random.randn(2)  # w[k] ~ N(0, I)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#stochastic-differential-equation",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#stochastic-differential-equation",
    "title": "",
    "section": "Stochastic Differential Equation",
    "text": "Stochastic Differential Equation\nGeneral form: dr = κ·(θ - r)·dt + σ·√r·dW\nWith control: dr = (κ·(θ - r) + u)·dt + σ·√r·dW\nwhere: - r(t) ∈ ℝ₊: State (interest rate, volatility, intensity) - κ &gt; 0: Mean reversion speed [1/time] - θ &gt; 0: Long-term mean (equilibrium level) - σ &gt; 0: Volatility [1/√time] - u ∈ ℝ: Control input (shifts equilibrium) - W(t): Standard Wiener process - √r: Square-root diffusion (ensures positivity)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nPositivity: r(t) ≥ 0 for all t if Feller condition holds: 2κθ ≥ σ²\nThis ensures boundary r=0 is unattainable.\nMean Reversion: Drift κ·(θ - r) pulls toward long-term mean θ: - Above θ: Negative drift (pulls down) - Below θ: Positive drift (pulls up)\nSquare-Root Diffusion: Noise σ·√r scales with square root of state: - High r: Large volatility - Low r: Small volatility - r = 0: Zero volatility (boundary sticky)\nStationary Distribution: r(∞) ~ Gamma(2κθ/σ², 2κ/σ²)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nFeller Condition: 2κθ ≥ σ² → r(t) &gt; 0 strictly 2κθ &lt; σ² → r(t) can hit and stay at 0\nMoments: Mean: E[r(t)] = r₀·e^(-κt) + θ·(1 - e^(-κt)) Variance: Var[r(t)] = r₀·(σ²/κ)·(e^(-κt) - e^(-2κt)) + θ·(σ²/2κ)·(1 - e^(-κt))²\nAsymptotic: Mean: E[r(∞)] = θ Variance: Var[r(∞)] = θ·σ²/(2κ) Distribution: Gamma(2κθ/σ², 2κ/σ²)\nAutocorrelation: Cov[r(t), r(t+τ)] = (θ·σ²/2κ)·e^(-κ·τ)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nMean Reversion Speed κ: - Time constant: τ = 1/κ - Half-life: ln(2)/κ - Typical: 0.1-2.0 (annual)\nLong-Term Mean θ: - Equilibrium level - Economic: Long-run average rate - Typical: 0.02-0.08 (2%-8%)\nVolatility σ: - Noise intensity - Stationary std: √(θ·σ²/2κ) - Typical: 0.05-0.20\nFeller Condition: 2κθ ≥ σ²\nEnsures positivity. Always verify!"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: r ∈ ℝ₊ = [0, ∞) - Non-negative (strictly positive if Feller holds) - Equilibrium: θ (long-term mean) - Stationary distribution: Gamma\nControl: u ∈ ℝ (optional) - Shifts equilibrium to (θ + u/κ)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkappa\nfloat\nMean reversion speed (must be positive) - Typical: 0.1-2.0 (annual) - Time constant: 1/κ\n0.5\n\n\ntheta\nfloat\nLong-term mean (must be positive) - Typical rates: 0.02-0.08 (2%-8%) - Economic equilibrium\n0.05\n\n\nsigma\nfloat\nVolatility (must be positive) - Typical: 0.05-0.20 - Check Feller: 2κθ ≥ σ²\n0.1"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nNoise Type: MULTIPLICATIVE (√r diffusion)\nSDE Type: Itô (standard)\nNoise Dimension: nw = 1\nStationary: Yes (Gamma distribution)\nErgodic: Yes (if Feller holds)\nPositive: Yes (if Feller holds)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Interest Rate Modeling: - Short-term rate dynamics - Bond pricing (analytical formulas) - Term structure modeling\n2. Stochastic Volatility: - Heston model (variance process) - SABR model component - Realized volatility\n3. Credit Risk: - Default intensity (positive, mean-reverting) - Spread dynamics\n4. Commodity Prices: - Mean-reverting prices (ensures positive)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nEuler-Maruyama (Simple): r[k+1] = r[k] + κ·(θ - r[k])·Δt + σ·√r[k]·√Δt·Z[k]\nCan go negative! Use reflection or absorption.\nExact Sampling (Preferred): Use non-central chi-squared transition density. No discretization error, always positive.\nValidation: - Check positivity: All r[k] ≥ 0 - Verify Feller: 2κθ ≥ σ² - Test stationary distribution (Gamma)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#comparison-with-other-processes",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#comparison-with-other-processes",
    "title": "",
    "section": "Comparison with Other Processes",
    "text": "Comparison with Other Processes\nvs. Ornstein-Uhlenbeck: - OU: Additive noise, can be negative - CIR: Multiplicative noise, always positive\nvs. Geometric Brownian Motion: - GBM: No mean reversion, log-normal - CIR: Mean reversion, Gamma (stationary)\nvs. Vasicek: - Vasicek: Additive σ - CIR: Multiplicative σ·√r"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nFeller condition restricts parameters\nNon-Gaussian (complicates filtering)\nSquare-root creates numerical challenges\nSingle-factor (term structure limitations)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nMulti-factor CIR (correlated processes)\nJump-CIR (Poisson jumps)\nRegime-switching CIR\nTime-varying parameters"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.CoxIngersollRoss.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine Cox-Ingersoll-Ross process dynamics.\n\n\nget_feller_parameter\nGet Feller parameter ν = 2κθ/σ².\n\n\nget_stationary_mean\nGet stationary mean E[r(∞)] = θ.\n\n\nget_stationary_variance\nGet stationary variance Var[r(∞)] = θ·σ²/(2κ).\n\n\nget_time_constant\nGet mean reversion time constant τ = 1/κ.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.CoxIngersollRoss.define_system(\n    kappa=0.5,\n    theta=0.05,\n    sigma=0.1,\n)\nDefine Cox-Ingersoll-Ross process dynamics.\nSets up the SDE: dr = κ·(θ - r)·dt + σ·√r·dW\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkappa\nfloat\nMean reversion speed (must be positive) - Controls speed of return to θ - Time constant: τ = 1/κ - Typical: 0.1-2.0 (annual for rates)\n0.5\n\n\ntheta\nfloat\nLong-term mean (must be positive) - Equilibrium level - Typical rates: 0.02-0.08 (2%-8%) - As decimal, not percentage\n0.05\n\n\nsigma\nfloat\nVolatility (must be positive) - Noise intensity - Typical: 0.05-0.20 - Check Feller: 2κθ ≥ σ²\n0.1\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf any parameter is non-positive\n\n\n\nUserWarning\nIf Feller condition violated (2κθ &lt; σ²)\n\n\n\n\n\nNotes\nFeller Condition:\nCritical requirement: 2κθ ≥ σ²\nIf satisfied: - r(t) &gt; 0 strictly for all t - Boundary r=0 unattainable - Well-defined for all time\nIf violated: - r(t) can hit zero and stay there - Absorbing boundary - Problematic for interest rates\nParameter Relationships:\nStationary statistics: - Mean: θ - Variance: θ·σ²/(2κ) - Std: √(θ·σ²/2κ)\nTime scales: - Mean reversion time: 1/κ - Half-life: ln(2)/κ\nDesign Guidelines:\nTo achieve target mean μ and std s: 1. Set θ = μ 2. Set σ² = 2κ·s²/μ 3. Choose κ for desired time scale 4. Verify Feller: 2κμ ≥ 2κs²/μ → μ² ≥ s²\nTypical Combinations:\nConservative (low vol): - κ = 0.5, θ = 0.05, σ = 0.05 - Feller: 0.05 ≥ 0.0025 ✓ - σ_stat = 0.016 (1.6%)\nStandard: - κ = 0.5, θ = 0.05, σ = 0.1 - Feller: 0.05 ≥ 0.01 ✓ - σ_stat = 0.032 (3.2%)\nHigh volatility: - κ = 0.5, θ = 0.05, σ = 0.2 - Feller: 0.05 &lt; 0.04 ✗ (violates!) - Boundary attainable\n\n\n\nget_feller_parameter\nsystems.builtin.stochastic.continuous.CoxIngersollRoss.get_feller_parameter()\nGet Feller parameter ν = 2κθ/σ².\nIf ν ≥ 1: Feller condition satisfied (strictly positive) If ν &lt; 1: Feller condition violated (can hit zero)\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nFeller parameter ν\n\n\n\n\n\nNotes\nPhysical interpretation: - ν: Degrees of freedom in stationary chi-squared - ν &gt;&gt; 1: Far from boundary, nearly Gaussian - ν ≈ 1: Near boundary, skewed - ν &lt; 1: Boundary attainable\n\n\nExamples\n&gt;&gt;&gt; cir = CoxIngersollRoss(kappa=0.5, theta=0.05, sigma=0.1)\n&gt;&gt;&gt; nu = cir.get_feller_parameter()\n&gt;&gt;&gt; print(f\"Feller parameter: {nu:.2f}\")\n&gt;&gt;&gt; print(f\"Strictly positive: {nu &gt;= 1}\")\n\n\n\nget_stationary_mean\nsystems.builtin.stochastic.continuous.CoxIngersollRoss.get_stationary_mean()\nGet stationary mean E[r(∞)] = θ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nStationary mean\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cir = CoxIngersollRoss(theta=0.05)\n&gt;&gt;&gt; mean = cir.get_stationary_mean()\n&gt;&gt;&gt; print(f\"Long-term mean: {mean:.4f}\")  # 0.05\n\n\n\nget_stationary_variance\nsystems.builtin.stochastic.continuous.CoxIngersollRoss.get_stationary_variance()\nGet stationary variance Var[r(∞)] = θ·σ²/(2κ).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nStationary variance\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cir = CoxIngersollRoss(kappa=0.5, theta=0.05, sigma=0.1)\n&gt;&gt;&gt; var = cir.get_stationary_variance()\n&gt;&gt;&gt; std = np.sqrt(var)\n&gt;&gt;&gt; print(f\"Stationary std: {std:.4f}\")\n\n\n\nget_time_constant\nsystems.builtin.stochastic.continuous.CoxIngersollRoss.get_time_constant()\nGet mean reversion time constant τ = 1/κ.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTime constant\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cir = CoxIngersollRoss(kappa=0.5)\n&gt;&gt;&gt; tau = cir.get_time_constant()\n&gt;&gt;&gt; print(f\"Time constant: {tau:.2f} years\")  # 2.0"
  },
  {
    "objectID": "api/types.core.DiffusionFunction.html",
    "href": "api/types.core.DiffusionFunction.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.DiffusionFunction.html#parameters",
    "href": "api/types.core.DiffusionFunction.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nState (nx,)\nrequired\n\n\nu\nOptional[ControlVector]\nControl (nu,) or None\nrequired"
  },
  {
    "objectID": "api/types.core.DiffusionFunction.html#returns",
    "href": "api/types.core.DiffusionFunction.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiffusionMatrix\nDiffusion matrix (nx, nw)"
  },
  {
    "objectID": "api/types.core.DiffusionFunction.html#examples",
    "href": "api/types.core.DiffusionFunction.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Additive noise (constant)\n&gt;&gt;&gt; def g_additive(x: StateVector, u: ControlVector) -&gt; DiffusionMatrix:\n...     return 0.1 * np.eye(nx)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Multiplicative noise (state-dependent)\n&gt;&gt;&gt; def g_multiplicative(x: StateVector, u: ControlVector) -&gt; DiffusionMatrix:\n...     return np.diag(0.1 * np.abs(x))\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Geometric Brownian motion\n&gt;&gt;&gt; def g_gbm(x: StateVector, u: ControlVector) -&gt; DiffusionMatrix:\n...     return np.array([[sigma * x[0]]])"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacteristics.html",
    "href": "api/systems.base.utils.stochastic.NoiseCharacteristics.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacteristics.html#attributes",
    "href": "api/systems.base.utils.stochastic.NoiseCharacteristics.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nnoise_type\nNoiseType\nClassified noise type (ADDITIVE, SCALAR, DIAGONAL, MULTIPLICATIVE, GENERAL)\n\n\nnum_wiener\nint\nNumber of independent Wiener processes (nw)\n\n\nis_additive\nbool\nTrue if diffusion is constant (doesn’t depend on state/control/time)\n\n\nis_multiplicative\nbool\nTrue if diffusion depends on state\n\n\nis_diagonal\nbool\nTrue if noise sources don’t couple (diagonal diffusion matrix)\n\n\nis_scalar\nbool\nTrue if single Wiener process (nw = 1)\n\n\ndepends_on_state\nbool\nTrue if diffusion depends on any state variable\n\n\ndepends_on_control\nbool\nTrue if diffusion depends on any control variable\n\n\ndepends_on_time\nbool\nTrue if diffusion depends on time\n\n\nstate_dependencies\nSet[sp.Symbol]\nWhich specific state variables appear in diffusion\n\n\ncontrol_dependencies\nSet[sp.Symbol]\nWhich specific control variables appear in diffusion"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacteristics.html#examples",
    "href": "api/systems.base.utils.stochastic.NoiseCharacteristics.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; char = NoiseCharacteristics(...)\n&gt;&gt;&gt; if char.is_additive:\n...     G = precompute_constant_noise()  # Optimization!\n&gt;&gt;&gt;\n&gt;&gt;&gt; solvers = char.recommended_solvers('jax')\n&gt;&gt;&gt; print(solvers)  # ['sea', 'shark'] for additive"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacteristics.html#methods",
    "href": "api/systems.base.utils.stochastic.NoiseCharacteristics.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nrecommended_solvers\nRecommend efficient solvers based on noise structure.\n\n\n\n\nrecommended_solvers\nsystems.base.utils.stochastic.NoiseCharacteristics.recommended_solvers(backend)\nRecommend efficient solvers based on noise structure.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbackend\nBackend\nIntegration backend (‘jax’, ‘torch’, ‘numpy’)\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nRecommended solver names, ordered by efficiency/accuracy\n\n\n\n\n\nExamples\n&gt;&gt;&gt; if char.is_additive:\n...     solvers = char.recommended_solvers('jax')\n...     print(solvers)  # ['sea', 'shark', 'sra1']"
  },
  {
    "objectID": "api/types.backends.SDEType.html",
    "href": "api/types.backends.SDEType.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\ntypes.backends.SDEType\ntypes.backends.SDEType()\nSDE interpretation type.\nInterpretations: - ‘ito’: Itô interpretation (more common in control/finance) * dx = f(x)dt + g(x)dW * Martingale property * Simpler numerically\n\n‘stratonovich’: Stratonovich interpretation (physics/engineering)\ndx = f(x)dt + g(x)∘dW\nChain rule works normally\nMore intuitive for physical systems\n\nConversion: f_Stratonovich = f_Ito + 0.5 * g * (∂g/∂x)\nFor discrete systems: No distinction (both equivalent)"
  },
  {
    "objectID": "api/types.control_classical.LQRResult.html",
    "href": "api/types.control_classical.LQRResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.LQRResult.html#fields",
    "href": "api/types.control_classical.LQRResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ngain : GainMatrix Optimal feedback gain K of shape (nu, nx) cost_to_go : CovarianceMatrix Solution P to algebraic Riccati equation (nx, nx) controller_eigenvalues : np.ndarray Eigenvalues of (A - BK) - indicates stability and response stability_margin : float Distance from stability boundary (positive = stable)"
  },
  {
    "objectID": "api/types.control_classical.LQRResult.html#examples",
    "href": "api/types.control_classical.LQRResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Continuous LQR\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; B = np.array([[0], [1]])\n&gt;&gt;&gt; Q = np.diag([10, 1])  # Penalize position more than velocity\n&gt;&gt;&gt; R = np.array([[0.1]])  # Control cost\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: LQRResult = design_lqr_continuous(A, B, Q, R)\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt; print(K.shape)  # (1, 2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply control\n&gt;&gt;&gt; x = np.array([1.0, 0.0])\n&gt;&gt;&gt; u = -K @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check stability\n&gt;&gt;&gt; print(np.all(np.real(result['controller_eigenvalues']) &lt; 0))  # True\n&gt;&gt;&gt; print(result['stability_margin'])  # Positive value\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Discrete LQR\n&gt;&gt;&gt; Ad = np.array([[1, 0.1], [0, 0.9]])\n&gt;&gt;&gt; Bd = np.array([[0], [0.1]])\n&gt;&gt;&gt; result_d: LQRResult = design_lqr_discrete(Ad, Bd, Q, R)\n&gt;&gt;&gt; print(np.all(np.abs(result_d['controller_eigenvalues']) &lt; 1))  # True"
  },
  {
    "objectID": "api/systems.base.numerical_integration.ScipyIntegrator.html",
    "href": "api/systems.base.numerical_integration.ScipyIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.ScipyIntegrator.html#available-methods",
    "href": "api/systems.base.numerical_integration.ScipyIntegrator.html#available-methods",
    "title": "",
    "section": "Available Methods:",
    "text": "Available Methods:\nExplicit (Non-Stiff): - ‘RK45’: Dormand-Prince 5(4) [DEFAULT] * General-purpose, robust * Order 5 with 4th-order error estimate * Good for most problems\n\n‘RK23’: Bogacki-Shampine 3(2)\n\nLower accuracy, faster\nGood for coarse simulations\n\n‘DOP853’: Dormand-Prince 8(5,3)\n\nVery high accuracy\nGood for precise orbit calculations\n\n\nImplicit (Stiff): - ‘Radau’: Implicit Runge-Kutta * Stiff-stable * Good for moderately stiff problems * 5th order accuracy\n\n‘BDF’: Backward Differentiation Formula\n\nVery stiff systems\nUsed in circuit simulation, chemistry\nVariable order (1-5)\n\n\nAutomatic: - ‘LSODA’: Automatic stiffness detection * Switches between Adams (non-stiff) and BDF (stiff) * Best “set and forget” option * Used in MATLAB’s ode15s"
  },
  {
    "objectID": "api/systems.base.numerical_integration.ScipyIntegrator.html#examples",
    "href": "api/systems.base.numerical_integration.ScipyIntegrator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Controlled system - general-purpose adaptive integration\n&gt;&gt;&gt; integrator = ScipyIntegrator(\n...     system,\n...     dt=0.01,  # Initial guess\n...     method='RK45',\n...     rtol=1e-6,\n...     atol=1e-8\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: -K @ x,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Adaptive steps: {result['nsteps']}\")\n&gt;&gt;&gt; print(f\"Success: {result['success']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = ScipyIntegrator(autonomous_system, method='RK45')\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,  # No control\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stiff system (automatic detection)\n&gt;&gt;&gt; stiff_integrator = ScipyIntegrator(\n...     stiff_system,\n...     method='LSODA',  # Auto-detects stiffness\n...     rtol=1e-8,\n...     atol=1e-10\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Very stiff system (explicit method)\n&gt;&gt;&gt; very_stiff_integrator = ScipyIntegrator(\n...     chem_system,\n...     method='BDF',  # Backward differentiation\n...     rtol=1e-10\n... )"
  },
  {
    "objectID": "api/systems.base.numerical_integration.ScipyIntegrator.html#methods",
    "href": "api/systems.base.numerical_integration.ScipyIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nintegrate\nIntegrate using scipy.solve_ivp with adaptive stepping.\n\n\nstep\nTake one integration step (uses integrate() internally).\n\n\n\n\nintegrate\nsystems.base.numerical_integration.ScipyIntegrator.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n    events=None,\n)\nIntegrate using scipy.solve_ivp with adaptive stepping.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nArrayLike\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable[[float, ArrayLike], Optional[ArrayLike]]\nControl policy (t, x) → u (or None for autonomous systems)\nrequired\n\n\nt_span\nTuple[float, float]\nIntegration interval (t_start, t_end)\nrequired\n\n\nt_eval\nOptional[ArrayLike]\nSpecific times at which to store solution If None, solver chooses time points automatically\nNone\n\n\ndense_output\nbool\nIf True, compute continuous solution (allows interpolation)\nFalse\n\n\nevents\nOptional[Callable]\nEvent function for detection (e.g., impact, switching)\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nTypedDict containing: - t: Time points (T,) - x: State trajectory (T, nx) - time-major ordering - success: Whether integration succeeded - message: Status message - nfev: Number of function evaluations - nsteps: Number of steps taken - integration_time: Computation time - solver: Integrator name - njev: Number of Jacobian evaluations (if available) - nlu: Number of LU decompositions (if available) - status: Solver status code (if available) - sol: Dense output object (if dense_output=True) - dense_output: True (if dense_output=True)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Controlled system - let solver choose time points\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: -K @ x,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; # result[\"t\"] has variable spacing (adaptive!)\n&gt;&gt;&gt; print(f\"Used {result['nsteps']} adaptive steps\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=np.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Autonomous: {result['success']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Evaluate at specific times\n&gt;&gt;&gt; t_eval = np.linspace(0, 10, 1001)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0, u_func, (0, 10),\n...     t_eval=t_eval\n... )\n&gt;&gt;&gt; # result[\"t\"] matches t_eval\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Dense output for interpolation\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0, u_func, (0, 10),\n...     dense_output=True\n... )\n&gt;&gt;&gt; x_at_5_5 = result[\"sol\"](5.5)  # Interpolate at t=5.5\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Event detection\n&gt;&gt;&gt; def impact_event(t, x):\n...     return x[1]  # Detect when velocity crosses zero\n&gt;&gt;&gt; impact_event.terminal = True\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0, u_func, (0, 10),\n...     events=impact_event\n... )\n\n\n\nstep\nsystems.base.numerical_integration.ScipyIntegrator.step(x, u=None, dt=None)\nTake one integration step (uses integrate() internally).\nFor adaptive integrators, this integrates from t=0 to t=dt using adaptive stepping internally, then returns the final state.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nArrayLike\nCurrent state\nrequired\n\n\nu\nOptional[ArrayLike]\nControl input (None for autonomous systems, assumed constant over step)\nNone\n\n\ndt\nOptional[float]\nStep size (uses self.dt if None)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nArrayLike\nNext state\n\n\n\n\n\nNotes\nThis is less efficient than integrate() for multiple steps because it reinitializes the solver each time. Use integrate() for trajectory generation."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#vector-difference-equation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#vector-difference-equation",
    "title": "",
    "section": "Vector Difference Equation",
    "text": "Vector Difference Equation\nStandard VAR(1) form: X[k] = A·X[k-1] + w[k]\nWith control: X[k] = A·X[k-1] + B·u[k] + w[k]\nwhere: - X[k] ∈ ℝⁿ: State vector (n time series) - A ∈ ℝⁿˣⁿ: Coefficient matrix (VAR coefficients) - B ∈ ℝⁿˣᵖ: Control matrix (optional) - u[k] ∈ ℝᵖ: Exogenous inputs - w[k] ~ N(0, Σ_w): Vector white noise - Σ_w ∈ ℝⁿˣⁿ: Innovation covariance\nComponent Equations: X_i[k] = Σⱼ A_ij·X_j[k-1] + w_i[k]\nEach variable depends on all lagged variables."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nCoefficient Matrix A:\nDiagonal elements A_ii: - Own-lag effect (like univariate AR) - Persistence of variable i - Typical: 0.5-0.9 (positive persistence)\nOff-diagonal elements A_ij (i ≠ j): - Cross-lag effect (variable j → variable i) - Spillover, contagion, transmission - Can be positive (co-movement) or negative (offset) - Zero: No direct effect (X_j doesn’t Granger-cause X_i)\nExample (2D Macro Model): [GDP[k] ] = [a₁₁ a₁₂]·[GDP[k-1] ] + [w₁[k]] [Inflation[k]] [a₂₁ a₂₂] [Inflation[k-1]] [w₂[k]]\nInterpretation: - a₁₁: GDP persistence (momentum) - a₁₂: Effect of past inflation on GDP (Phillips curve) - a₂₁: Effect of past GDP on inflation (demand-pull) - a₂₂: Inflation persistence (expectations)\nInnovation Covariance Σ_w:\nDiagonal elements (Σ_w)_ii: - Variance of idiosyncratic shock to variable i\nOff-diagonal elements (Σ_w)_ij: - Contemporaneous correlation between shocks - Common factors affecting multiple variables - Non-zero typical (shocks correlated)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#key-features",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nMultivariate: n variables modeled jointly (not independently).\nCross-Effects: A_ij captures dynamic interaction (j → i).\nStationarity: All eigenvalues of A inside unit circle: |λ| &lt; 1\nSymmetry: A can be asymmetric (feedback loops possible).\nCorrelated Shocks: Σ_w typically non-diagonal (contemporaneous correlation).\nMarkov: Future depends only on X[k], not X[k-2], X[k-3], …\nGaussian: If w ~ N(0, Σ_w), then X is multivariate Gaussian."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nEigenvalue Decomposition: A = V·Λ·V⁻¹\nEigenvalues λ_i determine: - Stability: All |λ_i| &lt; 1 required - Time scales: τ_i = -1/ln|λ_i| periods - Oscillations: Im(λ_i) ≠ 0 → cycles\nStationary Covariance:\nDiscrete Lyapunov: Γ₀ = A·Γ₀·Aᵀ + Σ_w\nNumerical solution via: - scipy.linalg.solve_discrete_lyapunov - Bartels-Stewart algorithm - Kronecker form: (I - A⊗A)·vec(Γ₀) = vec(Σ_w)\nImpulse Response:\nh-step response: Ψ_h = Aʰ\nTrace shock propagation through system."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#physical-interpretation-1",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#physical-interpretation-1",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nMatrix A Structure:\nFull (dense): - All variables interact - n² parameters - Flexible but many parameters\nDiagonal: - No cross-effects (independent AR(1)s) - n parameters - Restrictive but parsimonious\nBlock diagonal: - Groups of interacting variables - Within-group coupling, no between-group - Intermediate complexity\nSparse: - Most A_ij = 0 (network structure) - Few interactions - Common in high-dimensional VARs"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#state-space",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X ∈ ℝⁿ - Vector of n time series - Unbounded (Gaussian)\nControl: u ∈ ℝᵖ (optional) - Exogenous inputs - Policy variables\nNoise: w ∈ ℝⁿ - Vector white noise - Covariance Σ_w (can be correlated)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#parameters",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\n(np.ndarray or list, shape(n, n))\nVAR coefficient matrix - Diagonal: Own-lag effects - Off-diagonal: Cross-effects - Eigenvalues must satisfy |λ| &lt; 1\nrequired\n\n\nSigma_w\n(np.ndarray or list, shape(n, n))\nInnovation covariance matrix - Must be symmetric positive definite - Diagonal: Idiosyncratic variances - Off-diagonal: Contemporaneous correlations\nrequired\n\n\nB\n(Optional[np.ndarray], shape(n, p))\nControl/exogenous input matrix\nrequired\n\n\ndt\nfloat\nSampling period (time units)\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: LINEAR (multivariate AR)\nNoise Type: ADDITIVE (vector white noise)\nMarkov: Yes (one lag)\nStationary: If all |λ(A)| &lt; 1\nGaussian: If w ~ N(0, Σ_w)\nDimension: n (number of variables)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#applications",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Macroeconomics: - GDP, inflation, interest rates - Unemployment, investment, consumption - Fiscal and monetary policy analysis\n2. Finance: - Multi-asset portfolios - Volatility spillovers - Market contagion\n3. International: - Multi-country models - Trade dynamics - Exchange rates\n4. Energy: - Electricity, gas, oil prices - Demand forecasting - Renewable integration\n5. Operations: - Multi-product demand - Supply chain dynamics - Inventory systems"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#numerical-simulation",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#numerical-simulation",
    "title": "",
    "section": "Numerical Simulation",
    "text": "Numerical Simulation\nDirect Matrix Multiplication: X[k+1] = A @ X[k] + w[k]\nEfficient: Use NumPy matrix operations.\nStability Check: Before long simulation, verify eigenvalues inside unit circle."
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#granger-causality-testing",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#granger-causality-testing",
    "title": "",
    "section": "Granger Causality Testing",
    "text": "Granger Causality Testing\nImplementation:\nTest if X_j → X_i (j Granger-causes i): 1. Restricted model: X_i[k] = a_ii·X_i[k-1] + ε[k] 2. Unrestricted: X_i[k] = a_ii·X_i[k-1] + a_ij·X_j[k-1] + ε[k] 3. F-test: Is a_ij significantly non-zero?"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#comparison-with-scalar-ar",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#comparison-with-scalar-ar",
    "title": "",
    "section": "Comparison with Scalar AR",
    "text": "Comparison with Scalar AR\nScalar AR(1): - 1 variable, 1 lag - 1 parameter (φ)\nVAR(1): - n variables, 1 lag - n² parameters (A matrix) - Captures interactions\nWhen VAR Essential: - Variables economically related - Spillovers/contagion - Joint forecasting better"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#limitations",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nLinear dynamics only\nConstant parameters\nShort memory (lag 1 only, extend to VAR(p))\nMany parameters (n² for n variables)\nCurse of dimensionality (high n)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#extensions",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nVAR(p): Multiple lags\nVARMA: Add moving average\nSVAR: Structural identification\nBVAR: Bayesian shrinkage (Minnesota prior)\nFactor-Augmented VAR: Handle high dimension"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#see-also",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDiscreteAR1 : Univariate version (n=1) MultivariateOrnsteinUhlenbeck : Continuous-time analog DiscreteARMA11 : Univariate with MA component"
  },
  {
    "objectID": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#methods",
    "href": "api/systems.builtin.stochastic.discrete.DiscreteVAR1.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_impulse_response\nCompute impulse response function.\n\n\ndefine_system\nDefine VAR(1) process dynamics.\n\n\nget_eigenvalues\nGet eigenvalues of A (determines stability and dynamics).\n\n\nget_innovation_covariance\nGet innovation covariance Σ_w.\n\n\nget_stationary_covariance\nCompute stationary covariance Γ₀.\n\n\nget_var_matrix\nGet VAR coefficient matrix A.\n\n\ntest_granger_causality\nTest if variable j Granger-causes variable i.\n\n\n\n\ncompute_impulse_response\nsystems.builtin.stochastic.discrete.DiscreteVAR1.compute_impulse_response(\n    horizon=20,\n)\nCompute impulse response function.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhorizon\nint\nNumber of periods ahead\n20\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nIRF tensor (horizon+1, n, n) IRF[h, i, j] = response of variable i to shock in j after h periods\n\n\n\n\n\nExamples\n&gt;&gt;&gt; var = DiscreteVAR1(A=[[0.8, 0.2], [0.1, 0.7]], Sigma_w=np.eye(2)*0.01)\n&gt;&gt;&gt; irf = var.compute_impulse_response(horizon=10)\n&gt;&gt;&gt; print(f\"Impact of shock to X₁ on X₂ after 5 periods: {irf[5, 1, 0]:.3f}\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.discrete.DiscreteVAR1.define_system(\n    A,\n    Sigma_w,\n    B=None,\n    dt=1.0,\n)\nDefine VAR(1) process dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nA\n(np.ndarray or list, shape(n, n))\nVAR coefficient matrix - Diagonal: Own-lag effects (persistence) - Off-diagonal: Cross-lag effects (spillovers) - Must have eigenvalues |λ| &lt; 1 for stationarity\nrequired\n\n\nSigma_w\n(np.ndarray or list, shape(n, n))\nInnovation covariance matrix - Must be symmetric positive definite - Diagonal: Shock variances - Off-diagonal: Shock correlations\nrequired\n\n\nB\n(Optional[np.ndarray], shape(n, p))\nControl/exogenous input matrix\nNone\n\n\ndt\nfloat\nSampling period (e.g., daily, monthly, quarterly)\n1.0\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf dimensions incompatible or Σ_w not positive definite\n\n\n\nUserWarning\nIf eigenvalues of A outside unit circle (non-stationary)\n\n\n\n\n\nNotes\nStationarity: Check all eigenvalues of A: |λ_i| &lt; 1\nParameter Count: - VAR coefficients: n² - Covariance: n(n+1)/2 - Total: n² + n(n+1)/2\nExample: n=3 → 9 + 6 = 15 parameters!\nGranger Causality: X_j Granger-causes X_i if A_ij ≠ 0. Test via F-test on individual coefficients.\nImpulse Response: h-step response: Ψ_h = Aʰ Trace shock effects over time.\n\n\n\nget_eigenvalues\nsystems.builtin.stochastic.discrete.DiscreteVAR1.get_eigenvalues()\nGet eigenvalues of A (determines stability and dynamics).\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nEigenvalues (may be complex)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; var = DiscreteVAR1(A=[[0.8, 0.1], [0.1, 0.7]],\n...                    Sigma_w=np.eye(2)*0.01)\n&gt;&gt;&gt; eigs = var.get_eigenvalues()\n&gt;&gt;&gt; print(f\"Eigenvalues: {eigs}\")\n\n\n\nget_innovation_covariance\nsystems.builtin.stochastic.discrete.DiscreteVAR1.get_innovation_covariance()\nGet innovation covariance Σ_w.\n\n\nget_stationary_covariance\nsystems.builtin.stochastic.discrete.DiscreteVAR1.get_stationary_covariance()\n    Compute stationary covariance Γ₀.\n\n    Solves: Γ₀ = A·Γ₀·Aᵀ + Σ_w\n\nReturns\n    np.ndarray\n        Stationary covariance\n\n\nExamples\n    &gt;&gt;&gt; var = DiscreteVAR1(A=[[0.8, 0], [0, 0.7]], Sigma_w=np.eye(2)*0.01)\n    &gt;&gt;&gt; Gamma = var.get_stationary_covariance()\n    &gt;&gt;&gt; print(f\"Stationary covariance:\n{Gamma}“)\n\n\n\nget_var_matrix\nsystems.builtin.stochastic.discrete.DiscreteVAR1.get_var_matrix()\nGet VAR coefficient matrix A.\n\n\ntest_granger_causality\nsystems.builtin.stochastic.discrete.DiscreteVAR1.test_granger_causality(i, j)\nTest if variable j Granger-causes variable i.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ni\nint\nTarget variable index\nrequired\n\n\nj\nint\nSource variable index\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{‘causes’: bool, ‘coefficient’: float}\n\n\n\n\n\nNotes\nSimple test: Is A_ij ≠ 0?\nFor rigorous test, need F-statistic from data.\n\n\nExamples\n&gt;&gt;&gt; var = DiscreteVAR1(A=[[0.8, 0.2], [0.0, 0.7]], Sigma_w=np.eye(2)*0.01)\n&gt;&gt;&gt; test = var.test_granger_causality(i=0, j=1)\n&gt;&gt;&gt; print(f\"X₁ causes X₀: {test}\")  # True (A₀₁ = 0.2)"
  },
  {
    "objectID": "api/types.control_advanced.SlidingModeResult.html",
    "href": "api/types.control_advanced.SlidingModeResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_advanced.SlidingModeResult.html#fields",
    "href": "api/types.control_advanced.SlidingModeResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ncontrol : ControlVector SMC control signal u (nu,) sliding_variable : ArrayLike Sliding surface variable s = Cx (ns,) on_sliding_surface : bool Whether |s| &lt; ε (in sliding mode) reaching_time_estimate : Optional[float] Estimated time to reach surface (if not on surface) chattering_magnitude : float Control chattering level (high-frequency switching)"
  },
  {
    "objectID": "api/types.control_advanced.SlidingModeResult.html#examples",
    "href": "api/types.control_advanced.SlidingModeResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Sliding mode controller\n&gt;&gt;&gt; smc = SlidingModeController(\n...     sliding_surface_gain=np.array([[1, 1]]),\n...     switching_gain=5.0,\n...     boundary_layer=0.1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute control\n&gt;&gt;&gt; x = np.array([1.0, 0.5])\n&gt;&gt;&gt; x_desired = np.zeros(2)\n&gt;&gt;&gt; result: SlidingModeResult = smc.compute_control(x, x_desired)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply control\n&gt;&gt;&gt; u = result['control']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check sliding mode\n&gt;&gt;&gt; s = result['sliding_variable']\n&gt;&gt;&gt; if result['on_sliding_surface']:\n...     print(\"In sliding mode - tracking achieved\")\n... else:\n...     t_reach = result['reaching_time_estimate']\n...     print(f\"Reaching surface in ~{t_reach:.2f} seconds\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Monitor chattering\n&gt;&gt;&gt; chattering = result['chattering_magnitude']\n&gt;&gt;&gt; if chattering &gt; 1.0:\n...     print(\"High chattering - consider boundary layer\")"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html",
    "href": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#parameters",
    "href": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsde_system\nStochasticDynamicalSystem\nSDE system to integrate (controlled or autonomous)\nrequired\n\n\ndt\nOptional[float]\nTime step size (required for fixed step, initial guess for adaptive)\nNone\n\n\nstep_mode\nStepMode\nFIXED or ADAPTIVE stepping mode\nStepMode.FIXED\n\n\nbackend\nstr\nMust be ‘jax’ for this integrator\n'jax'\n\n\nsolver\nstr\nDiffrax SDE solver name (default: ‘Euler’) Options: ‘Euler’, ‘EulerHeun’, ‘Heun’, ‘ItoMilstein’, ‘SEA’, ‘SHARK’, ‘SRA1’, ‘ReversibleHeun’\n'Euler'\n\n\nsde_type\nOptional[SDEType]\nSDE interpretation (None = use system’s type)\nNone\n\n\nconvergence_type\nConvergenceType\nStrong or weak convergence\nConvergenceType.STRONG\n\n\nseed\nOptional[int]\nRandom seed for reproducibility\nNone\n\n\nlevy_area\nstr\nLevy area approximation: ‘none’, ‘space-time’, or ‘full’ Required for Milstein-type solvers\n'none'\n\n\n**options\n\nAdditional options: - rtol : float (default: 1e-3) - Relative tolerance (adaptive only) - atol : float (default: 1e-6) - Absolute tolerance (adaptive only) - max_steps : int (default: 10000) - Maximum steps - adjoint : str (‘recursive_checkpoint’, ‘direct’, ‘implicit’)\n{}"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#raises",
    "href": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#raises",
    "title": "",
    "section": "Raises",
    "text": "Raises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf backend is not ‘jax’\n\n\n\nImportError\nIf JAX or Diffrax not installed"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#notes",
    "href": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nBackend must be ‘jax’ (Diffrax is JAX-only)\nSupports custom Brownian increments via dW parameter\nJIT compilation happens on first call (may be slow)\nFor optimization, use adjoint=‘recursive_checkpoint’\nMilstein methods require levy_area approximation"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#examples",
    "href": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Basic usage\n&gt;&gt;&gt; integrator = DiffraxSDEIntegrator(\n...     sde_system,\n...     dt=0.01,\n...     solver='Euler'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Deterministic testing with zero noise\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01, dW=jnp.zeros(nw))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom noise pattern\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01, dW=jnp.array([0.5]))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Optimized for additive noise\n&gt;&gt;&gt; integrator = DiffraxSDEIntegrator(\n...     additive_noise_system,\n...     dt=0.001,\n...     solver='SEA'  # Specialized for additive noise\n... )"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#attributes",
    "href": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nname\nReturn integrator name."
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#methods",
    "href": "api/systems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nget_solver_info\nGet information about a specific solver.\n\n\nintegrate\nIntegrate SDE over time interval.\n\n\nintegrate_with_gradient\nIntegrate and compute gradients w.r.t. initial conditions.\n\n\njit_compile\nJIT-compile the integration for faster execution.\n\n\nlist_solvers\nList available Diffrax SDE solvers by category.\n\n\nrecommend_solver\nRecommend Diffrax solver based on problem characteristics.\n\n\nstep\nTake one SDE integration step.\n\n\nto_device\nMove computations to specified device.\n\n\nvectorized_integrate\nVectorized integration over batch of initial conditions.\n\n\n\n\nget_solver_info\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.get_solver_info(\n    solver,\n)\nGet information about a specific solver.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsolver\nstr\nSolver name\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, Any]\nSolver properties including required levy_area type\n\n\n\n\n\n\nintegrate\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n    brownian_path=None,\n)\nIntegrate SDE over time interval.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable\nControl policy: (t, x) -&gt; u (or None for autonomous)\nrequired\n\n\nt_span\nTimeSpan\nIntegration interval (t_start, t_end)\nrequired\n\n\nt_eval\nOptional[TimePoints]\nSpecific times at which to save solution\nNone\n\n\ndense_output\nbool\nIf True, enable dense output (not supported for SDEs in Diffrax)\nFalse\n\n\nbrownian_path\nOptional[CustomBrownianPath]\nCustom Brownian path object (CustomBrownianPath or None) If provided, uses deterministic custom noise instead of random. Must be compatible with Diffrax’s AbstractPath interface.\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegrationResult\nIntegration result with trajectory\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Autonomous SDE with random noise\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=jnp.array([1.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With custom Brownian path (deterministic)\n&gt;&gt;&gt; from cdesym.systems.base.numerical_integration.stochastic.custom_brownian import (\n...     CustomBrownianPath\n... )\n&gt;&gt;&gt; dW = jnp.zeros(nw)  # Zero noise\n&gt;&gt;&gt; brownian = CustomBrownianPath(0.0, 10.0, dW)\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=jnp.array([1.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0),\n...     brownian_path=brownian\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Controlled SDE\n&gt;&gt;&gt; K = jnp.array([[1.0, 2.0]])\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=jnp.array([1.0, 0.0]),\n...     u_func=lambda t, x: -K @ x,\n...     t_span=(0.0, 10.0)\n... )\n\n\n\nintegrate_with_gradient\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.integrate_with_gradient(\n    x0,\n    u_func,\n    t_span,\n    loss_fn,\n    t_eval=None,\n)\nIntegrate and compute gradients w.r.t. initial conditions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nArrayLike\nInitial state\nrequired\n\n\nu_func\nCallable\nControl policy\nrequired\n\n\nt_span\nTuple[float, float]\nTime span\nrequired\n\n\nloss_fn\nCallable\nLoss function taking IntegrationResult\nrequired\n\n\nt_eval\nOptional[ArrayLike]\nEvaluation times\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(loss_value, gradient_wrt_x0)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; def loss_fn(result):\n...     return jnp.sum(result.x[-1]**2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; loss, grad = integrator.integrate_with_gradient(\n...     x0, u_func, t_span, loss_fn\n... )\n\n\n\njit_compile\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.jit_compile()\nJIT-compile the integration for faster execution.\nFirst call will be slow (compilation), subsequent calls fast.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nCallable\nJIT-compiled integration function\n\n\n\n\n\nExamples\n&gt;&gt;&gt; jit_integrate = integrator.jit_compile()\n&gt;&gt;&gt; result = jit_integrate(x0, u_func, t_span)  # Fast!\n\n\n\nlist_solvers\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.list_solvers(\n)\nList available Diffrax SDE solvers by category.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, List[str]]\nSolvers organized by category\n\n\n\n\n\nExamples\n&gt;&gt;&gt; solvers = DiffraxSDEIntegrator.list_solvers()\n&gt;&gt;&gt; print(solvers['additive_noise'])\n['SEA', 'SHARK', 'SRA1']\n\n\n\nrecommend_solver\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.recommend_solver(\n    noise_type,\n    accuracy='medium',\n    has_derivatives=False,\n)\nRecommend Diffrax solver based on problem characteristics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnoise_type\nstr\n‘additive’, ‘diagonal’, ‘scalar’, or ‘general’\nrequired\n\n\naccuracy\nstr\n‘low’, ‘medium’, or ‘high’\n'medium'\n\n\nhas_derivatives\nbool\nWhether diffusion derivatives are available\nFalse\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nRecommended solver name\n\n\n\n\n\nExamples\n&gt;&gt;&gt; solver = DiffraxSDEIntegrator.recommend_solver(\n...     noise_type='additive',\n...     accuracy='high'\n... )\n&gt;&gt;&gt; print(solver)\n'SHARK'\n\n\n\nstep\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.step(\n    x,\n    u=None,\n    dt=None,\n    dW=None,\n)\nTake one SDE integration step.\nNEW: Now supports custom Brownian increments via dW parameter!\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,) or (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input (nu,) or (batch, nu), or None for autonomous\nNone\n\n\ndt\nOptional[ScalarLike]\nStep size (uses self.dt if None)\nNone\n\n\ndW\nOptional[NoiseVector]\nBrownian increments (nw,) If provided, uses this deterministic noise instead of random. Shape must match (nw,) where nw is number of Wiener processes. Key feature: Providing dW enables: - Deterministic testing: dW=jnp.zeros(nw) - Custom noise patterns: dW=jnp.array([0.5, -0.3]) - Quasi-Monte Carlo methods - Antithetic variates for variance reduction\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x(t + dt)\n\n\n\n\n\nNotes\n\nSingle-step interface less efficient than full integration\nCustom noise (dW) is FULLY SUPPORTED by JAX/Diffrax\nSame dW always gives same result (deterministic)\nThis is the RECOMMENDED backend for custom noise needs\n\n\n\nExamples\n&gt;&gt;&gt; # Random noise (default)\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Zero noise (deterministic dynamics only)\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01, dW=jnp.zeros(nw))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Custom noise pattern\n&gt;&gt;&gt; x_next = integrator.step(x, u, dt=0.01, dW=jnp.array([0.5]))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Verify determinism\n&gt;&gt;&gt; x1 = integrator.step(x, u, dt=0.01, dW=jnp.zeros(1))\n&gt;&gt;&gt; x2 = integrator.step(x, u, dt=0.01, dW=jnp.zeros(1))\n&gt;&gt;&gt; assert jnp.allclose(x1, x2)  # Passes!\n\n\n\nto_device\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.to_device(\n    device,\n)\nMove computations to specified device.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndevice\nstr\n‘cpu’, ‘gpu’, ‘gpu:0’, ‘gpu:1’, etc.\nrequired\n\n\n\n\n\nExamples\n&gt;&gt;&gt; integrator.to_device('gpu')\n&gt;&gt;&gt; # Now all computations use GPU\n\n\n\nvectorized_integrate\nsystems.base.numerical_integration.stochastic.DiffraxSDEIntegrator.vectorized_integrate(\n    x0_batch,\n    u_func,\n    t_span,\n    t_eval=None,\n)\nVectorized integration over batch of initial conditions.\nUses jax.vmap for efficient batching.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0_batch\nArrayLike\nBatch of initial states (batch, nx)\nrequired\n\n\nu_func\nCallable\nControl policy\nrequired\n\n\nt_span\nTuple[float, float]\nTime span\nrequired\n\n\nt_eval\nOptional[ArrayLike]\nEvaluation times\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[SDEIntegrationResult]\nResults for each initial condition\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x0_batch = jnp.array([[1.0], [2.0], [3.0]])\n&gt;&gt;&gt; results = integrator.vectorized_integrate(\n...     x0_batch, u_func, (0, 10)\n... )"
  },
  {
    "objectID": "api/types.backends.OptimizationMethod.html",
    "href": "api/types.backends.OptimizationMethod.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\ntypes.backends.OptimizationMethod\ntypes.backends.OptimizationMethod\nOptimization method for control/estimation problems."
  },
  {
    "objectID": "api/types.core.StateMatrix.html",
    "href": "api/types.core.StateMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.StateMatrix.html#examples",
    "href": "api/types.core.StateMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Continuous linearization\n&gt;&gt;&gt; Ac: StateMatrix = np.array([[0, 1], [-1, 0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Discrete transition\n&gt;&gt;&gt; Ad: StateMatrix = np.eye(2) + dt*Ac\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Covariance\n&gt;&gt;&gt; P: StateMatrix = np.eye(2)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # LQR cost\n&gt;&gt;&gt; Q: StateMatrix = np.diag([10, 1])"
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html#parameters",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nContinuous-time system to integrate (controlled or autonomous)\nrequired\n\n\ndt\nOptional[float]\nTime step size\nNone\n\n\nstep_mode\nStepMode\nFIXED or ADAPTIVE stepping mode\nStepMode.ADAPTIVE\n\n\nbackend\nstr\nMust be ‘jax’ for this integrator\n'jax'\n\n\nsolver\nstr\nSolver name. See _solver_map for available options. Default: ‘tsit5’\n'tsit5'\n\n\nadjoint\nstr\nAdjoint method for backpropagation. Options: ‘recursive_checkpoint’, ‘direct’, ‘implicit’. Default: ‘recursive_checkpoint’\n'recursive_checkpoint'\n\n\n**options\n\nAdditional options including rtol, atol, max_steps\n{}"
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html#available-solvers-diffrax-0.7.0",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html#available-solvers-diffrax-0.7.0",
    "title": "",
    "section": "Available Solvers (Diffrax 0.7.0)",
    "text": "Available Solvers (Diffrax 0.7.0)\nExplicit Runge-Kutta: - tsit5: Tsitouras 5(4) - recommended for most problems - dopri5: Dormand-Prince 5(4) - dopri8: Dormand-Prince 8(7) - high accuracy - bosh3: Bogacki-Shampine 3(2) - euler: Forward Euler (1st order) - midpoint: Explicit midpoint (2nd order) - heun: Heun’s method (2nd order) - ralston: Ralston’s method (2nd order) - reversible_heun: Reversible Heun (2nd order, reversible)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html#additional-solvers-diffrax-0.8.0",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html#additional-solvers-diffrax-0.8.0",
    "title": "",
    "section": "Additional Solvers (Diffrax 0.8.0+)",
    "text": "Additional Solvers (Diffrax 0.8.0+)\nImplicit methods (for stiff systems): - implicit_euler: Backward Euler (1st order, A-stable) - kvaerno3: Kvaerno 3(2) ESDIRK - kvaerno4: Kvaerno 4(3) ESDIRK - kvaerno5: Kvaerno 5(4) ESDIRK\nIMEX methods (for semi-stiff systems): - sil3: 3rd order IMEX - kencarp3: Kennedy-Carpenter IMEX 3 - kencarp4: Kennedy-Carpenter IMEX 4 - kencarp5: Kennedy-Carpenter IMEX 5\nSpecial methods: - semi_implicit_euler: Semi-implicit Euler (symplectic)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html#notes",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nImplicit and IMEX solvers require Diffrax 0.8.0 or later\nThe integrator will automatically detect which solvers are available\nUse integrator._solver_map.keys() to see available solvers\nSupports autonomous systems (nu=0) by passing u=None\nBackward time integration (t_span with tf &lt; t0) is not supported"
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html#examples",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Controlled system\n&gt;&gt;&gt; integrator = DiffraxIntegrator(system, backend='jax', solver='tsit5')\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=jnp.array([1.0, 0.0]),\n...     u_func=lambda t, x: jnp.array([0.5]),\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; integrator = DiffraxIntegrator(autonomous_system, backend='jax')\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=jnp.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )"
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html#attributes",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nname\nReturn the name of the integrator."
  },
  {
    "objectID": "api/systems.base.numerical_integration.DiffraxIntegrator.html#methods",
    "href": "api/systems.base.numerical_integration.DiffraxIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nintegrate\nIntegrate over time interval with control policy.\n\n\nintegrate_imex\nIntegrate IMEX system with separate explicit and implicit parts.\n\n\nintegrate_with_gradient\nIntegrate and compute gradients w.r.t. initial conditions.\n\n\njit_compile_step\nReturn a JIT-compiled version of the step function.\n\n\nstep\nTake one integration step: x(t) → x(t + dt).\n\n\nvectorized_integrate\nVectorized integration over batch of initial conditions.\n\n\nvectorized_step\nVectorized step over batch of states and controls.\n\n\n\n\nintegrate\nsystems.base.numerical_integration.DiffraxIntegrator.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n)\nIntegrate over time interval with control policy.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable[[float, StateVector], Optional[ControlVector]]\nControl policy: (t, x) → u (or None for autonomous systems)\nrequired\n\n\nt_span\nTimeSpan\nIntegration interval (t_start, t_end) Note: t_end must be &gt; t_start (backward integration not supported)\nrequired\n\n\nt_eval\nOptional[TimePoints]\nSpecific times at which to store solution (must be increasing)\nNone\n\n\ndense_output\nbool\nIf True, return dense interpolated solution\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nTypedDict containing: - t: Time points (T,) - x: State trajectory (T, nx) - success: Whether integration succeeded - message: Status message - nfev: Number of function evaluations - nsteps: Number of steps taken - integration_time: Computation time (seconds) - solver: Integrator name - njev: Number of Jacobian evaluations (if applicable)\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf t_span has tf &lt; t0 (backward integration not supported)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Controlled system\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=jnp.array([1.0, 0.0]),\n...     u_func=lambda t, x: jnp.array([0.5]),\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; result = integrator.integrate(\n...     x0=jnp.array([1.0, 0.0]),\n...     u_func=lambda t, x: None,\n...     t_span=(0.0, 10.0)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Access results\n&gt;&gt;&gt; t = result[\"t\"]\n&gt;&gt;&gt; x_traj = result[\"x\"]\n&gt;&gt;&gt; print(f\"Success: {result['success']}\")\n&gt;&gt;&gt; print(f\"Steps: {result['nsteps']}, Function evals: {result['nfev']}\")\n\n\nNotes\nBackward time integration (tf &lt; t0) is not supported. If you need reverse-time integration, integrate forward and reverse the output:\n\n\n\nInstead of integrate(x0, u_func, (10.0, 0.0))\nresult = integrate(x0, u_func, (0.0, 10.0)) t_reversed = jnp.flip(result[“t”]) x_reversed = jnp.flip(result[“x”], axis=0)\n\n\n\n\n\n\nintegrate_imex\nsystems.base.numerical_integration.DiffraxIntegrator.integrate_imex(\n    x0,\n    explicit_func,\n    implicit_func,\n    t_span,\n    t_eval=None,\n)\nIntegrate IMEX system with separate explicit and implicit parts.\nFor systems of the form: dx/dt = f_explicit(t, x) + f_implicit(t, x)\nwhere f_explicit is non-stiff and f_implicit is stiff.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state\nrequired\n\n\nexplicit_func\nCallable[[float, StateVector], StateVector]\nNon-stiff part: (t, x) -&gt; dx/dt_explicit\nrequired\n\n\nimplicit_func\nCallable[[float, StateVector], StateVector]\nStiff part: (t, x) -&gt; dx/dt_implicit\nrequired\n\n\nt_span\nTimeSpan\nIntegration interval (must have tf &gt; t0)\nrequired\n\n\nt_eval\nOptional[TimePoints]\nEvaluation times\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nIntegrationResult\nIntegration result with IMEX solver\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf solver is not IMEX, IMEX solvers not available, or tf &lt; t0\n\n\n\n\n\nNotes\nIMEX solvers require Diffrax 0.8.0 or later\n\n\nExamples\n&gt;&gt;&gt; # Stiff-nonstiff splitting\n&gt;&gt;&gt; def explicit_part(t, x):\n...     # Non-stiff dynamics\n...     return jnp.array([x[1], 0.0])\n&gt;&gt;&gt;\n&gt;&gt;&gt; def implicit_part(t, x):\n...     # Stiff dynamics\n...     return jnp.array([0.0, -100*x[1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = integrator.integrate_imex(\n...     x0=jnp.array([1.0, 0.0]),\n...     explicit_func=explicit_part,\n...     implicit_func=implicit_part,\n...     t_span=(0.0, 10.0)\n... )\n\n\n\nintegrate_with_gradient\nsystems.base.numerical_integration.DiffraxIntegrator.integrate_with_gradient(\n    x0,\n    u_func,\n    t_span,\n    loss_fn,\n    t_eval=None,\n)\nIntegrate and compute gradients w.r.t. initial conditions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable[[float, StateVector], Optional[ControlVector]]\nControl policy: (t, x) → u\nrequired\n\n\nt_span\nTimeSpan\nIntegration interval (t_start, t_end)\nrequired\n\n\nloss_fn\nCallable[[IntegrationResult], float]\nLoss function on integration result\nrequired\n\n\nt_eval\nOptional[TimePoints]\nEvaluation times\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\nloss\nfloat\nLoss value\n\n\ngrad\nStateVector\nGradient of loss w.r.t. x0\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Define loss (e.g., final state error)\n&gt;&gt;&gt; def loss_fn(result):\n...     x_final = result[\"x\"][-1]\n...     x_target = jnp.array([1.0, 0.0])\n...     return jnp.sum((x_final - x_target)**2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute loss and gradient\n&gt;&gt;&gt; loss, grad = integrator.integrate_with_gradient(\n...     x0=jnp.array([0.0, 0.0]),\n...     u_func=lambda t, x: jnp.zeros(1),\n...     t_span=(0.0, 10.0),\n...     loss_fn=loss_fn\n... )\n&gt;&gt;&gt; print(f\"Loss: {loss:.4f}\")\n&gt;&gt;&gt; print(f\"Gradient: {grad}\")\n\n\n\njit_compile_step\nsystems.base.numerical_integration.DiffraxIntegrator.jit_compile_step()\nReturn a JIT-compiled version of the step function.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\njitted_step\ncallable\nJIT-compiled step function with signature: (x: StateVector, u: Optional[ControlVector], dt: float) -&gt; StateVector\n\n\n\n\n\nNotes\nThe JIT-compiled version does not track statistics for performance. Use the regular step() method if you need statistics tracking.\n\n\nExamples\n&gt;&gt;&gt; # Create JIT-compiled step\n&gt;&gt;&gt; jit_step = integrator.jit_compile_step()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use for fast repeated stepping\n&gt;&gt;&gt; x = jnp.array([1.0, 0.0])\n&gt;&gt;&gt; u = jnp.array([0.5])\n&gt;&gt;&gt; for _ in range(1000):\n...     x = jit_step(x, u, 0.01)\n\n\n\nstep\nsystems.base.numerical_integration.DiffraxIntegrator.step(x, u=None, dt=None)\nTake one integration step: x(t) → x(t + dt).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,) or (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input (nu,) or (batch, nu), or None for autonomous systems\nNone\n\n\ndt\nOptional[ScalarLike]\nStep size (uses self.dt if None)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x(t + dt)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Controlled system\n&gt;&gt;&gt; x_next = integrator.step(\n...     x=jnp.array([1.0, 0.0]),\n...     u=jnp.array([0.5])\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Autonomous system\n&gt;&gt;&gt; x_next = integrator.step(\n...     x=jnp.array([1.0, 0.0]),\n...     u=None\n... )\n\n\n\nvectorized_integrate\nsystems.base.numerical_integration.DiffraxIntegrator.vectorized_integrate(\n    x0_batch,\n    u_func,\n    t_span,\n    t_eval=None,\n)\nVectorized integration over batch of initial conditions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0_batch\nStateVector\nBatched initial states (batch, nx)\nrequired\n\n\nu_func\nCallable[[float, StateVector], Optional[ControlVector]]\nControl policy: (t, x) → u\nrequired\n\n\nt_span\nTimeSpan\nIntegration interval\nrequired\n\n\nt_eval\nOptional[TimePoints]\nEvaluation times\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nlist of IntegrationResult\nIntegration results for each initial condition\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Monte Carlo simulation with 100 initial conditions\n&gt;&gt;&gt; x0_batch = jnp.random.randn(100, 2)\n&gt;&gt;&gt; results = integrator.vectorized_integrate(\n...     x0_batch,\n...     lambda t, x: jnp.zeros(1),\n...     (0.0, 10.0)\n... )\n&gt;&gt;&gt; print(f\"Success rate: {sum(r['success'] for r in results) / 100}\")\n\n\n\nvectorized_step\nsystems.base.numerical_integration.DiffraxIntegrator.vectorized_step(\n    x_batch,\n    u_batch=None,\n    dt=None,\n)\nVectorized step over batch of states and controls.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_batch\nStateVector\nBatched states (batch, nx)\nrequired\n\n\nu_batch\nOptional[ControlVector]\nBatched controls (batch, nu) or None for autonomous\nNone\n\n\ndt\nOptional[ScalarLike]\nStep size\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext states (batch, nx)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Batch of 100 states\n&gt;&gt;&gt; x_batch = jnp.random.randn(100, 2)\n&gt;&gt;&gt; u_batch = jnp.zeros((100, 1))\n&gt;&gt;&gt; x_next_batch = integrator.vectorized_step(x_batch, u_batch)\n&gt;&gt;&gt; print(x_next_batch.shape)  # (100, 2)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nItô SDE form:\ndC_A = [(F/V)·(C_A_feed - C_A) - r]·dt + σ_C·dW_C\ndT = [(F/V)·(T_feed - T) + q_gen + q_removal]·dt + σ_T·dW_T\nwhere: - r = k₀·C_A·exp(-E/T): Reaction rate (Arrhenius) - q_gen = (-ΔH/ρC_p)·r: Heat generation - q_removal = (UA/VρC_p)·(T_jacket - T): Heat removal - σ_C: Concentration noise intensity [mol/(L·√s)] - σ_T: Temperature noise intensity [K/√s] - W_C(t), W_T(t): Independent Wiener processes"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nContinuous-Time Disturbances:\nUnlike discrete models where noise occurs at sampling instants, continuous noise represents: - Turbulent fluctuations (continuous) - Ambient variations (continuous) - Molecular stochasticity (continuous at microscale) - Unmodeled fast dynamics (continuous effective noise)\nNoise Intensities:\n\nσ_C [mol/(L·√s)]:\n\nFeed composition fluctuations\nMixing imperfections (macro-mixing time scale)\nSampling variability\nTypical: 0.0001-0.01 mol/(L·√s)\n\nσ_T [K/√s]:\n\nHeat transfer coefficient variations\nAmbient temperature changes\nJacket flow rate fluctuations\nMost critical (exponential coupling)\nTypical: 0.1-5.0 K/√s\n\n\nWhy Temperature Noise Dominates:\nArrhenius exponential sensitivity: ∂r/∂T = r·(E/T²)\nAt T = 390 K with E = 8750 K: ∂r/∂T ≈ 0.058·r per K\nTemperature noise amplified exponentially through reaction rate, creating strong coupling to concentration dynamics."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#multiple-steady-states-with-noise",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#multiple-steady-states-with-noise",
    "title": "",
    "section": "Multiple Steady States with Noise",
    "text": "Multiple Steady States with Noise\nDeterministic Equilibria: CSTR can have 1, 2, or 3 steady states (saddle-node bifurcation).\nStochastic Equilibria: With noise, “equilibria” become probability distributions: - Stationary distribution p_∞(C_A, T) from Fokker-Planck - May be bimodal (two peaks at stable equilibria) - Transitions between basins via noise\nNoise-Induced Transitions:\nEven from stable equilibrium, noise can cause escape: - Fluctuations occasionally reach saddle point - Once over barrier, fall into other basin - Rare but catastrophic for operation\nMean First Passage Time:\nExpected time to escape from basin: E[τ_escape] ≈ (2π/ω)·exp(ΔV/(σ_T²))\nwhere: - ΔV: Potential barrier (related to saddle height) - ω: Frequency at bottom of well (linearization eigenvalue)\nCritical Noise Level:\nσ_crit where transitions become frequent (τ_escape ~ operation time).\nFor typical CSTR: σ_T_crit ~ 1-5 K/√s\nAbove this, operation at high-conversion becomes unreliable."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#fokker-planck-analysis",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#fokker-planck-analysis",
    "title": "",
    "section": "Fokker-Planck Analysis",
    "text": "Fokker-Planck Analysis\nStationary Distribution:\nFor Itô SDE: dX = f·dt + g·dW\nStationary density satisfies: 0 = -∇·(f·p_∞) + (1/2)·∇·∇·(D·p_∞)\nwhere D = g·gᵀ is diffusion matrix.\nFor CSTR: D = diag(σ_C², σ_T²)\nIn 2D, this is a PDE for p_∞(C_A, T).\nQuasi-Potential:\nFor small noise: p_∞ ∝ exp(-2·Φ/σ²)\nwhere Φ satisfies: f·∇Φ - (1/2)·tr(D·∇∇Φ) = 0\nInterpretation: - Φ is like “energy” or “potential” - Minima at stable equilibria - Maxima at unstable equilibria (saddle points) - System prefers low-Φ regions\nComputing Stationary Distribution:\nMethods: 1. Long-time simulation: Histogram after transient 2. Fokker-Planck solver: Finite difference/element on PDE 3. Path integral: Monte Carlo on action functional"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#stochastic-stability",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#stochastic-stability",
    "title": "",
    "section": "Stochastic Stability",
    "text": "Stochastic Stability\nDifferent from Deterministic Stability:\nDeterministic: Eigenvalues of Jacobian at equilibrium - All Re(λ) &lt; 0 → stable - Any Re(λ) &gt; 0 → unstable\nStochastic: Lyapunov exponent of SDE - λ_L = lim_{t→∞} (1/t)·E[ln||δX(t)||] - λ_L &lt; 0 → stable (perturbations decay) - λ_L &gt; 0 → unstable (perturbations grow)\nNoise Can Stabilize or Destabilize: - Usually: Noise destabilizes (makes λ_L less negative) - Rarely: Noise stabilizes (noise-induced stability)\nFor CSTR: - High-conversion state: Moderately stable deterministically - With noise: Stability margin reduced - Large σ_T can make effectively unstable (frequent escapes)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#optimal-control-under-uncertainty",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#optimal-control-under-uncertainty",
    "title": "",
    "section": "Optimal Control Under Uncertainty",
    "text": "Optimal Control Under Uncertainty\nStochastic HJB Equation:\nFor infinite-horizon problem: 0 = min_u [L(x,u) + (∂V/∂x)ᵀ·f + (1/2)·tr(gᵀ·∂²V/∂x²·g)]\nOptimal control: u*(x) from minimization.\nFor CSTR: - Maintain high-conversion despite noise - Tradeoff: Performance vs robustness - May require backing away from optimal deterministic point\nRisk-Sensitive Control:\nJ_θ = -ln E[exp(-θ·∫₀^∞ L dt)]\nAdjusts conservativeness: - Small θ: Nearly risk-neutral - Large θ: Very risk-averse (stay away from transitions)\nExit Time Control:\nMinimize: E[∫₀^τ L dt]\nwhere τ is first exit time from safe region.\nMaximizes time until failure/transition."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x = [C_A, T] ∈ ℝ₊ × ℝ₊ - Stochastic processes (not deterministic functions) - Multiple modes possible (bimodal distribution)\nControl: u = T_jacket ∈ ℝ₊ - Deterministic control (no noise in actuation)\nNoise: w = [w_C, w_T] - Independent Wiener processes - Continuous-time (Brownian motion)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nF\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nV\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nC_A_feed\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nT_feed\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nk0\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nE\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\ndelta_H\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nrho\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nCp\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nUA\nfloat\nSame as deterministic CSTR (see ContinuousCSTR)\nrequired\n\n\nsigma_C\nfloat\nConcentration noise intensity [mol/(L·√s)] - Continuous-time units: per √s - Typical: 0.0001-0.01 mol/(L·√s) - Conversion to discrete: σ_d = σ_c·√Δt\n0.001\n\n\nsigma_T\nfloat\nTemperature noise intensity [K/√s] - Continuous-time units: per √s - Typical: 0.1-5.0 K/√s - Most critical parameter - Determines transition rates\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nNoise Type: ADDITIVE (state-independent)\nSDE Type: Itô (standard interpretation)\nNoise Dimension: nw = 2\nCorrelation: DIAGONAL (independent)\nStationary: Yes (Fokker-Planck stationary distribution)\nErgodic: Yes (time averages = ensemble averages)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Theoretical Analysis: - Fokker-Planck equation (stationary distribution) - Large deviations (rare events) - Stochastic bifurcations - Exit time problems\n2. Continuous-Time Control: - Stochastic HJB equation - Risk-sensitive control - Optimal stopping - Barrier certificates\n3. Nonlinear Filtering: - Zakai equation (unnormalized density) - Duncan-Mortensen-Zakai equation - Path integral formulation\n4. Reliability Analysis: - Mean first passage time - Transition rate estimation - Safety verification\n5. Validation: - Ground truth for discrete models - Benchmark for approximate methods"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nRecommended Methods: - Euler-Maruyama: dt = 0.01-0.1 s - Milstein: Same as Euler for additive noise - Framework stiff solvers: For stiff CSTR\nConvergence Check: - Halve dt, verify moments unchanged - Weak convergence: E[X], Var[X] - Strong convergence: Sample paths"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#monte-carlo-guidelines",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#monte-carlo-guidelines",
    "title": "",
    "section": "Monte Carlo Guidelines",
    "text": "Monte Carlo Guidelines\nSample Size: - Mean/variance: N = 100-1,000 - Rare events (P ~ 0.01): N = 10,000-100,000 - Use importance sampling for efficiency\nStatistics: - Mean trajectory: μ(t) = (1/N)·Σ X_i(t) - Variance: σ²(t) = (1/N)·Σ (X_i(t) - μ(t))² - Percentiles: 5th, 50th, 95th"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#comparison-with-other-models",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#comparison-with-other-models",
    "title": "",
    "section": "Comparison with Other Models",
    "text": "Comparison with Other Models\nvs. Deterministic CSTR: - Adds process noise - Enables reliability analysis - Captures transitions\nvs. Discrete Stochastic CSTR: - Continuous time (theoretical) - Noise in [state]/√[time] - Fokker-Planck equation\nvs. Stochastic Batch Reactor: - CSTR: Multiple equilibria, continuous operation - Batch: Transient, finite time"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nAdditive noise (not multiplicative)\nConstant noise (not state-dependent)\nNo jumps (only continuous paths)\nComputational cost (Monte Carlo expensive)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nDiscreteStochasticCSTR : Discrete-time version ContinuousCSTR : Deterministic version OrnsteinUhlenbeck : Simple mean-reverting SDE"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.ContinuousStochasticCSTR.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_residence_time\nCompute residence time τ = V/F [s].\n\n\ndefine_system\nDefine continuous-time stochastic CSTR dynamics.\n\n\nestimate_escape_rate\nEstimate escape rate from basin using large deviations theory.\n\n\nfind_steady_states\nFind all steady states of deterministic part.\n\n\nget_noise_intensities\nGet continuous-time noise intensities.\n\n\nsetup_equilibria\nSet up equilibrium points (deterministic part).\n\n\n\n\ncompute_residence_time\nsystems.builtin.stochastic.continuous.ContinuousStochasticCSTR.compute_residence_time(\n)\nCompute residence time τ = V/F [s].\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nResidence time\n\n\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.ContinuousStochasticCSTR.define_system(\n    F_val=100.0,\n    V_val=100.0,\n    C_A_feed_val=1.0,\n    T_feed_val=350.0,\n    k0_val=72000000000.0,\n    E_val=8750.0,\n    delta_H_val=-50000.0,\n    rho_val=1000.0,\n    Cp_val=0.239,\n    UA_val=50000.0,\n    sigma_C=0.001,\n    sigma_T=1.0,\n    x_ss=None,\n    u_ss=None,\n)\nDefine continuous-time stochastic CSTR dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nF_val\nfloat\nVolumetric flow rate [L/s]\n100.0\n\n\nV_val\nfloat\nReactor volume [L]\n100.0\n\n\nC_A_feed_val\nfloat\nFeed concentration [mol/L]\n1.0\n\n\nT_feed_val\nfloat\nFeed temperature [K]\n350.0\n\n\nk0_val\nfloat\nPre-exponential factor [1/s]\n72000000000.0\n\n\nE_val\nfloat\nActivation energy [K] (dimensionless Eₐ/R)\n8750.0\n\n\ndelta_H_val\nfloat\nHeat of reaction [J/mol] (negative = exothermic)\n-50000.0\n\n\nrho_val\nfloat\nDensity [kg/L]\n1000.0\n\n\nCp_val\nfloat\nSpecific heat capacity [J/(kg·K)]\n0.239\n\n\nUA_val\nfloat\nOverall heat transfer coefficient × area [J/(s·K)]\n50000.0\n\n\nx_ss\nOptional[np.ndarray]\nSteady-state [Cₐ, T] for equilibrium setup\nNone\n\n\nu_ss\nOptional[np.ndarray]\nSteady-state [T_jacket] for equilibrium setup\nNone\n\n\nsigma_C\nfloat\nConcentration noise intensity [mol/(L·√s)] - Continuous-time units: per √s - Typical: 0.0001-0.01 mol/(L·√s) - Smaller than batch reactor (continuous operation)\n0.001\n\n\nsigma_T\nfloat\nTemperature noise intensity [K/√s] - Continuous-time units: per √s - Typical: 0.1-5.0 K/√s - Determines transition rates (exponentially) - Critical parameter for reliability\n1.0\n\n\nx_ss\nOptional[np.ndarray]\nKnown steady state (if available)\nNone\n\n\nu_ss\nOptional[np.ndarray]\nKnown steady state (if available)\nNone\n\n\n\n\n\nNotes\nNoise Intensity Selection:\nPhysical reasoning: - σ_C ~ 0.001: Precise control, large reactor - σ_C ~ 0.01: Typical industrial - σ_T ~ 0.5: Good temperature control - σ_T ~ 2.0: Poor control, high variability\nTemperature Noise Impact:\nAt high-conversion (T ≈ 390 K): - σ_T = 0.5 K/√s: Very stable, rare transitions - σ_T = 1.0 K/√s: Occasional transitions (hours) - σ_T = 2.0 K/√s: Frequent transitions (minutes) - σ_T = 5.0 K/√s: Very unstable, constant switching\nDesign Criterion:\nChoose σ_T such that mean first passage time: τ_escape &gt; 100·τ_operation\nEnsures reliable operation (99% success).\nConversion to Discrete:\nFor discrete model with sampling Δt: σ_discrete = σ_continuous·√Δt\nExample: σ_T = 1.0 K/√s, Δt = 5 s → σ_T_discrete = 1.0·√5 ≈ 2.24 K per step\nAdditive vs Multiplicative:\nThis uses additive (state-independent) noise.\nAlternative: Multiplicative noise g(X) = diag(σ_C·C_A, σ_T·T)\nWould represent: - Relative errors (percentage fluctuations) - State-dependent uncertainty - More complex analysis\n\n\n\nestimate_escape_rate\nsystems.builtin.stochastic.continuous.ContinuousStochasticCSTR.estimate_escape_rate(\n    x_basin,\n    barrier_height,\n)\nEstimate escape rate from basin using large deviations theory.\nApproximate formula: Rate ≈ (ω/2π)·exp(-ΔV/σ_T²)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_basin\nnp.ndarray\nState in basin (stable equilibrium)\nrequired\n\n\nbarrier_height\nfloat\nPotential barrier height (energy to saddle)\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEscape rate [1/s]\n\n\n\n\n\nNotes\nThis is an approximation valid for small noise. For accurate rates, use Monte Carlo simulation.\n\n\nExamples\n&gt;&gt;&gt; cstr = ContinuousStochasticCSTR(sigma_T=1.0)\n&gt;&gt;&gt; # Approximate barrier height: 50 K² equivalent\n&gt;&gt;&gt; rate = cstr.estimate_escape_rate(\n...     x_basin=np.array([0.1, 390.0]),\n...     barrier_height=50.0\n... )\n&gt;&gt;&gt; mean_time = 1.0 / rate\n&gt;&gt;&gt; print(f\"Mean escape time: {mean_time:.1f} s\")\n\n\n\nfind_steady_states\nsystems.builtin.stochastic.continuous.ContinuousStochasticCSTR.find_steady_states(\n    T_jacket,\n    T_range=(300.0, 500.0),\n    n_points=100,\n)\nFind all steady states of deterministic part.\nThese are centers of Fokker-Planck stationary distribution.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT_jacket\nfloat\nJacket temperature [K]\nrequired\n\n\nT_range\ntuple\nSearch range\n(300.0, 500.0)\n\n\nn_points\nint\nInitial guesses\n100\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[Tuple[float, float]]\n[(C_A, T), …] steady states\n\n\n\n\n\nNotes\nWith noise, stationary distribution has peaks at these points (if stable) or valleys (if unstable).\n\n\nExamples\n&gt;&gt;&gt; cstr = ContinuousStochasticCSTR()\n&gt;&gt;&gt; states = cstr.find_steady_states(T_jacket=350.0)\n&gt;&gt;&gt; print(f\"Found {len(states)} steady states\")\n\n\n\nget_noise_intensities\nsystems.builtin.stochastic.continuous.ContinuousStochasticCSTR.get_noise_intensities(\n)\nGet continuous-time noise intensities.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{‘sigma_C’: …, ‘sigma_T’: …}\n\n\n\n\n\nNotes\nUnits: [state]/√[time] To convert to discrete: σ_d = σ_c·√Δt\n\n\nExamples\n&gt;&gt;&gt; cstr = ContinuousStochasticCSTR(sigma_C=0.001, sigma_T=1.0)\n&gt;&gt;&gt; noise = cstr.get_noise_intensities()\n&gt;&gt;&gt; print(f\"Temperature noise: {noise['sigma_T']} K/√s\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.continuous.ContinuousStochasticCSTR.setup_equilibria(\n)\nSet up equilibrium points (deterministic part).\nNote: These are centers of stationary distributions. Multiple equilibria may exist. Use find_steady_states()."
  },
  {
    "objectID": "api/types.control_classical.PolePlacementResult.html",
    "href": "api/types.control_classical.PolePlacementResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.PolePlacementResult.html#fields",
    "href": "api/types.control_classical.PolePlacementResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ngain : GainMatrix State feedback gain K (nu, nx) desired_poles : np.ndarray Desired closed-loop eigenvalues achieved_poles : np.ndarray Actual achieved eigenvalues of (A - BK) is_controllable : bool System must be controllable for arbitrary placement"
  },
  {
    "objectID": "api/types.control_classical.PolePlacementResult.html#examples",
    "href": "api/types.control_classical.PolePlacementResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; A = np.array([[0, 1], [-2, -3]])\n&gt;&gt;&gt; B = np.array([[0], [1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Place poles for faster response\n&gt;&gt;&gt; desired_poles = np.array([-5, -6])\n&gt;&gt;&gt; result: PolePlacementResult = pole_placement(A, B, desired_poles)\n&gt;&gt;&gt;\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt; print(result['is_controllable'])  # True\n&gt;&gt;&gt; print(np.allclose(result['achieved_poles'], result['desired_poles']))  # True\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Verify\n&gt;&gt;&gt; A_cl = A - B @ K\n&gt;&gt;&gt; actual_poles = np.linalg.eigvals(A_cl)\n&gt;&gt;&gt; print(np.sort(actual_poles))  # [-6, -5]"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#physical-system",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA well-mixed batch reactor where chemical species A converts to B,\nwhich then converts to product C. The reactor operates in continuous\ntime with differential equations governing the evolution of concentrations\nand temperature.\n\nThe reaction sequence is:\n    A → B → C\n\nBoth reactions are first-order and temperature-dependent following\nArrhenius kinetics. Temperature affects reaction rates exponentially,\ncreating strong nonlinear coupling between composition and thermal\ndynamics."
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#state-space",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x = [Cₐ, Cᵦ, T]\n    Concentration states:\n    - Cₐ: Concentration of reactant A [mol/L]\n      * Initial concentration typically Cₐ(0) = 1.0 mol/L\n      * Decreases monotonically (consumed by first reaction)\n      * Must remain non-negative: Cₐ ≥ 0\n\n    - Cᵦ: Concentration of intermediate B [mol/L]\n      * Produced from A, consumed to form C\n      * Non-monotonic: rises then falls\n      * Maximum occurs when r₁ = r₂ (production = consumption)\n      * Must remain non-negative: Cᵦ ≥ 0\n\n    Temperature state:\n    - T: Reactor temperature [K]\n      * Typical range: 300-400 K (27-127°C)\n      * Affects reaction rates exponentially via Arrhenius\n      * Subject to heat loss to ambient (cooling)\n      * Controlled by external heating Q\n\nControl: u = [Q]\n    - Q: Heating/cooling rate [K/s]\n      * Q &gt; 0: Heating applied\n      * Q &lt; 0: Active cooling\n      * Q = 0: Natural heat loss only\n      * Typical range: -50 to +50 K/s\n\nOutput: y = [Cₐ, Cᵦ, T]\n    - Full state measurement (all concentrations and temperature)\n    - In practice, concentration may be measured via:\n      * Spectroscopy (UV-Vis, IR)\n      * Chromatography (GC, HPLC)\n      * Online analyzers\n    - Temperature measured via thermocouple or RTD"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#dynamics",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe continuous-time dynamics are:\n\n    dCₐ/dt = -r₁\n    dCᵦ/dt = r₁ - r₂\n    dT/dt = Q - α·(T - Tₐₘᵦ)\n\n**Reaction Rates (Arrhenius kinetics)**:\n    r₁ = k₁·Cₐ·exp(-E₁/T)    [mol/(L·s)]\n    r₂ = k₂·Cᵦ·exp(-E₂/T)    [mol/(L·s)]\n\nwhere:\n- k₁, k₂: Pre-exponential factors (frequency factors)\n- E₁, E₂: Activation energies [K] (using Eₐ/R as temperature)\n- exp(-E/T): Arrhenius temperature dependence\n\n**Physical Interpretation**:\n\nReaction 1 (A → B):\n- Rate r₁ proportional to Cₐ (first-order kinetics)\n- Exponentially increases with temperature\n- Higher E₁ → more temperature sensitive\n- Depletes reactant A, produces intermediate B\n\nReaction 2 (B → C):\n- Rate r₂ proportional to Cᵦ (first-order kinetics)\n- Exponentially increases with temperature\n- Higher E₂ → more temperature sensitive\n- Consumes intermediate B, produces final product C\n\nTemperature dynamics:\n- Q: External heating/cooling control\n- -α·(T - Tₐₘᵦ): Heat loss to ambient (Newton's cooling)\n- α: Heat transfer coefficient [1/s]\n- Tₐₘᵦ: Ambient temperature [K]\n\n**Nonlinear Coupling**:\nThe system exhibits strong nonlinear coupling:\n1. Temperature affects reaction rates exponentially\n2. Reactions may be exothermic/endothermic (not modeled here)\n3. Competing reactions create non-monotonic Cᵦ profile"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#parameters",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nk1 : float, default=0.5\n    Pre-exponential factor for reaction 1 (A→B) [1/s]\n    Higher k₁ → faster depletion of A\n    Typical range: 0.1 - 10.0\n\nk2 : float, default=0.3\n    Pre-exponential factor for reaction 2 (B→C) [1/s]\n    Higher k₂ → faster conversion of B to C\n    Typical range: 0.1 - 10.0\n\nE1 : float, default=1000.0\n    Activation energy for reaction 1 [K] (actually Eₐ/R)\n    Higher E₁ → more sensitive to temperature\n    Physical Eₐ typically 8,000 - 30,000 K\n\nE2 : float, default=1500.0\n    Activation energy for reaction 2 [K] (actually Eₐ/R)\n    E₂ &gt; E₁ means reaction 2 is more temperature-sensitive\n    Creates selectivity control via temperature\n\nalpha : float, default=0.1\n    Heat transfer coefficient [1/s]\n    Characterizes cooling rate to ambient\n    Higher α → faster heat loss, harder to maintain temperature\n\nT_amb : float, default=300.0\n    Ambient temperature [K] (27°C)\n    System equilibrium temperature with Q = 0"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#equilibria",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\n**Steady-state (complete conversion)**:\n    x_eq = [0, 0, Tₐₘᵦ]  (all reactants consumed, cooled to ambient)\n    u_eq = 0  (no heating needed)\n\nThis equilibrium is reached asymptotically as t → ∞ when:\n- All A has converted to B: Cₐ → 0\n- All B has converted to C: Cᵦ → 0\n- Temperature equilibrates with ambient: T → Tₐₘᵦ\n\nThis is a **stable equilibrium** (globally attracting).\n\n**Optimal operating point** (maximum B yield):\n    If goal is to maximize Cᵦ at a specific time, equilibrium\n    concept doesn't apply. Instead, use optimal control to find\n    temperature trajectory Q(t) that maximizes Cᵦ at final time.\n\n**Temperature setpoint equilibrium** (partial reaction):\n    For constant T* &gt; Tₐₘᵦ maintained by control:\n    - Requires Q_eq = α·(T* - Tₐₘᵦ) to balance heat loss\n    - Concentrations evolve according to reaction kinetics at T*\n    - Not a true equilibrium (Cₐ, Cᵦ still changing)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#control-objectives",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\nCommon control goals for batch reactors:\n\n1. **Temperature tracking**: Maintain T(t) ≈ T_ref(t)\n   - Maximize reaction rate\n   - Ensure safety (prevent runaway)\n   - PID/LQR/MPC controllers typical\n\n2. **Yield optimization**: Maximize Cᵦ at final time\n   - Requires optimal temperature trajectory\n   - May involve heating → cooling profile\n   - Calculus of variations or optimal control\n\n3. **Batch time minimization**: Reach Cₐ &lt; ε in minimum time\n   - Subject to temperature constraints (T_min ≤ T ≤ T_max)\n   - Bang-bang control often optimal\n\n4. **Selectivity control**: Maximize ratio Cᵦ/Cᶜ\n   - Exploit different activation energies (E₁ vs E₂)\n   - Intermediate temperature maximizes B"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#state-constraints",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\nPhysical constraints that must be enforced:\n\n1. **Non-negativity**: Cₐ(t) ≥ 0, Cᵦ(t) ≥ 0\n   - Concentrations cannot be negative\n   - Physical meaning: species present or absent\n\n2. **Conservation**: Cₐ(t) + Cᵦ(t) + Cᶜ(t) = Cₐ(0)\n   - Total moles conserved (if C tracked)\n   - Useful for validation\n\n3. **Temperature limits**: T_min ≤ T(t) ≤ T_max\n   - Safety: prevent runaway or solidification\n   - Typical: 280 K ≤ T ≤ 450 K\n\n4. **Actuation limits**: Q_min ≤ Q(t) ≤ Q_max\n   - Physical heating/cooling capacity\n   - Typical: -50 ≤ Q ≤ 50 K/s"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#numerical-integration",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration:",
    "text": "Numerical Integration:\n**Stiffness**: This system can be **moderately stiff** due to:\n- Exponential temperature dependence (Arrhenius)\n- Different time scales (fast reactions at high T, slow cooling)\n- Stiffness ratio ≈ exp((E₂ - E₁)/T)\n\n**Recommended Solvers**:\n- **Moderate stiffness**: RK45 (adaptive Runge-Kutta)\n- **High stiffness**: Radau, BDF (implicit methods)\n- **High accuracy**: Vern7, Vern9 (Julia DiffEq)\n- **GPU acceleration**: JAX with diffrax\n\n**Tolerance Selection**:\n- Standard: rtol=1e-6, atol=1e-8\n- High accuracy: rtol=1e-9, atol=1e-11\n- Tighter tolerances needed for optimization"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#example-usage",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n&gt;&gt;&gt; # Create reactor with default parameters\n&gt;&gt;&gt; reactor = ContinuousBatchReactor()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Initial condition: fresh batch\n&gt;&gt;&gt; x0 = np.array([1.0, 0.0, 350.0])  # [Cₐ, Cᵦ, T]\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simulate with constant heating\n&gt;&gt;&gt; def controller(x, t):\n...     return np.array([10.0])  # Constant Q = 10 K/s\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = reactor.simulate(\n...     x0=x0,\n...     controller=controller,\n...     t_span=(0, 100),\n...     dt=0.1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Plot concentration profiles\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(result['time'], result['states'][:, 0], label='Cₐ')\n&gt;&gt;&gt; plt.plot(result['time'], result['states'][:, 1], label='Cᵦ')\n&gt;&gt;&gt; plt.xlabel('Time (s)')\n&gt;&gt;&gt; plt.ylabel('Concentration [mol/L]')\n&gt;&gt;&gt; plt.legend()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design LQR temperature controller\n&gt;&gt;&gt; T_ref = 360.0  # Reference temperature\n&gt;&gt;&gt; x_ref = np.array([0.5, 0.3, T_ref])\n&gt;&gt;&gt; u_ref = reactor._calculate_steady_heating(T_ref)\n&gt;&gt;&gt;\n&gt;&gt;&gt; A, B = reactor.linearize(x_ref, u_ref)\n&gt;&gt;&gt; Q_lqr = np.diag([0, 0, 100])  # Only care about temperature\n&gt;&gt;&gt; R_lqr = np.array([[1.0]])\n&gt;&gt;&gt; lqr_result = reactor.control.design_lqr(A, B, Q_lqr, R_lqr,\n...                                          system_type='continuous')\n&gt;&gt;&gt; K = lqr_result['gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Simulate with LQR control\n&gt;&gt;&gt; def lqr_controller(x, t):\n...     return -K @ (x - x_ref) + u_ref\n&gt;&gt;&gt;\n&gt;&gt;&gt; result_lqr = reactor.simulate(x0, lqr_controller, t_span=(0, 100), dt=0.1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or use integrate() for adaptive time stepping\n&gt;&gt;&gt; result_adaptive = reactor.integrate(\n...     x0=x0,\n...     u=lqr_controller,\n...     t_span=(0, 100),\n...     method='Radau',  # Stiff solver\n...     rtol=1e-8,\n...     atol=1e-10\n... )"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#physical-insights",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\n**Reaction Selectivity**:\nSince E₂ &gt; E₁ (default), reaction 2 is more temperature-sensitive.\nThis means:\n- Low T: Slow r₂, Cᵦ accumulates (favors intermediate)\n- High T: Fast r₂, Cᵦ depletes quickly (favors product)\n\n**Temperature Control Strategy**:\nTo maximize Cᵦ yield:\n1. Heat initially to accelerate reaction 1 (produce B)\n2. Cool before reaction 2 becomes too fast (preserve B)\n3. Optimal trajectory: heating → plateau → cooling\n\n**Batch Time vs. Yield Tradeoff**:\n- High temperature: Fast reactions, short batch time, but may\n  overshoot optimal Cᵦ (too much conversion to C)\n- Low temperature: Slow reactions, long batch time, but can\n  maintain high Cᵦ for longer\n- Economic optimum balances these factors\n\n**Safety Considerations**:\n- Exothermic reactions (not modeled) can cause thermal runaway\n- High temperature reduces selectivity, may form byproducts\n- Emergency cooling (Q &lt; 0) must be available\n- Temperature constraints critical for safe operation\n\n**Comparison with Discrete Version**:\nThis continuous-time model is the \"ground truth\" that discrete\nsystems approximate:\n- Discrete system: Uses Euler/RK4 discretization with fixed dt\n- Continuous system: Adaptive time stepping, arbitrary accuracy\n- Use discretize() method to create discrete version:\n        reactor_discrete = reactor.discretize(dt=1.0, method='rk4')"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#see-also",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nDiscreteBatchReactor : Discrete-time version of this system\nContinuousCSTR : Continuous stirred-tank reactor (continuous flow)\nLorenz : Another nonlinear continuous system with multiple equilibria\nVanDerPolOscillator : Continuous nonlinear oscillator with limit cycle"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#notes",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n**Stiffness Detection**: If integration is slow or fails, try:\n1. Check condition number of Jacobian\n2. Use stiff solver (Radau, BDF)\n3. Reduce temperature range\n4. Use Julia backend for better stiff solvers\n\n**Optimal Control**: For batch optimization:\n1. Define cost functional: J = -Cᵦ(t_f) + ∫(Q²/R)dt\n2. Solve using Pontryagin's maximum principle\n3. Or use direct methods (collocation, multiple shooting)\n4. Result: Bang-bang or singular arc control\n\n**Parameter Estimation**: If fitting to data:\n1. Minimize ||data - model(θ)||²\n2. Use scipy.optimize.minimize with integrate()\n3. May need to estimate k₁, k₂, E₁, E₂, α\n4. Ensure identifiability (different θ → different output)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#methods",
    "href": "api/systems.builtin.deterministic.continuous.ContinuousBatchReactor.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncalculate_steady_heating\nCalculate steady-state heating required to maintain temperature setpoint.\n\n\ncompute_conversion\nCompute fractional conversion of reactant A.\n\n\ncompute_selectivity\nCompute selectivity to intermediate B.\n\n\ncompute_yield\nCompute yield of intermediate B.\n\n\ndefine_system\nDefine symbolic continuous-time batch reactor dynamics.\n\n\nsetup_equilibria\nSet up equilibrium points for the batch reactor.\n\n\n\n\ncalculate_steady_heating\nsystems.builtin.deterministic.continuous.ContinuousBatchReactor.calculate_steady_heating(\n    T_setpoint,\n)\nCalculate steady-state heating required to maintain temperature setpoint.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT_setpoint\nfloat\nDesired reactor temperature [K]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nRequired heating rate Q [K/s]\n\n\n\n\n\nNotes\nAt steady state (constant T), heat input must balance heat loss: Q = α·(T - T_amb)\n\n\n\ncompute_conversion\nsystems.builtin.deterministic.continuous.ContinuousBatchReactor.compute_conversion(\n    C_A,\n    C_A0,\n)\nCompute fractional conversion of reactant A.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_A\nfloat\nCurrent concentration of A [mol/L]\nrequired\n\n\nC_A0\nfloat\nInitial concentration of A [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nConversion fraction X_A (0 = no conversion, 1 = complete)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; reactor = ContinuousBatchReactor()\n&gt;&gt;&gt; X = reactor.compute_conversion(C_A=0.3, C_A0=1.0)\n&gt;&gt;&gt; print(f\"Conversion: {X*100:.1f}%\")\nConversion: 70.0%\n\n\n\ncompute_selectivity\nsystems.builtin.deterministic.continuous.ContinuousBatchReactor.compute_selectivity(\n    C_B,\n    C_A,\n    C_A0,\n)\nCompute selectivity to intermediate B.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_B\nfloat\nCurrent concentration of B [mol/L]\nrequired\n\n\nC_A\nfloat\nCurrent concentration of A [mol/L]\nrequired\n\n\nC_A0\nfloat\nInitial concentration of A [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nSelectivity S_B = C_B / (C_A0 - C_A) (moles B per mole A converted)\n\n\n\n\n\nNotes\nSelectivity measures how much intermediate B is produced per mole of A consumed. Values: - S_B = 1.0: Perfect selectivity (all A → B, no B → C yet) - S_B &lt; 1.0: Some B has already converted to C - S_B → 0: Most B has converted to C (over-reacted)\n\n\nExamples\n&gt;&gt;&gt; reactor = ContinuousBatchReactor()\n&gt;&gt;&gt; S = reactor.compute_selectivity(C_B=0.5, C_A=0.3, C_A0=1.0)\n&gt;&gt;&gt; print(f\"Selectivity: {S:.2f} mol B / mol A converted\")\n\n\n\ncompute_yield\nsystems.builtin.deterministic.continuous.ContinuousBatchReactor.compute_yield(\n    C_B,\n    C_A0,\n)\nCompute yield of intermediate B.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_B\nfloat\nCurrent concentration of B [mol/L]\nrequired\n\n\nC_A0\nfloat\nInitial concentration of A [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nYield Y_B = C_B / C_A0 (moles B per initial mole A)\n\n\n\n\n\nNotes\nYield is the most important metric for batch optimization. Combines both conversion and selectivity: Y_B = X_A · S_B\n\n\nExamples\n&gt;&gt;&gt; reactor = ContinuousBatchReactor()\n&gt;&gt;&gt; Y = reactor.compute_yield(C_B=0.4, C_A0=1.0)\n&gt;&gt;&gt; print(f\"Yield: {Y*100:.1f}%\")\nYield: 40.0%\n\n\n\ndefine_system\nsystems.builtin.deterministic.continuous.ContinuousBatchReactor.define_system(\n    k1_val=0.5,\n    k2_val=0.3,\n    E1_val=1000.0,\n    E2_val=1500.0,\n    alpha_val=0.1,\n    T_amb_val=300.0,\n    C_A0=None,\n    T0=None,\n)\nDefine symbolic continuous-time batch reactor dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk1_val\nfloat\nPre-exponential factor for A→B reaction [1/s]\n0.5\n\n\nk2_val\nfloat\nPre-exponential factor for B→C reaction [1/s]\n0.3\n\n\nE1_val\nfloat\nActivation energy for reaction 1 [K]\n1000.0\n\n\nE2_val\nfloat\nActivation energy for reaction 2 [K]\n1500.0\n\n\nalpha_val\nfloat\nHeat transfer coefficient [1/s]\n0.1\n\n\nT_amb_val\nfloat\nAmbient temperature [K]\n300.0\n\n\nC_A0\nOptional[float]\nInitial concentration of A for equilibrium setup [mol/L]\nNone\n\n\nT0\nOptional[float]\nInitial temperature for equilibrium setup [K]\nNone\n\n\n\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.continuous.ContinuousBatchReactor.setup_equilibria(\n)\nSet up equilibrium points for the batch reactor.\nAdds two equilibria: 1. ‘complete’: Complete conversion (Cₐ=0, Cᵦ=0, T=Tₐₘᵦ) 2. ‘initial’: Optional initial state if C_A0 and T0 specified"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotionWithDrift.html",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotionWithDrift.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nsystems.builtin.stochastic.continuous.BrownianMotionWithDrift\nsystems.builtin.stochastic.continuous.BrownianMotionWithDrift(*args, **kwargs)\nAlias for GeometricBrownianMotion.\nAlternative name sometimes used in literature. Mathematically identical to GBM."
  },
  {
    "objectID": "api/types.trajectories.TrajectorySegment.html",
    "href": "api/types.trajectories.TrajectorySegment.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.TrajectorySegment.html#attributes",
    "href": "api/types.trajectories.TrajectorySegment.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nstates\nStateTrajectory\nState trajectory segment\n\n\ncontrols\nOptional[ControlSequence]\nControl sequence segment\n\n\ntime\nTimePoints\nTime points for segment\n\n\nstart_index\nint\nIndex in original trajectory where segment starts\n\n\nend_index\nint\nIndex in original trajectory where segment ends"
  },
  {
    "objectID": "api/types.trajectories.TrajectorySegment.html#examples",
    "href": "api/types.trajectories.TrajectorySegment.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; def extract_segment(\n...     result: SimulationResult,\n...     t_start: float,\n...     t_end: float\n... ) -&gt; TrajectorySegment:\n...     '''Extract trajectory segment.'''\n...     time = result['time']\n...     mask = (time &gt;= t_start) & (time &lt;= t_end)\n...     indices = np.where(mask)[0]\n...\n...     return TrajectorySegment(\n...         states=result['states'][mask],\n...         controls=result['controls'][mask[:-1]] if 'controls' in result else None,\n...         time=time[mask],\n...         start_index=indices[0],\n...         end_index=indices[-1],\n...     )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract transient response (first 2 seconds)\n&gt;&gt;&gt; segment: TrajectorySegment = extract_segment(result, 0.0, 2.0)\n&gt;&gt;&gt; transient_states = segment['states']"
  },
  {
    "objectID": "api/types.core.ControlPolicy.html",
    "href": "api/types.core.ControlPolicy.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.ControlPolicy.html#parameters",
    "href": "api/types.core.ControlPolicy.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,)\nrequired"
  },
  {
    "objectID": "api/types.core.ControlPolicy.html#returns",
    "href": "api/types.core.ControlPolicy.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nControlVector\nControl action (nu,)"
  },
  {
    "objectID": "api/types.core.ControlPolicy.html#examples",
    "href": "api/types.core.ControlPolicy.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # LQR policy\n&gt;&gt;&gt; def lqr_policy(x: StateVector) -&gt; ControlVector:\n...     return -K @ x\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Nonlinear policy\n&gt;&gt;&gt; def nonlinear_policy(x: StateVector) -&gt; ControlVector:\n...     return -np.tanh(K @ x)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Neural network policy\n&gt;&gt;&gt; def nn_policy(x: StateVector) -&gt; ControlVector:\n...     return model.forward(torch.tensor(x)).numpy()"
  },
  {
    "objectID": "api/types.estimation.UKFResult.html",
    "href": "api/types.estimation.UKFResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.estimation.UKFResult.html#fields",
    "href": "api/types.estimation.UKFResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nstate_estimate : StateVector State estimate x̂[k] (nx,) covariance : CovarianceMatrix Error covariance P[k] (nx, nx) innovation : OutputVector Measurement innovation y[k] - ŷ[k] (ny,) sigma_points : StateTrajectory Sigma points used χᵢ (2nx+1, nx) weights_mean : ArrayLike Weights for mean computation wᵢᵐ (2nx+1,) weights_covariance : ArrayLike Weights for covariance computation wᵢᶜ (2*nx+1,)"
  },
  {
    "objectID": "api/types.estimation.UKFResult.html#examples",
    "href": "api/types.estimation.UKFResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Highly nonlinear system (bearings-only tracking)\n&gt;&gt;&gt; def dynamics(x, u):\n...     # State: [x_pos, y_pos, x_vel, y_vel]\n...     dt = 0.1\n...     F = np.array([[1, 0, dt, 0],\n...                   [0, 1, 0, dt],\n...                   [0, 0, 1, 0],\n...                   [0, 0, 0, 1]])\n...     return F @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; def measurement(x):\n...     # Measure bearing angle only\n...     return np.array([np.arctan2(x[1], x[0])])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create UKF with tuned parameters\n&gt;&gt;&gt; ukf = UnscentedKalmanFilter(\n...     dynamics_fn=dynamics,\n...     measurement_fn=measurement,\n...     Q=0.01 * np.eye(4),\n...     R=0.05 * np.eye(1),\n...     alpha=0.001,  # Spread of sigma points\n...     beta=2.0,     # Prior knowledge (2 = Gaussian)\n...     kappa=0.0     # Secondary scaling parameter\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Initialize\n&gt;&gt;&gt; ukf.initialize(x0=np.array([1.0, 1.0, 0.1, 0.1]), P0=np.eye(4))\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update\n&gt;&gt;&gt; result: UKFResult = ukf.update(y_measured)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Inspect sigma points (useful for debugging)\n&gt;&gt;&gt; sigma_points = result['sigma_points']\n&gt;&gt;&gt; print(f\"Sigma points shape: {sigma_points.shape}\")  # (9, 4)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Visualize sigma point spread\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.scatter(sigma_points[:, 0], sigma_points[:, 1])\n&gt;&gt;&gt; plt.title(\"UKF Sigma Points\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check weights\n&gt;&gt;&gt; w_mean = result['weights_mean']\n&gt;&gt;&gt; print(f\"Weight sum: {np.sum(w_mean):.6f}\")  # Should be 1.0"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.analyze_noise_structure.html",
    "href": "api/systems.base.utils.stochastic.analyze_noise_structure.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.analyze_noise_structure.html#parameters",
    "href": "api/systems.base.utils.stochastic.analyze_noise_structure.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndiffusion_expr\nsp.Matrix\nSymbolic diffusion matrix\nrequired\n\n\nstate_vars\nList[sp.Symbol]\nState variables\nrequired\n\n\ncontrol_vars\nList[sp.Symbol]\nControl variables\nrequired\n\n\ntime_var\nsp.Symbol\nTime variable\nNone"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.analyze_noise_structure.html#returns",
    "href": "api/systems.base.utils.stochastic.analyze_noise_structure.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNoiseCharacteristics\nAnalysis results"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.analyze_noise_structure.html#examples",
    "href": "api/systems.base.utils.stochastic.analyze_noise_structure.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; x = sp.symbols('x')\n&gt;&gt;&gt; diffusion = sp.Matrix([[0.1 * x, 0.05 * x]])\n&gt;&gt;&gt; char = analyze_noise_structure(diffusion, [x], [])\n&gt;&gt;&gt; print(char.noise_type)\nNoiseType.MULTIPLICATIVE"
  },
  {
    "objectID": "api/types.estimation.ParticleFilterResult.html",
    "href": "api/types.estimation.ParticleFilterResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.estimation.ParticleFilterResult.html#fields",
    "href": "api/types.estimation.ParticleFilterResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nstate_estimate : StateVector Mean of particle distribution x̂[k] = Σ wᵢ xᵢ (nx,) covariance : CovarianceMatrix Sample covariance P[k] (nx, nx) particles : StateTrajectory All particle states (n_particles, nx) weights : ArrayLike Normalized particle weights wᵢ (n_particles,) effective_sample_size : float ESS = 1/Σwᵢ² ∈ [1, n_particles] resampled : bool Whether resampling occurred this step"
  },
  {
    "objectID": "api/types.estimation.ParticleFilterResult.html#examples",
    "href": "api/types.estimation.ParticleFilterResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Highly nonlinear system with non-Gaussian noise\n&gt;&gt;&gt; def dynamics(x, u, noise):\n...     # Chaotic dynamics with state-dependent noise\n...     return np.array([\n...         x[1],\n...         -np.sin(x[0]) + u[0] + noise[0] * (1 + x[0]**2)\n...     ])\n&gt;&gt;&gt;\n&gt;&gt;&gt; def measurement(x, noise):\n...     # Nonlinear measurement with outliers\n...     return np.array([x[0]**2 + noise[0]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create Particle Filter\n&gt;&gt;&gt; pf = ParticleFilter(\n...     dynamics_fn=dynamics,\n...     measurement_fn=measurement,\n...     n_particles=1000,\n...     resampling_threshold=0.5  # Resample when ESS &lt; 500\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Initialize particles\n&gt;&gt;&gt; pf.initialize(\n...     x0_mean=np.array([0.0, 0.0]),\n...     x0_cov=np.eye(2)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Update loop\n&gt;&gt;&gt; for k in range(N):\n...     # Predict (propagate particles through dynamics)\n...     pf.predict(u[k], Q=0.1*np.eye(2))\n...\n...     # Update (weight by measurement likelihood)\n...     result: ParticleFilterResult = pf.update(y[k], R=0.5*np.eye(1))\n...\n...     # Extract estimate\n...     x_hat = result['state_estimate']\n...     P = result['covariance']\n...\n...     # Monitor particle degeneracy\n...     ess = result['effective_sample_size']\n...     if ess &lt; 100:\n...         print(f\"Warning: Low ESS = {ess:.0f} at k={k}\")\n...\n...     # Check if resampling occurred\n...     if result['resampled']:\n...         print(f\"Resampling at k={k}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Visualize particle distribution\n&gt;&gt;&gt; particles = result['particles']\n&gt;&gt;&gt; weights = result['weights']\n&gt;&gt;&gt;\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.scatter(particles[:, 0], particles[:, 1],\n...            s=weights*1000, alpha=0.5)\n&gt;&gt;&gt; plt.title(f\"Particle Distribution (ESS={ess:.0f})\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute credible intervals from particles\n&gt;&gt;&gt; x_samples = particles[:, 0]\n&gt;&gt;&gt; x_lower = np.percentile(x_samples, 2.5, weights=weights)\n&gt;&gt;&gt; x_upper = np.percentile(x_samples, 97.5, weights=weights)\n&gt;&gt;&gt; print(f\"95% credible interval: [{x_lower:.3f}, {x_upper:.3f}]\")"
  },
  {
    "objectID": "api/systems.base.numerical_integration.list_all_methods.html",
    "href": "api/systems.base.numerical_integration.list_all_methods.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.list_all_methods.html#returns",
    "href": "api/systems.base.numerical_integration.list_all_methods.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with all methods organized by category: - deterministic_fixed_step : list - deterministic_adaptive : list - sde_fixed_step : list - sde_adaptive : list - all_canonical : list"
  },
  {
    "objectID": "api/systems.base.numerical_integration.list_all_methods.html#examples",
    "href": "api/systems.base.numerical_integration.list_all_methods.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; methods = list_all_methods()\n&gt;&gt;&gt; print(f\"Total methods: {sum(len(v) for v in methods.values())}\")\n&gt;&gt;&gt; print(f\"SDE methods: {len(methods['sde_fixed_step']) + len(methods['sde_adaptive'])}\")"
  },
  {
    "objectID": "api/types.linearization.StochasticLinearization.html",
    "href": "api/types.linearization.StochasticLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.StochasticLinearization.html#examples",
    "href": "api/types.linearization.StochasticLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Continuous SDE linearization\n&gt;&gt;&gt; Ac, Bc, Gc = sde_system.linearize(\n...     x_eq=np.zeros(2),\n...     u_eq=np.zeros(1)\n... )\n&gt;&gt;&gt; print(Ac.shape)  # (2, 2)\n&gt;&gt;&gt; print(Bc.shape)  # (2, 1)\n&gt;&gt;&gt; print(Gc.shape)  # (2, nw)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Process noise covariance\n&gt;&gt;&gt; Q = Gc @ Gc.T\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Discrete stochastic linearization\n&gt;&gt;&gt; Ad, Bd, Gd = discrete_stochastic.linearize(\n...     x_eq=np.zeros(2),\n...     u_eq=np.zeros(1)\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Design LQG controller\n&gt;&gt;&gt; # 1. LQR for control\n&gt;&gt;&gt; P_control = solve_discrete_are(Ad, Bd, Q_cost, R_cost)\n&gt;&gt;&gt; K_lqr = np.linalg.inv(R_cost + Bd.T @ P_control @ Bd) @ (Bd.T @ P_control @ Ad)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # 2. Kalman for estimation\n&gt;&gt;&gt; Q_noise = Gd @ Gd.T\n&gt;&gt;&gt; P_estimate = solve_discrete_are(Ad.T, Cd.T, Q_noise, R_noise)\n&gt;&gt;&gt; L_kalman = Ad @ P_estimate @ Cd.T @ np.linalg.inv(Cd @ P_estimate @ Cd.T + R_noise)"
  },
  {
    "objectID": "api/types.protocols.LinearizableDiscreteProtocol.html",
    "href": "api/types.protocols.LinearizableDiscreteProtocol.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.protocols.LinearizableDiscreteProtocol.html#implementations",
    "href": "api/types.protocols.LinearizableDiscreteProtocol.html#implementations",
    "title": "",
    "section": "Implementations",
    "text": "Implementations\nConcrete classes that satisfy this protocol: - DiscreteSymbolicSystem: Symbolic Jacobians via automatic differentiation - DiscreteStochasticSystem: Symbolic Jacobians + diffusion matrix - DiscretizedSystem: Wraps continuous linearization then discretizes - LinearizedDiscreteSystem: Explicitly provided A, B matrices"
  },
  {
    "objectID": "api/types.protocols.LinearizableDiscreteProtocol.html#required-methods-in-addition-to-discretesystemprotocol",
    "href": "api/types.protocols.LinearizableDiscreteProtocol.html#required-methods-in-addition-to-discretesystemprotocol",
    "title": "",
    "section": "Required Methods (in addition to DiscreteSystemProtocol)",
    "text": "Required Methods (in addition to DiscreteSystemProtocol)\nlinearize(x_eq, u_eq) -&gt; (Ad, Bd) Compute discrete Jacobian matrices"
  },
  {
    "objectID": "api/types.protocols.LinearizableDiscreteProtocol.html#use-cases",
    "href": "api/types.protocols.LinearizableDiscreteProtocol.html#use-cases",
    "title": "",
    "section": "Use Cases",
    "text": "Use Cases\n\nLQR controller design\nModel Predictive Control (MPC) with linearization\nPole placement\nDiscrete Kalman filter design\nStability analysis (eigenvalue-based)\nControllability/observability analysis\nMost modern control algorithms"
  },
  {
    "objectID": "api/types.protocols.LinearizableDiscreteProtocol.html#examples",
    "href": "api/types.protocols.LinearizableDiscreteProtocol.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nLQR design function:\n&gt;&gt;&gt; from scipy.linalg import solve_discrete_are\n&gt;&gt;&gt;\n&gt;&gt;&gt; def design_lqr(\n...     system: LinearizableDiscreteProtocol,\n...     Q: np.ndarray,\n...     R: np.ndarray,\n...     x_eq: Optional[StateVector] = None,\n...     u_eq: Optional[ControlVector] = None\n... ) -&gt; LQRResult:\n...     '''Design LQR controller for any linearizable discrete system.'''\n...     # Default to origin\n...     if x_eq is None:\n...         x_eq = np.zeros(system.nx)\n...         u_eq = np.zeros(system.nu)\n...\n...     # Get linearization\n...     Ad, Bd = system.linearize(x_eq, u_eq)\n...\n...     # Solve discrete-time algebraic Riccati equation\n...     P = solve_discrete_are(Ad, Bd, Q, R)\n...     K = np.linalg.inv(R + Bd.T @ P @ Bd) @ (Bd.T @ P @ Ad)\n...\n...     # Check closed-loop stability\n...     A_cl = Ad - Bd @ K\n...     eigenvalues = np.linalg.eigvals(A_cl)\n...\n...     return {\n...         \"K\": K,\n...         \"P\": P,\n...         \"eigenvalues\": eigenvalues,\n...         \"cost\": x_eq.T @ P @ x_eq\n...     }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Works with DiscreteSymbolicSystem\n&gt;&gt;&gt; symbolic_sys = DiscreteOscillator(dt=0.01)\n&gt;&gt;&gt; result1 = design_lqr(symbolic_sys, Q, R)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Also works with DiscretizedSystem\n&gt;&gt;&gt; continuous = Pendulum(m=1.0, l=0.5)\n&gt;&gt;&gt; discretized = DiscretizedSystem(continuous, dt=0.01)\n&gt;&gt;&gt; result2 = design_lqr(discretized, Q, R)  # ✓ Same function!\nStability analysis:\n&gt;&gt;&gt; def check_stability(system: LinearizableDiscreteProtocol) -&gt; bool:\n...     '''Check if discrete system is stable at origin.'''\n...     Ad, Bd = system.linearize(\n...         np.zeros(system.nx),\n...         np.zeros(system.nu)\n...     )\n...     eigenvalues = np.linalg.eigvals(Ad)\n...     return np.all(np.abs(eigenvalues) &lt; 1.0)\n&gt;&gt;&gt;\n&gt;&gt;&gt; is_stable = check_stability(any_discrete_system)  # Works with any!\nMPC with linearization:\n&gt;&gt;&gt; def mpc_step(\n...     system: LinearizableDiscreteProtocol,\n...     x_current: StateVector,\n...     x_ref: StateVector,\n...     horizon: int = 10\n... ) -&gt; ControlVector:\n...     '''MPC using linearization around reference.'''\n...     # Linearize around reference\n...     Ad, Bd = system.linearize(x_ref, np.zeros(system.nu))\n...\n...     # Solve QP for optimal control\n...     # ... MPC formulation ...\n...     return u_optimal"
  },
  {
    "objectID": "api/types.protocols.LinearizableDiscreteProtocol.html#notes",
    "href": "api/types.protocols.LinearizableDiscreteProtocol.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nThe linearization is typically valid only for small deviations from the equilibrium point: δx = x - x_eq, δu = u - u_eq.\nFor nonlinear systems, linearization provides a local approximation useful for controller design, but may not capture global behavior.\nThe runtime_checkable? decorator enables isinstance() checks at runtime, though this should be used sparingly in favor of static type checking."
  },
  {
    "objectID": "api/types.protocols.LinearizableDiscreteProtocol.html#methods",
    "href": "api/types.protocols.LinearizableDiscreteProtocol.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nlinearize\nCompute discrete-time linearization: Ad = ∂f/∂x, Bd = ∂f/∂u.\n\n\n\n\nlinearize\ntypes.protocols.LinearizableDiscreteProtocol.linearize(x_eq, u_eq=None)\nCompute discrete-time linearization: Ad = ∂f/∂x, Bd = ∂f/∂u.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control (nu,), None = zero control\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteLinearization\nTuple (Ad, Bd) of Jacobian matrices: - Ad: State transition matrix (nx, nx) - Bd: Control input matrix (nx, nu)"
  },
  {
    "objectID": "api/types.core.SystemDimensions.html",
    "href": "api/types.core.SystemDimensions.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.SystemDimensions.html#attributes",
    "href": "api/types.core.SystemDimensions.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nnx\nint\nState dimension\n\n\nnu\nint\nControl dimension\n\n\nny\nint\nOutput dimension\n\n\nnw\nint\nNoise dimension (stochastic systems only)\n\n\nnp\nint\nParameter dimension (for learning/adaptation)"
  },
  {
    "objectID": "api/types.core.SystemDimensions.html#examples",
    "href": "api/types.core.SystemDimensions.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Deterministic system\n&gt;&gt;&gt; dims: SystemDimensions = {'nx': 3, 'nu': 2, 'ny': 3}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stochastic system\n&gt;&gt;&gt; dims_stochastic: SystemDimensions = {\n...     'nx': 2, 'nu': 1, 'ny': 2, 'nw': 2\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With parameters\n&gt;&gt;&gt; dims_adaptive: SystemDimensions = {\n...     'nx': 3, 'nu': 1, 'ny': 3, 'np': 5\n... }"
  },
  {
    "objectID": "api/types.linearization.LinearizationCacheKey.html",
    "href": "api/types.linearization.LinearizationCacheKey.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.LinearizationCacheKey.html#examples",
    "href": "api/types.linearization.LinearizationCacheKey.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; key: LinearizationCacheKey = \"x_eq=abc123_u_eq=def456_method=euler\"\n&gt;&gt;&gt; cache[key] = (Ad, Bd)"
  },
  {
    "objectID": "api/types.backends.DiscretizationMethod.html",
    "href": "api/types.backends.DiscretizationMethod.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\ntypes.backends.DiscretizationMethod\ntypes.backends.DiscretizationMethod\nDiscretization method for continuous → discrete transformation."
  },
  {
    "objectID": "api/types.linearization.DeterministicLinearization.html",
    "href": "api/types.linearization.DeterministicLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.DeterministicLinearization.html#examples",
    "href": "api/types.linearization.DeterministicLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Continuous system linearization\n&gt;&gt;&gt; Ac, Bc = continuous_system.linearize(\n...     x_eq=np.zeros(2),\n...     u_eq=np.zeros(1)\n... )\n&gt;&gt;&gt; print(Ac.shape)  # (2, 2)\n&gt;&gt;&gt; print(Bc.shape)  # (2, 1)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Use for LQR design\n&gt;&gt;&gt; from scipy.linalg import solve_continuous_are\n&gt;&gt;&gt; P = solve_continuous_are(Ac, Bc, Q, R)\n&gt;&gt;&gt; K = np.linalg.inv(R) @ Bc.T @ P\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Discrete system linearization\n&gt;&gt;&gt; Ad, Bd = discrete_system.linearize(\n...     x_eq=np.zeros(2),\n...     u_eq=np.zeros(1)\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Check stability\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(Ad)\n&gt;&gt;&gt; is_stable = np.all(np.abs(eigenvalues) &lt; 1.0)"
  },
  {
    "objectID": "api/types.control_classical.KalmanFilterResult.html",
    "href": "api/types.control_classical.KalmanFilterResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.control_classical.KalmanFilterResult.html#fields",
    "href": "api/types.control_classical.KalmanFilterResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\ngain : GainMatrix Kalman gain L of shape (nx, ny) estimation_error_covariance : CovarianceMatrix Steady-state error covariance P (nx, nx) innovation_covariance : CovarianceMatrix Innovation covariance S = CPC’ + R (ny, ny) estimator_eigenvalues : np.ndarray Eigenvalues of (A - LC) - determines convergence rate"
  },
  {
    "objectID": "api/types.control_classical.KalmanFilterResult.html#examples",
    "href": "api/types.control_classical.KalmanFilterResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Design Kalman filter\n&gt;&gt;&gt; A = np.array([[1, 0.1], [0, 0.9]])\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position only\n&gt;&gt;&gt; Q_process = 0.01 * np.eye(2)  # Process noise covariance\n&gt;&gt;&gt; R_meas = 0.1 * np.eye(1)      # Measurement noise covariance\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: KalmanFilterResult = design_kalman_filter(A, C, Q_process, R_meas)\n&gt;&gt;&gt; L = result['gain']\n&gt;&gt;&gt; print(L.shape)  # (2, 1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # State estimation loop\n&gt;&gt;&gt; x_hat = np.zeros(2)\n&gt;&gt;&gt; for k in range(N):\n...     # Prediction\n...     x_hat_pred = A @ x_hat + B @ u[k]\n...\n...     # Update (correction)\n...     innovation = y[k] - C @ x_hat_pred\n...     x_hat = x_hat_pred + L @ innovation\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check observer stability\n&gt;&gt;&gt; print(np.all(np.abs(result['estimator_eigenvalues']) &lt; 1))  # True\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Innovation statistics\n&gt;&gt;&gt; S = result['innovation_covariance']\n&gt;&gt;&gt; print(S.shape)  # (1, 1)"
  },
  {
    "objectID": "api/systems.base.core.discretize.html",
    "href": "api/systems.base.core.discretize.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.discretize.html#parameters",
    "href": "api/systems.base.core.discretize.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncontinuous_system\nContinuousSystemBase\nContinuous system to discretize\nrequired\n\n\ndt\nfloat\nSampling time step (seconds)\nrequired\n\n\nmethod\nstr\nIntegration method. Can use canonical names (‘euler_maruyama’, ‘rk45’) or backend-specific names. Method name is automatically normalized for the system’s backend.\n'rk4'\n\n\n**kwargs\n\nAdditional arguments passed to DiscretizedSystem\n{}"
  },
  {
    "objectID": "api/systems.base.core.discretize.html#returns",
    "href": "api/systems.base.core.discretize.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscretizedSystem\nDiscretized system ready for simulation"
  },
  {
    "objectID": "api/systems.base.core.discretize.html#examples",
    "href": "api/systems.base.core.discretize.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; from controldesymulation.systems.examples import Pendulum\n&gt;&gt;&gt; continuous = Pendulum(m=1.0, l=0.5)\n&gt;&gt;&gt; discrete = discretize(continuous, dt=0.01)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#stochastic-differential-equations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#stochastic-differential-equations",
    "title": "",
    "section": "Stochastic Differential Equations",
    "text": "Stochastic Differential Equations\nState-space form with noise on velocities:\ndx = ẋ·dt\ndẋ = [(F + m·L·θ̇²·sin(θ) - m·L·θ̈·cos(θ))/(M+m)]·dt + σ_x·dW_x\ndθ = θ̇·dt\ndθ̇ = [(g·sin(θ) - cos(θ)·(F + m·L·θ̇²·sin(θ))/(M+m)) /\n      (L·(4/3 - m·cos²(θ)/(M+m)))]·dt + σ_θ·dW_θ\nwhere: - x: Cart position [m] - ẋ: Cart velocity [m/s] - θ: Pole angle from upward vertical [rad] - θ̇: Pole angular velocity [rad/s] - F: Applied horizontal force (control) [N] - σ_x: Cart disturbance intensity [m/(s²·√s)] - σ_θ: Pole disturbance intensity [rad/(s²·√s)] - W_x, W_θ: Independent Wiener processes\nDeterministic Part: Same coupled nonlinear dynamics as deterministic cart-pole. See CartPole or DiscreteCartPole for detailed derivation.\nStochastic Part: Additive noise on velocity derivatives models: - Cart: Ground vibrations, wind on cart body - Pole: Wind on pole, measurement/actuation noise"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nCart Noise (σ_x):\nSources: - Ground irregularities (bumps, friction variations) - Wind gusts on cart - Motor noise (torque ripple) - Track vibrations\nEffect: - Horizontal disturbances - Couples to pole via inertial forces - Less critical than pole noise\nPole Noise (σ_θ):\nSources: - Wind on pole (large moment arm) - Joint friction variations - Measurement noise (affects observer) - Structural flexibility\nEffect: - Directly affects unstable mode - Most critical for stability - Primary cause of falling\nWhy Pole Noise Dominates:\nUpright equilibrium is unstable in θ: - Eigenvalue: λ ≈ +√(g/L) &gt; 0 (exponentially unstable) - Small θ perturbation grows exponentially - Noise on θ̇ integrates to θ → falling\nCart position (x) is marginally stable: - Can drift but doesn’t diverge - Less critical for balance"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#key-features",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#key-features",
    "title": "",
    "section": "Key Features",
    "text": "Key Features\nUnderactuated + Noise: - 4 states, 1 control, 2 noise sources - Cannot independently control all modes - Noise affects modes directly\nUnstable + Noise: - Upright equilibrium exponentially unstable - Noise continuously perturbs - Requires fast, accurate control\nNonlinear + Noise: - Coupling via sin(θ), cos(θ) - Small angle approximation poor under noise - Need nonlinear control/estimation\nBistable: - Upright (unstable) vs downward (stable) - Noise can cause transitions - Swing-up under noise challenging"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: X = [x, ẋ, θ, θ̇] - x ∈ ℝ: Cart position (track limits in practice) - ẋ ∈ ℝ: Cart velocity - θ ∈ ℝ: Pole angle (|θ| &lt; π/4 for balance typically) - θ̇ ∈ ℝ: Pole angular velocity\nControl: u = F ∈ ℝ - Horizontal force on cart [N] - Bounded: |F| ≤ F_max typically\nNoise: w = [w_x, w_θ] ∈ ℝ² - Independent Wiener processes - Enter velocity equations"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nM\nfloat\nCart mass [kg]\n1.0\n\n\nm\nfloat\nPole mass [kg]\n0.1\n\n\nL\nfloat\nPole half-length [m]\n0.5\n\n\ng\nfloat\nGravity [m/s²]\n9.81\n\n\nb_cart\nfloat\nCart friction [N·s/m]\n0.1\n\n\nb_pole\nfloat\nPole friction [N·m·s/rad]\n0.0\n\n\nsigma_x\nfloat\nCart noise intensity [m/(s²·√s)] - Typical: 0.01-1.0 - Less critical than σ_θ\n0.1\n\n\nsigma_theta\nfloat\nPole noise intensity [rad/(s²·√s)] - Typical: 0.01-0.5 - Most critical parameter - Determines mean time to failure\n0.05"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\n\nSystem Type: NONLINEAR\nNoise Type: ADDITIVE (on velocities)\nSDE Type: Itô\nNoise Dimension: nw = 2\nStationary: No (open-loop)\nBistable: Yes (upright vs downward)\nUnstable: Yes (upright equilibrium)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Robust Control: - LQG near upright (linearized) - Robust H∞ control - Stochastic MPC with chance constraints - Risk-sensitive control\n2. State Estimation: - EKF for balance (linearized) - UKF for swing-up (nonlinear) - Particle filter for multimodal\n3. Reinforcement Learning: - Robust RL with noise - Domain randomization - Sim-to-real transfer\n4. Reliability Analysis: - Mean time to failure - Probability of falling - Safety verification\n5. Sensor Fusion: - IMU + encoders - Kalman filter for fusion - Complementary filtering"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#numerical-integration",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#numerical-integration",
    "title": "",
    "section": "Numerical Integration",
    "text": "Numerical Integration\nRecommended: - Euler-Maruyama: dt = 0.001-0.01 s - Check falling: |θ| &gt; threshold - Monitor constraints\nEvent Detection: Terminate when falling: - |θ| &gt; π/4 (45°) - |x| &gt; x_max (track end)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#monte-carlo-guidelines",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#monte-carlo-guidelines",
    "title": "",
    "section": "Monte Carlo Guidelines",
    "text": "Monte Carlo Guidelines\nReliability Assessment: - N = 100-1,000 runs - Record failure times - Compute success rate, MTF\nStatistics: - Mean trajectory ± 2σ bands - Histogram of max |θ| - Distribution of failure times"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#comparison-with-deterministic",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#comparison-with-deterministic",
    "title": "",
    "section": "Comparison with Deterministic",
    "text": "Comparison with Deterministic\nDeterministic: - Perfect upright stabilization - Deterministic swing-up - Infinite uptime with LQR\nStochastic: - Probabilistic stabilization - Swing-up success rate - Finite mean time to failure"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#limitations",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nAdditive noise only (not multiplicative)\nIndependent noise sources\nNo actuator noise (only process)\nRigid body (no flexibility)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\n\nMultiplicative noise: σ(X)\nActuator noise: u → u + noise\nMeasurement delays\nFlexible pole\n3D cart-pole"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nCartPole : Deterministic version DiscreteCartPole : Discrete-time deterministic StochasticPendulum : Simpler (no cart)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.StochasticCartPole.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncompute_energy\nCompute total mechanical energy.\n\n\ndefine_system\nDefine stochastic cart-pole dynamics.\n\n\nestimate_mean_time_to_failure\nEstimate mean time to failure (very rough approximation).\n\n\nget_noise_intensities\nGet noise intensity parameters.\n\n\nsetup_equilibria\nSet up equilibrium points (deterministic part).\n\n\n\n\ncompute_energy\nsystems.builtin.stochastic.continuous.StochasticCartPole.compute_energy(x)\nCompute total mechanical energy.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState [x, ẋ, θ, θ̇]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nTotal energy [J]\n\n\n\n\n\nNotes\nEnergy fluctuates due to noise (not conserved).\n\n\nExamples\n&gt;&gt;&gt; cartpole = StochasticCartPole()\n&gt;&gt;&gt; x = np.array([0.0, 0.5, 0.1, 0.2])\n&gt;&gt;&gt; E = cartpole.compute_energy(x)\n&gt;&gt;&gt; print(f\"Energy: {E:.3f} J\")\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.StochasticCartPole.define_system(\n    M=1.0,\n    m=0.1,\n    L=0.5,\n    g=9.81,\n    b_cart=0.1,\n    b_pole=0.0,\n    sigma_x=0.1,\n    sigma_theta=0.05,\n)\nDefine stochastic cart-pole dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nM\nfloat\nCart mass [kg]\n1.0\n\n\nm\nfloat\nPole mass [kg]\n0.1\n\n\nL\nfloat\nPole half-length [m]\n0.5\n\n\ng\nfloat\nGravity [m/s²]\n9.81\n\n\nb_cart\nfloat\nCart friction [N·s/m]\n0.1\n\n\nb_pole\nfloat\nPole friction [N·m·s/rad]\n0.0\n\n\nsigma_x\nfloat\nCart disturbance intensity [m/(s²·√s)] - Horizontal disturbances - Typical: 0.01-1.0 - Less critical than σ_θ\n0.1\n\n\nsigma_theta\nfloat\nPole disturbance intensity [rad/(s²·√s)] - Angular disturbances - Typical: 0.01-0.5 - MOST CRITICAL for stability - Determines mean time to failure\n0.05\n\n\n\n\n\nNotes\nNoise Intensity Guidelines:\nCart noise (σ_x): - Small (0.01): Lab conditions, smooth track - Medium (0.1): Typical industrial - Large (1.0): Rough terrain, high wind\nPole noise (σ_θ): - Small (0.01): Precise control, low wind - Medium (0.05): Typical outdoor - Large (0.2): High wind, poor sensors\nCritical: σ_θ Determines Reliability\nExponential dependence: MTF ~ exp(θ_max²/σ_θ²)\nExample (θ_max = 0.2 rad ≈ 11.5°): - σ_θ = 0.01: MTF ~ exp(400) ~ infinite - σ_θ = 0.05: MTF ~ exp(16) ~ 9 million seconds ~ 3 months - σ_θ = 0.1: MTF ~ exp(4) ~ 55 seconds - σ_θ = 0.2: MTF ~ exp(1) ~ 3 seconds\nSmall increase in noise → huge decrease in reliability!\nNoise Correlation:\nCurrently: Independent noise on x and θ.\nIn reality: May be correlated (common wind gust affects both). Extension: Use 2×2 covariance matrix.\nPhysical Validation:\nCheck noise levels are reasonable: 1. Simulate deterministic + stochastic 2. Compare trajectories (should be similar but not identical) 3. Success rate should be 50-95% (not 0% or 100%)\nDesign Tradeoff:\nSmaller noise: - More reliable (longer MTF) - Easier control problem - Less realistic\nLarger noise: - Less reliable (shorter MTF) - Harder control (robustness needed) - More realistic\nChoose based on application requirements.\n\n\n\nestimate_mean_time_to_failure\nsystems.builtin.stochastic.continuous.StochasticCartPole.estimate_mean_time_to_failure(\n    theta_max=0.2,\n    control_gain=None,\n)\nEstimate mean time to failure (very rough approximation).\nUses Kramers-like formula: MTF ~ exp(θ_max²·κ/σ_θ²)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntheta_max\nfloat\nFailure threshold [rad]\n0.2\n\n\ncontrol_gain\nOptional[float]\nEffective stabilization strength (if None, estimate from g/L)\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nEstimated MTF [s]\n\n\n\n\n\nNotes\nThis is very approximate! For accurate MTF, use Monte Carlo.\n\n\nExamples\n&gt;&gt;&gt; cartpole = StochasticCartPole(sigma_theta=0.05)\n&gt;&gt;&gt; mtf = cartpole.estimate_mean_time_to_failure(theta_max=0.2)\n&gt;&gt;&gt; print(f\"Estimated MTF: {mtf:.2e} seconds\")\n\n\n\nget_noise_intensities\nsystems.builtin.stochastic.continuous.StochasticCartPole.get_noise_intensities()\nGet noise intensity parameters.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\n{‘sigma_x’: …, ‘sigma_theta’: …}\n\n\n\n\n\nExamples\n&gt;&gt;&gt; cartpole = StochasticCartPole(sigma_x=0.1, sigma_theta=0.05)\n&gt;&gt;&gt; noise = cartpole.get_noise_intensities()\n&gt;&gt;&gt; print(f\"Pole noise (critical): {noise['sigma_theta']}\")\n\n\n\nsetup_equilibria\nsystems.builtin.stochastic.continuous.StochasticCartPole.setup_equilibria()\nSet up equilibrium points (deterministic part).\nNote: With noise, cannot maintain exact equilibrium. These are nominal targets that fluctuate."
  },
  {
    "objectID": "api/systems.base.utils.SymbolicValidator.html",
    "href": "api/systems.base.utils.SymbolicValidator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.SymbolicValidator.html#examples",
    "href": "api/systems.base.utils.SymbolicValidator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; validator = SymbolicValidator(system)\n&gt;&gt;&gt; result = validator.validate()\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result.is_valid:\n...     print(\"System is valid!\")\n... else:\n...     print(f\"Errors: {result.errors}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Raise exception on error\n&gt;&gt;&gt; try:\n...     result = validator.validate(raise_on_error=True)\n... except ValidationError as e:\n...     print(f\"Validation failed: {e}\")"
  },
  {
    "objectID": "api/systems.base.utils.SymbolicValidator.html#methods",
    "href": "api/systems.base.utils.SymbolicValidator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nvalidate\nValidate system definition.\n\n\nvalidate_system\nStatic convenience method for one-off validation.\n\n\n\n\nvalidate\nsystems.base.utils.SymbolicValidator.validate(raise_on_error=True)\nValidate system definition.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nraise_on_error\nbool\nIf True, raise ValidationError on validation failure If False, return SymbolicValidationResult with errors\nTrue\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSymbolicValidationResult\nValidation results with errors, warnings, and info\n\n\n\n\n\nRaises\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValidationError\nIf validation fails and raise_on_error=True\n\n\n\n\n\nExamples\n&gt;&gt;&gt; result = validator.validate(raise_on_error=False)\n&gt;&gt;&gt; if not result.is_valid:\n...     for error in result.errors:\n...         print(f\"Error: {error}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or raise on error\n&gt;&gt;&gt; try:\n...     validator.validate(raise_on_error=True)\n... except ValidationError as e:\n...     print(f\"Validation failed: {e}\")\n\n\n\nvalidate_system\nsystems.base.utils.SymbolicValidator.validate_system(\n    system,\n    raise_on_error=True,\n)\nStatic convenience method for one-off validation.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsystem\nSymbolicDynamicalSystem\nSystem to validate\nrequired\n\n\nraise_on_error\nbool\nIf True, raise ValidationError on failure\nTrue\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSymbolicValidationResult\nValidation results\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValidationError\nIf invalid and raise_on_error=True\n\n\n\n\n\nExamples\n&gt;&gt;&gt; result = SymbolicValidator.validate_system(my_system)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or without raising\n&gt;&gt;&gt; result = SymbolicValidator.validate_system(\n...     my_system, raise_on_error=False\n... )"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nA well-mixed batch reactor where chemical species A converts to B, which then converts to product C. The reactor operates in discrete time steps (sampling intervals) typical of: - Digital control systems with periodic measurements - Batch processing with staged operations - Industrial reactors with discrete valve/heater actuation\nThe reaction sequence is: A → B → C\nBoth reactions are first-order and temperature-dependent following Arrhenius kinetics. Temperature affects reaction rates exponentially, creating strong nonlinear coupling between composition and thermal dynamics."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[k] = [Cₐ[k], Cᵦ[k], T[k]] Concentration states: - Cₐ: Concentration of reactant A [mol/L] * Initial concentration typically Cₐ[0] = 1.0 mol/L * Decreases monotonically (consumed by first reaction) * Must remain non-negative: Cₐ ≥ 0\n- Cᵦ: Concentration of intermediate B [mol/L]\n  * Produced from A, consumed to form C\n  * Non-monotonic: rises then falls\n  * Maximum occurs when r₁ = r₂ (production = consumption)\n  * Must remain non-negative: Cᵦ ≥ 0\n\nTemperature state:\n- T: Reactor temperature [K]\n  * Typical range: 300-400 K (27-127°C)\n  * Affects reaction rates exponentially via Arrhenius\n  * Subject to heat loss to ambient (cooling)\n  * Controlled by external heating Q\nControl: u[k] = [Q[k]] - Q: Heating/cooling rate [K/s] * Q &gt; 0: Heating applied * Q &lt; 0: Active cooling * Q = 0: Natural heat loss only * Typical range: -50 to +50 K/s\nOutput: y[k] = [Cₐ[k], Cᵦ[k], T[k]] - Full state measurement (all concentrations and temperature) - In practice, concentration may be measured via: * Spectroscopy (UV-Vis, IR) * Chromatography (GC, HPLC) * Online analyzers - Temperature measured via thermocouple or RTD"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#dynamics",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe discrete-time dynamics use Euler discretization:\nCₐ[k+1] = Cₐ[k] - dt·r₁[k]\nCᵦ[k+1] = Cᵦ[k] + dt·(r₁[k] - r₂[k])\nT[k+1] = T[k] + dt·(Q[k] - α·(T[k] - Tₐₘᵦ))\nReaction Rates (Arrhenius kinetics): r₁[k] = k₁·Cₐ[k]·exp(-E₁/T[k]) [mol/(L·s)] r₂[k] = k₂·Cᵦ[k]·exp(-E₂/T[k]) [mol/(L·s)]\nwhere: - k₁, k₂: Pre-exponential factors (frequency factors) - E₁, E₂: Activation energies [K] (using Eₐ/R as temperature) - exp(-E/T): Arrhenius temperature dependence\nPhysical Interpretation:\nReaction 1 (A → B): - Rate r₁ proportional to Cₐ (first-order kinetics) - Exponentially increases with temperature - Higher E₁ → more temperature sensitive - Depletes reactant A, produces intermediate B\nReaction 2 (B → C): - Rate r₂ proportional to Cᵦ (first-order kinetics) - Exponentially increases with temperature - Higher E₂ → more temperature sensitive - Consumes intermediate B, produces final product C\nTemperature dynamics: - Q[k]: External heating/cooling control - -α·(T - Tₐₘᵦ): Heat loss to ambient (Newton’s cooling) - α: Heat transfer coefficient [1/s] - Tₐₘᵦ: Ambient temperature [K]\nNonlinear Coupling: The system exhibits strong nonlinear coupling: 1. Temperature affects reaction rates exponentially 2. Reactions may be exothermic/endothermic (not modeled here) 3. Competing reactions create non-monotonic Cᵦ profile"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nk1 : float, default=0.5 Pre-exponential factor for reaction 1 (A→B) [1/s] Higher k₁ → faster depletion of A Typical range: 0.1 - 10.0\nk2 : float, default=0.3 Pre-exponential factor for reaction 2 (B→C) [1/s] Higher k₂ → faster conversion of B to C Typical range: 0.1 - 10.0\nE1 : float, default=1000.0 Activation energy for reaction 1 [K] (actually Eₐ/R) Higher E₁ → more sensitive to temperature Physical Eₐ typically 8,000 - 30,000 K\nE2 : float, default=1500.0 Activation energy for reaction 2 [K] (actually Eₐ/R) E₂ &gt; E₁ means reaction 2 is more temperature-sensitive Creates selectivity control via temperature\nalpha : float, default=0.1 Heat transfer coefficient [1/s] Characterizes cooling rate to ambient Higher α → faster heat loss, harder to maintain temperature\nT_amb : float, default=300.0 Ambient temperature [K] (27°C) System equilibrium temperature with Q = 0\ndt : float, default=1.0 Sampling/discretization time step [s] Critical parameter affecting stability: - Too large → numerical instability - Too small → slow simulation, control system bandwidth Typical: 0.1 - 10.0 seconds"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#equilibria",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#equilibria",
    "title": "",
    "section": "Equilibria:",
    "text": "Equilibria:\nSteady-state (complete conversion): x_eq = [0, 0, Tₐₘᵦ] (all reactants consumed, cooled to ambient) u_eq = 0 (no heating needed)\nThis equilibrium is reached after sufficient batch time when: - All A has converted to B: Cₐ → 0 - All B has converted to C: Cᵦ → 0 - Temperature equilibrates with ambient: T → Tₐₘᵦ\nThis is a stable equilibrium (globally attracting).\nOptimal operating point (maximum B yield): If goal is to maximize Cᵦ at a specific time, equilibrium concept doesn’t apply. Instead, use optimal control to find temperature trajectory Q[k] that maximizes Cᵦ at final time.\nTemperature setpoint equilibrium (partial reaction): For constant T* &gt; Tₐₘᵦ maintained by control: - Requires Q_eq = α·(T* - Tₐₘᵦ) to balance heat loss - Concentrations evolve according to reaction kinetics at T* - Not a true equilibrium (Cₐ, Cᵦ still changing)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\nCommon control goals for batch reactors:\n\nTemperature tracking: Maintain T[k] ≈ T_ref[k]\n\nMaximize reaction rate\nEnsure safety (prevent runaway)\nLQR/MPC controllers typical\n\nYield optimization: Maximize Cᵦ at final time\n\nRequires optimal temperature trajectory\nMay involve heating → cooling profile\nDynamic programming or direct optimization\n\nBatch time minimization: Reach Cₐ &lt; ε in minimum time\n\nSubject to temperature constraints (T_min ≤ T ≤ T_max)\nBang-bang control often optimal\n\nSelectivity control: Maximize ratio Cᵦ/Cᶜ\n\nExploit different activation energies (E₁ vs E₂)\nIntermediate temperature maximizes B"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#state-constraints",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#state-constraints",
    "title": "",
    "section": "State Constraints:",
    "text": "State Constraints:\nPhysical constraints that must be enforced:\n\nNon-negativity: Cₐ[k] ≥ 0, Cᵦ[k] ≥ 0\n\nConcentrations cannot be negative\nEuler discretization may violate if dt too large\n\nConservation: Cₐ[k] + Cᵦ[k] + Cᶜ[k] = Cₐ[0]\n\nTotal moles conserved (if C tracked)\nUseful for validation\n\nTemperature limits: T_min ≤ T[k] ≤ T_max\n\nSafety: prevent runaway or solidification\nTypical: 280 K ≤ T ≤ 450 K\n\nActuation limits: Q_min ≤ Q[k] ≤ Q_max\n\nPhysical heating/cooling capacity\nTypical: -50 ≤ Q ≤ 50 K/s"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\nStability: The explicit Euler discretization is stable if: dt &lt; 1/λ_max\nwhere λ_max is the maximum eigenvalue of the Jacobian.\nFor this system, linearizing around typical operating points: λ_max ≈ max(k₁·exp(-E₁/T), k₂·exp(-E₂/T), α)\nAt high temperature, reaction rates can be very fast, requiring small dt for stability. Rule of thumb: dt &lt; 0.1 / max(k₁·exp(-E₁/T), k₂·exp(-E₂/T))\nAccuracy: Higher-order methods (RK4, etc.) can be used: system_continuous = ContinuousBatchReactor(…) system_discrete = system_continuous.discretize(dt=1.0, method=‘rk4’)\nStiffness: If E₁ ≫ E₂ or vice versa, system may be stiff, requiring implicit methods or very small dt."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate reactor with default parameters\nreactor = DiscreteBatchReactor(dt=0.5)\nInitial condition: fresh batch\nx0 = np.array([1.0, 0.0, 350.0]) # [Cₐ, Cᵦ, T]\nSimulate with constant heating\nresult = reactor.simulate( … x0=x0, … u_sequence=np.array([10.0]), # Constant Q = 10 K/s … n_steps=100 … )\nPlot concentration profiles\nimport matplotlib.pyplot as plt plt.plot(result[‘time_steps’], result[‘states’][:, 0], label=‘Cₐ’) plt.plot(result[‘time_steps’], result[‘states’][:, 1], label=‘Cᵦ’) plt.xlabel(‘Time step’) plt.ylabel(‘Concentration [mol/L]’) plt.legend()\nDesign LQR temperature controller\nT_ref = 360.0 # Reference temperature x_ref = np.array([0.5, 0.3, T_ref]) u_ref = reactor._calculate_steady_heating(T_ref)\nAd, Bd = reactor.linearize(x_ref, u_ref) Q_lqr = np.diag([0, 0, 100]) # Only care about temperature R_lqr = np.array([[1.0]]) lqr_result = reactor.control.design_lqr(Ad, Bd, Q_lqr, R_lqr, … system_type=‘discrete’) K = lqr_result[‘gain’]\nSimulate with LQR control\ndef lqr_controller(x, k): … return -K @ (x - x_ref) + u_ref\nresult_lqr = reactor.rollout(x0, lqr_controller, n_steps=100)"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nReaction Selectivity: Since E₂ &gt; E₁ (default), reaction 2 is more temperature-sensitive. This means: - Low T: Slow r₂, Cᵦ accumulates (favors intermediate) - High T: Fast r₂, Cᵦ depletes quickly (favors product)\nTemperature Control Strategy: To maximize Cᵦ yield: 1. Heat initially to accelerate reaction 1 (produce B) 2. Cool before reaction 2 becomes too fast (preserve B) 3. Optimal trajectory: heating → plateau → cooling\nBatch Time vs. Yield Tradeoff: - High temperature: Fast reactions, short batch time, but may overshoot optimal Cᵦ (too much conversion to C) - Low temperature: Slow reactions, long batch time, but can maintain high Cᵦ for longer - Economic optimum balances these factors\nSafety Considerations: - Exothermic reactions (not modeled) can cause thermal runaway - High temperature reduces selectivity, may form byproducts - Emergency cooling (Q &lt; 0) must be available - Temperature constraints critical for safe operation"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nContinuousBatchReactor : Continuous-time version of this system DiscreteCSTR : Continuous stirred-tank reactor (continuous flow) LogisticMap : Simpler discrete nonlinear dynamics DiscretePendulum : Another discrete nonlinear control problem"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.DiscreteBatchReactor.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncalculate_steady_heating\nCalculate steady-state heating required to maintain temperature setpoint.\n\n\ncompute_conversion\nCompute fractional conversion of reactant A.\n\n\ncompute_selectivity\nCompute selectivity to intermediate B.\n\n\ncompute_yield\nCompute yield of intermediate B.\n\n\ndefine_system\nDefine symbolic discrete-time batch reactor dynamics.\n\n\nsetup_equilibria\nSet up equilibrium points for the batch reactor.\n\n\n\n\ncalculate_steady_heating\nsystems.builtin.deterministic.discrete.DiscreteBatchReactor.calculate_steady_heating(\n    T_setpoint,\n)\nCalculate steady-state heating required to maintain temperature setpoint.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nT_setpoint\nfloat\nDesired reactor temperature [K]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nRequired heating rate Q [K/s]\n\n\n\n\n\nNotes\nAt steady state (constant T), heat input must balance heat loss: Q = α·(T - T_amb)\n\n\n\ncompute_conversion\nsystems.builtin.deterministic.discrete.DiscreteBatchReactor.compute_conversion(\n    C_A,\n    C_A0,\n)\nCompute fractional conversion of reactant A.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_A\nfloat\nCurrent concentration of A [mol/L]\nrequired\n\n\nC_A0\nfloat\nInitial concentration of A [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nConversion fraction X_A (0 = no conversion, 1 = complete)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; reactor = DiscreteBatchReactor()\n&gt;&gt;&gt; X = reactor.compute_conversion(C_A=0.3, C_A0=1.0)\n&gt;&gt;&gt; print(f\"Conversion: {X*100:.1f}%\")\nConversion: 70.0%\n\n\n\ncompute_selectivity\nsystems.builtin.deterministic.discrete.DiscreteBatchReactor.compute_selectivity(\n    C_B,\n    C_A,\n    C_A0,\n)\nCompute selectivity to intermediate B.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_B\nfloat\nCurrent concentration of B [mol/L]\nrequired\n\n\nC_A\nfloat\nCurrent concentration of A [mol/L]\nrequired\n\n\nC_A0\nfloat\nInitial concentration of A [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nSelectivity S_B = C_B / (C_A0 - C_A) (moles B per mole A converted)\n\n\n\n\n\nNotes\nSelectivity measures how much intermediate B is produced per mole of A consumed. Values: - S_B = 1.0: Perfect selectivity (all A → B, no B → C yet) - S_B &lt; 1.0: Some B has already converted to C - S_B → 0: Most B has converted to C (over-reacted)\n\n\nExamples\n&gt;&gt;&gt; reactor = DiscreteBatchReactor()\n&gt;&gt;&gt; S = reactor.compute_selectivity(C_B=0.5, C_A=0.3, C_A0=1.0)\n&gt;&gt;&gt; print(f\"Selectivity: {S:.2f} mol B / mol A converted\")\n\n\n\ncompute_yield\nsystems.builtin.deterministic.discrete.DiscreteBatchReactor.compute_yield(\n    C_B,\n    C_A0,\n)\nCompute yield of intermediate B.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nC_B\nfloat\nCurrent concentration of B [mol/L]\nrequired\n\n\nC_A0\nfloat\nInitial concentration of A [mol/L]\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nYield Y_B = C_B / C_A0 (moles B per initial mole A)\n\n\n\n\n\nNotes\nYield is the most important metric for batch optimization. Combines both conversion and selectivity: Y_B = X_A · S_B\n\n\nExamples\n&gt;&gt;&gt; reactor = DiscreteBatchReactor()\n&gt;&gt;&gt; Y = reactor.compute_yield(C_B=0.4, C_A0=1.0)\n&gt;&gt;&gt; print(f\"Yield: {Y*100:.1f}%\")\nYield: 40.0%\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.DiscreteBatchReactor.define_system(\n    k1_val=0.5,\n    k2_val=0.3,\n    E1_val=1000.0,\n    E2_val=1500.0,\n    alpha_val=0.1,\n    T_amb_val=300.0,\n    dt=1.0,\n    C_A0=None,\n    T0=None,\n)\nDefine symbolic discrete-time batch reactor dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk1_val\nfloat\nPre-exponential factor for A→B reaction [1/s]\n0.5\n\n\nk2_val\nfloat\nPre-exponential factor for B→C reaction [1/s]\n0.3\n\n\nE1_val\nfloat\nActivation energy for reaction 1 [K]\n1000.0\n\n\nE2_val\nfloat\nActivation energy for reaction 2 [K]\n1500.0\n\n\nalpha_val\nfloat\nHeat transfer coefficient [1/s]\n0.1\n\n\nT_amb_val\nfloat\nAmbient temperature [K]\n300.0\n\n\ndt\nfloat\nDiscretization time step [s]\n1.0\n\n\nC_A0\nOptional[float]\nInitial concentration of A for equilibrium setup [mol/L]\nNone\n\n\nT0\nOptional[float]\nInitial temperature for equilibrium setup [K]\nNone\n\n\n\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.DiscreteBatchReactor.setup_equilibria()\nSet up equilibrium points for the batch reactor.\nAdds two equilibria: 1. ‘complete’: Complete conversion (Cₐ=0, Cᵦ=0, T=Tₐₘᵦ) 2. ‘initial’: Optional initial state if C_A0 and T0 specified"
  },
  {
    "objectID": "api/control.ControlSynthesis.html",
    "href": "api/control.ControlSynthesis.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/control.ControlSynthesis.html#attributes",
    "href": "api/control.ControlSynthesis.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nbackend\nBackend\nComputational backend (‘numpy’, ‘torch’, ‘jax’)"
  },
  {
    "objectID": "api/control.ControlSynthesis.html#examples",
    "href": "api/control.ControlSynthesis.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Via system composition (typical usage)\n&gt;&gt;&gt; system = Pendulum()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design LQR controller (unified interface)\n&gt;&gt;&gt; Q = np.diag([10, 1])\n&gt;&gt;&gt; R = np.array([[0.1]])\n&gt;&gt;&gt; result = system.control.design_lqr(\n...     *system.linearize(x_eq, u_eq),\n...     Q, R,\n...     system_type='continuous'\n... )\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design Kalman filter\n&gt;&gt;&gt; C = np.array([[1, 0]])\n&gt;&gt;&gt; Q_proc = 0.01 * np.eye(2)\n&gt;&gt;&gt; R_meas = np.array([[0.1]])\n&gt;&gt;&gt; A, _ = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; kalman = system.control.design_kalman(A, C, Q_proc, R_meas)\n&gt;&gt;&gt; L = kalman['gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Design LQG (combined)\n&gt;&gt;&gt; lqg = system.control.design_lqg(\n...     *system.linearize(x_eq, u_eq),\n...     C,\n...     Q, R,  # LQR weights\n...     Q_proc, R_meas  # Kalman noise\n... )"
  },
  {
    "objectID": "api/control.ControlSynthesis.html#notes",
    "href": "api/control.ControlSynthesis.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nThis is a thin wrapper - all algorithms are in classical_control_functions.py. The wrapper only provides: 1. Backend consistency with parent system 2. Clean composition interface 3. Convenience for system integration"
  },
  {
    "objectID": "api/control.ControlSynthesis.html#methods",
    "href": "api/control.ControlSynthesis.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndesign_kalman\nDesign Kalman filter for optimal state estimation.\n\n\ndesign_lqg\nDesign Linear Quadratic Gaussian (LQG) controller.\n\n\ndesign_lqr\nDesign LQR controller (unified interface).\n\n\n\n\ndesign_kalman\ncontrol.ControlSynthesis.design_kalman(A, C, Q, R, system_type='discrete')\nDesign Kalman filter for optimal state estimation.\nRoutes to classical.design_kalman_filter() with system backend.\nSystem: x[k+1] = Ax[k] + Bu[k] + w[k], w ~ N(0, Q) y[k] = Cx[k] + v[k], v ~ N(0, R)\nEstimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\nArgs: A: State matrix (nx, nx) C: Output matrix (ny, nx) Q: Process noise covariance (nx, nx), Q ≥ 0 R: Measurement noise covariance (ny, ny), R &gt; 0 system_type: ‘continuous’ or ‘discrete’\nReturns: KalmanFilterResult with gain, covariances, observer eigenvalues\n\nExamples\n&gt;&gt;&gt; # Design Kalman filter\n&gt;&gt;&gt; A, _ = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Measure position only\n&gt;&gt;&gt; Q_proc = 0.01 * np.eye(2)  # Process noise\n&gt;&gt;&gt; R_meas = np.array([[0.1]])  # Measurement noise\n&gt;&gt;&gt;\n&gt;&gt;&gt; kalman = system.control.design_kalman(\n...     A, C, Q_proc, R_meas,\n...     system_type='discrete'\n... )\n&gt;&gt;&gt; L = kalman['gain']\n&gt;&gt;&gt; print(f\"Kalman gain shape: {L.shape}\")  # (nx, ny)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use in estimation loop\n&gt;&gt;&gt; x_hat = np.zeros(2)\n&gt;&gt;&gt; for k in range(N):\n...     # Prediction\n...     x_hat_pred = A @ x_hat + B @ u[k]\n...\n...     # Correction\n...     innovation = y[k] - C @ x_hat_pred\n...     x_hat = x_hat_pred + L @ innovation\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check observer convergence\n&gt;&gt;&gt; obs_stable = np.all(np.abs(kalman['estimator_eigenvalues']) &lt; 1)\n&gt;&gt;&gt; print(f\"Observer stable: {obs_stable}\")\n\n\nSee Also\ndesign_lqg : Combined LQR + Kalman (full LQG controller)\n\n\n\ndesign_lqg\ncontrol.ControlSynthesis.design_lqg(\n    A,\n    B,\n    C,\n    Q_state,\n    R_control,\n    Q_process,\n    R_measurement,\n    N=None,\n    system_type='discrete',\n)\nDesign Linear Quadratic Gaussian (LQG) controller.\nRoutes to classical.design_lqg() with system backend.\nCombines LQR controller with Kalman filter estimator via separation principle.\nController: u[k] = -Kx̂[k] Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\nArgs: A: State matrix (nx, nx) B: Input matrix (nx, nu) C: Output matrix (ny, nx) Q_state: LQR state cost matrix (nx, nx) R_control: LQR control cost matrix (nu, nu) Q_process: Process noise covariance (nx, nx) R_measurement: Measurement noise covariance (ny, ny) N: Cross-coupling matrix (nx, nu), optional system_type: ‘continuous’ or ‘discrete’\nReturns: LQGResult with controller gain, estimator gain, Riccati solutions, and eigenvalues\n\nExamples\n&gt;&gt;&gt; # Design complete LQG controller\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; C = np.array([[1, 0]])  # Partial state measurement\n&gt;&gt;&gt;\n&gt;&gt;&gt; # LQR weights\n&gt;&gt;&gt; Q_state = np.diag([10, 1])\n&gt;&gt;&gt; R_control = np.array([[0.1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Noise covariances\n&gt;&gt;&gt; Q_process = 0.01 * np.eye(2)\n&gt;&gt;&gt; R_measurement = np.array([[0.1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; lqg = system.control.design_lqg(\n...     A, B, C,\n...     Q_state, R_control,\n...     Q_process, R_measurement,\n...     system_type='discrete'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; K = lqg['control_gain']  # LQR gain\n&gt;&gt;&gt; L = lqg['estimator_gain']   # Kalman gain\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With cross-coupling term\n&gt;&gt;&gt; N = np.array([[0.5], [0.1]])\n&gt;&gt;&gt; lqg = system.control.design_lqg(\n...     A, B, C,\n...     Q_state, R_control,\n...     Q_process, R_measurement,\n...     N=N,\n...     system_type='discrete'\n... )\n\n\nNotes\n\nSeparation principle: LQR and Kalman designed independently\nLQG optimal for linear Gaussian systems\nController eigenvalues determine regulation performance\nObserver eigenvalues determine estimation convergence\nEstimator should converge faster than controller\n\n\n\nSee Also\ndesign_lqr : Unified LQR controller design design_kalman : Kalman filter only\n\n\n\ndesign_lqr\ncontrol.ControlSynthesis.design_lqr(A, B, Q, R, N=None, system_type='discrete')\nDesign LQR controller (unified interface).\nRoutes to classical.design_lqr() with system backend.\nMinimizes cost functional: Continuous: J = ∫₀^∞ (x’Qx + u’Ru + 2x’Nu) dt Discrete: J = Σₖ₌₀^∞ (x[k]’Qx[k] + u[k]’Ru[k] + 2x[k]’Nu[k])\nControl law: Continuous: u = -Kx Discrete: u[k] = -Kx[k]\nArgs: A: State matrix (nx, nx) B: Input matrix (nx, nu) Q: State cost matrix (nx, nx), Q ≥ 0 R: Control cost matrix (nu, nu), R &gt; 0 N: Cross-coupling matrix (nx, nu), optional system_type: ‘continuous’ or ‘discrete’, default ‘discrete’\nReturns: LQRResult with gain, cost-to-go, eigenvalues, stability margin\n\nExamples\n&gt;&gt;&gt; # Via system - continuous\n&gt;&gt;&gt; A, B = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; Q = np.diag([10, 1])\n&gt;&gt;&gt; R = np.array([[0.1]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = system.control.design_lqr(\n...     A, B, Q, R,\n...     system_type='continuous'\n... )\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Via system - discrete (default)\n&gt;&gt;&gt; result = discrete_system.control.design_lqr(A, B, Q, R)\n&gt;&gt;&gt; K = result['gain']\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With cross-coupling term\n&gt;&gt;&gt; N = np.array([[0.5], [0.1]])\n&gt;&gt;&gt; result = system.control.design_lqr(\n...     A, B, Q, R, N=N,\n...     system_type='continuous'\n... )\n\n\nSee Also\ndesign_kalman : Kalman filter design design_lqg : Combined LQR + Kalman filter"
  },
  {
    "objectID": "api/types.contraction.ContractionAnalysisResult.html",
    "href": "api/types.contraction.ContractionAnalysisResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.contraction.ContractionAnalysisResult.html#fields",
    "href": "api/types.contraction.ContractionAnalysisResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nis_contracting : bool True if system is contracting contraction_rate : ContractionRate Exponential rate β metric : ContractionMetric Contraction metric M(x) metric_type : str Metric type (‘constant’, ‘state_dependent’, ‘control_dependent’) verification_method : str Method used (‘LMI’, ‘SOS’, ‘optimization’, ‘analytic’) convergence_bound : Optional[Callable] Upper bound ||δx(t)|| ≤ bound(t, ||δx(0)||) exponential_convergence : bool True if exponential (vs polynomial) incremental_stability : bool True if incrementally asymptotically stable condition_number : Optional[float] Condition number κ(M) if constant metric"
  },
  {
    "objectID": "api/types.contraction.ContractionAnalysisResult.html#examples",
    "href": "api/types.contraction.ContractionAnalysisResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Analyze system contraction\n&gt;&gt;&gt; result: ContractionAnalysisResult = analyze_contraction(\n...     dynamics=lambda x: -A @ x,\n...     method='LMI'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['is_contracting']:\n...     beta = result['contraction_rate']\n...     M = result['metric']\n...\n...     print(f\"System is contracting!\")\n...     print(f\"Rate β = {beta:.3f}\")\n...     print(f\"Method: {result['verification_method']}\")\n...\n...     # Convergence bound\n...     if 'convergence_bound' in result:\n...         bound = result['convergence_bound']\n...         t = np.linspace(0, 10, 100)\n...         delta_bound = [bound(ti, 1.0) for ti in t]\n...\n...         import matplotlib.pyplot as plt\n...         plt.plot(t, delta_bound)\n...         plt.xlabel('Time')\n...         plt.ylabel('||δx|| bound')\n... else:\n...     print(\"System is not contracting\")"
  },
  {
    "objectID": "api/types.core.OutputMatrix.html",
    "href": "api/types.core.OutputMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.OutputMatrix.html#examples",
    "href": "api/types.core.OutputMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Full state observation\n&gt;&gt;&gt; C: OutputMatrix = np.eye(3)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Partial observation (position only)\n&gt;&gt;&gt; C_partial: OutputMatrix = np.array([[1, 0, 0]])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Multi-sensor observation\n&gt;&gt;&gt; C_multi: OutputMatrix = np.array([[1, 0, 0], [0, 1, 0]])"
  },
  {
    "objectID": "api/systems.base.core.DiscreteSystemBase.html",
    "href": "api/systems.base.core.DiscreteSystemBase.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.core.DiscreteSystemBase.html#examples",
    "href": "api/systems.base.core.DiscreteSystemBase.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; class MyDiscreteSystem(DiscreteSystemBase):\n...     def __init__(self, dt=0.1):\n...         self._dt = dt\n...         self.nx = 2\n...         self.nu = 1\n...\n...     @property\n...     def dt(self):\n...         return self._dt\n...\n...     def step(self, x, u=None, k=0):\n...         u = u if u is not None else np.zeros(self.nu)\n...         return 0.9 * x + 0.1 * u\n...\n...     def simulate(self, x0, u_sequence, n_steps):\n...         # Implement multi-step simulation\n...         ...\n...\n...     def linearize(self, x_eq, u_eq):\n...         Ad = 0.9 * np.eye(self.nx)\n...         Bd = 0.1 * np.eye(self.nx, self.nu)\n...         return (Ad, Bd)"
  },
  {
    "objectID": "api/systems.base.core.DiscreteSystemBase.html#attributes",
    "href": "api/systems.base.core.DiscreteSystemBase.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nanalysis\nAccess system analysis utilities.\n\n\ncontrol\nAccess control synthesis utilities.\n\n\ncontrol_plotter\nAccess control system analysis plotting utilities.\n\n\ndt\nSampling period / time step of the discrete system.\n\n\nis_continuous\nReturn False (this is NOT a continuous-time system).\n\n\nis_discrete\nReturn True (this is a discrete-time system).\n\n\nis_stochastic\nReturn True if system has stochastic dynamics.\n\n\nis_time_varying\nReturn True if system dynamics depend explicitly on time step k.\n\n\nphase_plotter\nAccess phase portrait plotting utilities.\n\n\nplotter\nAccess trajectory plotting utilities.\n\n\nsampling_frequency\nGet sampling frequency in Hz."
  },
  {
    "objectID": "api/systems.base.core.DiscreteSystemBase.html#methods",
    "href": "api/systems.base.core.DiscreteSystemBase.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nlinearize\nCompute linearized discrete dynamics around an equilibrium point.\n\n\nplot\nPlot simulation result (convenience method).\n\n\nrollout\nRollout system trajectory with optional state-feedback policy.\n\n\nsimulate\nSimulate system for multiple discrete time steps.\n\n\nstep\nCompute next state: x[k+1] = f(x[k], u[k], k).\n\n\n\n\nlinearize\nsystems.base.core.DiscreteSystemBase.linearize(x_eq, u_eq=None)\nCompute linearized discrete dynamics around an equilibrium point.\nFor a discrete system x[k+1] = f(x[k], u[k]), compute the linearization: δx[k+1] = Ad·δx[k] + Bd·δu[k]\nwhere: Ad = ∂f/∂x|(x_eq, u_eq) (State Jacobian, nx × nx) Bd = ∂f/∂u|(x_eq, u_eq) (Control Jacobian, nx × nu)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_eq\nStateVector\nEquilibrium state (nx,)\nrequired\n\n\nu_eq\nOptional[ControlVector]\nEquilibrium control (nu,) If None, uses zero control\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteLinearization\nTuple containing Jacobian matrices: - Deterministic systems: (Ad, Bd) - Stochastic systems: (Ad, Bd, Gd) where Gd is diffusion matrix\n\n\n\n\n\nNotes\nThe linearization is valid for small deviations from the equilibrium: δx[k] = x[k] - x_eq δu[k] = u[k] - u_eq\nFor symbolic systems, Jacobians are computed symbolically then evaluated. For data-driven systems, Jacobians may be computed via finite differences.\nThe equilibrium point should satisfy f(x_eq, u_eq) = x_eq (fixed point).\nStability analysis for discrete systems: - Stable if all |eigenvalues(Ad)| &lt; 1 - Unstable if any |eigenvalue(Ad)| &gt; 1 - Marginal if |eigenvalue(Ad)| = 1\n\n\nExamples\nLinearize at origin:\n&gt;&gt;&gt; x_eq = np.zeros(2)\n&gt;&gt;&gt; u_eq = np.zeros(1)\n&gt;&gt;&gt; Ad, Bd = system.linearize(x_eq, u_eq)\n&gt;&gt;&gt; print(f\"Ad matrix:\\n{Ad}\")\n&gt;&gt;&gt; print(f\"Bd matrix:\\n{Bd}\")\nCheck discrete stability:\n&gt;&gt;&gt; eigenvalues = np.linalg.eigvals(Ad)\n&gt;&gt;&gt; is_stable = np.all(np.abs(eigenvalues) &lt; 1)\n&gt;&gt;&gt; print(f\"System stable: {is_stable}\")\nDesign discrete LQR controller:\n&gt;&gt;&gt; from scipy.linalg import solve_discrete_are\n&gt;&gt;&gt; P = solve_discrete_are(Ad, Bd, Q, R)\n&gt;&gt;&gt; K = np.linalg.inv(R + Bd.T @ P @ Bd) @ (Bd.T @ P @ Ad)\nRelationship to continuous linearization:\n&gt;&gt;&gt; # For Euler discretization: Ad ≈ I + dt * A\n&gt;&gt;&gt; dt = system.dt\n&gt;&gt;&gt; A_approx = (Ad - np.eye(system.nx)) / dt\n\n\n\nplot\nsystems.base.core.DiscreteSystemBase.plot(result, state_names=None, **kwargs)\nPlot simulation result (convenience method).\nWrapper around plotter.plot_trajectory() for quick visualization of discrete-time simulation results.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nresult\nDiscreteSimulationResult\nSimulation result dictionary with ‘t’ and ‘x’ keys from simulate() or rollout()\nrequired\n\n\nstate_names\nOptional[list]\nNames for state variables (e.g., [‘Position’, ‘Velocity’]) If None, uses generic labels [‘x₁’, ‘x₂’, …]\nNone\n\n\n**kwargs\n\nAdditional arguments passed to plot_trajectory(): - title : str - Plot title - color_scheme : str - Color scheme name - show_legend : bool - Show legend for batched trajectories\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nInteractive Plotly figure object\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Simple usage\n&gt;&gt;&gt; result = system.simulate(x0, u_sequence, n_steps=100)\n&gt;&gt;&gt; fig = system.plot(result)\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With state names and custom title\n&gt;&gt;&gt; fig = system.plot(\n...     result,\n...     state_names=['θ', 'ω'],\n...     title='Discrete Pendulum Dynamics'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Export to HTML\n&gt;&gt;&gt; fig.write_html('simulation.html')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Apply publication theme\n&gt;&gt;&gt; from controldesymulation.visualization.themes import PlotThemes\n&gt;&gt;&gt; fig = system.plot(result)\n&gt;&gt;&gt; fig = PlotThemes.apply_theme(fig, theme='publication')\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Batched trajectories (Monte Carlo)\n&gt;&gt;&gt; results = []\n&gt;&gt;&gt; for x0 in initial_conditions:\n...     results.append(system.simulate(x0, u_sequence, n_steps=100))\n&gt;&gt;&gt; x_batch = np.stack([r['x'] for r in results])\n&gt;&gt;&gt; result_batch = {'t': results[0]['t'], 'x': x_batch}\n&gt;&gt;&gt; fig = system.plot(result_batch)  # Plots all trajectories\n\n\nSee Also\nplotter.plot_trajectory : Full trajectory plotting method plotter.plot_state_and_control : Plot states and controls together phase_plotter.plot_2d : Phase space visualization control_plotter : Control analysis plots\n\n\nNotes\nThis is a convenience wrapper that: - Extracts time and state from result dictionary - Calls plotter.plot_trajectory() with appropriate arguments - Returns Plotly figure for further customization\nFor more control over plotting, use plotter methods directly.\n\n\n\nrollout\nsystems.base.core.DiscreteSystemBase.rollout(\n    x0,\n    policy=None,\n    n_steps=100,\n    **kwargs,\n)\nRollout system trajectory with optional state-feedback policy.\nThis is a higher-level alternative to simulate() that provides a cleaner interface for closed-loop simulation with state-dependent policies.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\npolicy\nOptional[Callable[[StateVector, int], ControlVector]]\nControl policy u = policy(x, k) If None, uses zero control (open-loop)\nNone\n\n\nn_steps\nint\nNumber of simulation steps\n100\n\n\n**kwargs\n\nAdditional arguments (stored in metadata)\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteSimulationResult\nTypedDict (returns as dict) containing trajectory and metadata - states: (n_steps+1, nx) - TIME-MAJOR - controls: (n_steps, nu) - TIME-MAJOR - time_steps: (n_steps+1,) - dt: float - metadata: dict with closed_loop flag\n\n\n\n\n\nExamples\nOpen-loop rollout:\n&gt;&gt;&gt; result = system.rollout(x0, n_steps=100)\nState feedback policy (LQR):\n&gt;&gt;&gt; K = np.array([[-1.0, -2.0]])  # LQR gain\n&gt;&gt;&gt; def policy(x, k):\n...     return -K @ x\n&gt;&gt;&gt; result = system.rollout(x0, policy, n_steps=100)\nTime-varying policy with reference:\n&gt;&gt;&gt; x_ref_trajectory = generate_reference()\n&gt;&gt;&gt; def policy(x, k):\n...     x_ref = x_ref_trajectory[k]\n...     return K @ (x_ref - x)\n&gt;&gt;&gt; result = system.rollout(x0, policy, n_steps=100)\nMPC policy:\n&gt;&gt;&gt; mpc_controller = system.control.mpc(horizon=10, Q=Q, R=R)\n&gt;&gt;&gt; def policy(x, k):\n...     return mpc_controller.compute_control(x, k)\n&gt;&gt;&gt; result = system.rollout(x0, policy, n_steps=100)\n\n\n\nsimulate\nsystems.base.core.DiscreteSystemBase.simulate(\n    x0,\n    u_sequence=None,\n    n_steps=100,\n    **kwargs,\n)\nSimulate system for multiple discrete time steps.\nRun the discrete dynamics forward in time: x[0] = x0 x[k+1] = f(x[k], u[k], k) for k = 0, 1, …, n_steps-1\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_sequence\nOptional[Union[ControlVector, Sequence, Callable]]\nControl input sequence, can be: - None: Zero control for all steps - Array (nu,): Constant control u[k] = u for all k - Sequence: Pre-computed sequence u[0], u[1], …, u[n_steps-1] - Callable: Control policy u[k] = u_func(k)\nNone\n\n\nn_steps\nint\nNumber of simulation steps (default: 100)\n100\n\n\n**kwargs\n\nAdditional simulation options (e.g., save_intermediate)\n{}\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDiscreteSimulationResult\nTypedDict (returns as dict) containing: - states: State trajectory (nx, n_steps+1) - includes x[0] - controls: Control sequence (nu, n_steps) if applicable - time_steps: Time step indices [0, 1, …, n_steps] - dt: Sampling period - metadata: Additional info (method, success, etc.)\n\n\n\n\n\nNotes\nThe state trajectory includes n_steps+1 points (including x0). The control sequence has n_steps points (one for each transition).\nFor closed-loop simulation with state-dependent control, you can use rollout() instead, which provides a cleaner interface for state feedback.\n\n\nExamples\nOpen-loop with constant control:\n&gt;&gt;&gt; x0 = np.array([1.0, 0.0])\n&gt;&gt;&gt; u = np.array([0.5])\n&gt;&gt;&gt; result = system.simulate(x0, u, n_steps=100)\n&gt;&gt;&gt; plt.step(result[\"time_steps\"], result[\"states\"][0, :])\nPre-computed control sequence:\n&gt;&gt;&gt; u_seq = [np.array([0.5 * np.sin(k * 0.1)]) for k in range(100)]\n&gt;&gt;&gt; result = system.simulate(x0, u_seq, n_steps=100)\nTime-indexed control function:\n&gt;&gt;&gt; def u_func(k):\n...     return np.array([0.5 * np.sin(k * system.dt)])\n&gt;&gt;&gt; result = system.simulate(x0, u_func, n_steps=100)\nAutonomous system (no control):\n&gt;&gt;&gt; result = system.simulate(x0, u_sequence=None, n_steps=100)\n\n\n\nstep\nsystems.base.core.DiscreteSystemBase.step(x, u=None, k=0)\nCompute next state: x[k+1] = f(x[k], u[k], k).\nThis is the core state update method. It computes the next state given the current state and control input.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state vector (nx,) or (nx, n_batch)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input vector (nu,) or (nu, n_batch) If None, assumes zero control or autonomous dynamics\nNone\n\n\nk\nint\nCurrent discrete time step (default: 0) Used for time-varying systems\n0\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x[k+1] with same shape as x\n\n\n\n\n\nNotes\n\nFor autonomous systems, k is ignored\nFor time-invariant systems, k is typically ignored\nFor batch evaluation, x and u should have shape (n_dim, n_batch)\nThe returned state should be in the same backend as the input\n\n\n\nExamples\nSingle step update:\n&gt;&gt;&gt; x = np.array([1.0, 2.0])\n&gt;&gt;&gt; u = np.array([0.5])\n&gt;&gt;&gt; x_next = system.step(x, u)\nBatch evaluation:\n&gt;&gt;&gt; x_batch = np.random.randn(2, 100)  # 100 states\n&gt;&gt;&gt; u_batch = np.random.randn(1, 100)  # 100 controls\n&gt;&gt;&gt; x_next_batch = system.step(x_batch, u_batch)\nManual simulation loop:\n&gt;&gt;&gt; x = x0\n&gt;&gt;&gt; for k in range(100):\n...     u = controller(x, k)\n...     x = system.step(x, u, k)\n...     # Log or visualize x"
  },
  {
    "objectID": "api/types.symbolic.SymbolicStateEquations.html",
    "href": "api/types.symbolic.SymbolicStateEquations.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.symbolic.SymbolicStateEquations.html#examples",
    "href": "api/types.symbolic.SymbolicStateEquations.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; import sympy as sp\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Simple pendulum\n&gt;&gt;&gt; theta, omega = sp.symbols('theta omega', real=True)\n&gt;&gt;&gt; u = sp.symbols('u', real=True)\n&gt;&gt;&gt; m, l, g, b = sp.symbols('m l g b', positive=True)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Continuous dynamics: [dθ/dt, dω/dt]\n&gt;&gt;&gt; f: SymbolicStateEquations = sp.Matrix([\n...     omega,\n...     -(g/l)*sp.sin(theta) - (b/m)*omega + u/(m*l**2)\n... ])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Compile to callable function\n&gt;&gt;&gt; from sympy import lambdify\n&gt;&gt;&gt; f_func = lambdify(\n...     ([theta, omega], u, [m, l, g, b]),\n...     f,\n...     'numpy'\n... )\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Linear system\n&gt;&gt;&gt; x1, x2, u = sp.symbols('x1 x2 u')\n&gt;&gt;&gt; A11, A12, A21, A22 = sp.symbols('A11 A12 A21 A22')\n&gt;&gt;&gt; B1, B2 = sp.symbols('B1 B2')\n&gt;&gt;&gt; \n&gt;&gt;&gt; f_linear: SymbolicStateEquations = sp.Matrix([\n...     A11*x1 + A12*x2 + B1*u,\n...     A21*x1 + A22*x2 + B2*u\n... ])"
  },
  {
    "objectID": "api/types.linearization.ObservationLinearization.html",
    "href": "api/types.linearization.ObservationLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.ObservationLinearization.html#examples",
    "href": "api/types.linearization.ObservationLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Linearize output\n&gt;&gt;&gt; C, D = system.linearized_observation(x_eq, u_eq)\n&gt;&gt;&gt; print(C.shape)  # (ny, nx)\n&gt;&gt;&gt; print(D.shape)  # (ny, nu)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # For Kalman filter\n&gt;&gt;&gt; # Prediction: ŷ = C @ x̂_pred\n&gt;&gt;&gt; # Innovation: v = y - ŷ\n&gt;&gt;&gt; # Update: x̂ = x̂_pred + L @ v\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Full state observation (common case)\n&gt;&gt;&gt; C_full = np.eye(nx)  # y = x\n&gt;&gt;&gt; D_full = np.zeros((nx, nu))  # No feedthrough"
  },
  {
    "objectID": "api/types.linearization.DiffusionJacobian.html",
    "href": "api/types.linearization.DiffusionJacobian.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.DiffusionJacobian.html#examples",
    "href": "api/types.linearization.DiffusionJacobian.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Gc: DiffusionJacobian = sde_system.diffusion_jacobian(x_eq, u_eq)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Additive noise (constant)\n&gt;&gt;&gt; Gc_additive = 0.1 * np.eye(nx)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Multiplicative noise (state-dependent)\n&gt;&gt;&gt; # For dx = f(x)dt + σ*x*dW:\n&gt;&gt;&gt; Gc_multiplicative = σ * x_eq  # ∂(σ*x)/∂x evaluated at x_eq"
  },
  {
    "objectID": "api/types.optimization.OptimizationResult.html",
    "href": "api/types.optimization.OptimizationResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.optimization.OptimizationResult.html#fields",
    "href": "api/types.optimization.OptimizationResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nx : ArrayLike Optimal solution x* (n,) fun : float Optimal objective value f(x*) success : bool Whether optimization converged successfully message : str Solver status message nit : int Number of iterations performed nfev : int Number of objective function evaluations njev : int Number of Jacobian evaluations (if applicable)"
  },
  {
    "objectID": "api/types.optimization.OptimizationResult.html#examples",
    "href": "api/types.optimization.OptimizationResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Unconstrained optimization\n&gt;&gt;&gt; def rosenbrock(x):\n...     return (1 - x[0])**2 + 100*(x[1] - x[0]**2)**2\n&gt;&gt;&gt;\n&gt;&gt;&gt; from scipy.optimize import minimize\n&gt;&gt;&gt; result: OptimizationResult = minimize(\n...     rosenbrock,\n...     x0=np.array([0.0, 0.0]),\n...     method='BFGS'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['success']:\n...     print(f\"Optimum: {result['x']}\")  # [1, 1]\n...     print(f\"Cost: {result['fun']}\")   # ~0\n...     print(f\"Iterations: {result['nit']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Constrained optimization\n&gt;&gt;&gt; def objective(x):\n...     return x[0]**2 + x[1]**2\n&gt;&gt;&gt;\n&gt;&gt;&gt; def constraint(x):\n...     return x[0] + x[1] - 1  # x[0] + x[1] &gt;= 1\n&gt;&gt;&gt;\n&gt;&gt;&gt; from scipy.optimize import NonlinearConstraint\n&gt;&gt;&gt; result: OptimizationResult = minimize(\n...     objective,\n...     x0=np.array([1.0, 1.0]),\n...     method='SLSQP',\n...     constraints=NonlinearConstraint(constraint, 0, np.inf)\n... )"
  },
  {
    "objectID": "api/types.linearization.FullLinearization.html",
    "href": "api/types.linearization.FullLinearization.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.FullLinearization.html#examples",
    "href": "api/types.linearization.FullLinearization.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; A, B, C, D = system.full_linearization(x_eq, u_eq)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # State space model\n&gt;&gt;&gt; ss_continuous = scipy.signal.StateSpace(A, B, C, D)\n&gt;&gt;&gt; ss_discrete = scipy.signal.dlti(A, B, C, D, dt=0.01)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Transfer function\n&gt;&gt;&gt; G_s = C @ np.linalg.inv(s*I - A) @ B + D"
  },
  {
    "objectID": "api/observers.ExtendedKalmanFilter.html",
    "href": "api/observers.ExtendedKalmanFilter.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/observers.ExtendedKalmanFilter.html#theory",
    "href": "api/observers.ExtendedKalmanFilter.html#theory",
    "title": "",
    "section": "Theory:",
    "text": "Theory:\nPredict Step: x̂[k|k-1] = f(x̂[k-1|k-1], u[k-1]) [Nonlinear dynamics] A[k] = ∂f/∂x |_{x̂[k-1|k-1], u[k-1]} [Linearization at current estimate] P[k|k-1] = A[k] P[k-1|k-1] A[k]^T + Q [Covariance propagation]\nUpdate Step: ŷ[k|k-1] = h(x̂[k|k-1]) [Nonlinear observation] C[k] = ∂h/∂x |_{x̂[k|k-1]} [Observation Jacobian] S[k] = C[k] P[k|k-1] C[k]^T + R [Innovation covariance] K[k] = P[k|k-1] C[k]^T S[k]^{-1} [Kalman gain - varies with time!] x̂[k|k] = x̂[k|k-1] + Kk [State update] P[k|k] = (I - K[k]C[k]) P[k|k-1] [Covariance update]\nAttributes: system: SymbolicDynamicalSystem or GenericDiscreteTimeSystem Q: Process noise covariance (nx, nx) R: Measurement noise covariance (ny, ny) x_hat: Current state estimate (nx,) P: Current covariance estimate (nx, nx) is_discrete: Whether system is discrete or continuous\nExample: &gt;&gt;&gt; # Create EKF for pendulum &gt;&gt;&gt; pendulum = SymbolicPendulum(m=0.15, l=0.5, beta=0.1, g=9.81) &gt;&gt;&gt; Q_process = np.diag([0.001, 0.01]) &gt;&gt;&gt; R_measurement = np.array([[0.1]]) &gt;&gt;&gt; &gt;&gt;&gt; ekf = ExtendedKalmanFilter(pendulum, Q_process, R_measurement) &gt;&gt;&gt; &gt;&gt;&gt; # Initialize at origin &gt;&gt;&gt; ekf.reset(x0=torch.tensor([0.1, 0.0])) &gt;&gt;&gt; &gt;&gt;&gt; # Estimation loop &gt;&gt;&gt; for t in range(num_steps): &gt;&gt;&gt; # Predict &gt;&gt;&gt; ekf.predict(u[t], dt=0.01) &gt;&gt;&gt; &gt;&gt;&gt; # Get noisy measurement &gt;&gt;&gt; y_measured = measure_angle(x_true[t]) + np.random.randn() * 0.1 &gt;&gt;&gt; &gt;&gt;&gt; # Update &gt;&gt;&gt; ekf.update(torch.tensor([y_measured])) &gt;&gt;&gt; &gt;&gt;&gt; # Get estimate &gt;&gt;&gt; x_estimate = ekf.x_hat &gt;&gt;&gt; uncertainty = ekf.P &gt;&gt;&gt; &gt;&gt;&gt; # EKF can track large swings &gt;&gt;&gt; # Unlike constant-gain observer which is only valid near equilibrium\nNotes: - Process noise Q represents model uncertainty and disturbances - Measurement noise R represents sensor characteristics - Larger Q → trust measurements more (higher gain) - Larger R → trust model more (lower gain) - Covariance P tracks estimate uncertainty - Can be used with nonlinear controllers (MPC, feedback linearization)\nSee Also: kalman_gain: Constant-gain observer for linear systems LinearObserver: Linear observer with constant gain discrete_kalman_gain: Discrete-time constant-gain design"
  },
  {
    "objectID": "api/observers.ExtendedKalmanFilter.html#methods",
    "href": "api/observers.ExtendedKalmanFilter.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\npredict\nEKF prediction step: propagate state estimate and covariance.\n\n\nreset\nReset filter to initial state and covariance.\n\n\nupdate\nEKF update step: correct estimate using measurement.\n\n\n\n\npredict\nobservers.ExtendedKalmanFilter.predict(u, dt=None)\nEKF prediction step: propagate state estimate and covariance.\nArgs: u: Control input (nu,) dt: Time step (required for continuous-time systems, ignored for discrete)\nExample: &gt;&gt;&gt; ekf.predict(u=torch.tensor([1.0]), dt=0.01) &gt;&gt;&gt; print(f”Predicted state: {ekf.x_hat}“) &gt;&gt;&gt; print(f”Predicted covariance: {ekf.P}“)\nNotes: - Must call predict() before update() in each cycle - For discrete systems, dt is ignored - For continuous systems, uses Euler integration - Covariance grows during prediction (adds Q)\n\n\nreset\nobservers.ExtendedKalmanFilter.reset(x0=None, P0=None)\nReset filter to initial state and covariance.\nUseful for: - Starting a new estimation sequence - Recovering from filter divergence - Testing different initial conditions\nArgs: x0: Initial state estimate (nx,). Uses equilibrium if None. P0: Initial covariance (nx, nx). Uses 0.1*I if None.\nExample: &gt;&gt;&gt; # Reset to known initial condition &gt;&gt;&gt; ekf.reset(x0=torch.tensor([0.1, 0.0]), … P0=torch.eye(2) * 0.01) # Low initial uncertainty &gt;&gt;&gt; &gt;&gt;&gt; # Reset to equilibrium with high uncertainty &gt;&gt;&gt; ekf.reset() # Uses default x_equilibrium and 0.1*I\nNotes: - Called automatically in init() - P0 represents initial uncertainty about x0 - Larger P0 → less confident in initial estimate - After reset, start with predict() then update()\n\n\nupdate\nobservers.ExtendedKalmanFilter.update(y_measurement)\nEKF update step: correct estimate using measurement.\nArgs: y_measurement: Measurement vector (ny,). Should match the output dimension of h(x).\nExample: &gt;&gt;&gt; # After prediction &gt;&gt;&gt; y_measured = torch.tensor([0.15, 2.1, 0.05]) # Noisy measurement &gt;&gt;&gt; ekf.update(y_measured) &gt;&gt;&gt; print(f”Updated state: {ekf.x_hat}“) &gt;&gt;&gt; print(f”Updated covariance: {ekf.P}“) &gt;&gt;&gt; print(f”Uncertainty reduced: {np.trace(ekf.P)}“)\nNotes: - Covariance shrinks during update (information gained) - Large innovation → either bad estimate or bad measurement - Gain K[k] adapts based on current uncertainty P - Must call predict() before update()"
  },
  {
    "objectID": "api/types.core.FeedbackController.html",
    "href": "api/types.core.FeedbackController.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.FeedbackController.html#parameters",
    "href": "api/types.core.FeedbackController.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,)\nrequired\n\n\nt\nfloat\nCurrent time\nrequired"
  },
  {
    "objectID": "api/types.core.FeedbackController.html#returns",
    "href": "api/types.core.FeedbackController.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nControlVector\nControl action (nu,)"
  },
  {
    "objectID": "api/types.core.FeedbackController.html#examples",
    "href": "api/types.core.FeedbackController.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Time-varying LQR (scheduled gain)\n&gt;&gt;&gt; def scheduled_lqr(x: StateVector, t: float) -&gt; ControlVector:\n...     K_t = K0 * np.exp(-t / tau)  # Decaying gain\n...     return -K_t @ x\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Reference tracking with time-varying setpoint\n&gt;&gt;&gt; def tracking_controller(x: StateVector, t: float) -&gt; ControlVector:\n...     x_ref_t = np.array([np.sin(t), np.cos(t)])\n...     error = x - x_ref_t\n...     return -K @ error\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Gain scheduling based on time\n&gt;&gt;&gt; def gain_scheduled(x: StateVector, t: float) -&gt; ControlVector:\n...     if t &lt; 5.0:\n...         return -K_low @ x   # Low gain initially\n...     else:\n...         return -K_high @ x  # High gain later\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Model predictive control with receding horizon\n&gt;&gt;&gt; def mpc_controller(x: StateVector, t: float) -&gt; ControlVector:\n...     horizon = [t, t + T_horizon]\n...     return solve_mpc(x, horizon)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Use in simulation\n&gt;&gt;&gt; result = system.simulate(x0, controller=tracking_controller, t_span=(0, 10))"
  },
  {
    "objectID": "api/types.core.FeedbackController.html#notes",
    "href": "api/types.core.FeedbackController.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\nFor purely state-dependent control (no time dependence), prefer ControlPolicy which has the simpler signature u = π(x)."
  },
  {
    "objectID": "api/types.core.FeedbackController.html#see-also",
    "href": "api/types.core.FeedbackController.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nControlPolicy : Pure state feedback u = π(x) TimeVaryingControl : Pure time-varying u = u(t)"
  },
  {
    "objectID": "api/types.optimization.TrajectoryOptimizationResult.html",
    "href": "api/types.optimization.TrajectoryOptimizationResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.optimization.TrajectoryOptimizationResult.html#fields",
    "href": "api/types.optimization.TrajectoryOptimizationResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nstate_trajectory : StateTrajectory Optimal state trajectory x(t) (N+1, nx) control_trajectory : ControlSequence Optimal control trajectory u(t) (N, nu) cost : float Total cost J = Σ L(x,u) + Φ(x[N]) success : bool Whether optimization converged message : str Solver message solve_time : float Computation time in seconds iterations : int Number of optimization iterations constraint_violations : Optional[ArrayLike] Dynamics and path constraint violations"
  },
  {
    "objectID": "api/types.optimization.TrajectoryOptimizationResult.html#examples",
    "href": "api/types.optimization.TrajectoryOptimizationResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Minimum-time problem\n&gt;&gt;&gt; def running_cost(x, u):\n...     return 1.0  # Time-optimal\n&gt;&gt;&gt;\n&gt;&gt;&gt; def terminal_cost(x):\n...     return 0.0\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: TrajectoryOptimizationResult = solve_ocp(\n...     system=pendulum,\n...     x0=np.array([np.pi, 0]),     # Hanging down\n...     xf=np.array([0, 0]),         # Upright\n...     running_cost=running_cost,\n...     terminal_cost=terminal_cost,\n...     horizon=100,\n...     dt=0.05\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['success']:\n...     x_traj = result['state_trajectory']\n...     u_traj = result['control_trajectory']\n...\n...     import matplotlib.pyplot as plt\n...     plt.plot(x_traj[:, 0], label='theta')\n...     plt.plot(u_traj[:, 0], label='torque')\n...     plt.legend()\n...\n...     print(f\"Minimum time: {result['cost']:.3f} seconds\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check dynamics constraints\n&gt;&gt;&gt; if 'constraint_violations' in result:\n...     max_viol = np.max(np.abs(result['constraint_violations']))\n...     print(f\"Max constraint violation: {max_viol:.2e}\")"
  },
  {
    "objectID": "api/types.backends.Backend.html",
    "href": "api/types.backends.Backend.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.backends.Backend.html#examples",
    "href": "api/types.backends.Backend.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; backend: Backend = 'torch'\n&gt;&gt;&gt; system.set_default_backend('jax')\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Conditional on backend\n&gt;&gt;&gt; if backend == 'torch':\n...     import torch\n...     x = torch.tensor(x_np)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html",
    "href": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#parameters",
    "href": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\nsde_system : StochasticDynamicalSystem SDE system to integrate (controlled or autonomous) dt : Optional[ScalarLike] Time step size step_mode : StepMode FIXED or ADAPTIVE stepping mode backend : str Must be ‘torch’ for this integrator method : str Integration method (default: ‘euler’) Options: ‘euler’, ‘milstein’, ‘srk’, ‘midpoint’, ‘reversible_heun’ sde_type : Optional[SDEType] SDE interpretation (None = use system’s type) convergence_type : ConvergenceType Strong or weak convergence seed : Optional[int] Random seed for reproducibility adjoint : bool Use adjoint method for memory-efficient backpropagation Recommended for neural SDEs (default: False) noise_type : Optional[str] Noise type: ‘diagonal’, ‘additive’, ‘scalar’, ‘general’ Auto-detected from system if not specified **options Additional options: - rtol : float (default: 1e-3) - Relative tolerance - atol : float (default: 1e-6) - Absolute tolerance - dt_min : float - Minimum step size (adaptive only)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#raises",
    "href": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#raises",
    "title": "",
    "section": "Raises",
    "text": "Raises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf backend is not ‘torch’\n\n\n\nImportError\nIf PyTorch or torchsde not installed"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#notes",
    "href": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nBackend must be ‘torch’ (torchsde is PyTorch-only)\nAdjoint method recommended for neural SDEs to save memory\nGPU acceleration via .to_device(‘cuda’)\nExcellent gradient support for training"
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#examples",
    "href": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Basic usage\n&gt;&gt;&gt; integrator = TorchSDEIntegrator(\n...     sde_system,\n...     dt=0.01,\n...     method='euler'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # High accuracy\n&gt;&gt;&gt; integrator = TorchSDEIntegrator(\n...     sde_system,\n...     dt=0.001,\n...     method='srk'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Neural SDE with adjoint\n&gt;&gt;&gt; integrator = TorchSDEIntegrator(\n...     neural_sde,\n...     dt=0.01,\n...     method='euler',\n...     adjoint=True\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # GPU acceleration\n&gt;&gt;&gt; integrator = TorchSDEIntegrator(\n...     sde_system,\n...     dt=0.01,\n...     method='euler'\n... )\n&gt;&gt;&gt; integrator.to_device('cuda:0')\nIMPORTANT LIMITATION: TorchSDE does NOT support custom Brownian motion. The library generates noise internally and cannot accept user-provided dW values. This is an architectural design decision that enables: - Efficient GPU-based noise generation - Adjoint method for backpropagation - Optimized batched operations\nFor custom noise needs (deterministic testing, quasi-Monte Carlo, antithetic variates), use JAX/Diffrax which has full custom noise support.\nAll methods listed below are verified to work with TorchSDE."
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#attributes",
    "href": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nname\nReturn integrator name."
  },
  {
    "objectID": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#methods",
    "href": "api/systems.base.numerical_integration.stochastic.TorchSDEIntegrator.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndisable_adjoint\nDisable adjoint method.\n\n\nenable_adjoint\nEnable adjoint method.\n\n\nget_method_info\nGet method information.\n\n\nintegrate\nIntegrate SDE over time interval.\n\n\nintegrate_with_gradient\nIntegrate and compute gradients.\n\n\nlist_methods\nList available methods.\n\n\nrecommend_method\nRecommend method based on use case.\n\n\nstep\nTake one SDE integration step.\n\n\nto_device\nMove to device.\n\n\nvectorized_step\nVectorized step over batch.\n\n\n\n\ndisable_adjoint\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.disable_adjoint(\n)\nDisable adjoint method.\n\n\nenable_adjoint\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.enable_adjoint(\n)\nEnable adjoint method.\n\n\nget_method_info\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.get_method_info(\n    method,\n)\nGet method information.\n\n\nintegrate\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.integrate(\n    x0,\n    u_func,\n    t_span,\n    t_eval=None,\n    dense_output=False,\n)\nIntegrate SDE over time interval.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (nx,)\nrequired\n\n\nu_func\nCallable[[ScalarLike, StateVector], Optional[ControlVector]]\nControl policy: (t, x) → u or None\nrequired\n\n\nt_span\nTimeSpan\nTime interval (t_start, t_end)\nrequired\n\n\nt_eval\nOptional[TimePoints]\nSpecific times to evaluate (uses automatic grid if None)\nNone\n\n\ndense_output\nbool\nNot used (TorchSDE doesn’t support dense output)\nFalse\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nSDEIntegrationResult\nIntegration result with trajectory and diagnostics\n\n\n\n\n\n\nintegrate_with_gradient\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.integrate_with_gradient(\n    x0,\n    u_func,\n    t_span,\n    loss_fn,\n    t_eval=None,\n)\nIntegrate and compute gradients.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nStateVector\nInitial state (requires gradient)\nrequired\n\n\nu_func\nCallable\nControl policy\nrequired\n\n\nt_span\nTimeSpan\nTime interval\nrequired\n\n\nloss_fn\nCallable\nLoss function operating on integration result\nrequired\n\n\nt_eval\nOptional[TimePoints]\nEvaluation times\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntuple\n(loss_value, gradient)\n\n\n\n\n\n\nlist_methods\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.list_methods()\nList available methods.\n\n\nrecommend_method\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.recommend_method(\n    use_case='general',\n    has_gpu=False,\n)\nRecommend method based on use case.\n\n\nstep\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.step(\n    x,\n    u=None,\n    dt=None,\n    dW=None,\n)\nTake one SDE integration step.\nHandles both single and batched inputs automatically: - Input (nx,) → Output (nx,) - Input (batch, nx) → Output (batch, nx)\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nStateVector\nCurrent state (nx,) or (batch, nx)\nrequired\n\n\nu\nOptional[ControlVector]\nControl input (nu,) or (batch, nu), or None for autonomous\nNone\n\n\ndt\nOptional[ScalarLike]\nStep size (uses self.dt if None)\nNone\n\n\ndW\nOptional[StateVector]\nNOT SUPPORTED - TorchSDE does NOT support custom noise. This parameter is IGNORED. Use JAX/Diffrax for custom noise.\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext state x(t + dt)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x_next = integrator.step(torch.tensor([1.0]), None)\n&gt;&gt;&gt; # Custom noise ignored:\n&gt;&gt;&gt; x_next = integrator.step(x, u, dW=torch.zeros(1))  # dW ignored!\n\n\n\nto_device\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.to_device(\n    device,\n)\nMove to device.\n\n\nvectorized_step\nsystems.base.numerical_integration.stochastic.TorchSDEIntegrator.vectorized_step(\n    x_batch,\n    u_batch=None,\n    dt=None,\n)\nVectorized step over batch.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx_batch\nStateVector\nBatched states (batch, nx)\nrequired\n\n\nu_batch\nOptional[ControlVector]\nBatched controls (batch, nu)\nNone\n\n\ndt\nOptional[ScalarLike]\nStep size\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nStateVector\nNext states (batch, nx)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#stochastic-differential-equation",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#stochastic-differential-equation",
    "title": "",
    "section": "Stochastic Differential Equation",
    "text": "Stochastic Differential Equation\nSystem of two SDEs: dX₁ = σ₁·dW₁ dX₂ = σ₂·dW₂\nwhere: - X₁, X₂: Position coordinates in 2D space - σ₁, σ₂: Diffusion coefficients for each dimension - W₁, W₂: Independent standard Wiener processes - dW₁, dW₂: Independent Brownian motion increments\nKey Features: - Two independent noise sources (nw = 2) - No coupling between dimensions - Diagonal diffusion matrix: G = diag(σ₁, σ₂) - Can be anisotropic (σ₁ ≠ σ₂)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#mathematical-properties",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#mathematical-properties",
    "title": "",
    "section": "Mathematical Properties",
    "text": "Mathematical Properties\nJoint Distribution: The state vector [X₁(t), X₂(t)] starting at [x₁₀, x₂₀] has distribution: [X₁(t)] [x₁₀] [σ₁²·t 0 ] [X₂(t)] ~ N([x₂₀] , [ 0 σ₂²·t])\nIndependence: X₁(t) and X₂(t) are independent for all t: Cov[X₁(t), X₂(t)] = 0\nRadial Distance: The distance from origin R(t) = √(X₁² + X₂²) follows: E[R²(t)] = r₀² + (σ₁² + σ₂²)·t where r₀² = x₁₀² + x₂₀².\nFirst Passage Time: For hitting a circle of radius a: E[τ_a] = a²/(2D) where D = (σ₁² + σ₂²)/2 (For σ₁ = σ₂ = σ, this gives E[τ_a] = a²/(2σ²))"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#physical-interpretation",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#physical-interpretation",
    "title": "",
    "section": "Physical Interpretation",
    "text": "Physical Interpretation\nIsotropic vs. Anisotropic Diffusion:\n\nIsotropic (σ₁ = σ₂):\n\nDiffuses equally in all directions\nCircular symmetry\nExamples: Particle in homogeneous fluid, thermal diffusion\n\nAnisotropic (σ₁ ≠ σ₂):\n\nDifferent diffusion rates in x and y\nElliptical symmetry\nExamples: Diffusion in crystals, flow in porous media\n\n\nApplications: - Particle tracking in 2D microscopy - Random walk on plane (e.g., animal foraging) - 2D heat diffusion with noise - Currency pair exchange rate fluctuations - Spatial point processes"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#parameters",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma1\nfloat\nDiffusion coefficient for first dimension - Must be positive: σ₁ &gt; 0 - Controls diffusion rate in X₁ direction - Variance growth: Var[X₁(t)] = σ₁²·t\n1.0\n\n\nsigma2\nfloat\nDiffusion coefficient for second dimension - Must be positive: σ₂ &gt; 0 - Controls diffusion rate in X₂ direction - Variance growth: Var[X₂(t)] = σ₂²·t\n1.0"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#state-space",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#state-space",
    "title": "",
    "section": "State Space",
    "text": "State Space\nState: x = [x₁, x₂] ∈ ℝ² (unbounded 2D space) - First component: x₁ (arbitrary real number) - Second component: x₂ (arbitrary real number) - Joint distribution is bivariate normal - No boundaries (can go anywhere in plane)\nControl: None (autonomous) - nu = 0: No control inputs - Purely noise-driven motion"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#stochastic-properties",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#stochastic-properties",
    "title": "",
    "section": "Stochastic Properties",
    "text": "Stochastic Properties\nNoise Structure: - Type: ADDITIVE (diffusion matrix constant) - Dimension: nw = 2 (two independent noise sources) - Coupling: DIAGONAL (no cross-terms) - Independence: W₁ ⊥ W₂ (orthogonal noise sources)\nDiffusion Matrix: G(x) = [σ₁ 0 ] [0 σ₂]\nThis diagonal structure means: - Each dimension has its own noise source - No correlation between dimensions - Can be simulated independently\nCovariance Structure: For times s &lt; t: Cov[X₁(s), X₁(t)] = σ₁²·s Cov[X₂(s), X₂(t)] = σ₂²·s Cov[X₁(s), X₂(t)] = 0 (independent)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#statistical-analysis",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#statistical-analysis",
    "title": "",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\nHypothesis Tests:\n\nIndependence Test:\n\nH₀: X₁ and X₂ are independent\nTest: Correlation should be ≈0\nMethod: Pearson correlation test\n\nIsotropy Test:\n\nH₀: σ₁ = σ₂ (isotropic diffusion)\nTest: Var[X₁] = Var[X₂]\nMethod: F-test for equal variances\n\nNormality Test:\n\nH₀: (X₁, X₂) follows bivariate normal\nTest: Mardia’s test, Henze-Zirkler test\nAlternative: Q-Q plot for each dimension\n\nRadial Distribution:\n\nDistance R = √(X₁² + X₂²)\nFor isotropic case: R²/t ~ χ²(2) scaled\nTest: Goodness-of-fit to chi-squared"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#simulation-considerations",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#simulation-considerations",
    "title": "",
    "section": "Simulation Considerations",
    "text": "Simulation Considerations\nIndependent Sampling: Each dimension can be sampled independently: X₁[k+1] = X₁[k] + σ₁·√(Δt)·Z₁[k] X₂[k+1] = X₂[k] + σ₂·√(Δt)·Z₂[k] where Z₁[k], Z₂[k] ~ N(0,1) are independent."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#applications",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#applications",
    "title": "",
    "section": "Applications",
    "text": "Applications\n1. Particle Tracking: - Track particles in microscopy - Determine diffusion coefficients - Identify anisotropy in medium - Classify motion types (confined, free, directed)\n2. Animal Movement: - Random walk models of foraging - Home range estimation - Habitat selection analysis - Dispersal modeling\n3. Financial Markets: - Correlated asset pairs (when extended to non-zero correlation) - Exchange rate dynamics - Portfolio diffusion - Risk analysis\n4. Physics: - 2D diffusion in membranes - Molecular motion on surfaces - Colloidal particle dynamics - Thermal fluctuations\n5. Spatial Statistics: - Point process backgrounds - Spatial inhomogeneity detection - Landscape ecology - Epidemiology (disease spread)"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#extensions",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#extensions",
    "title": "",
    "section": "Extensions",
    "text": "Extensions\nCorrelated Brownian Motion: For correlated noise: G = [σ₁ ρ·σ₁·σ₂] [ρ·σ₁·σ₂ σ₂ ] where ρ is correlation coefficient (-1 ≤ ρ ≤ 1).\nReflected Brownian Motion: Bounce off rectangular boundary: [0, L₁] × [0, L₂]\nDrift Addition: Add deterministic drift: dX₁ = μ₁·dt + σ₁·dW₁ dX₂ = μ₂·dt + σ₂·dW₂\nTime-Varying Diffusion: Allow σ₁(t), σ₂(t) to vary with time."
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#see-also",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nBrownianMotion : One-dimensional version"
  },
  {
    "objectID": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#methods",
    "href": "api/systems.builtin.stochastic.continuous.BrownianMotion2D.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndefine_system\nDefine 2D Brownian motion dynamics.\n\n\n\n\ndefine_system\nsystems.builtin.stochastic.continuous.BrownianMotion2D.define_system(\n    sigma1=1.0,\n    sigma2=1.0,\n)\nDefine 2D Brownian motion dynamics.\nSets up the system: dX₁ = σ₁·dW₁ dX₂ = σ₂·dW₂\nwith two independent noise sources.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsigma1\nfloat\nDiffusion coefficient for first dimension - Must be positive: σ₁ &gt; 0 - Controls X₁ diffusion rate\n1.0\n\n\nsigma2\nfloat\nDiffusion coefficient for second dimension - Must be positive: σ₂ &gt; 0 - Controls X₂ diffusion rate\n1.0\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf either sigma value is non-positive\n\n\n\n\n\nNotes\nDiffusion Matrix Structure: The diffusion matrix is diagonal: G = diag(σ₁, σ₂)\nThis means: - Independent noise sources for each dimension - No correlation between X₁ and X₂ dynamics - Can simulate each dimension separately\nIsotropy Condition: The system is isotropic if and only if σ₁ = σ₂. - Isotropic: Diffusion looks the same in all directions - Anisotropic: Preferred directions of diffusion\nEffective Diffusion Coefficient: For radial distance R = √(X₁² + X₂²): D_eff = (σ₁² + σ₂²)/2\nVariance Ellipse: At time t, the state variance forms an ellipse: - Semi-major axis: max(σ₁, σ₂)·√t - Semi-minor axis: min(σ₁, σ₂)·√t - Aligned with coordinate axes (uncorrelated)"
  },
  {
    "objectID": "api/types.linearization.OutputJacobian.html",
    "href": "api/types.linearization.OutputJacobian.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.linearization.OutputJacobian.html#examples",
    "href": "api/types.linearization.OutputJacobian.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; Cc: OutputJacobian = system.output_jacobian(x_eq)\n&gt;&gt;&gt; # Position measurement: Cc = [[1, 0]] (measure position, not velocity)"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacterizer.html",
    "href": "api/systems.base.utils.stochastic.NoiseCharacterizer.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacterizer.html#examples",
    "href": "api/systems.base.utils.stochastic.NoiseCharacterizer.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Additive noise (constant)\n&gt;&gt;&gt; diffusion = sp.Matrix([[0.1], [0.2]])\n&gt;&gt;&gt; char = NoiseCharacterizer(diffusion, [x1, x2], [u])\n&gt;&gt;&gt; results = char.analyze()\n&gt;&gt;&gt; print(results.noise_type)\nNoiseType.ADDITIVE\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Multiplicative noise (state-dependent, non-diagonal)\n&gt;&gt;&gt; diffusion = sp.Matrix([[0.1 * x1, 0.05 * x2]])\n&gt;&gt;&gt; char = NoiseCharacterizer(diffusion, [x1, x2], [u])\n&gt;&gt;&gt; results = char.analyze()\n&gt;&gt;&gt; print(results.noise_type)\nNoiseType.MULTIPLICATIVE\n&gt;&gt;&gt; print(results.is_multiplicative)\nTrue"
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacterizer.html#attributes",
    "href": "api/systems.base.utils.stochastic.NoiseCharacterizer.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ncharacteristics\nGet noise characteristics (cached after first analysis)."
  },
  {
    "objectID": "api/systems.base.utils.stochastic.NoiseCharacterizer.html#methods",
    "href": "api/systems.base.utils.stochastic.NoiseCharacterizer.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nanalyze\nAnalyze diffusion expression structure.\n\n\nfrom_dict\nCreate NoiseCharacterizer from configuration dictionary.\n\n\nget_optimization_hints\nProvide optimization hints based on noise structure.\n\n\nvalidate_noise_type_claim\nValidate that a claimed noise_type matches actual structure.\n\n\n\n\nanalyze\nsystems.base.utils.stochastic.NoiseCharacterizer.analyze()\nAnalyze diffusion expression structure.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNoiseCharacteristics\nComplete analysis of noise structure\n\n\n\n\n\nExamples\n&gt;&gt;&gt; char = NoiseCharacterizer(diffusion, states, controls)\n&gt;&gt;&gt; results = char.analyze()\n&gt;&gt;&gt; if results.is_additive:\n...     print(\"Use specialized additive-noise solver!\")\n\n\n\nfrom_dict\nsystems.base.utils.stochastic.NoiseCharacterizer.from_dict(config)\nCreate NoiseCharacterizer from configuration dictionary.\nThis is a convenience factory method for creating characterizers from dictionaries, such as test fixtures or saved configurations.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconfig\nDict\nConfiguration dictionary with keys: - “diffusion” or “diffusion_expr”: Symbolic diffusion matrix - “state_vars”: List of state symbols - “control_vars”: List of control symbols - “time_var” (optional): Time symbol\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNoiseCharacterizer\nInitialized characterizer\n\n\n\n\n\nExamples\n&gt;&gt;&gt; config = {\n...     \"diffusion\": sp.Matrix([[0.1*x]]),\n...     \"state_vars\": [x],\n...     \"control_vars\": [u]\n... }\n&gt;&gt;&gt; char = NoiseCharacterizer.from_dict(config)\n&gt;&gt;&gt; result = char.analyze()\nWith test fixtures:\n&gt;&gt;&gt; @pytest.fixture\n... def my_noise():\n...     return {\"diffusion\": ..., \"state_vars\": ..., \"control_vars\": ...}\n&gt;&gt;&gt;\n&gt;&gt;&gt; def test_something(my_noise):\n...     char = NoiseCharacterizer.from_dict(my_noise)\n...     # or equivalently:\n...     char = NoiseCharacterizer(**my_noise)  # Now works!\n\n\n\nget_optimization_hints\nsystems.base.utils.stochastic.NoiseCharacterizer.get_optimization_hints()\nProvide optimization hints based on noise structure.\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDict[str, any]\nOptimization opportunities and recommendations\n\n\n\n\n\nExamples\n&gt;&gt;&gt; hints = char.get_optimization_hints()\n&gt;&gt;&gt; if hints['can_precompute']:\n...     print(\"Can precompute constant noise!\")\n\n\n\nvalidate_noise_type_claim\nsystems.base.utils.stochastic.NoiseCharacterizer.validate_noise_type_claim(\n    claimed_type,\n)\nValidate that a claimed noise_type matches actual structure.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclaimed_type\nstr\nUser’s claim about noise type (‘additive’, ‘diagonal’, etc.)\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if claim matches analysis\n\n\n\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf claimed type contradicts analysis\n\n\n\n\n\nExamples\n&gt;&gt;&gt; char = NoiseCharacterizer(diffusion, states, controls)\n&gt;&gt;&gt; char.validate_noise_type_claim('additive')  # Validates"
  },
  {
    "objectID": "api/visualization.TrajectoryPlotter.html",
    "href": "api/visualization.TrajectoryPlotter.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/visualization.TrajectoryPlotter.html#attributes",
    "href": "api/visualization.TrajectoryPlotter.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nbackend\nBackend\nDefault computational backend for array conversion\n\n\ndefault_theme\nstr\nDefault plot theme to apply"
  },
  {
    "objectID": "api/visualization.TrajectoryPlotter.html#examples",
    "href": "api/visualization.TrajectoryPlotter.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nBasic trajectory plotting:\n&gt;&gt;&gt; plotter = TrajectoryPlotter()\n&gt;&gt;&gt; t = np.linspace(0, 10, 100)\n&gt;&gt;&gt; x = np.sin(t)[:, None]  # (100, 1)\n&gt;&gt;&gt; fig = plotter.plot_trajectory(t, x, state_names=['sin(t)'])\n&gt;&gt;&gt; fig.show()\nBatched trajectories (Monte Carlo):\n&gt;&gt;&gt; x_batch = np.stack([np.sin(t + phi)[:, None] for phi in [0, 0.5, 1.0]])\n&gt;&gt;&gt; # x_batch shape: (3, 100, 1)\n&gt;&gt;&gt; fig = plotter.plot_trajectory(t, x_batch)\n&gt;&gt;&gt; fig.show()  # Shows all 3 trajectories\nState and control with publication theme:\n&gt;&gt;&gt; u = 0.1 * np.random.randn(100, 1)\n&gt;&gt;&gt; fig = plotter.plot_state_and_control(\n...     t, x, u,\n...     theme='publication',\n...     color_scheme='colorblind_safe'\n... )\n&gt;&gt;&gt; fig.show()"
  },
  {
    "objectID": "api/visualization.TrajectoryPlotter.html#methods",
    "href": "api/visualization.TrajectoryPlotter.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nlist_available_color_schemes\nList available color schemes.\n\n\nlist_available_themes\nList available plot themes.\n\n\nplot_comparison\nCompare multiple simulation runs.\n\n\nplot_state_and_control\nPlot states and controls in synchronized subplots.\n\n\nplot_trajectory\nPlot state trajectories over time.\n\n\n\n\nlist_available_color_schemes\nvisualization.TrajectoryPlotter.list_available_color_schemes()\nList available color schemes.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nAvailable color scheme names\n\n\n\n\n\nExamples\n&gt;&gt;&gt; schemes = TrajectoryPlotter.list_available_color_schemes()\n&gt;&gt;&gt; print(schemes)\n['plotly', 'd3', 'colorblind_safe', 'tableau', ...]\n\n\n\nlist_available_themes\nvisualization.TrajectoryPlotter.list_available_themes()\nList available plot themes.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nAvailable theme names\n\n\n\n\n\nExamples\n&gt;&gt;&gt; themes = TrajectoryPlotter.list_available_themes()\n&gt;&gt;&gt; print(themes)\n['default', 'publication', 'dark', 'presentation']\n\n\n\nplot_comparison\nvisualization.TrajectoryPlotter.plot_comparison(\n    t,\n    trajectories,\n    state_names=None,\n    title='Trajectory Comparison',\n    mode='overlay',\n    color_scheme='plotly',\n    theme=None,\n    **kwargs,\n)\nCompare multiple simulation runs.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nnp.ndarray\nTime points, shape (T,)\nrequired\n\n\ntrajectories\nDict[str, np.ndarray]\nDictionary mapping labels to trajectories Each trajectory: (T, nx) array\nrequired\n\n\nstate_names\nOptional[List[str]]\nNames for state variables\nNone\n\n\ntitle\nstr\nOverall plot title\n'Trajectory Comparison'\n\n\nmode\nstr\nComparison mode: ‘overlay’ or ‘side-by-side’\n'overlay'\n\n\ncolor_scheme\nstr\nColor scheme name Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, etc.\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nComparison plot\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Compare controlled vs uncontrolled\n&gt;&gt;&gt; trajectories = {\n...     'Controlled': x_controlled,\n...     'Uncontrolled': x_uncontrolled,\n... }\n&gt;&gt;&gt; fig = plotter.plot_comparison(\n...     t, trajectories,\n...     mode='overlay',\n...     color_scheme='colorblind_safe',\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n\n\n\nplot_state_and_control\nvisualization.TrajectoryPlotter.plot_state_and_control(\n    t,\n    x,\n    u,\n    state_names=None,\n    control_names=None,\n    title='State and Control Trajectories',\n    color_scheme='plotly',\n    theme=None,\n    show_legend=True,\n    **kwargs,\n)\nPlot states and controls in synchronized subplots.\nCreates two subplot groups: states (top) and controls (bottom), with synchronized time axes.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nnp.ndarray\nTime points, shape (T,) or (n_batch, T)\nrequired\n\n\nx\nnp.ndarray\nState trajectories, shape (T, nx) or (n_batch, T, nx)\nrequired\n\n\nu\nnp.ndarray\nControl inputs, shape (T, nu) or (n_batch, T, nu)\nrequired\n\n\nstate_names\nOptional[List[str]]\nNames for state variables\nNone\n\n\ncontrol_names\nOptional[List[str]]\nNames for control inputs\nNone\n\n\ntitle\nstr\nOverall plot title\n'State and Control Trajectories'\n\n\ncolor_scheme\nstr\nColor scheme name Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, etc.\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\nshow_legend\nbool\nWhether to show legend Default: True\nTrue\n\n\n**kwargs\n\nAdditional arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nPlotly figure with state and control subplots\n\n\n\n\n\nExamples\n&gt;&gt;&gt; t = np.linspace(0, 10, 100)\n&gt;&gt;&gt; x = np.column_stack([np.sin(t), np.cos(t)])\n&gt;&gt;&gt; u = 0.1 * np.random.randn(100, 1)\n&gt;&gt;&gt; fig = plotter.plot_state_and_control(\n...     t, x, u,\n...     state_names=['Position', 'Velocity'],\n...     control_names=['Force'],\n...     theme='publication'\n... )\n&gt;&gt;&gt; fig.show()\n\n\n\nplot_trajectory\nvisualization.TrajectoryPlotter.plot_trajectory(\n    t,\n    x,\n    u=None,\n    state_names=None,\n    control_names=None,\n    title='State Trajectories',\n    color_scheme='plotly',\n    theme=None,\n    show_legend=True,\n    **kwargs,\n)\nPlot state trajectories over time.\nCreates subplots for each state variable showing evolution over time. Automatically handles single or batched trajectories.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nt\nnp.ndarray\nTime points, shape (T,) or (n_batch, T)\nrequired\n\n\nx\nnp.ndarray\nState trajectories, shape (T, nx) or (n_batch, T, nx)\nrequired\n\n\nu\nOptional[np.ndarray]\nControl inputs, shape (T, nu) or (n_batch, T, nu) If provided, adds control subplot(s)\nNone\n\n\nstate_names\nOptional[List[str]]\nNames for state variables, length nx Default: [‘x₁’, ‘x₂’, …]\nNone\n\n\ncontrol_names\nOptional[List[str]]\nNames for control inputs, length nu\nNone\n\n\ntitle\nstr\nOverall plot title\n'State Trajectories'\n\n\ncolor_scheme\nstr\nColor scheme name Options: ‘plotly’, ‘d3’, ‘colorblind_safe’, ‘tableau’, ‘sequential_blue’, ‘diverging_red_blue’, etc. Default: ‘plotly’\n'plotly'\n\n\ntheme\nOptional[str]\nPlot theme to apply Options: ‘default’, ‘publication’, ‘dark’, ‘presentation’ If None, uses self.default_theme\nNone\n\n\nshow_legend\nbool\nWhether to show legend for batched trajectories\nTrue\n\n\n**kwargs\n\nAdditional arguments for customization\n{}\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\ngo.Figure\nPlotly figure object\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Single trajectory\n&gt;&gt;&gt; t = np.linspace(0, 10, 100)\n&gt;&gt;&gt; x = np.column_stack([np.sin(t), np.cos(t)])\n&gt;&gt;&gt; fig = plotter.plot_trajectory(t, x, state_names=['sin', 'cos'])\n&gt;&gt;&gt; fig.show()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Batched trajectories with colorblind-safe palette\n&gt;&gt;&gt; x_batch = np.random.randn(5, 100, 2)\n&gt;&gt;&gt; fig = plotter.plot_trajectory(\n...     t, x_batch,\n...     color_scheme='colorblind_safe'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Publication-ready plot\n&gt;&gt;&gt; fig = plotter.plot_trajectory(\n...     t, x,\n...     theme='publication',\n...     color_scheme='colorblind_safe'\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # With control\n&gt;&gt;&gt; u = 0.1 * np.random.randn(100, 1)\n&gt;&gt;&gt; fig = plotter.plot_trajectory(t, x, u=u)\n\n\nNotes\n\nAutomatically detects batched vs single trajectories\nConverts from PyTorch/JAX to NumPy internally\nAdaptive subplot layout based on number of states\nInteractive: zoom, pan, hover tooltips"
  },
  {
    "objectID": "api/types.core.CovarianceMatrix.html",
    "href": "api/types.core.CovarianceMatrix.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.core.CovarianceMatrix.html#examples",
    "href": "api/types.core.CovarianceMatrix.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # State covariance (isotropic)\n&gt;&gt;&gt; P: CovarianceMatrix = np.eye(3)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Measurement noise (diagonal)\n&gt;&gt;&gt; R: CovarianceMatrix = np.diag([0.1, 0.05, 0.02])\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Process noise (correlated)\n&gt;&gt;&gt; Q: CovarianceMatrix = np.array([[0.1, 0.05], [0.05, 0.2]])"
  },
  {
    "objectID": "api/types.conformal.ConformalPredictionResult.html",
    "href": "api/types.conformal.ConformalPredictionResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.conformal.ConformalPredictionResult.html#fields",
    "href": "api/types.conformal.ConformalPredictionResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nprediction_set : ConformalPredictionSet Prediction set(s) for test point(s) point_prediction : StateVector Point prediction (e.g., set center) coverage_guarantee : float Guaranteed coverage level (1 - α) average_set_size : float Average size of prediction sets nonconformity_score : NonconformityScore Nonconformity score(s) for test point(s) threshold : float Threshold q for set construction adaptive : bool Whether adaptive to input x"
  },
  {
    "objectID": "api/types.conformal.ConformalPredictionResult.html#examples",
    "href": "api/types.conformal.ConformalPredictionResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Create conformal predictor\n&gt;&gt;&gt; cp = ConformalPredictor(\n...     model=my_model,\n...     calibration_data=(x_cal, y_cal)\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Predict with 90% coverage guarantee\n&gt;&gt;&gt; result: ConformalPredictionResult = cp.predict(\n...     x_test=np.array([1.5, 2.0]),\n...     alpha=0.1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Extract prediction set\n&gt;&gt;&gt; if isinstance(result['prediction_set'], tuple):\n...     lower, upper = result['prediction_set']\n...     print(f\"Prediction interval: [{lower}, {upper}]\")\n...\n&gt;&gt;&gt; print(f\"Coverage guarantee: {result['coverage_guarantee']*100:.1f}%\")\n&gt;&gt;&gt; print(f\"Average set size: {result['average_set_size']:.3f}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # For multiple test points\n&gt;&gt;&gt; result_batch: ConformalPredictionResult = cp.predict(\n...     x_test=np.random.randn(100, 2),\n...     alpha=0.05  # 95% coverage\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; avg_size = result_batch['average_set_size']\n&gt;&gt;&gt; print(f\"Average prediction set size: {avg_size:.3f}\")"
  },
  {
    "objectID": "api/types.reachability.CLFResult.html",
    "href": "api/types.reachability.CLFResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.reachability.CLFResult.html#fields",
    "href": "api/types.reachability.CLFResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nstabilizing_control : ControlVector Control ensuring V̇ &lt; 0 lyapunov_value : float V(x) at current state lyapunov_derivative : float V̇(x, u) under current control stability_margin : float How much V̇ &lt; 0 (larger = faster convergence) convergence_rate : float Exponential rate α in V̇ ≤ -αV feasible : bool CLF condition feasible"
  },
  {
    "objectID": "api/types.reachability.CLFResult.html#examples",
    "href": "api/types.reachability.CLFResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Quadratic Lyapunov function\n&gt;&gt;&gt; P = np.array([[2, 0], [0, 1]])\n&gt;&gt;&gt; V = lambda x: x.T @ P @ x\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create CLF controller\n&gt;&gt;&gt; clf = ControlLyapunovFunction(lyapunov=V, system=pendulum, alpha=0.5)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Compute stabilizing control\n&gt;&gt;&gt; x = np.array([0.5, 0.1])\n&gt;&gt;&gt;\n&gt;&gt;&gt; result: CLFResult = clf.compute_control(x)\n&gt;&gt;&gt;\n&gt;&gt;&gt; if result['feasible']:\n...     u = result['stabilizing_control']\n...     print(f\"V(x) = {result['lyapunov_value']:.3f}\")\n...     print(f\"V̇(x,u) = {result['lyapunov_derivative']:.3f}\")\n...     print(f\"Convergence rate: {result['convergence_rate']:.2f}\")\n... else:\n...     print(\"CLF condition infeasible\")"
  },
  {
    "objectID": "api/types.trajectories.NoiseSequence.html",
    "href": "api/types.trajectories.NoiseSequence.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.trajectories.NoiseSequence.html#examples",
    "href": "api/types.trajectories.NoiseSequence.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Standard normal noise for discrete system\n&gt;&gt;&gt; w_seq: NoiseSequence = np.random.randn(100, 2)\n&gt;&gt;&gt; trajectory = system.simulate_stochastic(x0, u_seq, w_seq)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Brownian increments for continuous SDE\n&gt;&gt;&gt; dt = 0.01\n&gt;&gt;&gt; n_steps = 1000\n&gt;&gt;&gt; dW: NoiseSequence = np.random.randn(n_steps, 2) * np.sqrt(dt)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Reproducible simulation with seed\n&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; w_seq: NoiseSequence = np.random.randn(100, 3)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Batched Monte Carlo simulation\n&gt;&gt;&gt; n_trials = 1000\n&gt;&gt;&gt; w_batch: NoiseSequence = np.random.randn(100, n_trials, 2)\n&gt;&gt;&gt; trajectories_mc = system.simulate_stochastic_batch(x0, u_seq, w_batch)\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Colored noise (correlated)\n&gt;&gt;&gt; # First generate white noise, then filter\n&gt;&gt;&gt; w_white = np.random.randn(1000, 2)\n&gt;&gt;&gt; # Apply low-pass filter for colored noise\n&gt;&gt;&gt; from scipy.signal import lfilter\n&gt;&gt;&gt; b, a = [0.1, 0.9], [1.0]\n&gt;&gt;&gt; w_colored: NoiseSequence = lfilter(b, a, w_white, axis=0)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html",
    "href": "api/systems.base.numerical_integration.validate_method.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#parameters",
    "href": "api/systems.base.numerical_integration.validate_method.html#parameters",
    "title": "",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmethod\nstr\nMethod name to validate (canonical or backend-specific)\nrequired\n\n\nbackend\nBackend\nTarget backend: ‘numpy’, ‘torch’, or ‘jax’\nrequired\n\n\nis_stochastic\nbool\nWhether the system is stochastic (SDE) or deterministic (ODE)\nFalse"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#returns",
    "href": "api/systems.base.numerical_integration.validate_method.html#returns",
    "title": "",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nis_valid\nbool\nTrue if method is valid, False otherwise\n\n\nerror_message\nstr or None\nDescription of problem if invalid, None if valid"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#validation-checks",
    "href": "api/systems.base.numerical_integration.validate_method.html#validation-checks",
    "title": "",
    "section": "Validation Checks",
    "text": "Validation Checks\n\nNormalization: Convert canonical names to backend-specific\nBackend availability: Check if method exists for backend\nType mismatch: Detect SDE method on deterministic system\n\nDoes NOT check: - Whether required packages are installed (diffeqpy, torchsde, etc.) - Whether method will actually work (that’s for integrator factory) - Performance characteristics or accuracy"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#error-messages",
    "href": "api/systems.base.numerical_integration.validate_method.html#error-messages",
    "title": "",
    "section": "Error Messages",
    "text": "Error Messages\nError messages are designed to be user-friendly and actionable:\n\nMethod not available: Lists available methods for backend\nType mismatch: Explains SDE method used on deterministic system\nInvalid backend: Lists valid backends"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#examples",
    "href": "api/systems.base.numerical_integration.validate_method.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\nValid configurations:\n&gt;&gt;&gt; # Canonical name on appropriate backend\n&gt;&gt;&gt; is_valid, error = validate_method('euler_maruyama', 'torch', is_stochastic=True)\n&gt;&gt;&gt; print(is_valid)\nTrue\n&gt;&gt;&gt; print(error)\nNone\n&gt;&gt;&gt; # Backend-specific name\n&gt;&gt;&gt; is_valid, error = validate_method('RK45', 'numpy', is_stochastic=False)\n&gt;&gt;&gt; print(is_valid)\nTrue\n&gt;&gt;&gt; # Manual implementation (works everywhere)\n&gt;&gt;&gt; is_valid, error = validate_method('rk4', 'jax', is_stochastic=False)\n&gt;&gt;&gt; print(is_valid)\nTrue\nInvalid configurations:\n&gt;&gt;&gt; # Method doesn't exist for backend\n&gt;&gt;&gt; is_valid, error = validate_method('LSODA', 'torch', is_stochastic=False)\n&gt;&gt;&gt; print(is_valid)\nFalse\n&gt;&gt;&gt; print(error)\nMethod 'LSODA' not available for torch backend. Available methods: ...\n&gt;&gt;&gt; # SDE method on deterministic system\n&gt;&gt;&gt; is_valid, error = validate_method('euler_maruyama', 'numpy', is_stochastic=False)\n&gt;&gt;&gt; print(is_valid)\nFalse\n&gt;&gt;&gt; print(error)\nSDE method 'euler_maruyama' used on deterministic system\n&gt;&gt;&gt; # Deterministic method on SDE system (WARNING, not error)\n&gt;&gt;&gt; is_valid, error = validate_method('rk4', 'numpy', is_stochastic=True)\n&gt;&gt;&gt; print(is_valid)\nTrue  # Valid, but may ignore noise (handled elsewhere)\nUsage in DiscretizedSystem:\n&gt;&gt;&gt; # Validate during initialization\n&gt;&gt;&gt; normalized_method = normalize_method_name(user_method, backend)\n&gt;&gt;&gt; is_valid, error = validate_method(normalized_method, backend, is_stochastic)\n&gt;&gt;&gt;\n&gt;&gt;&gt; if not is_valid:\n...     raise ValueError(f\"Invalid method configuration: {error}\")\nPre-flight check before expensive computation:\n&gt;&gt;&gt; # Check multiple configurations\n&gt;&gt;&gt; configurations = [\n...     ('rk4', 'numpy', False),\n...     ('euler_maruyama', 'torch', True),\n...     ('LSODA', 'jax', False),  # This will fail\n... ]\n&gt;&gt;&gt;\n&gt;&gt;&gt; for method, backend, is_stochastic in configurations:\n...     is_valid, error = validate_method(method, backend, is_stochastic)\n...     if is_valid:\n...         print(f\"✓ {method} on {backend}\")\n...     else:\n...         print(f\"✗ {method} on {backend}: {error}\")\nGenerate user-friendly error messages:\n&gt;&gt;&gt; def create_discretization(system, method, backend):\n...     is_valid, error = validate_method(\n...         method, backend, system.is_stochastic\n...     )\n...\n...     if not is_valid:\n...         # Show user what went wrong\n...         print(f\"Error: {error}\")\n...\n...         # Show alternatives\n...         available = get_available_methods(\n...             backend,\n...             method_type='stochastic' if system.is_stochastic else 'deterministic'\n...         )\n...         print(f\"Try one of: {available['canonical_aliases']}\")\n...         return None\n...\n...     return DiscretizedSystem(system, dt=0.01, method=method)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#notes",
    "href": "api/systems.base.numerical_integration.validate_method.html#notes",
    "title": "",
    "section": "Notes",
    "text": "Notes\n\nNormalization happens automatically before validation\nDoes not check if packages (diffeqpy, torchsde) are installed\nOnly validates logical consistency, not runtime availability\nOriginal method name preserved in error messages for clarity\n\nAmbiguous Method Handling: Some methods appear in both deterministic and SDE categories: - ‘euler’: Valid for both contexts (determined by is_stochastic flag) - ‘midpoint’: Valid for both contexts (determined by is_stochastic flag) - When is_stochastic=False and method is SDE-only, validation fails - When is_stochastic=True and method is deterministic, validation passes (with warning handled elsewhere, as noise will be ignored)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#limitations",
    "href": "api/systems.base.numerical_integration.validate_method.html#limitations",
    "title": "",
    "section": "Limitations",
    "text": "Limitations\n\nCannot detect if specific method version is buggy\nCannot check if method is appropriate for problem stiffness\nCannot verify if tolerances are reasonable\nDoes not check hardware compatibility (GPU, TPU)"
  },
  {
    "objectID": "api/systems.base.numerical_integration.validate_method.html#see-also",
    "href": "api/systems.base.numerical_integration.validate_method.html#see-also",
    "title": "",
    "section": "See Also",
    "text": "See Also\nnormalize_method_name : Normalize before validation get_available_methods : List all methods for backend is_sde_method : Check if method is for stochastic systems"
  },
  {
    "objectID": "api/types.reachability.ReachabilityResult.html",
    "href": "api/types.reachability.ReachabilityResult.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/types.reachability.ReachabilityResult.html#fields",
    "href": "api/types.reachability.ReachabilityResult.html#fields",
    "title": "",
    "section": "Fields",
    "text": "Fields\nreachable_set : ReachableSet Reachable set at final time T reachable_tube : List[ReachableSet] Reachable set at each time t ∈ [0,T] volume : float Volume/measure of reachable set representation : str Set representation type (‘polytope’, ‘ellipsoid’, ‘zonotope’, ‘grid’) method : str Method used (‘Hamilton-Jacobi’, ‘Ellipsoidal’, ‘Zonotope’, ‘sampling’) computation_time : float Computation time in seconds"
  },
  {
    "objectID": "api/types.reachability.ReachabilityResult.html#examples",
    "href": "api/types.reachability.ReachabilityResult.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Forward reachability\n&gt;&gt;&gt; result: ReachabilityResult = compute_reachable_set(\n...     system=pendulum,\n...     x0=np.array([0.1, 0.0]),\n...     u_bounds=[-1, 1],\n...     horizon=10,\n...     dt=0.1\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Visualize reachable tube\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; for i, reach_set in enumerate(result['reachable_tube']):\n...     plt.plot(reach_set[:, 0], reach_set[:, 1],\n...              alpha=0.3, color='blue')\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(f\"Final volume: {result['volume']:.3f}\")\n&gt;&gt;&gt; print(f\"Method: {result['method']}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check if target reached\n&gt;&gt;&gt; x_target = np.array([0, 0])\n&gt;&gt;&gt; final_set = result['reachable_set']\n&gt;&gt;&gt; # Check if x_target in convex hull of final_set"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#physical-system",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#physical-system",
    "title": "",
    "section": "Physical System:",
    "text": "Physical System:\nThe Standard Map models a kicked rotor: a pendulum that receives periodic impulses (kicks). Between kicks, the pendulum rotates freely; at each kick, it receives an angular momentum impulse proportional to sin(θ).\nPhysical Setup: - Rotor with moment of inertia I (normalized to 1) - Free rotation between kicks (no gravity, no friction) - Periodic kicks at times t = n·τ (τ = kick period) - Kick strength K controls perturbation amplitude\nHamiltonian Description: Between kicks (continuous time): H₀ = p²/2 (free rotation) θ̇ = ∂H₀/∂p = p ṗ = -∂H₀/∂θ = 0\nAt kicks (instantaneous): H_kick = -K·cos(θ)·Σδ(t - nτ) Δp = K·sin(θ)\nThe Map: Combining free rotation + kicks gives discrete-time evolution: p[n+1] = p[n] + K·sin(θ[n]) θ[n+1] = θ[n] + p[n+1] (mod 2π)\nKey Feature - Area Preservation (Symplectic): The Standard Map preserves phase space area (Liouville’s theorem): |det(Jacobian)| = 1\nThis is the discrete analog of energy conservation in Hamiltonian systems. Unlike dissipative systems (logistic map), there are NO attractors - trajectories fill phase space densely."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#state-space",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#state-space",
    "title": "",
    "section": "State Space:",
    "text": "State Space:\nState: x[n] = [θ[n], p[n]] Angular position: - θ: Angle [rad], periodic: θ ∈ [0, 2π) or (-π, π] * θ = 0: Reference position * θ + 2π ≡ θ (rotational symmetry) * Represents angular coordinate on circle\nAngular momentum:\n- p: Conjugate momentum [rad/time], unbounded: -∞ &lt; p &lt; ∞\n  * p &gt; 0: Counterclockwise rotation\n  * p &lt; 0: Clockwise rotation\n  * p = 0: Stationary (at kick instant)\n  * Between kicks: p is constant of motion\n  * At kicks: p changes by K·sin(θ)\nPhase Space Structure: The (θ, p) plane has cylindrical topology: - θ is periodic (circle) - p is unbounded (line) - Phase space is a cylinder: S¹ × ℝ\nControl: u[n] (optional, for controlled standard map) - Can represent: * Variable kick strength: K → K + u[n] * Additional external torque * Feedback control to stabilize orbits - Standard map: u = 0 (autonomous)\nOutput: y[n] = [θ[n], p[n]] - Full state measurement (both angle and momentum) - In practice: * θ measured via encoder/position sensor * p inferred from Δθ or measured via velocity sensor"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#dynamics",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#dynamics",
    "title": "",
    "section": "Dynamics:",
    "text": "Dynamics:\nThe Standard Map equations are:\np[n+1] = p[n] + K·sin(θ[n])\nθ[n+1] = θ[n] + p[n+1]  (mod 2π)\nMathematical Properties:\n\nArea-preserving (symplectic): Jacobian determinant = 1 (exactly) Phase space volume conserved No attractors or repellers\nTime-reversal symmetry: Map is reversible: can run backwards Inverse map exists\nTwo-dimensional: Simplest non-integrable Hamiltonian system Higher dimensions allow Arnold diffusion\nPoincaré map: Samples continuous kicked rotor at kick times Reduces continuous flow to discrete map\nPeriodic in θ: f(θ + 2π, p) = f(θ, p) + (2π, 0) Allows folding phase space onto cylinder"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#parameters",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#parameters",
    "title": "",
    "section": "Parameters:",
    "text": "Parameters:\nK : float, default=1.0 Kick strength (stochasticity parameter)\n**Physical Meaning:**\n- K measures perturbation strength relative to free motion\n- Dimensionless parameter (ratio of kick to rotation)\n- Controls degree of nonlinearity\n\n**Parameter Regimes:**\n\n**K = 0:**\n- Integrable limit (no kicks)\n- Pure rotation: θ[n+1] = θ[n] + p₀\n- All orbits are straight lines in (θ, p)\n- Every trajectory is regular (quasi-periodic)\n- Phase space foliated by invariant tori\n\n**0 &lt; K &lt; 0.5:**\n- Near-integrable regime\n- Most phase space covered by KAM tori (invariant curves)\n- Small chaotic regions near separatrices\n- Orbits mostly regular, quasi-periodic\n- KAM theorem applies: most tori survive\n\n**K ≈ 0.971635...**\n- Critical threshold for last KAM torus\n- Golden mean winding number (most robust)\n- Below: global stochastic layer blocked by KAM tori\n- Above: trajectories can diffuse to arbitrarily large |p|\n\n**0.5 &lt; K &lt; 2:**\n- Mixed phase space\n- Chaotic seas coexist with regular islands\n- Resonance overlap (Chirikov criterion)\n- Some KAM tori destroyed, others persist\n- Complicated fractal boundary structure\n\n**2 &lt; K &lt; 5:**\n- Mostly chaotic\n- Few surviving islands (high-order resonances)\n- Large-scale chaos, but bounded regions remain\n- Cantori (destroyed tori) create partial barriers\n\n**K &gt; 5:**\n- Fully developed chaos\n- Almost all phase space is chaotic\n- Fast momentum diffusion: ⟨p²⟩ ~ K²·n (classical diffusion)\n- Only tiny islands remain at high-order resonances\n\n**K → ∞:**\n- Random walk limit\n- Momentum diffusion coefficient: D ~ K²/2\n- Approaches Brownian motion\ndt : float, default=1.0 Time between kicks (kick period τ) - Usually normalized to 1 - Physical time scale (seconds, milliseconds, etc.) - Doesn’t affect map dynamics (only units)\nuse_wrapped_theta : bool, default=True If True, θ ∈ [0, 2π); if False, θ unbounded - Wrapped: Natural for rotational dynamics - Unwrapped: Useful for tracking rotation number"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#equilibria-and-periodic-orbits",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#equilibria-and-periodic-orbits",
    "title": "",
    "section": "Equilibria and Periodic Orbits:",
    "text": "Equilibria and Periodic Orbits:\nUnlike dissipative systems, the Standard Map has NO fixed points in the usual sense (except at K = 0). Instead, it has:\nPeriodic Orbits: - Period-1: (θ, p) such that map returns after 1 iteration - Period-n: Returns after n iterations - Infinitely many periodic orbits of each period - Form hierarchical island chain structure\nResonances: For small K, periodic orbits occur near: p ≈ 2πm/n (m, n integers)\nThese are resonances where rotation number is rational.\nElliptic vs Hyperbolic Fixed Points: - Elliptic: Stable, surrounded by invariant curves (islands) - Hyperbolic: Unstable, with stable/unstable manifolds (X-points)\nExample Period-1 Orbits (K small): - (0, 0): Elliptic, stable - (π, 0): Hyperbolic, unstable (separatrix)\nKAM Tori (Invariant Curves): For K &lt; K_critical, some invariant curves survive: - Most robust: Golden mean winding number ω = (√5 - 1)/2 ≈ 0.618… - Form barriers to chaotic transport - Destroy via resonance overlap as K increases"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#kam-theory-and-resonance-overlap",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#kam-theory-and-resonance-overlap",
    "title": "",
    "section": "KAM Theory and Resonance Overlap:",
    "text": "KAM Theory and Resonance Overlap:\nKAM Theorem (Kolmogorov-Arnold-Moser): For sufficiently small perturbations, MOST invariant tori survive, though they are deformed. Tori are destroyed if: 1. Winding number is rational (resonance) 2. Winding number is “too well approximated” by rationals\nChirikov Resonance Overlap Criterion: Chaos sets in when neighboring resonances overlap: ΔK ≈ K·(width of resonances)\nFor Standard Map: K_critical ≈ 1 for onset of global stochasticity\nGreene’s Residue Criterion: Precise threshold: K_c ≈ 0.971635… Last KAM torus has golden mean winding number.\nMixed Phase Space: For K &lt; K_c: - Chaotic sea confined by KAM tori - Regular islands embedded in chaos - Fractal boundaries (cantori) - No global diffusion\nFor K &gt; K_c: - Trajectories can diffuse to arbitrarily large |p| - Stochastic layer connects all regions - Cantori (partial barriers) slow diffusion"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#chaos-characterization",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#chaos-characterization",
    "title": "",
    "section": "Chaos Characterization:",
    "text": "Chaos Characterization:\nLyapunov Exponents: Area preservation implies: λ₁ + λ₂ = 0 (sum of Lyapunov exponents = 0)\nIf λ₁ &gt; 0 (chaos), then λ₂ = -λ₁ &lt; 0.\nRotation Number: For regular orbits, rotation number is defined: ω = lim (θ[n] - θ[0])/(2πn) n→∞\n\nRational ω: Periodic orbit\nIrrational ω: Quasi-periodic (on KAM torus)\nUndefined ω: Chaotic orbit\n\nPoincaré-Birkhoff Theorem: Each rational rotation number has at least two periodic orbits: one elliptic (stable) and one hyperbolic (unstable).\nWinding Number Distribution: For chaotic orbits, winding number has probabilistic description."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#momentum-diffusion",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#momentum-diffusion",
    "title": "",
    "section": "Momentum Diffusion:",
    "text": "Momentum Diffusion:\nIn chaotic regime, momentum performs random walk: ⟨p²⟩ ~ D·n\nDiffusion coefficient: - K small: D ~ exp(-const/K) (exponentially suppressed) - K large: D ~ K²/2 (classical random walk)\nAcceleration Modes: At special K values, ballistic growth possible: ⟨p²⟩ ~ n² (super-diffusive)\nThis occurs when dynamics resonates with map periodicity."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#control-objectives",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#control-objectives",
    "title": "",
    "section": "Control Objectives:",
    "text": "Control Objectives:\n1. Chaos Control: Goal: Stabilize unstable periodic orbits (UPO) Method: OGY (Ott-Grebogi-Yorke) control - Locate UPO in chaotic sea - Apply small perturbations to K - Stabilize orbit with minimal control\n2. Chaos Suppression: Goal: Restore regular motion by feedback Control: u[n] = -K_control·sin(θ[n]) Reduces effective K below chaos threshold\n3. Accelerator Mode Stabilization: Goal: Maintain accelerator mode for rapid transport Applications: Particle beam control\n4. Island Confinement: Goal: Keep trajectory within regular island Useful for stability in beam dynamics\n5. Transport Enhancement: Goal: Maximize momentum diffusion Applications: Mixing, ergodic optimization"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#numerical-considerations",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#numerical-considerations",
    "title": "",
    "section": "Numerical Considerations:",
    "text": "Numerical Considerations:\nAngle Wrapping: Always reduce θ modulo 2π to keep in [0, 2π): θ[n+1] = (θ[n] + p[n+1]) % (2π)\nWithout wrapping, θ grows unbounded, complicating visualization.\nArea Preservation Check: Jacobian should always have determinant = 1: J = | ∂θ[n+1]/∂θ[n] ∂θ[n+1]/∂p[n] | | ∂p[n+1]/∂θ[n] ∂p[n+1]/∂p[n] |\ndet(J) = 1 + K·cos(θ)·1 - K·cos(θ)·1 = 1 ✓\nLong-Time Integration: - Standard Map is exactly area-preserving (no drift) - Can integrate indefinitely without accumulation of error - Unlike approximate integrators for continuous systems - Roundoff errors may accumulate but don’t break symplecticity\nInitial Conditions: Choice of (θ₀, p₀) determines orbit character: - Regular regions: orbit stays on torus - Chaotic sea: orbit explores allowed region - Near separatrix: most sensitive to K\nVisualization: Phase space plots (Poincaré sections): - Plot (θ[n], p[n]) for many iterations - Regular orbits → closed curves (tori) - Chaotic orbits → scattered points (dense filling) - Mixed: islands + chaotic sea"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#example-usage",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#example-usage",
    "title": "",
    "section": "Example Usage:",
    "text": "Example Usage:\n\n\n\nCreate Standard Map with moderate chaos\nsystem = StandardMap(K=1.5)\nSingle trajectory - chaotic sea\nx0_chaotic = np.array([0.5, 0.5]) result_chaotic = system.simulate( … x0=x0_chaotic, … u_sequence=None, … n_steps=5000 … )\nSingle trajectory - regular island\nx0_regular = np.array([0.0, 0.1]) result_regular = system.simulate( … x0=x0_regular, … u_sequence=None, … n_steps=5000 … )\nPhase space portrait\nimport plotly.graph_objects as go fig = go.Figure()\nChaotic trajectory\nfig.add_trace(go.Scatter( … x=result_chaotic[‘states’][:, 0], … y=result_chaotic[‘states’][:, 1], … mode=‘markers’, … marker=dict(size=1, color=‘red’, opacity=0.5), … name=‘Chaotic’ … ))\nRegular trajectory\nfig.add_trace(go.Scatter( … x=result_regular[‘states’][:, 0], … y=result_regular[‘states’][:, 1], … mode=‘markers’, … marker=dict(size=1, color=‘blue’, opacity=0.5), … name=‘Regular’ … ))\nfig.update_layout( … title=f’Standard Map Phase Space (K = {system.K})‘, … xaxis_title=’θ [rad]’, … yaxis_title=‘p [rad]’, … width=800, … height=600 … ) fig.show()\nGenerate phase space portrait with many initial conditions\nphase_portrait = system.generate_phase_portrait( … n_trajectories=20, … n_steps=1000, … p_range=(-3, 3) … ) fig_portrait = system.plot_phase_portrait(phase_portrait) fig_portrait.show()\nCompute Lyapunov exponent\nlyapunov = system.compute_lyapunov_exponent( … x0=np.array([1.0, 1.0]), … n_iterations=10000 … ) print(f”Lyapunov exponent: λ = {lyapunov:.4f}“) if lyapunov &gt; 0.01: … print(”Trajectory is CHAOTIC”)\nStudy K dependence (bifurcation-like diagram)\nK_values = np.linspace(0.1, 5.0, 50) lyapunov_vs_K = []\nfor K_val in K_values: … sys_temp = StandardMap(K=K_val) … lyap = sys_temp.compute_lyapunov_exponent( … x0=np.array([1.0, 1.0]), … n_iterations=5000 … ) … lyapunov_vs_K.append(lyap)\nimport plotly.graph_objects as go fig = go.Figure() fig.add_trace(go.Scatter( … x=K_values, … y=lyapunov_vs_K, … mode=‘lines+markers’, … name=‘Lyapunov exponent’ … )) fig.add_hline(y=0, line_dash=‘dash’, line_color=‘red’) fig.update_layout( … title=‘Chaos Onset: Lyapunov Exponent vs Kick Strength’, … xaxis_title=‘K (kick strength)’, … yaxis_title=‘λ (Lyapunov exponent)’, … width=900, … height=500 … ) fig.show()\nCompute rotation number\nrotation_number = system.compute_rotation_number( … x0=np.array([0.0, 0.5]), … n_iterations=10000 … ) if rotation_number is not None: … print(f”Rotation number: ω = {rotation_number:.6f}“) … # Check if rational … from fractions import Fraction … frac = Fraction(rotation_number).limit_denominator(1000) … print(f”Approximately: {frac}“) … else: … print(”Orbit is chaotic (rotation number undefined)“)\nMomentum diffusion analysis\ndiffusion_data = system.compute_momentum_diffusion( … x0=np.array([1.0, 1.0]), … n_steps=10000 … )\nfig = go.Figure() fig.add_trace(go.Scatter( … x=diffusion_data[‘n’], … y=diffusion_data[‘p_squared’], … mode=‘lines’, … name=‘⟨p²⟩’ … ))\nFit to p² ~ D·n\nD_fit = np.polyfit( … diffusion_data[‘n’][1000:], … diffusion_data[‘p_squared’][1000:], … deg=1 … )[0] fig.add_trace(go.Scatter( … x=diffusion_data[‘n’], … y=D_fit * diffusion_data[‘n’], … mode=‘lines’, … line=dict(dash=‘dash’), … name=f’Fit: D = {D_fit:.3f}’ … ))\nfig.update_layout( … title=f’Momentum Diffusion (K = {system.K})‘, … xaxis_title=’Iteration n’, … yaxis_title=‘⟨p²⟩’, … width=800, … height=500 … ) fig.show()\nCompare different K values in phase space\nfrom plotly.subplots import make_subplots\nK_compare = [0.5, 1.0, 2.0, 4.0] fig = make_subplots( … rows=2, cols=2, … subplot_titles=[f’K = {K}’ for K in K_compare] … )\nfor idx, K_val in enumerate(K_compare): … row = idx // 2 + 1 … col = idx % 2 + 1 … … sys_temp = StandardMap(K=K_val) … portrait = sys_temp.generate_phase_portrait( … n_trajectories=15, … n_steps=800, … p_range=(-np.pi, np.pi) … ) … … for traj in portrait[‘trajectories’]: … fig.add_trace( … go.Scatter( … x=traj[:, 0], … y=traj[:, 1], … mode=‘markers’, … marker=dict(size=0.5), … showlegend=False … ), … row=row, col=col … )\nfig.update_xaxes(title_text=‘θ’, range=[0, 2*np.pi]) fig.update_yaxes(title_text=‘p’) fig.update_layout( … title_text=‘Standard Map: Transition to Chaos’, … height=800, … width=1000 … ) fig.show()"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#physical-insights",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#physical-insights",
    "title": "",
    "section": "Physical Insights:",
    "text": "Physical Insights:\nWhy Area Preservation Matters: Conservation of phase space volume is the discrete analog of energy conservation. Unlike dissipative systems: - No attractors (everything keeps moving) - No basins of attraction - Volume in phase space is conserved - Ergodic properties possible\nKAM Tori as Barriers: Invariant curves (KAM tori) act as impenetrable barriers: - Prevent momentum diffusion - Confine chaotic regions - When destroyed → global transport possible - Golden mean torus is most robust\nResonance Overlap: Chaos emerges when perturbation strong enough that: - Neighboring resonances overlap - Separatrices intersect chaotically - Homoclinic tangle forms - Regular motion destroyed\nConnection to Quantum Mechanics: Standard Map is prototypical for quantum chaos: - Classical chaos ↔︎ Quantum eigenfunctions - K plays role of effective ℏ (inverse) - “Quantum” Standard Map shows localization - Dynamical Anderson localization\nAccelerator Physics: Standard Map models: - Particles in storage rings - RF cavity kicks - Nonlinear resonances - Beam stability criteria\nCelestial Mechanics: Analogous to: - Asteroid belt gaps (resonances with Jupiter) - Satellite orbit perturbations - Three-body problem (restricted) - Kirkwood gaps explained by resonance overlap"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#common-pitfalls",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#common-pitfalls",
    "title": "",
    "section": "Common Pitfalls:",
    "text": "Common Pitfalls:\n\nForgetting angle wrapping: Must reduce θ mod 2π for correct visualization Unwrapped θ grows linearly with rotation\nConfusing with dissipative maps: Standard Map has NO attractors Phase space is uniformly filled (ergodic) Cannot use attractor-finding methods\nInsufficient iterations: Need many iterations (&gt;1000) to see structure Chaotic orbits fill region densely Regular orbits trace closed curves slowly\nWrong initial conditions: Different regions show different behavior Need to sample many ICs to see full phase space\nIgnoring symplectic structure: Standard Map exactly preserves det(J) = 1 Numerical methods must respect this Standard integration schemes may fail\nRotation number convergence: Chaotic orbits have no well-defined rotation number Regular orbits require many iterations to converge Rational approximations can be misleading"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#extensions-and-variations",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#extensions-and-variations",
    "title": "",
    "section": "Extensions and Variations:",
    "text": "Extensions and Variations:\n\nGeneralized Standard Map: p[n+1] = p[n] + K·f(θ[n]) θ[n+1] = θ[n] + p[n+1] Different f(θ) changes chaos threshold\nDissipative Standard Map: p[n+1] = γ·p[n] + K·sin(θ[n]) θ[n+1] = θ[n] + p[n+1] γ &lt; 1 breaks area preservation, creates attractors\nStandard Map with Noise: Stochastic perturbations Studies interplay of chaos and noise\nFour-Dimensional Standard Map: Two coupled kicked rotors Shows Arnold diffusion\nQuantum Standard Map: Kicked rotor in quantum mechanics Dynamical localization phenomenon\nWeb Map (K &lt; 0): Accelerator-mode version Ballistic momentum growth"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#see-also",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#see-also",
    "title": "",
    "section": "See Also:",
    "text": "See Also:\nHenonMap : 2D dissipative chaos LogisticMap : 1D dissipative chaos"
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#attributes",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nK\nKick strength parameter."
  },
  {
    "objectID": "api/systems.builtin.deterministic.discrete.StandardMap.html#methods",
    "href": "api/systems.builtin.deterministic.discrete.StandardMap.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nclassify_regime\nClassify dynamical regime based on K value.\n\n\ncompute_jacobian\nCompute Jacobian matrix at state x.\n\n\ncompute_lyapunov_exponent\nCompute largest Lyapunov exponent.\n\n\ncompute_momentum_diffusion\nCompute momentum diffusion ⟨p²⟩ vs iteration number.\n\n\ncompute_rotation_number\nCompute rotation number (winding number) for regular orbits.\n\n\ndefine_system\nDefine Standard Map dynamics.\n\n\nsetup_equilibria\nSet up periodic orbits (no true fixed points for K ≠ 0).\n\n\nstep\nOverride step to add angle wrapping if enabled.\n\n\nverify_symplectic\nVerify that Jacobian is symplectic (det = 1).\n\n\n\n\nclassify_regime\nsystems.builtin.deterministic.discrete.StandardMap.classify_regime()\nClassify dynamical regime based on K value.\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nRegime description\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = StandardMap(K=0.3)\n&gt;&gt;&gt; print(system.classify_regime())\n'near_integrable'\n\n\n\ncompute_jacobian\nsystems.builtin.deterministic.discrete.StandardMap.compute_jacobian(x)\nCompute Jacobian matrix at state x.\nFor Standard Map: J = | 1 + K·cos(θ) 1 | | K·cos(θ) 1 |\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState [θ, p]\nrequired\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nJacobian matrix (2×2)\n\n\n\n\n\nNotes\nDeterminant is always 1 (area-preserving): det(J) = (1 + K·cos(θ))·1 - K·cos(θ)·1 = 1 ✓\n\n\n\ncompute_lyapunov_exponent\nsystems.builtin.deterministic.discrete.StandardMap.compute_lyapunov_exponent(\n    x0,\n    n_iterations=10000,\n    n_transient=1000,\n)\nCompute largest Lyapunov exponent.\nFor Standard Map, λ₁ + λ₂ = 0 (symplectic constraint). We compute λ₁ (largest exponent).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nnp.ndarray\nInitial state [θ₀, p₀]\nrequired\n\n\nn_iterations\nint\nNumber of iterations for averaging\n10000\n\n\nn_transient\nint\nNumber of initial iterations to discard\n1000\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nLargest Lyapunov exponent - λ &gt; 0: Chaotic - λ ≈ 0: Neutral (near bifurcation or integrable) - λ &lt; 0: Regular (on KAM torus)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = StandardMap(K=2.0)\n&gt;&gt;&gt; lyap = system.compute_lyapunov_exponent(\n...     x0=np.array([1.0, 1.0]),\n...     n_iterations=20000\n... )\n&gt;&gt;&gt; print(f\"Lyapunov exponent: {lyap:.4f}\")\n\n\n\ncompute_momentum_diffusion\nsystems.builtin.deterministic.discrete.StandardMap.compute_momentum_diffusion(\n    x0,\n    n_steps=10000,\n)\nCompute momentum diffusion ⟨p²⟩ vs iteration number.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nnp.ndarray\nInitial state\nrequired\n\n\nn_steps\nint\nNumber of iterations\n10000\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ndict\nDictionary with: - ‘n’: Iteration numbers - ‘p’: Momentum values - ‘p_squared’: ⟨p²⟩ values\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = StandardMap(K=3.0)\n&gt;&gt;&gt; diff_data = system.compute_momentum_diffusion(\n...     x0=np.array([1.0, 1.0]),\n...     n_steps=20000\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; import plotly.graph_objects as go\n&gt;&gt;&gt; fig = go.Figure()\n&gt;&gt;&gt; fig.add_trace(go.Scatter(\n...     x=diff_data['n'],\n...     y=diff_data['p_squared'],\n...     mode='lines'\n... ))\n&gt;&gt;&gt; fig.update_layout(title='Momentum Diffusion')\n&gt;&gt;&gt; fig.show()\n\n\n\ncompute_rotation_number\nsystems.builtin.deterministic.discrete.StandardMap.compute_rotation_number(\n    x0,\n    n_iterations=10000,\n    tolerance=1e-06,\n)\nCompute rotation number (winding number) for regular orbits.\nFor regular (quasi-periodic) orbits on KAM tori: ω = lim (θ[n] - θ[0])/(2πn) n→∞\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx0\nnp.ndarray\nInitial state [θ₀, p₀]\nrequired\n\n\nn_iterations\nint\nNumber of iterations\n10000\n\n\ntolerance\nfloat\nTolerance for convergence check\n1e-06\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat or None\nRotation number if orbit is regular, None if chaotic\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = StandardMap(K=0.5)\n&gt;&gt;&gt; # Regular orbit\n&gt;&gt;&gt; omega = system.compute_rotation_number(np.array([0.5, 0.5]))\n&gt;&gt;&gt; if omega is not None:\n...     print(f\"Rotation number: ω = {omega:.6f}\")\n\n\nNotes\nFor chaotic orbits, rotation number is undefined (returns None). For rational rotation numbers, orbit is periodic. For irrational rotation numbers, orbit is quasi-periodic (on torus).\n\n\n\ndefine_system\nsystems.builtin.deterministic.discrete.StandardMap.define_system(\n    K=1.0,\n    dt=1.0,\n    use_wrapped_theta=True,\n    use_controlled_version=False,\n)\nDefine Standard Map dynamics.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nK\nfloat\nKick strength (stochasticity parameter)\n1.0\n\n\ndt\nfloat\nTime between kicks (usually 1.0)\n1.0\n\n\nuse_wrapped_theta\nbool\nIf True, wrap θ to [0, 2π); if False, allow unbounded θ\nTrue\n\n\nuse_controlled_version\nbool\nIf True, adds control input u[n] to momentum equation\nFalse\n\n\n\n\n\n\nsetup_equilibria\nsystems.builtin.deterministic.discrete.StandardMap.setup_equilibria()\nSet up periodic orbits (no true fixed points for K ≠ 0).\nFor K ≠ 0, there are no fixed points, only periodic orbits. We add the origin as a “reference point” for small K.\n\n\nstep\nsystems.builtin.deterministic.discrete.StandardMap.step(\n    x,\n    u=None,\n    k=0,\n    backend=None,\n)\nOverride step to add angle wrapping if enabled.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState [θ, p]\nrequired\n\n\nu\nOptional[np.ndarray]\nControl input (if enabled)\nNone\n\n\nk\nint\nTime step\n0\n\n\nbackend\nOptional[str]\nBackend to use\nNone\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nnp.ndarray\nNext state [θ[k+1], p[k+1]] with θ wrapped if enabled\n\n\n\n\n\n\nverify_symplectic\nsystems.builtin.deterministic.discrete.StandardMap.verify_symplectic(\n    x,\n    tolerance=1e-10,\n)\nVerify that Jacobian is symplectic (det = 1).\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nnp.ndarray\nState to check\nrequired\n\n\ntolerance\nfloat\nTolerance for determinant = 1\n1e-10\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nbool\nTrue if symplectic within tolerance\n\n\n\n\n\nExamples\n&gt;&gt;&gt; system = StandardMap(K=2.0)\n&gt;&gt;&gt; x_test = np.array([1.0, 0.5])\n&gt;&gt;&gt; is_symplectic = system.verify_symplectic(x_test)\n&gt;&gt;&gt; print(f\"Symplectic: {is_symplectic}\")"
  },
  {
    "objectID": "api/visualization.ColorSchemes.html",
    "href": "api/visualization.ColorSchemes.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "api/visualization.ColorSchemes.html#attributes",
    "href": "api/visualization.ColorSchemes.html#attributes",
    "title": "",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nPLOTLY\nList[str]\nDefault Plotly color sequence (10 colors)\n\n\nD3\nList[str]\nD3.js Category10 colors (10 colors)\n\n\nCOLORBLIND_SAFE\nList[str]\nWong palette - colorblind accessible (8 colors)\n\n\nTABLEAU\nList[str]\nTableau 10 color palette (10 colors)\n\n\nSEQUENTIAL_BLUE\nList[str]\nBlue sequential scale for heatmaps (9 colors)\n\n\nSEQUENTIAL_GREEN\nList[str]\nGreen sequential scale (9 colors)\n\n\nDIVERGING_RED_BLUE\nList[str]\nRed-blue diverging scale (9 colors)\n\n\nDIVERGING_PURPLE_GREEN\nList[str]\nPurple-green diverging scale (9 colors)"
  },
  {
    "objectID": "api/visualization.ColorSchemes.html#examples",
    "href": "api/visualization.ColorSchemes.html#examples",
    "title": "",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; # Get Plotly colors\n&gt;&gt;&gt; colors = ColorSchemes.PLOTLY\n&gt;&gt;&gt; print(colors[0])  # '#636EFA'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get colorblind-safe palette\n&gt;&gt;&gt; colors = ColorSchemes.get_colors('colorblind_safe', n_colors=3)"
  },
  {
    "objectID": "api/visualization.ColorSchemes.html#methods",
    "href": "api/visualization.ColorSchemes.html#methods",
    "title": "",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nget_colors\nGet color palette by name.\n\n\ninterpolate_colors\nGenerate color gradient between two colors.\n\n\n\n\nget_colors\nvisualization.ColorSchemes.get_colors(scheme='plotly', n_colors=None)\nGet color palette by name.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nscheme\nstr\nName of color scheme: - ‘plotly’: Default Plotly colors - ‘d3’: D3.js colors - ‘colorblind_safe’: Colorblind accessible - ‘tableau’: Tableau 10 palette - ‘sequential_blue’: Blue gradient - ‘sequential_green’: Green gradient - ‘diverging_red_blue’: Red-blue scale - ‘diverging_purple_green’: Purple-green scale\n'plotly'\n\n\nn_colors\nOptional[int]\nNumber of colors needed If more than available, cycles through palette\nNone\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nList of hex color codes\n\n\n\n\n\nExamples\n&gt;&gt;&gt; colors = ColorSchemes.get_colors('plotly', n_colors=5)\n&gt;&gt;&gt; print(len(colors))  # 5\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Cycles if more colors needed\n&gt;&gt;&gt; colors = ColorSchemes.get_colors('colorblind_safe', n_colors=10)\n&gt;&gt;&gt; print(len(colors))  # 10 (cycles through 8-color palette)\n\n\nRaises\n\n\n\nName\nType\nDescription\n\n\n\n\n\nValueError\nIf scheme name is not recognized\n\n\n\n\n\n\ninterpolate_colors\nvisualization.ColorSchemes.interpolate_colors(color1, color2, n_steps=10)\nGenerate color gradient between two colors.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolor1\nstr\nStarting color (hex code)\nrequired\n\n\ncolor2\nstr\nEnding color (hex code)\nrequired\n\n\nn_steps\nint\nNumber of intermediate colors\n10\n\n\n\n\n\nReturns\n\n\n\nName\nType\nDescription\n\n\n\n\n\nList[str]\nList of hex color codes\n\n\n\n\n\nExamples\n&gt;&gt;&gt; # Gradient from red to blue\n&gt;&gt;&gt; gradient = ColorSchemes.interpolate_colors('#FF0000', '#0000FF', n_steps=5)\n&gt;&gt;&gt; print(gradient)\n['#FF0000', '#BF003F', '#7F007F', '#3F00BF', '#0000FF']"
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "TODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-mechanical-systems",
    "href": "examples/index.html#sec-mechanical-systems",
    "title": "Examples",
    "section": "",
    "text": "TODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-aerospace-systems",
    "href": "examples/index.html#sec-aerospace-systems",
    "title": "Examples",
    "section": "Aerospace Systems",
    "text": "Aerospace Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-chemical-systems",
    "href": "examples/index.html#sec-chemical-systems",
    "title": "Examples",
    "section": "Chemical Systems",
    "text": "Chemical Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-chaotic-systems",
    "href": "examples/index.html#sec-chaotic-systems",
    "title": "Examples",
    "section": "Chaotic Systems",
    "text": "Chaotic Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-stochastic-systems",
    "href": "examples/index.html#sec-stochastic-systems",
    "title": "Examples",
    "section": "Stochastic Systems",
    "text": "Stochastic Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "examples/index.html#sec-discrete-systems",
    "href": "examples/index.html#sec-discrete-systems",
    "title": "Examples",
    "section": "Discrete Systems",
    "text": "Discrete Systems\n\nTODO: Plan and make these"
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html",
    "href": "architecture/Delegation_Layer_Architecture.html",
    "title": "Delegation Layer Architecture",
    "section": "",
    "text": "The Delegation Layer (also called the Support Framework) provides specialized internal services to the UI framework through composition rather than inheritance. This layer consists of 11 focused utility classes that handle backend management, code generation, dynamics evaluation, and stochastic analysis.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework components. Users should NOT directly instantiate or interact with these classes. The delegation layer is an internal implementation detail accessed through the high-level system interface:\n# ❌ INCORRECT: Direct delegation layer access\ncode_gen = CodeGenerator(system)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n\n# ✓ CORRECT: Use system interface (delegation happens automatically)\nsystem = Pendulum()\ndx = system(x, u)  # DynamicsEvaluator called internally\nA, B = system.linearize(x_eq, u_eq)  # LinearizationEngine called internally\nThe system classes (e.g., ContinuousSymbolicSystem) automatically compose these utilities and expose their functionality through clean, user-facing APIs. This documentation is provided for framework developers and advanced users who need to understand the internal architecture.",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-overview",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-overview",
    "title": "Delegation Layer Architecture",
    "section": "",
    "text": "The Delegation Layer (also called the Support Framework) provides specialized internal services to the UI framework through composition rather than inheritance. This layer consists of 11 focused utility classes that handle backend management, code generation, dynamics evaluation, and stochastic analysis.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework components. Users should NOT directly instantiate or interact with these classes. The delegation layer is an internal implementation detail accessed through the high-level system interface:\n# ❌ INCORRECT: Direct delegation layer access\ncode_gen = CodeGenerator(system)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n\n# ✓ CORRECT: Use system interface (delegation happens automatically)\nsystem = Pendulum()\ndx = system(x, u)  # DynamicsEvaluator called internally\nA, B = system.linearize(x_eq, u_eq)  # LinearizationEngine called internally\nThe system classes (e.g., ContinuousSymbolicSystem) automatically compose these utilities and expose their functionality through clean, user-facing APIs. This documentation is provided for framework developers and advanced users who need to understand the internal architecture.",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-architecture-philosophy",
    "title": "Delegation Layer Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\n\nComposition Over Inheritance\nInstead of creating deep inheritance hierarchies, the UI framework composes these specialized utilities as private attributes. This internal composition is transparent to users:\n\n\nCode\n# Internal framework structure (users never access these directly)\nbackend_manager = continuous_pendulum.backend  # BackendManager\ncode_generator = continuous_pendulum._code_gen  # CodeGenerator\ndynamics_evaluator = continuous_pendulum._dynamics  # DynamicsEvaluator\nlinearization_engine = continuous_pendulum._linearization  # LinearizationEngine\nobservation_engine = continuous_pendulum._observation  # ObservationEngine\nequilibrium_handler = continuous_pendulum.equilibria  # EquilibriumHandler\n\n# Stochastic systems add additional handlers\ndiffusion_handler = langevin.diffusion_handler  # DiffusionHandler\n\nprint(\"✓ Framework internally composed - users interact with system methods only\")\n\n\n\n\nDesign Benefits\nThis architecture provides:\n\nSingle Responsibility - Each class does one thing well\nReusability - Utilities can be composed by different system types\nTestability - Each component tested in isolation\nFlexibility - Easy to swap implementations internally\nClarity - Clear separation of concerns\nEncapsulation - Internal complexity hidden from users",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-architecture-layers",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-architecture-layers",
    "title": "Delegation Layer Architecture",
    "section": "Architecture Layers",
    "text": "Architecture Layers\n┌─────────────────────────────────────────────────────────────┐\n│                     UI FRAMEWORK                            │\n│  (SymbolicSystemBase, ContinuousSymbolicSystem, etc.)       │\n│                                                             │\n│  User-facing methods that delegate to utilities:            │\n│  • system(x, u) → delegates to DynamicsEvaluator            │\n│  • system.linearize() → delegates to LinearizationEngine    │\n│  • system.set_default_backend() → delegates to BackendMgr   │\n└────────────────────┬────────────────────────────────────────┘\n                     │ uses (composition)\n                     ↓\n┌─────────────────────────────────────────────────────────────┐\n│                  DELEGATION LAYER (Internal)                │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  CORE UTILITIES (Universal)                           │  │\n│  │  • BackendManager      - Multi-backend support        │  │\n│  │  • CodeGenerator       - Symbolic → numerical         │  │\n│  │  • EquilibriumHandler  - Equilibrium management       │  │\n│  │  • SymbolicValidator   - System validation            │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  DETERMINISTIC EVALUATION (ODE Systems)               │  │\n│  │  • DynamicsEvaluator    - Forward dynamics            │  │\n│  │  • LinearizationEngine  - Jacobian computation        │  │\n│  │  • ObservationEngine    - Output evaluation           │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  STOCHASTIC SUPPORT (SDE Systems)                     │  │\n│  │  • DiffusionHandler    - Diffusion generation         │  │\n│  │  • NoiseCharacterizer  - Noise analysis               │  │\n│  │  • SDEValidator        - SDE validation               │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  LOW-LEVEL UTILITIES                                  │  │\n│  │  • codegen_utils       - SymPy code generation        │  │\n│  └───────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-core-utilities",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-core-utilities",
    "title": "Delegation Layer Architecture",
    "section": "Core Utilities (Universal)",
    "text": "Core Utilities (Universal)\n\nBackendManager: Multi-Backend Array Handling\nFile: backend_manager.py\nThe BackendManager handles all backend-specific array operations and device management. Users interact with this functionality through system-level methods, never directly.\nInternal responsibilities:\n\nBackend detection from array types\nArray conversion between backends (NumPy ↔︎ PyTorch ↔︎ JAX)\nBackend availability checking\nDevice management (CPU, CUDA, TPU)\nDefault backend configuration\nTemporary backend switching (context manager)\n\nUser-facing interface (system-level):\n\n\nCode\n# ✓ User interacts with system methods\nsystem = Pendulum()\n\n# Check current backend\nprint(f\"Default backend: {system.backend.default_backend}\")\n\n# Set backend for system\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\n# Temporary backend switching\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx = system(x_torch, u_torch)\n    print(f\"Result type: {type(dx)}\")\n\nprint(\"✓ Backend management through system interface\")\n\n\nSupported backends:\n\n\n\n\n\n\n\n\nBackend\nExecution\nBest For\n\n\n\n\nNumPy\nCPU\nGeneral purpose, maximum compatibility\n\n\nPyTorch\nCPU/GPU\nNeural networks, GPU acceleration, autograd\n\n\nJAX\nCPU/GPU/TPU\nOptimization, XLA compilation, functional programming\n\n\n\nInternal capabilities (framework use only):\n# Framework code (users never write this)\nbackend = backend_manager.detect(array)\nx_torch = backend_manager.convert(array, target_backend='torch')\nx_cuda = backend_manager.convert(array, target_backend='torch', device='cuda:0')\n\n\nCodeGenerator: Symbolic to Numerical Compilation\nFile: code_generator.py\nThe CodeGenerator orchestrates the symbolic-to-numerical code generation pipeline with intelligent caching. This is completely internal—users simply call system methods that trigger code generation when needed.\nInternal responsibilities:\n\nGenerate dynamics functions: f(x, u) → dx/dt\nGenerate output functions: h(x) → y\nGenerate Jacobian functions: A, B, C\nPer-backend function caching\nCompilation and warmup\nCache invalidation on parameter changes\n\nHow users benefit (transparent):\n\n\nCode\nsystem = Pendulum()\n\n# First call: Code generated and cached automatically\nx = np.array([1.0, 0.0])\nu = np.array([0.0])\ndx1 = system(x, u)  # CodeGenerator works internally\n\n# Subsequent calls: Use cached compiled function (fast)\ndx2 = system(x, u)  # Instant - cached function reused\n\n# When you change parameters, cache automatically invalidates\n# (parameters are accessed via system.parameters dict)\nm_sym = [k for k in system.parameters.keys() if str(k) == 'm'][0]\nl_sym = [k for k in system.parameters.keys() if str(k) == 'l'][0]\nsystem.parameters[m_sym] = 2.0\nsystem.parameters[l_sym] = 1.0\nsystem.reset_caches()  # Explicitly clear cache after parameter change\ndx3 = system(x, u)  # Uses new parameter values\n\nprint(\"✓ Code generation happens transparently\")\n\n\nCaching strategy (internal):\n\nFunctions cached per backend\nSymbolic Jacobians computed once, then compiled per backend\nAutomatic cache invalidation on parameter changes\nLazy generation (only when first needed)\n\nBackend-specific optimizations (internal):\n\nNumPy: Common subexpression elimination (CSE)\nPyTorch: Expression simplification for autograd\nJAX: JIT compilation via jax.jit\n\n\n\nEquilibriumHandler: Named Equilibrium Management\nFile: equilibrium_handler.py\nThe EquilibriumHandler manages multiple named equilibrium points with automatic backend conversion. Users interact through system methods.\nInternal responsibilities:\n\nStore equilibria as NumPy arrays (backend-neutral)\nConvert to any backend on demand\nNamed equilibrium management\nEquilibrium verification\nMetadata storage (stability, description, etc.)\n\nUser-facing interface:\n\n\nCode\nsystem = Pendulum()\n\n# Add equilibrium (system delegates to EquilibriumHandler)\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0]),\n    u_eq=np.zeros(1),\n    verify=True,\n    metadata={'stability': 'unstable', 'description': 'Inverted pendulum'}\n)\n\n# Get equilibrium (backend conversion automatic)\nx_eq, u_eq = system.get_equilibrium('upright')\n\n# List all equilibria\nequilibria = system.list_equilibria()\nprint(f\"Available equilibria: {equilibria}\")\n\n# Get metadata\nmeta = system.get_equilibrium_metadata('upright')\nif meta:\n    print(f\"Stability: {meta.get('stability', 'unknown')}\")\nelse:\n    print(\"No metadata available\")\n\n\nAutomatic features:\n\nOrigin equilibrium always present\nDimension validation on add\nFinite value checking (no NaN/Inf)\nOptional verification with tolerance\nBackend-agnostic storage with on-demand conversion\n\n\n\nSymbolicValidator: System Definition Validation\nFile: symbolic_validator.py\nThe SymbolicValidator performs comprehensive validation of symbolic system definitions during initialization. Users benefit from clear error messages without directly interacting with the validator.\nValidation checks (automatic during system creation):\nRequired validations:\n\n✓ state_vars is list of sp.Symbol\n✓ control_vars is list of sp.Symbol\n✓ _f_sym is sp.Matrix with correct dimensions\n✓ parameters keys are sp.Symbol (not strings)\n✓ order divides nx evenly (nx % order == 0)\n\nOutput function validations (if defined):\n\n✓ _h_sym is sp.Matrix\n✓ _h_sym only depends on state_vars (not control)\n✓ output_vars matches _h_sym dimensions\n\nExample validation (automatic):\n# This validation happens automatically during system creation\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self):\n        x = sp.Symbol('x')\n        \n        # ❌ This will fail validation with clear error message\n        self.parameters = {'m': 1.0}  # String key instead of Symbol\n        \n        # ✓ Correct - validator passes\n        m = sp.Symbol('m')\n        self.parameters = {m: 1.0}  # Symbol key\nError messages are clear and actionable, helping users fix issues quickly.",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-deterministic-evaluation",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-deterministic-evaluation",
    "title": "Delegation Layer Architecture",
    "section": "Deterministic Evaluation Components",
    "text": "Deterministic Evaluation Components\n\nDynamicsEvaluator: Forward Dynamics Computation\nFile: dynamics_evaluator.py\nThe DynamicsEvaluator handles forward dynamics evaluation (dx/dt = f(x, u)) across all backends. Users call system(x, u) which internally delegates to this evaluator.\nInternal responsibilities:\n\nEvaluate dx/dt = f(x, u) for controlled systems\nEvaluate dx/dt = f(x) for autonomous systems\nHandle batched vs single evaluation\nBackend-specific dispatch\nInput shape validation\nPerformance tracking\n\nUser-facing interface:\n\n\nCode\nsystem = Pendulum()\n\n# Single evaluation (DynamicsEvaluator called internally)\nx = np.array([1.0, 0.0])\nu = np.array([0.0])\ndx = system(x, u)\nprint(f\"State derivative shape: {dx.shape}\")\n\n# Batched evaluation (automatically detected)\nx_batch = np.random.randn(100, 2)\nu_batch = np.zeros((100, 1))\ndx_batch = system(x_batch, u_batch)\nprint(f\"Batch derivatives shape: {dx_batch.shape}\")\n\n# Works seamlessly with different backends\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx_torch = system(x_torch, u_torch)\n    print(f\"PyTorch result type: {type(dx_torch)}\")\n\n\nAutomatic features:\n\nBackend detection from input arrays\nShape validation and broadcasting\nBatched evaluation detection\nPerformance statistics tracking\n\n\n\nLinearizationEngine: Jacobian Computation\nFile: linearization_engine.py\nThe LinearizationEngine computes system linearizations (Jacobians) at equilibrium points. Users access this through system.linearize().\nMathematical forms:\nContinuous systems:\n\\[\\delta\\dot{x} = A\\delta x + B\\delta u\\]\nwhere:\n\\[A = \\frac{\\partial f}{\\partial x}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_x}\\]\n\\[B = \\frac{\\partial f}{\\partial u}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_u}\\]\nDiscrete systems:\n\\[\\delta x[k+1] = A_d\\delta x[k] + B_d\\delta u[k]\\]\nUser-facing interface:\n\n\nCode\nsystem = Pendulum()\n\n# Get equilibrium point\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Compute linearization (LinearizationEngine called internally)\nA, B = system.linearize(x_eq, u_eq)\nprint(f\"A matrix shape: {A.shape}\")\nprint(f\"B matrix shape: {B.shape}\")\n\n# Works with any backend\nwith system.use_backend('torch'):\n    x_eq_torch = torch.tensor([0.0, 0.0])\n    u_eq_torch = torch.tensor([0.0])\n    A_torch, B_torch = system.linearize(x_eq_torch, u_eq_torch)\n    print(f\"PyTorch A type: {type(A_torch)}\")\n\n\nHigher-order system handling:\nFor order=n systems where the state is [q, q̇, ..., q^(n-1)] and only q^(n) is defined:\n\nAutomatically constructs full state-space representation\nComputes Jacobian of complete state derivative\nReturns proper \\((n_x \\times n_x)\\) and \\((n_x \\times n_u)\\) matrices\n\n\n\nObservationEngine: Output Function Evaluation\nFile: observation_engine.py\nThe ObservationEngine handles output function evaluation (y = h(x)) and output Jacobian computation. Users access through system.output() and system.output_jacobian().\nMathematical form:\n\\[y = h(x)\\]\nOutput linearization:\n\\[\\delta y = C\\delta x\\]\nwhere\n\\[C = \\frac{\\partial h}{\\partial x}\\bigg|_{x_{eq}} \\in \\mathbb{R}^{n_y \\times n_x}\\]\nUser-facing interface:\n\n\nCode\n# Create system with output function\nclass ObservableSystem(ContinuousSymbolicSystem):\n    def define_system(self):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -x + u])\n        \n        # Output: only position is measured\n        self._h_sym = sp.Matrix([x])\n        self.output_vars = [sp.Symbol('y')]\n        self.order = 1\n\nsystem = ObservableSystem()\n\n# Evaluate output\nx = np.array([1.5, 0.2])\ny = system.h(x)  # h() method evaluates output\nprint(f\"Output: {y}\")\n\n# Compute output Jacobian\nC = system.linearized_observation(x)\nprint(f\"C matrix shape: {C.shape}\")",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-stochastic-support",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-stochastic-support",
    "title": "Delegation Layer Architecture",
    "section": "Stochastic Support Components",
    "text": "Stochastic Support Components\n\nDiffusionHandler: SDE Diffusion Management\nFile: diffusion_handler.py\nThe DiffusionHandler generates and caches diffusion functions for stochastic systems. Users interact through system.diffusion() method.\nMathematical form:\n\\[dx = f(x, u)dt + g(x, u)dW\\]\nDiffusion matrix \\(g(x, u) \\in \\mathbb{R}^{n_x \\times n_w}\\)\nwhere:\n\n\\(n_x\\): state dimension\n\\(n_w\\): number of independent Wiener processes\n\nNoise structure types (auto-detected):\n\n\n\n\n\n\n\n\nType\nStructure\nOptimization\n\n\n\n\nAdditive\n\\(g(x, u) = \\text{constant}\\)\nReturn constant matrix (no recomputation)\n\n\nMultiplicative Diagonal\n\\(g\\) is diagonal\nIndependent noise channels\n\n\nMultiplicative Scalar\n\\(n_w = 1\\)\nSingle Wiener process\n\n\nGeneral\nFull matrix coupling\nComplete computation\n\n\n\nUser-facing interface:\n\n\nCode\n# Stochastic system automatically sets up DiffusionHandler\nsystem = LangevinDynamics()\n\n# Evaluate diffusion (DiffusionHandler called internally)\n# LangevinDynamics has nx=2 (position and velocity)\nx = np.array([1.0, 0.5])\nu = np.array([0.0])\ng = system.diffusion(x, u)\nprint(f\"Diffusion matrix shape: {g.shape}\")\n\n# Check noise properties\nprint(f\"Is additive noise: {system.is_additive_noise()}\")\nprint(f\"Noise dimensions: {system.nw}\")\n\n# Get solver recommendations based on noise structure\nsolvers = system.recommend_solvers('torch')\nprint(f\"Recommended solvers: {solvers[:3] if len(solvers) &gt; 3 else solvers}\")\n\n\nAutomatic optimizations (internal):\n\nAdditive noise: Returns constant matrix, no function calls needed\nDiagonal noise: Specialized handling for independent channels\nScalar noise: Simplified operations for single Wiener process\n\n\n\nSDEValidator: SDE-Specific Validation\nFile: sde_validator.py\nThe SDEValidator performs SDE-specific validation during system creation. Validation happens automatically with clear error messages.\nValidation checks (automatic):\n\n✓ diffusion_expr is sp.Matrix\n✓ Dimensions: \\((n_x, n_w)\\) where \\(n_w \\geq 1\\)\n✓ diffusion_expr only uses state_vars and control_vars\n✓ sde_type is ‘ito’ or ‘stratonovich’\n✓ Compatibility between drift and diffusion\n✓ No division by zero in diffusion terms\n\nExample validation (automatic):\nclass MyStochasticSystem(ContinuousStochasticSystem):\n    def define_system(self):\n        x = sp.Symbol('x')\n        sigma = sp.Symbol('sigma', positive=True)\n        \n        # ❌ Wrong dimensions - validator catches this\n        self.diffusion_expr = sp.Matrix([[sigma]])  # nx=2 but only 1 row\n        \n        # ✓ Correct dimensions\n        self.diffusion_expr = sp.Matrix([[sigma], [0]])  # (2, 1) ✓",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-low-level-utilities",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-low-level-utilities",
    "title": "Delegation Layer Architecture",
    "section": "Low-Level Utilities",
    "text": "Low-Level Utilities\n\ncodegen_utils: SymPy Code Generation\nFile: codegen_utils.py\nLow-level utilities for converting SymPy expressions to executable functions. This is completely internal to the framework.\nOptimization strategies (internal):\nNumPy: - Common subexpression elimination (CSE) - Fast numerical modules (‘numpy’, ‘scipy’) - Matrix operation optimization\nPyTorch: - Symbolic simplification before generation - Automatic differentiation compatibility - GPU tensor operation support\nJAX: - JIT compilation via jax.jit - Pure functional style for XLA - Automatic vectorization",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-composition-patterns",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-composition-patterns",
    "title": "Delegation Layer Architecture",
    "section": "Internal Composition Patterns",
    "text": "Internal Composition Patterns\n\n\n\n\n\n\nNoteFramework Implementation Details\n\n\n\nThese patterns show how the framework internally composes delegation layer components. Users never write this code—it’s handled automatically by system classes.\n\n\n\nPattern 1: Core System Utilities\nUsed by all symbolic systems:\n# Internal framework code (in SymbolicSystemBase.__init__)\nself.backend = BackendManager(default_backend, default_device)\nself._code_gen = CodeGenerator(self, self.backend)\nself._validator = SymbolicValidator()\nself.equilibria = EquilibriumHandler(nx, nu)\n\n\nPattern 2: Deterministic Extensions\nAdded by continuous and discrete systems:\n# Internal framework code (in ContinuousSymbolicSystem.__init__)\nsuper().__init__(*args, **kwargs)  # Core utilities\n\n# Add deterministic evaluators\nself._dynamics = DynamicsEvaluator(self, self._code_gen, self.backend)\nself._linearization = LinearizationEngine(self, self._code_gen, self.backend)\nself._observation = ObservationEngine(self, self._code_gen, self.backend)\n\n\nPattern 3: Stochastic Extensions\nAdded by stochastic systems:\n# Internal framework code (in ContinuousStochasticSystem.__init__)\nsuper().__init__(*args, **kwargs)  # Deterministic utilities\n\n# Add stochastic support\nself.diffusion_handler = DiffusionHandler(self, self._code_gen, self.backend)\nself.noise_characteristics = NoiseCharacterizer().analyze(self.diffusion_expr)\nself._sde_validator = SDEValidator()",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-design-principles",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-design-principles",
    "title": "Delegation Layer Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\nSingle Responsibility Principle\nEach class has one clear, focused purpose:\n\nBackendManager → Backend management only\nCodeGenerator → Code generation only\nDynamicsEvaluator → Dynamics evaluation only\nLinearizationEngine → Linearization only\n\n\n\nComposition Over Inheritance\nSystems compose utilities as private attributes rather than inheriting functionality:\n# ❌ NOT: Deep inheritance\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator):\n    pass\n\n# ✓ YES: Composition\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()\n        self._code_gen = CodeGenerator()\n        self._dynamics = DynamicsEvaluator()\n\n\nDependency Injection\nUtilities receive dependencies explicitly through constructors:\n# Clear dependency chain (internal framework code)\nbackend_mgr = BackendManager()\ncode_gen = CodeGenerator(system, backend_mgr)\ndynamics = DynamicsEvaluator(system, code_gen, backend_mgr)\n\n\nInterface Segregation\nEach utility exposes a minimal, focused interface:\n\nBackendManager: detect, convert, to_backend\nCodeGenerator: generate_dynamics, generate_jacobians\nDynamicsEvaluator: evaluate\n\n\n\nLazy Initialization\nFunctions generated and cached only when first needed:\n# First call: generates and caches\nf = code_gen.generate_dynamics('numpy')\n\n# Subsequent calls: returns cached\nf_again = code_gen.generate_dynamics('numpy')\nassert f is f_again  # Same function object\n\n\nBackend Agnosticism\nAll utilities work transparently across backends:\n# Same interface, different backends (internal)\ndx_numpy = evaluator.evaluate(x_np, u_np, backend='numpy')\ndx_torch = evaluator.evaluate(x_torch, u_torch, backend='torch')\ndx_jax = evaluator.evaluate(x_jax, u_jax, backend='jax')",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-practical-examples",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-practical-examples",
    "title": "Delegation Layer Architecture",
    "section": "Practical Examples",
    "text": "Practical Examples\n\n\n\n\n\n\nNoteUser-Facing Examples\n\n\n\nThese examples show how users benefit from the delegation layer through the system interface. Users never directly instantiate delegation layer components.\n\n\n\nExample 1: Creating a System (Delegation Automatic)\n\n\nCode\nclass SpringMassDamper(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0, c=0.5):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        m_sym, k_sym, c_sym = sp.symbols('m k c', positive=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([\n            v,\n            (-k_sym*x - c_sym*v + u)/m_sym\n        ])\n        self.parameters = {m_sym: m, k_sym: k, c_sym: c}\n        self.order = 1\n\n# Delegation layer automatically composed internally\nsystem = SpringMassDamper()\n\n# User interacts with clean system interface\nx = np.array([1.0, 0.0])\nu = np.array([0.5])\ndx = system(x, u)  # DynamicsEvaluator called internally\n\nA, B = system.linearize(np.zeros(2), np.zeros(1))  # LinearizationEngine\nprint(f\"System created with automatic delegation\")\n\n\n\n\nExample 2: Multi-Backend Usage (Transparent)\n\n\nCode\nsystem = Pendulum()\n\n# NumPy computation\nx_np = np.array([1.0, 0.0])\nu_np = np.array([0.0])\ndx_np = system(x_np, u_np)\n\n# PyTorch computation (backend conversion automatic)\nwith system.use_backend('torch'):\n    x_torch = torch.tensor([1.0, 0.0])\n    u_torch = torch.tensor([0.0])\n    dx_torch = system(x_torch, u_torch)\n    print(f\"PyTorch result: {type(dx_torch)}\")\n\n# JAX computation\nwith system.use_backend('jax'):\n    x_jax = jnp.array([1.0, 0.0])\n    u_jax = jnp.array([0.0])\n    dx_jax = system(x_jax, u_jax)\n    print(f\"JAX result: {type(dx_jax)}\")\n\nprint(\"✓ Backend management completely transparent\")\n\n\n\n\nExample 3: Stochastic System (Full Delegation)\n\n\nCode\nclass BrownianMotion(ContinuousStochasticSystem):\n    def define_system(self, mu=0.0, sigma=1.0):\n        x = sp.Symbol('x', real=True)\n        u = sp.Symbol('u', real=True)\n        mu_sym, sigma_sym = sp.symbols('mu sigma', real=True)\n        \n        self.state_vars = [x]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([mu_sym + u])\n        self.diffusion_expr = sp.Matrix([[sigma_sym]])\n        self.parameters = {mu_sym: mu, sigma_sym: sigma}\n        self.sde_type = 'ito'\n        self.order = 1\n\n# Stochastic delegation automatic\nsde_system = BrownianMotion()\n\n# User interacts through clean interface\nx = np.array([0.0])\nu = np.array([0.0])\n\n# Drift and diffusion evaluated automatically\nf = sde_system.drift(x, u)  # DynamicsEvaluator\ng = sde_system.diffusion(x, u)  # DiffusionHandler\n\nprint(f\"Noise type: {sde_system.is_additive_noise()}\")\nprint(f\"Recommended methods: {sde_system.recommend_solvers('numpy')[:3]}\")\n\n\n\n\nExample 4: Equilibrium Management (Delegated)\n\n\nCode\nsystem = Pendulum()\n\n# Add multiple equilibria (delegates to EquilibriumHandler)\nsystem.add_equilibrium(\n    'upright',\n    x_eq=np.array([np.pi, 0.0]),\n    u_eq=np.zeros(1),\n    verify=True,\n    metadata={'stability': 'unstable'}\n)\n\nsystem.add_equilibrium(\n    'downright',\n    x_eq=np.array([-np.pi, 0.0]),\n    u_eq=np.zeros(1),\n    metadata={'stability': 'unstable'}\n)\n\n# List and access equilibria\nequilibria = system.list_equilibria()\nprint(f\"Available: {equilibria}\")\n\n# Get equilibrium in any backend\nx_eq_np, u_eq_np = system.get_equilibrium('upright')\n\nwith system.use_backend('torch'):\n    x_eq_torch, u_eq_torch = system.get_equilibrium('upright')\n    print(f\"Backend conversion automatic: {type(x_eq_torch)}\")\n\n\n\n\nExample 5: Linearization Workflow (Seamless)\n\n\nCode\nsystem = SpringMassDamper()\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Linearize (LinearizationEngine called internally)\nA, B = system.linearize(x_eq, u_eq)\n\n# Analyze stability\neigenvalues = np.linalg.eigvals(A)\nprint(f\"Eigenvalues: {eigenvalues}\")\nprint(f\"Stable: {np.all(eigenvalues.real &lt; 0)}\")\n\n# Linearization works with any backend\nwith system.use_backend('torch'):\n    A_torch, B_torch = system.linearize(\n        torch.zeros(2),\n        torch.zeros(1)\n    )\n    print(f\"PyTorch linearization: {type(A_torch)}\")",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#sec-key-strengths",
    "href": "architecture/Delegation_Layer_Architecture.html#sec-key-strengths",
    "title": "Delegation Layer Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\nClean Separation - Each utility has one clear responsibility\nEncapsulation - Internal complexity hidden from users\nReusability - Components can be composed by different system types\nTestability - Easy to test each component in isolation\nFlexibility - Internal implementation can change without affecting users\nPerformance - Intelligent caching and lazy initialization\nMulti-Backend - Seamless backend switching without user intervention\nType Safety - TypedDict and semantic types throughout\nDocumentation - Clear purpose and interface for each component\nMaintainability - Easy to understand, modify, and extend\nUser-Friendly - Complex functionality exposed through simple interfaces",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Delegation_Layer_Architecture.html#summary",
    "href": "architecture/Delegation_Layer_Architecture.html#summary",
    "title": "Delegation Layer Architecture",
    "section": "Summary",
    "text": "Summary\nThe delegation layer provides robust internal services that power the ControlDESymulation framework. Through careful composition and encapsulation, these utilities enable powerful functionality while maintaining a clean, user-friendly system interface.\nUsers benefit from this architecture without needing to understand its internal workings—they simply interact with intuitive system methods that delegate to the appropriate internal components automatically.",
    "crumbs": [
      "Framework Design",
      "Delegation Layer Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html",
    "href": "architecture/Visualization_Framework_Architecture.html",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "The Visualization Framework provides interactive, publication-ready plotting for dynamical systems analysis. It consists of 4 core modules organized into a 2-layer architecture: centralized theming + specialized plotters.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\n\nTheming Layer: Centralized colors, styles, and themes\nPlotter Layer: Specialized visualization classes\n\nTrajectoryPlotter - Time-domain plots\nPhasePortraitPlotter - State-space plots\nControlPlotter - Control analysis plots\n\n\n\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nUsers should NOT directly instantiate plotter classes. Instead, access plotters through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)  # TrajectoryPlotter\nfig = system.phase_plotter.plot_2d(x)       # PhasePortraitPlotter\nfig = system.control_plotter.plot_eigenvalue_map(eigs)  # ControlPlotter\n\n# ❌ INCORRECT: Direct instantiation (not recommended)\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nplotter = TrajectoryPlotter()  # Don't do this!\nfig = plotter.plot_trajectory(t, x)\nThe system properties automatically configure plotters with the correct backend and provide a consistent interface. Direct instantiation is only needed for framework development or advanced customization.",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-overview",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-overview",
    "title": "Visualization Framework Architecture",
    "section": "",
    "text": "The Visualization Framework provides interactive, publication-ready plotting for dynamical systems analysis. It consists of 4 core modules organized into a 2-layer architecture: centralized theming + specialized plotters.\n\n\n\n\n\n\nNoteFramework Components\n\n\n\n\nTheming Layer: Centralized colors, styles, and themes\nPlotter Layer: Specialized visualization classes\n\nTrajectoryPlotter - Time-domain plots\nPhasePortraitPlotter - State-space plots\nControlPlotter - Control analysis plots\n\n\n\n\n\n\n\n\n\n\nImportantUser Interface\n\n\n\nUsers should NOT directly instantiate plotter classes. Instead, access plotters through system properties:\n# ✓ CORRECT: Access via system properties\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)  # TrajectoryPlotter\nfig = system.phase_plotter.plot_2d(x)       # PhasePortraitPlotter\nfig = system.control_plotter.plot_eigenvalue_map(eigs)  # ControlPlotter\n\n# ❌ INCORRECT: Direct instantiation (not recommended)\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nplotter = TrajectoryPlotter()  # Don't do this!\nfig = plotter.plot_trajectory(t, x)\nThe system properties automatically configure plotters with the correct backend and provide a consistent interface. Direct instantiation is only needed for framework development or advanced customization.",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-architecture-philosophy",
    "title": "Visualization Framework Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nThemeable Interactive Visualization - The visualization framework enables:\n\nInteractive Plots - Plotly-based with zoom, pan, hover tooltips\nCentralized Theming - Consistent colors and styles across all plots\nBackend Agnostic - Works with NumPy, PyTorch, JAX seamlessly\nSpecialized Plotters - Dedicated classes for different visualization types\nPublication Ready - High-quality output for papers and presentations\nSystem Integration - Clean system.plotter and system.control_plotter APIs\nAccessible Design - Colorblind-safe palettes available",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-framework-layers",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-framework-layers",
    "title": "Visualization Framework Architecture",
    "section": "Framework Layers",
    "text": "Framework Layers\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│         (ContinuousSystemBase, DiscreteSystemBase)         │\n│                                                            │\n│  system.plotter          ──────► TrajectoryPlotter         │\n│  system.phase_plotter    ──────► PhasePortraitPlotter      │\n│  system.control_plotter  ──────► ControlPlotter            │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ use theming from\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   THEMING LAYER                            │\n│                   themes.py                                │\n│                                                            │\n│  ColorSchemes:            PlotThemes:                      │\n│  • PLOTLY                • DEFAULT                         │\n│  • D3                    • PUBLICATION                     │\n│  • COLORBLIND_SAFE       • DARK                            │\n│  • TABLEAU                                                 │\n│  • SEQUENTIAL_BLUE                                         │\n│  • DIVERGING_RED_BLUE                                      │\n└──────────────────┬─────────────────────────────────────────┘\n                   │ used by\n                   ↓\n┌────────────────────────────────────────────────────────────┐\n│                   PLOTTER LAYER                            │\n│                                                            │\n│  TrajectoryPlotter, PhasePortraitPlotter, ControlPlotter   │\n└────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-theming-layer",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-theming-layer",
    "title": "Visualization Framework Architecture",
    "section": "Theming Layer",
    "text": "Theming Layer\n\nColor Schemes\nThe framework provides several built-in color schemes optimized for different purposes:\n\n\nCode\n# Demonstrate different color schemes\nschemes = {\n    'Plotly (Default)': ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A'],\n    'Colorblind Safe': ['#0173B2', '#DE8F05', '#029E73', '#CC78BC', '#CA9161'],\n    'Tableau': ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F'],\n}\n\nfig = make_subplots(\n    rows=len(schemes), cols=1,\n    subplot_titles=list(schemes.keys()),\n    vertical_spacing=0.20\n)\n\nfor i, (name, colors) in enumerate(schemes.items(), 1):\n    for j, color in enumerate(colors):\n        fig.add_trace(\n            go.Bar(x=[j], y=[1], marker_color=color, showlegend=False),\n            row=i, col=1\n        )\n    fig.update_xaxes(showticklabels=False, row=i, col=1)  # Hide x ticks\n    fig.update_yaxes(showticklabels=False, row=i, col=1)\n\n# Add single x-axis label at bottom\nfig.add_annotation(\n    text=\"Color Index\",\n    xref=\"paper\", yref=\"paper\",\n    x=0.5, y=-0.05,\n    showarrow=False,\n    font=dict(size=12)\n)\n\nfig.update_layout(\n    height=450,\n    title_text=\"Color Scheme Comparison\",\n    showlegend=False,\n    margin=dict(b=60)\n)\nfig\n\n\n                            \n                                            \nBuilt-in color schemes with accessibility options\n\n\n\n\nPlot Themes\nThree built-in themes provide different visual styles:\n\n\n\n\n\n\n\n\nTheme\nUse Case\nFeatures\n\n\n\n\ndefault\nInteractive exploration\nPlotly default, colorful\n\n\npublication\nPapers, presentations\nClean, high-contrast, serif fonts\n\n\ndark\nPresentations, demos\nDark background, reduced eye strain",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-trajectory-plotter",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-trajectory-plotter",
    "title": "Visualization Framework Architecture",
    "section": "TrajectoryPlotter: Time-Domain Visualization",
    "text": "TrajectoryPlotter: Time-Domain Visualization\n\n\n\n\n\n\nTipIntegration Methods for Visualization\n\n\n\nFor visualization purposes, use simulate() instead of integrate():\n\nsimulate() returns regular time grids (uniform spacing) - ideal for plotting\nintegrate() returns adaptive time points (variable spacing) - can create uneven plots\n\n# ✓ RECOMMENDED for plotting: Regular time grid\nresult = system.simulate(x0, controller, t_span=(0, 10), dt=0.01)\nfig = system.plotter.plot_trajectory(result['time'], result['states'])\n\n# ⚠️ Works but may have uneven time spacing: Adaptive grid\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='RK45')\n# Or use t_eval for regular grid:\nresult = system.integrate(x0, u=None, t_span=(0, 10), t_eval=np.linspace(0, 10, 1001))\nfig = system.plotter.plot_trajectory(result['t'], result['x'])\nWhy this matters: - Adaptive methods choose time points based on error control (dense where dynamics change, sparse where smooth) - This can create visually uneven plots with more points in some regions - Regular grids ensure uniform visual appearance - For comparison plots, all trajectories must have same time grid\n\n\n\nBasic Trajectory Plot\nThe most common visualization: state variables vs time.\n\n\nCode\n# Simulate pendulum with regular time grid (recommended for plotting)\nx0 = np.array([0.5, 0.0])\nresult = system.simulate(x0, controller=None, t_span=(0, 10), dt=0.01)\n\n# Plot using system's built-in plotter\nfig = system.plotter.plot_trajectory(\n    result['time'],\n    result['states'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title='Pendulum Dynamics'\n)\nfig\n\n\n                            \n                                            \nSimple pendulum trajectory showing angle and angular velocity over time\n\n\n\n\n\n\n\n\nNoteWhy simulate() for Plotting\n\n\n\nThis example uses simulate() rather than integrate() because:\n\nRegular time grid (uniform dt=0.01) makes for smooth, evenly-spaced plots\nTime-major output result['states'] is (T, nx) - natural for plotting\nReconstructed controls available if controller provided\n\nFor comparison, integrate() returns adaptive time points that may create visually uneven plots.\n\n\n\n\nBatched Trajectories (Monte Carlo)\nAutomatically handles multiple trajectories. This example uses the stochastic pendulum to show genuine stochastic dynamics:\n\n\nCode\n# Use torch backend (now fixed!)\nstochastic_system.set_default_backend('torch')\n\n# Run Monte Carlo simulation\nn_trials = 20\nx0 = np.array([0.5, 0.0])\n\n# Define output times\nt_eval = np.linspace(0, 10, 1001)\n\n# Collect trajectories\nresults = []\nfor i in range(n_trials):\n    result = stochastic_system.integrate(\n        x0, \n        u=None, \n        t_span=(0, 10),\n        method='euler',\n        dt=0.01,\n        t_eval=t_eval,\n        seed=i\n    )\n    # Convert torch tensor to numpy\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    results.append(x_np)\n\n# Stack: (n_trials, T, nx)\nx_batch = np.stack(results)\nt_np = result['t'].cpu().numpy() if hasattr(result['t'], 'cpu') else result['t']\n\nprint(f\"Batch shape: {x_batch.shape} (n_trials={n_trials}, T={len(t_np)}, nx=2)\")\n\n# Plot individual trajectories\nfig = stochastic_system.plotter.plot_trajectory(\n    t_np,\n    x_batch,\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title=f'Stochastic Pendulum Monte Carlo (n={n_trials}, σ=0.3)',\n    color_scheme='colorblind_safe'\n)\nfig\n\n\nBatch shape: (20, 1001, 2) (n_trials=20, T=1001, nx=2)\n\n\n                            \n                                            \nMonte Carlo simulation of stochastic pendulum showing 20 independent noise realizations\n\n\n\n\n\n\n\n\nNoteStochastic Monte Carlo Visualization\n\n\n\nThis demonstrates true stochastic dynamics from Wiener process noise, described by the SDE:\n\\[dx = f(x, u)dt + g(x, u)dW\\]\nWhat you see:\n\nIndividual trajectories: Each colored line shows one noise realization\nStochastic spread: Trajectories diverge over time from accumulated Brownian forcing\nNonlinear effects: Pendulum damping limits growth but uncertainty remains\n\nKey distinction: The trajectory variability comes from random Brownian forcing \\(dW(t)\\), not just different initial conditions. Starting from identical states (θ=0.5, ω=0), the 20 trajectories spread due to different noise realizations, visualizing inherent stochastic uncertainty.\nFor comparison, deterministic Monte Carlo shows variability only from initial condition uncertainty, not from dynamic randomness.\n\n\n\n\n\n\n\n\nTipSDE Integration\n\n\n\nIf you still want to use integrate directly despite the recommendation for simulate, specify output times with t_eval:\n# Define output times\nt_eval = np.linspace(0, 10, 1001)  # 1001 uniformly spaced points\n\nresult = system.integrate(\n    x0,\n    u=None,\n    t_span=(0, 10),\n    method='euler',       # PyTorch torchsde method\n    dt=0.01,              # Integration time step\n    t_eval=t_eval,        # Output time points\n    seed=42\n)\nIntegration Parameters:\n\ndt=0.01: Internal time step (controls accuracy)\nt_eval: Which points to return in output (controls density)\n\n\n\n\n\n\n\n\n\nTipBackend Conversion for Plotting\n\n\n\nThe plotter requires NumPy arrays, but integration returns arrays of default backend type:\n# Convert torch tensor to numpy\nx_np = result['x'].cpu().numpy()  # Move to CPU, then numpy\nt_np = result['t'].cpu().numpy()  # Same for time\nWhy this is needed:\n\nPyTorch solvers work with torch tensors (for autodiff/GPU)\nJAX solvers work with jax.numpy.array arrays (for TPU/JIT performance)\nPlotly requires NumPy arrays for visualization\n\n\n\n\n\nState and Control Together\nVisualize both states and control inputs:\n\n\nCode\n# Simple proportional controller\ndef controller(x, t):\n    K = np.array([[-0.5, -0.15]])\n    return -K @ x\n\n# Simulate with controller\nfrom cdesym.systems.base.core.continuous_system_base import ContinuousSystemBase\nresult = system.simulate(x0, controller=controller, t_span=(0, 10), dt=0.01)\n\n# Plot states and controls\nfig = system.plotter.plot_state_and_control(\n    result['time'],\n    result['states'],\n    result['controls'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    control_names=['Torque (N⋅m)']\n)\nfig\n\n\n                            \n                                            \nCombined state and control visualization\n\n\n\n\nComparing Multiple Designs\nCompare different control strategies:\n\n\nCode\n# Simulate with different controllers\n# Note: All must use same time grid for comparison\ncontrollers = {\n    'P (K=1)': lambda x, t: np.array([-1.0 * x[0] - 0.5 * x[1]]),\n    'P (K=5)': lambda x, t: np.array([-5.0 * x[0] - 2.0 * x[1]]),\n    'No Control': None\n}\n\n# Use common dt for all simulations\ndt = 0.01\ntrajectories = {}\nt_common = np.arange(0, 10 + dt, dt)\n\nfor name, ctrl in controllers.items():\n    # Use simulate() to ensure regular time grid\n    result = system.simulate(x0, controller=ctrl, t_span=(0, 10), dt=dt)\n    trajectories[name] = result['states']\n\n# Compare trajectories (all have same time grid)\nfig = system.plotter.plot_comparison(\n    t_common,\n    trajectories,\n    state_names=['θ (rad)', 'ω (rad/s)']\n)\nfig\n\n\n                            \n                                            \nComparison of different control strategies\n\n\n\n\n\n\n\n\nImportantRegular Time Grids Required for Comparison\n\n\n\nWhen comparing multiple trajectories, all must use the same time grid. Use simulate() with the same dt for all runs, or use integrate() with the same t_eval array.\n# ✓ CORRECT: Same time grid\nfor name, ctrl in controllers.items():\n    result = system.simulate(x0, controller=ctrl, t_span=(0, 10), dt=0.01)\n    \n# ❌ WRONG: Different adaptive grids\nfor name, ctrl in controllers.items():\n    result = system.integrate(x0, u=ctrl, t_span=(0, 10))\n    # Different number of time points! Cannot compare directly.",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-phase-portrait",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-phase-portrait",
    "title": "Visualization Framework Architecture",
    "section": "PhasePortraitPlotter: State-Space Visualization",
    "text": "PhasePortraitPlotter: State-Space Visualization\n\n2D Phase Portrait\nVisualize dynamics in state space:\n\n\nCode\n# Simulate from multiple initial conditions (use simulate for regular grids)\ninitial_conditions = [\n    np.array([0.3, 0.0]),\n    np.array([1.0, 0.0]),\n    np.array([1.5, 0.5]),\n]\n\ntrajectories = []\nfor x0_i in initial_conditions:\n    result = system.simulate(x0_i, controller=None, t_span=(0, 15), dt=0.01)\n    trajectories.append(result['states'])\n\nx_all = np.stack(trajectories)  # (n_traj, T, nx)\n\n# Plot phase portrait\nfig = system.phase_plotter.plot_2d(\n    x_all,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    equilibria=[np.array([0, 0])],\n    show_direction=True\n)\nfig\n\n\n                            \n                                            \n2D phase portrait showing state-space trajectory\n\n\n\n\nWith Vector Field\nAdd vector field to show dynamics everywhere:\n\n\nCode\n# Define vector field function\ndef pendulum_field(theta, omega):\n    \"\"\"Compute derivatives at any point in phase space.\"\"\"\n    x = np.array([theta, omega])\n    dx = system(x, u=np.zeros(1))\n    return dx[0], dx[1]\n\n# Plot with vector field\nfig = system.phase_plotter.plot_2d(\n    x_all,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    vector_field=pendulum_field,\n    equilibria=[np.array([0, 0]), np.array([np.pi, 0])],\n    show_direction=True\n)\nfig\n\n\n                            \n                                            \nPhase portrait with vector field overlay",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter",
    "title": "Visualization Framework Architecture",
    "section": "ControlPlotter: Control Analysis",
    "text": "ControlPlotter: Control Analysis\n\nEigenvalue Map\nVisualize closed-loop stability with comparison:\n\n\nCode\n# Get linearization at origin\nx_eq, u_eq = system.get_equilibrium('origin')\nA, B = system.linearize(x_eq, u_eq)\n\n# Design LQR controller\nQ = np.diag([10, 1])\nR = np.array([[0.1]])\nlqr_result = system.control.design_lqr(A, B, Q, R, system_type='continuous')\n\n# Plot eigenvalues using dictionary format (recommended for comparison)\neigenvalues_ol = np.linalg.eigvals(A)\neigenvalues_cl = lqr_result['controller_eigenvalues']\n\neigenvalue_sets = {\n    'Open-loop': eigenvalues_ol,\n    'Closed-loop (LQR)': eigenvalues_cl,\n}\n\nfig = system.control_plotter.plot_eigenvalue_map(\n    eigenvalue_sets,\n    system_type='continuous',\n    color_scheme='colorblind_safe',\n    theme='publication'\n)\nfig\n\n\n                            \n                                            \nEigenvalue map comparing open-loop and closed-loop poles\n\n\n\n\n\n\n\n\nTipComparing Eigenvalue Sets\n\n\n\nThe plot_eigenvalue_map() method supports multiple input formats:\nDictionary format (recommended for comparison):\neigenvalue_sets = {\n    'Open-loop': eigs_ol,\n    'Closed-loop (LQR)': eigs_cl,\n}\nfig = system.control_plotter.plot_eigenvalue_map(eigenvalue_sets)\nConcatenated with per-eigenvalue labels:\neigs_all = np.concatenate([eigs_ol, eigs_cl])\nlabels = ['Open-loop'] * len(eigs_ol) + ['Closed-loop'] * len(eigs_cl)\nfig = system.control_plotter.plot_eigenvalue_map(eigs_all, labels=labels)\nSingle set:\nfig = system.control_plotter.plot_eigenvalue_map(eigs_cl, labels='LQR')\nEach set gets a unique color and marker symbol for easy distinction!",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-stochastic-viz",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-stochastic-viz",
    "title": "Visualization Framework Architecture",
    "section": "Stochastic System Visualization",
    "text": "Stochastic System Visualization\n\nComparing Noise Levels\nVisualize impact of different noise intensities:\n\n\nCode\n# Create systems with different noise levels\nnoise_levels = [0.1, 0.3, 0.5]\ntrajectories_noise = {}\n\n# Use common time grid for comparison\ndt = 0.01\nt_common = np.arange(0, 15 + dt, dt)\n\nfor sigma in noise_levels:\n    sys_i = ContinuousStochasticPendulum(g=9.81, L=1.0, b=0.5, sigma=sigma)\n    sys_i.set_default_backend('torch')\n    x0 = np.array([0.3, 0.0])\n    \n    result = sys_i.integrate(\n        x0, u=None, t_span=(0, 15), \n        method='euler', dt=dt, seed=42\n    )\n    \n    # Convert to numpy for plotting\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    trajectories_noise[f'σ={sigma}'] = x_np\n\n# Compare trajectories (pass t and trajectories separately)\nfig = stochastic_system.plotter.plot_comparison(\n    t_common,\n    trajectories_noise,\n    state_names=['θ (rad)', 'ω (rad/s)']\n)\nfig.update_layout(title='Effect of Noise Intensity on Stochastic Pendulum')\nfig\n\n\n                            \n                                            \nEffect of noise intensity on pendulum dynamics\n\n\n\n\n\n\n\n\nTipNoise Impact\n\n\n\nNotice how increasing noise intensity (\\(\\sigma\\)):\n\nCreates larger amplitude fluctuations\nCan induce transitions over energy barriers\nAffects regularity of oscillations\nChanges effective damping behavior\n\nAt moderate noise levels, the system exhibits stochastic resonance - an optimal noise level that actually enhances response to periodic forcing.\n\n\n\n\nStochastic Phase Portrait\nPhase portraits reveal noise-induced behavior:\n\n\nCode\n# Switch to torch for SDE integration\nstochastic_system.set_default_backend('torch')\n\n# Multiple stochastic trajectories from same initial condition\nn_trajectories = 3\nstochastic_trajectories = []\n\nfor i in range(n_trajectories):\n    result = stochastic_system.integrate(\n        np.array([np.pi/2, 0.0]),\n        u=None,\n        t_span=(0, 20),\n        method='euler',\n        dt=0.01,\n        seed=i\n    )\n    # Convert to numpy\n    x_np = result['x'].cpu().numpy() if hasattr(result['x'], 'cpu') else result['x']\n    stochastic_trajectories.append(x_np)\n\nx_stochastic = np.stack(stochastic_trajectories)\n\n# Reset backend\nstochastic_system.set_default_backend('numpy')\n\n# Plot stochastic phase portrait\nfig = stochastic_system.phase_plotter.plot_2d(\n    x_stochastic,\n    state_names=('θ (rad)', 'ω (rad/s)'),\n    equilibria=[np.array([0, 0])],\n    show_direction=True\n)\nfig.update_layout(title='Stochastic Pendulum Phase Portrait (Same IC, Different Noise)')\nfig\n\n\n                            \n                                            \nPhase portrait of stochastic pendulum showing noise-induced wandering\n\n\n\n\n\n\n\n\nNoteStochastic vs Deterministic Phase Portraits\n\n\n\nUnlike deterministic systems where each initial condition produces one unique trajectory, stochastic systems produce a cloud of possible trajectories from the same initial condition. This visualization shows:\n\nTrajectory spreading due to random forcing\nNoise-induced wandering in phase space\nProbabilistic barrier crossing (not deterministic separatrix)\nEffective diffusion in state space\n\nThe phase portrait becomes a probability distribution rather than a single curve!",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter-continued",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-control-plotter-continued",
    "title": "Visualization Framework Architecture",
    "section": "ControlPlotter: Control Analysis",
    "text": "ControlPlotter: Control Analysis\n\nGain Comparison\nCompare feedback gains for different designs:\n\n\nCode\n# Design LQR with different Q weights\nQ_values = [1, 10, 100]\ngains = {}\nfor q in Q_values:\n    Q_i = q * np.diag([10, 1])\n    result = system.control.design_lqr(A, B, Q_i, R, system_type='continuous')\n    gains[f'Q={q}'] = result['gain']\n\n# Plot gain comparison\nfig = system.control_plotter.plot_gain_comparison(\n    gains,\n    labels=['θ', 'ω']\n)\nfig\n\n\n                            \n                                            \nHeatmap comparing LQR gains for different Q weights\n\n\n\n\nStep Response\nAnalyze closed-loop performance:\n\n\nCode\n# Create closed-loop system with reference tracking\nfrom scipy import signal\n\n# Output: measure angle only\nC = np.array([[1, 0]])\nD = np.zeros((1, 1))\n\n# Closed-loop dynamics with state feedback u = -Kx\nA_cl = A - B @ lqr_result['gain']\n\n# For proper reference tracking, we need feedforward compensation.\n# With u = -Kx + K_r*r, the steady-state output tracks the reference r.\n# K_r is chosen so that y_ss = r, which requires: K_r = -1/(C @ inv(A_cl) @ B)\ndc_gain = C @ np.linalg.inv(A_cl) @ B\nK_r = -1.0 / dc_gain[0, 0]\n\n# Create tracking system: ẋ = A_cl*x + B*K_r*r, y = Cx\n# When r is a unit step, the input to the system is B*K_r\nB_ref = B * K_r\nsys_tracking = signal.StateSpace(A_cl, B_ref, C, D)\n\n# Step response (now properly tracks the reference)\nt_step = np.linspace(0, 5, 500)\nt_out, y_out = signal.step(sys_tracking, T=t_step)\n\n# Plot with metrics\nfig = system.control_plotter.plot_step_response(\n    t_out,\n    y_out.squeeze(),\n    reference=1.0,\n    show_metrics=True\n)\nfig\n\n\n                            \n                                            \nStep response showing rise time, overshoot, and settling time\n\n\n\n\n\n\n\n\nNoteReference Tracking with State Feedback\n\n\n\nLQR designs a state feedback controller u = -Kx that regulates the state to zero. To track a non-zero reference, we add feedforward compensation:\n\\[u = -Kx + K_r \\cdot r\\]\nwhere \\(K_r\\) is chosen to achieve zero steady-state error. For the closed-loop system \\(\\dot{x} = A_{cl}x + BK_r r\\) with output \\(y = Cx\\), the DC gain must equal 1:\n\\[K_r = -\\frac{1}{C A_{cl}^{-1} B}\\]\nThis ensures the output tracks step references with the stability and transient performance designed by LQR.",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-publication-ready",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-publication-ready",
    "title": "Visualization Framework Architecture",
    "section": "Publication-Ready Output",
    "text": "Publication-Ready Output\n\nPublication Theme\nSwitch to publication theme for papers:\n\n\nCode\n# Get a fresh result for this example\nx0_pub = np.array([0.5, 0.0])\nresult_pub = system.simulate(x0_pub, controller=None, t_span=(0, 10), dt=0.01)\n\n# Same trajectory, publication theme\nfig = system.plotter.plot_trajectory(\n    result_pub['time'],\n    result_pub['states'],\n    state_names=['θ (rad)', 'ω (rad/s)'],\n    title='Pendulum Dynamics',\n    theme='publication',\n    color_scheme='colorblind_safe'\n)\nfig\n\n\n                            \n                                            \nSame plot with publication theme (serif fonts, clean styling)\n\n\n\n\nExporting Figures\nPlotly figures can be exported in multiple formats:\n# Export as HTML (interactive)\nfig.write_html('pendulum_trajectory.html')\n\n# Export as static image (requires kaleido)\nfig.write_image('pendulum_trajectory.pdf', width=800, height=600)\nfig.write_image('pendulum_trajectory.png', width=800, height=600, scale=2)\n\n# Export as SVG (vector graphics)\nfig.write_image('pendulum_trajectory.svg')",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-design-patterns",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-design-patterns",
    "title": "Visualization Framework Architecture",
    "section": "Design Patterns",
    "text": "Design Patterns\n\nPattern 1: Centralized Theming\nAll plotters use centralized themes:\n# ❌ BAD: Hardcoded colors\nclass BadPlotter:\n    def plot(self):\n        fig.add_trace(go.Scatter(line=dict(color='#1f77b4')))\n\n# ✓ GOOD: Centralized theming\nclass GoodPlotter:\n    def plot(self, color_scheme='plotly', theme='default'):\n        colors = ColorSchemes.get_colors(color_scheme)\n        fig.add_trace(go.Scatter(line=dict(color=colors[0])))\n        fig = PlotThemes.apply_theme(fig, theme)\n\n\nPattern 2: Backend Agnostic\nAutomatically converts PyTorch/JAX to NumPy:\ndef plot_trajectory(self, t, x):\n    # Convert to NumPy for Plotly\n    t_np = self._to_numpy(t)\n    x_np = self._to_numpy(x)\n    \n    # Plot with Plotly (requires NumPy)\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=t_np, y=x_np[:, 0]))\n    return fig\n\ndef _to_numpy(self, arr):\n    if hasattr(arr, 'cpu'):  # PyTorch\n        return arr.cpu().numpy()\n    elif hasattr(arr, '__array__'):  # JAX\n        return np.array(arr)\n    return arr\n\n\nPattern 3: Adaptive Layouts\nOptimal subplot arrangements:\ndef _determine_subplot_layout(self, n_plots: int) -&gt; Tuple[int, int]:\n    \"\"\"\n    Determine optimal subplot grid.\n    \n    1-2 plots: (n, 1) vertical\n    3-4 plots: (2, 2) square\n    5-6 plots: (2, 3)\n    7-9 plots: (3, 3)\n    \"\"\"\n    if n_plots &lt;= 2:\n        return n_plots, 1\n    elif n_plots &lt;= 4:\n        return 2, 2\n    else:\n        cols = int(np.ceil(np.sqrt(n_plots)))\n        rows = int(np.ceil(n_plots / cols))\n        return rows, cols\n\n\nPattern 4: Batch Detection\nAutomatically detect and process batched data:\ndef _process_batch(self, x: np.ndarray):\n    if x.ndim == 3:  # (n_batch, T, nx)\n        return np.mean(x, axis=0), np.std(x, axis=0), True\n    elif x.ndim == 2:  # (T, nx)\n        return x, None, False\n    else:\n        raise ValueError(f\"Invalid shape: {x.shape}\")",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-integration",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-integration",
    "title": "Visualization Framework Architecture",
    "section": "Integration with Systems",
    "text": "Integration with Systems\n\nProperty-Based Access (Recommended)\nAll systems provide plotter properties for convenient access:\n# ✓ Access via system properties (recommended)\nsystem.plotter           # TrajectoryPlotter instance\nsystem.phase_plotter     # PhasePortraitPlotter instance\nsystem.control_plotter   # ControlPlotter instance\n\n# Convenience method\nsystem.plot(result)      # Quick trajectory plot\n\n\n\n\n\n\nWarningDo Not Instantiate Plotters Directly\n\n\n\nPlotters are internal framework components that should be accessed through system properties, not instantiated directly:\n# ❌ WRONG: Direct instantiation\nfrom cdesym.visualization.trajectory_plotter import TrajectoryPlotter\nfrom cdesym.visualization.phase_portrait import PhasePortraitPlotter\nfrom cdesym.visualization.control_plots import ControlPlotter\n\nplotter = TrajectoryPlotter(backend='numpy')  # Don't do this!\nphase = PhasePortraitPlotter(backend='numpy')  # Don't do this!\ncontrol = ControlPlotter(backend='numpy')      # Don't do this!\n\n# ✓ CORRECT: Access via system\nsystem = Pendulum()\nfig = system.plotter.plot_trajectory(t, x)\nfig = system.phase_plotter.plot_2d(x)\nfig = system.control_plotter.plot_eigenvalue_map(eigs)\nThe system automatically creates and configures plotters with the correct backend. Direct instantiation is only needed for: - Framework development - Testing plotter components in isolation - Advanced customization outside the system context\n\n\n\n\nTypical Workflow\n# 1. Create system\nsystem = Pendulum()\n\n# 2. Simulate\nresult = system.simulate(x0, controller, t_span=(0, 10))\n\n# 3. Visualize (plotters accessed through system)\nfig = system.plotter.plot_trajectory(\n    result['time'],\n    result['states'],\n    theme='publication'\n)\nfig",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-plot-types",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-plot-types",
    "title": "Visualization Framework Architecture",
    "section": "Available Plot Types",
    "text": "Available Plot Types\n\nSummary Table\n\n\n\nPlotter\nMethod\nPurpose\n\n\n\n\nTrajectoryPlotter\n\n\n\n\n\nplot_trajectory()\nStates vs time\n\n\n\nplot_state_and_control()\nStates + controls\n\n\n\nplot_comparison()\nCompare multiple runs\n\n\nPhasePortraitPlotter\n\n\n\n\n\nplot_2d()\n2D phase portrait\n\n\n\nplot_3d()\n3D phase portrait\n\n\n\nplot_limit_cycle()\nPeriodic orbits\n\n\nControlPlotter\n\n\n\n\n\nplot_eigenvalue_map()\nStability analysis\n\n\n\nplot_gain_comparison()\nCompare gains\n\n\n\nplot_step_response()\nStep response metrics\n\n\n\nplot_impulse_response()\nImpulse response\n\n\n\nplot_frequency_response()\nBode plots\n\n\n\nplot_nyquist()\nNyquist diagram\n\n\n\nplot_root_locus()\nRoot locus\n\n\n\nplot_controllability_gramian()\nGramian heatmap\n\n\n\nplot_observability_gramian()\nGramian heatmap\n\n\n\nplot_riccati_convergence()\nSolver convergence",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#sec-key-strengths",
    "href": "architecture/Visualization_Framework_Architecture.html#sec-key-strengths",
    "title": "Visualization Framework Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipFramework Advantages\n\n\n\n\nCentralized Theming - Single source of truth for colors/styles\nBackend Agnostic - NumPy/PyTorch/JAX transparent\nInteractive - Plotly-based with zoom, pan, hover\nPublication Ready - Professional defaults and themes\nAccessible - Colorblind-safe palettes\nSpecialized Plotters - Right tool for each visualization type\nSystem Integration - Clean system.plotter APIs\nAdaptive Layouts - Optimal subplot arrangements\nBatch Support - Monte Carlo visualization automatic\nComprehensive - 16+ plot types covering all needs",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Visualization_Framework_Architecture.html#summary",
    "href": "architecture/Visualization_Framework_Architecture.html#summary",
    "title": "Visualization Framework Architecture",
    "section": "Summary",
    "text": "Summary\nThe visualization framework provides publication-quality interactive plotting seamlessly integrated with ControlDESymulation’s dynamical systems. All plots are:\n\n✅ Interactive with Plotly\n✅ Themeable for different contexts\n✅ Backend-agnostic\n✅ Automatically adaptive\n✅ Publication-ready\n\n\n\n\n\n\n\nImportantUsage Reminder\n\n\n\nAccess visualization through system properties:\nsystem.plotter           # Time-domain plots\nsystem.phase_plotter     # Phase space plots\nsystem.control_plotter   # Control analysis plots\nDo not directly instantiate TrajectoryPlotter, PhasePortraitPlotter, or ControlPlotter classes—the system handles this automatically with proper configuration.",
    "crumbs": [
      "Framework Design",
      "Visualization Framework Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html",
    "href": "architecture/Type_System_Architecture.html",
    "title": "Type System Architecture",
    "section": "",
    "text": "The Type System is the foundational layer (Layer 0) that provides semantic types, structured results, and type-safe interfaces for the entire framework. It consists of 8 focused modules defining over 200 type aliases and structured dictionaries.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework types. Users should NOT directly reference or manipulate these types except through system methods. The type system is an internal implementation detail that provides:\n\nType safety through static checking\nIDE autocomplete support\nClear documentation of expected types\nBackend-agnostic interfaces\n\n# ✓ CORRECT: Types work transparently through system methods\nsystem = Pendulum()\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n# result is IntegrationResult (TypedDict) - IDE knows fields available\n\nA, B = system.linearize(x_eq, u_eq)\n# A is StateMatrix, B is InputMatrix - types guide usage\n\n# ✗ INCORRECT: No need to import or reference types directly\nfrom cdesym.types.core import StateVector, ControlVector\nx: StateVector = np.array([1.0, 0.0])  # Unnecessary annotation\nThe type system enables type checking and IDE support while remaining invisible during normal use. This documentation is provided for framework developers and advanced users implementing custom components.",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-overview",
    "href": "architecture/Type_System_Architecture.html#sec-overview",
    "title": "Type System Architecture",
    "section": "",
    "text": "The Type System is the foundational layer (Layer 0) that provides semantic types, structured results, and type-safe interfaces for the entire framework. It consists of 8 focused modules defining over 200 type aliases and structured dictionaries.\n\n\n\n\n\n\nImportantInternal Framework - Not for Direct Use\n\n\n\nThis documentation describes internal framework types. Users should NOT directly reference or manipulate these types except through system methods. The type system is an internal implementation detail that provides:\n\nType safety through static checking\nIDE autocomplete support\nClear documentation of expected types\nBackend-agnostic interfaces\n\n# ✓ CORRECT: Types work transparently through system methods\nsystem = Pendulum()\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n# result is IntegrationResult (TypedDict) - IDE knows fields available\n\nA, B = system.linearize(x_eq, u_eq)\n# A is StateMatrix, B is InputMatrix - types guide usage\n\n# ✗ INCORRECT: No need to import or reference types directly\nfrom cdesym.types.core import StateVector, ControlVector\nx: StateVector = np.array([1.0, 0.0])  # Unnecessary annotation\nThe type system enables type checking and IDE support while remaining invisible during normal use. This documentation is provided for framework developers and advanced users implementing custom components.",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-architecture-philosophy",
    "href": "architecture/Type_System_Architecture.html#sec-architecture-philosophy",
    "title": "Type System Architecture",
    "section": "Architecture Philosophy",
    "text": "Architecture Philosophy\nType-Driven Design - Types are not just annotations—they are architecture.\nThe type system enables:\n\nSemantic Clarity - Names convey mathematical meaning (StateVector, not ArrayLike)\nType Safety - Static checking via mypy/pyright catches errors before runtime\nIDE Support - Autocomplete knows result['t'] exists and is TimePoints\nBackend Agnosticism - Same types work with NumPy/PyTorch/JAX\nStructured Results - TypedDict for dictionaries (not plain dict)\nSelf-Documentation - Type signatures encode mathematical constraints\n\nExample comparison:\n\n\nCode\n# ✗ Bad: Unclear types and semantics\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# ✓ Good: Clear semantics and constraints\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-framework-layers",
    "href": "architecture/Type_System_Architecture.html#sec-framework-layers",
    "title": "Type System Architecture",
    "section": "Framework Layers",
    "text": "Framework Layers\n┌────────────────────────────────────────────────────────────┐\n│                   APPLICATION LAYER                        │\n│  (UI Framework, Delegation Layer, Integration Framework)   │\n└─────────────────────┬──────────────────────────────────────┘\n                      │ uses types from\n                      ↓\n┌────────────────────────────────────────────────────────────┐\n│                    TYPE SYSTEM (Layer 0)                   │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  FOUNDATIONAL TYPES                                  │  │\n│  │  • core.py           - Vectors, matrices             │  │\n│  │  • backends.py       - Backend enums, configs        │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  DOMAIN TYPES                                        │  │\n│  │  • trajectories.py   - Time series results           │  │\n│  │  • linearization.py  - Jacobian tuples               │  │\n│  │  • symbolic.py       - SymPy types                   │  │\n│  │  • control_classical.py - Control design results     │  │\n│  └──────────────────────────────────────────────────────┘  │\n│                                                            │\n│  ┌──────────────────────────────────────────────────────┐  │\n│  │  STRUCTURAL TYPES                                    │  │\n│  │  • protocols.py      - Abstract interfaces           │  │\n│  │  • utilities.py      - Helper types, guards          │  │\n│  └──────────────────────────────────────────────────────┘  │\n└────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-foundational-types",
    "href": "architecture/Type_System_Architecture.html#sec-foundational-types",
    "title": "Type System Architecture",
    "section": "Foundational Types",
    "text": "Foundational Types\n\ncore.py: Fundamental Building Blocks\nFile: core.py\nThe core module provides fundamental building blocks for all other types in the framework. These types establish semantic clarity and backend agnosticism throughout the library.\nKey categories:\n\nMulti-Backend Arrays (20+ types)\nBackend-agnostic array types that work transparently with NumPy, PyTorch, and JAX:\nArrayLike = Union[np.ndarray, torch.Tensor, jnp.ndarray]\nNumpyArray = np.ndarray\nTorchTensor = torch.Tensor\nJaxArray = jnp.ndarray\nScalarLike = Union[float, int, np.number, torch.Tensor, jnp.ndarray]\nIntegerLike = Union[int, np.integer]\nUsage in framework:\n\n\nCode\nsystem = Pendulum()\n\n# Same function works with all backends\nx_np = np.array([1.0, 0.0])      # NumPy\nx_torch = torch.tensor([1.0, 0.0])  # PyTorch\nx_jax = jnp.array([1.0, 0.0])    # JAX\n\n# Backend detected automatically - no type errors\ndx_np = system(x_np, np.zeros(1))\ndx_torch = system(x_torch, torch.zeros(1))\ndx_jax = system(x_jax, jnp.zeros(1))\n\nprint(\"✓ Backend-agnostic type system\")\n\n\n\n\nSemantic Vector Types (15+ types)\nVector types that convey mathematical meaning:\nStateVector         # x ∈ ℝⁿˣ - System state\nControlVector       # u ∈ ℝⁿᵘ - Control input\nOutputVector        # y ∈ ℝⁿʸ - Measured output\nNoiseVector         # w ∈ ℝⁿʷ - Stochastic noise\nEquilibriumState    # x_eq - Equilibrium state\nEquilibriumControl  # u_eq - Equilibrium control\nTimeDerivative      # dx/dt - State derivative\nStateIncrement      # δx - State deviation\nControlIncrement    # δu - Control deviation\nWhy semantic types matter:\n\n\nCode\n# ✗ Unclear what arrays represent\ndef compute(arr1, arr2, arr3):\n    return arr1 @ arr2 + arr3\n\n# ✓ Clear mathematical meaning\ndef compute_control(x: StateVector, K: GainMatrix, u_ff: ControlVector) -&gt; ControlVector:\n    \"\"\"State feedback with feedforward: u = -K*x + u_ff\"\"\"\n    return -K @ x + u_ff\n\n\n\n\nMatrix Types (30+ types)\nMatrix types organized by mathematical purpose:\nDynamics matrices:\nStateMatrix         # A ∈ ℝⁿˣˣⁿˣ - ∂f/∂x\nInputMatrix         # B ∈ ℝⁿˣˣⁿᵘ - ∂f/∂u  \nDiffusionMatrix     # G ∈ ℝⁿˣˣⁿʷ - Noise intensity\nObservation matrices:\nOutputMatrix        # C ∈ ℝⁿʸˣⁿˣ - ∂h/∂x\nFeedthroughMatrix   # D ∈ ℝⁿʸˣⁿᵘ - Direct feedthrough\nControl matrices:\nGainMatrix          # K ∈ ℝⁿᵘˣⁿˣ - Feedback gain\nCostMatrix          # Q ∈ ℝⁿˣˣⁿˣ - State cost\nControlCostMatrix   # R ∈ ℝⁿᵘˣⁿᵘ - Control cost\nStochastic matrices:\nCovarianceMatrix    # P ∈ ℝⁿˣˣⁿˣ - Covariance\nProcessNoiseMatrix  # Q ∈ ℝⁿˣˣⁿˣ - Process noise cov\nMeasurementNoiseMatrix  # R ∈ ℝⁿʸˣⁿʸ - Measurement noise cov\nSpecial matrices:\nIdentityMatrix      # I ∈ ℝⁿˣⁿ\nZeroMatrix         # 0 ∈ ℝᵐˣⁿ\nGramianMatrix      # Controllability/observability gramian\nControllabilityMatrix  # [B AB A²B ... Aⁿ⁻¹B]\nObservabilityMatrix    # [C; CA; CA²; ...; CAⁿ⁻¹]\n\n\nFunction Signatures (10+ types)\nCallable types that define function interfaces:\nDynamicsFunction    # (x, u) → dx/dt\nOutputFunction      # (x) → y\nControlPolicy       # (t, x) → u\nCostFunction        # (x, u) → scalar\nObserverFunction    # (y, u) → x_hat\nUsage example:\n\n\nCode\nfrom cdesym.types import StateVector, ControlVector\n# Function signature guides implementation\ndef simulate_with_controller(\n    system: Callable[[StateVector, ControlVector], StateVector],  # DynamicsFunction\n    controller: Callable[[float, StateVector], ControlVector],    # ControlPolicy\n    x0: StateVector,\n    t_span: Tuple[float, float]\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Type signatures document the contract.\"\"\"\n    # Implementation here\n    pass\n\nprint(\"✓ Function types document interfaces\")\n\n\n\n\nSystem Properties (15+ types)\nTypes for system dimensions and properties:\nStateDimension      # nx - Number of states\nControlDimension    # nu - Number of controls\nOutputDimension     # ny - Number of outputs\nNoiseDimension      # nw - Number of Wiener processes\nSystemOrder         # order - Differential order\n\nEquilibriumPoint    # (x_eq, u_eq) - Tuple\nEquilibriumName     # str - Named equilibrium\n\n\n\nbackends.py: Backend Configuration\nFile: backends.py\nThe backends module defines backend selection, device management, and method specification types.\nKey categories:\n\nBackend Types\nBackend = Literal[\"numpy\", \"torch\", \"jax\"]\nDevice = str  # 'cpu', 'cuda:0', 'mps', 'tpu'\n\nclass BackendConfig(TypedDict, total=False):\n    backend: Backend\n    device: Optional[Device]\n    dtype: Optional[str]  # 'float32', 'float64'\nUsage in framework:\n\n\nCode\nsystem = Pendulum()\n\n# Backend configuration handled internally\nprint(f\"Default backend: {system.backend.default_backend}\")\nprint(f\"Default device: {system.backend.preferred_device}\")\n\n# Users interact through simple methods\nsystem.set_default_backend('numpy')\nsystem.to_device('cpu')\n\nwith system.use_backend('torch'):\n    print(f\"Temporary backend: {system.backend.default_backend}\")\n\n\n\n\nIntegration Methods\nIntegrationMethod = str  # 'RK45', 'dopri5', 'tsit5', etc.\n\n# Specific categories\nOdeMethod = str          # Deterministic methods\nSdeMethod = str          # Stochastic methods\nFixedStepMethod = str    # Fixed-step methods\nAdaptiveMethod = str     # Adaptive methods\n\n\nDiscretization Methods\nDiscretizationMethod = Literal[\n    \"exact\",      # Matrix exponential\n    \"euler\",      # Forward Euler\n    \"tustin\",     # Bilinear transform\n    \"backward\",   # Backward Euler\n    \"matched\",    # Zero-order hold\n]\n\n\nSDE Types\nSDEType = Literal[\"ito\", \"stratonovich\"]\n\nclass NoiseType(Enum):\n    ADDITIVE = \"additive\"\n    MULTIPLICATIVE = \"multiplicative\"\n    MULTIPLICATIVE_DIAGONAL = \"multiplicative_diagonal\"\n    MULTIPLICATIVE_SCALAR = \"multiplicative_scalar\"\n    MULTIPLICATIVE_GENERAL = \"multiplicative_general\"\n    UNKNOWN = \"unknown\"\n\nclass ConvergenceType(Enum):\n    STRONG = \"strong\"  # Pathwise convergence\n    WEAK = \"weak\"      # Distribution convergence\n\n\nSystem Configuration\nclass SystemConfig(TypedDict, total=False):\n    \"\"\"Complete system configuration.\"\"\"\n    nx: int              # State dimension\n    nu: int              # Control dimension\n    ny: int              # Output dimension\n    nw: int              # Noise dimension\n    order: int           # System order\n    dt: Optional[float]  # Time step (discrete)\n    backend: Backend\n    device: Device",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-domain-types",
    "href": "architecture/Type_System_Architecture.html#sec-domain-types",
    "title": "Type System Architecture",
    "section": "Domain Types",
    "text": "Domain Types\n\ntrajectories.py: Time Series Results\nFile: trajectories.py\nThe trajectories module defines types for time series data and simulation results.\nKey categories:\n\nTrajectory Types\nStateTrajectory = ArrayLike      # (T, nx) or (T, batch, nx)\nControlSequence = ArrayLike      # (T, nu) or (T, batch, nu)\nOutputSequence = ArrayLike       # (T, ny)\nNoiseSequence = ArrayLike        # (T, nw)\nConvention: Time-major ordering - All trajectories use (T, ...) format where T is the first dimension.\n\n\nTime Types\nTimePoints = ArrayLike           # (T,) - Time grid\nTimeSpan = Tuple[float, float]   # (t0, tf) - Interval\nTimeStep = float                 # dt - Step size\n\n\nIntegration Results (TypedDict)\nDeterministic ODE Integration:\nclass IntegrationResult(TypedDict, total=False):\n    \"\"\"ODE integration result.\"\"\"\n    t: TimePoints              # Time points\n    x: StateTrajectory         # State trajectory (T, nx)\n    success: bool              # Integration succeeded\n    message: str               # Status message\n    nfev: int                  # Function evaluations\n    nsteps: int                # Integration steps\n    integration_time: float    # Wall time (seconds)\n    solver: str                # Integrator name\n    \n    # Optional fields (adaptive methods)\n    njev: int                  # Jacobian evaluations\n    nlu: int                   # LU decompositions\n    status: int                # Solver status code\n    sol: Any                   # Dense output object\n    dense_output: bool         # Dense output available\nStochastic SDE Integration:\nclass SDEIntegrationResult(TypedDict, total=False):\n    \"\"\"SDE integration result (extends IntegrationResult).\"\"\"\n    # All IntegrationResult fields, plus:\n    diffusion_evals: int       # Diffusion function calls\n    noise_samples: NoiseVector # Brownian increments used\n    n_paths: int               # Number of trajectories\n    convergence_type: str      # 'strong' or 'weak'\n    sde_type: str              # 'ito' or 'stratonovich'\n    noise_type: str            # Noise structure\nBatch Simulation:\nclass BatchSimulationResult(TypedDict):\n    \"\"\"Batched simulation result.\"\"\"\n    t: TimePoints                    # (T,)\n    x: StateTrajectory               # (T, batch, nx)\n    u: ControlSequence               # (T, batch, nu)\n    batch_size: int\n    statistics: Dict[str, ArrayLike] # Mean, std, etc.\nWhy TypedDict:\n\n\nCode\nsystem = Pendulum()\nx0 = np.array([1.0, 0.0])\n\n# TypedDict result provides IDE support\nresult = system.integrate(x0, u=None, t_span=(0, 10))\n\n# IDE knows these fields exist and their types\nt = result['t']              # TimePoints\nx = result['x']              # StateTrajectory\nsuccess = result['success']  # bool\nsolver = result['solver']    # str\n\nprint(f\"Integration {'succeeded' if success else 'failed'}\")\nprint(f\"Solver: {solver}\")\n\n\n\n\n\nlinearization.py: Jacobian Types\nFile: linearization.py\nThe linearization module defines return types for linearization operations.\nMathematical forms:\nContinuous systems:\n\\[\\delta\\dot{x} = A\\delta x + B\\delta u\\]\nwhere:\n\\[A = \\frac{\\partial f}{\\partial x}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_x}\\]\n\\[B = \\frac{\\partial f}{\\partial u}\\bigg|_{(x_{eq}, u_{eq})} \\in \\mathbb{R}^{n_x \\times n_u}\\]\nDiscrete systems:\n\\[\\delta x[k+1] = A_d\\delta x[k] + B_d\\delta u[k]\\]\nType definitions:\n\nBasic Linearization\nDeterministicLinearization = Tuple[StateMatrix, InputMatrix]\n# Returns: (A, B) where\n#   A = ∂f/∂x - State Jacobian\n#   B = ∂f/∂u - Control Jacobian\n\nStochasticLinearization = Tuple[StateMatrix, InputMatrix, DiffusionMatrix]\n# Returns: (A, B, G) where\n#   A = ∂f/∂x\n#   B = ∂f/∂u  \n#   G = ∂g/∂x or g(x_eq) - Diffusion\n\nLinearizationResult = Union[DeterministicLinearization, StochasticLinearization]\n# Polymorphic: works with both\n\n\nOutput Linearization\nObservationLinearization = Tuple[OutputMatrix, FeedthroughMatrix]\n# Returns: (C, D) where\n#   C = ∂h/∂x - Output Jacobian\n#   D = ∂h/∂u - Feedthrough (usually 0)\n\n\nFull State-Space\nFullLinearization = Tuple[StateMatrix, InputMatrix, OutputMatrix, FeedthroughMatrix]\n# Returns: (A, B, C, D)\n\nFullStochasticLinearization = Tuple[\n    StateMatrix, InputMatrix, DiffusionMatrix, OutputMatrix, FeedthroughMatrix\n]\n# Returns: (A, B, G, C, D)\nUsage example:\n\n\nCode\nsystem = Pendulum()\n\n# Get equilibrium\nx_eq, u_eq = system.get_equilibrium('origin')\n\n# Type annotation guides usage\nA, B = system.linearize(x_eq, u_eq)  # DeterministicLinearization\n\n# Natural tuple unpacking\nprint(f\"A shape: {A.shape}\")  # (nx, nx)\nprint(f\"B shape: {B.shape}\")  # (nx, nu)\n\n\n\n\n\nsymbolic.py: SymPy Integration\nFile: symbolic.py\nThe symbolic module provides types for SymPy symbolic expressions.\nKey categories:\n\nSymbolic Variables\nSymbolicVariable = sp.Symbol        # Single variable\nSymbolicVector = sp.Matrix          # Vector of symbols\nSymbolicMatrix = sp.Matrix          # Matrix expression\nSymbolicExpression = sp.Expr        # General expression\n\n\nSystem Components\nDynamicsExpression = sp.Matrix      # f(x, u) symbolic\nOutputExpression = sp.Matrix        # h(x) symbolic\nDiffusionExpression = sp.Matrix     # g(x, u) symbolic\nParameterDict = Dict[sp.Symbol, float]  # Parameter values\n\n\nJacobian Expressions\nJacobianExpression = sp.Matrix      # ∂f/∂x symbolic\nHessianExpression = sp.Matrix       # ∂²f/∂x² symbolic\nGradientExpression = sp.Matrix      # ∇f symbolic\nUsage in framework:\n\n\nCode\n# Define custom system using symbolic types\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        # SymbolicVariable\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        # SymbolicVector\n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        \n        # DynamicsExpression (SymbolicMatrix)\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\n        \n        # ParameterDict\n        m_sym, k_sym = sp.symbols('m k', positive=True)\n        self.parameters = {m_sym: m, k_sym: k}\n        \n        self.order = 1\n\nsystem = MySystem()\nprint(\"✓ Symbolic types guide system definition\")\n\n\n\n\n\ncontrol_classical.py: Control Design Results\nFile: control_classical.py\nThe control_classical module provides TypedDict results for classical control theory operations.\nKey categories:\n\nSystem Analysis Results\nStability Analysis:\nclass StabilityInfo(TypedDict):\n    \"\"\"Stability analysis result.\n    \n    Stability Criteria:\n    - Continuous: All Re(λ) &lt; 0 (left half-plane)\n    - Discrete: All |λ| &lt; 1 (inside unit circle)\n    \"\"\"\n    eigenvalues: np.ndarray          # Complex eigenvalues\n    magnitudes: np.ndarray           # |λ| values\n    max_magnitude: float             # Spectral radius\n    spectral_radius: float           # Same as max_magnitude\n    is_stable: bool                  # Asymptotically stable\n    is_marginally_stable: bool       # On stability boundary\n    is_unstable: bool                # Unstable\nControllability:\nclass ControllabilityInfo(TypedDict, total=False):\n    \"\"\"Controllability analysis result.\n    \n    Test: rank(C) = nx where C = [B AB A²B ... Aⁿ⁻¹B]\n    \"\"\"\n    controllability_matrix: ControllabilityMatrix  # (nx, nx*nu)\n    rank: int                        # Rank of C\n    is_controllable: bool            # rank == nx\n    uncontrollable_modes: Optional[np.ndarray]  # Eigenvalues\nObservability:\nclass ObservabilityInfo(TypedDict, total=False):\n    \"\"\"Observability analysis result.\n    \n    Test: rank(O) = nx where O = [C; CA; CA²; ...; CAⁿ⁻¹]\n    \"\"\"\n    observability_matrix: ObservabilityMatrix  # (nx*ny, nx)\n    rank: int                        # Rank of O\n    is_observable: bool              # rank == nx\n    unobservable_modes: Optional[np.ndarray]  # Eigenvalues\n\n\nControl Design Results\nLQR Controller:\nclass LQRResult(TypedDict):\n    \"\"\"Linear Quadratic Regulator result.\n    \n    Minimizes: J = ∫(x'Qx + u'Ru)dt  (continuous)\n               J = Σ(x'Qx + u'Ru)     (discrete)\n    \n    Control law: u = -Kx\n    \"\"\"\n    gain: GainMatrix                 # Feedback gain K (nu, nx)\n    cost_to_go: CovarianceMatrix     # Riccati solution P (nx, nx)\n    closed_loop_eigenvalues: np.ndarray  # eig(A - BK)\n    stability_margin: float          # Phase/gain margin\nKalman Filter:\nclass KalmanFilterResult(TypedDict):\n    \"\"\"Kalman Filter (optimal estimator) result.\n    \n    System:\n        x[k+1] = Ax[k] + Bu[k] + w[k],  w ~ N(0,Q)\n        y[k] = Cx[k] + v[k],            v ~ N(0,R)\n    \n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    gain: GainMatrix                 # Kalman gain L (nx, ny)\n    error_covariance: CovarianceMatrix  # Error cov P (nx, nx)\n    innovation_covariance: CovarianceMatrix  # Innovation S (ny, ny)\n    observer_eigenvalues: np.ndarray  # eig(A - LC)\nLQG Controller:\nclass LQGResult(TypedDict):\n    \"\"\"Linear Quadratic Gaussian controller result.\n    \n    Combines LQR (optimal control) + Kalman (optimal estimation)\n    via separation principle.\n    \n    Controller: u = -Kx̂\n    Estimator: x̂[k+1] = Ax̂[k] + Bu[k] + L(y[k] - Cx̂[k])\n    \"\"\"\n    control_gain: GainMatrix         # LQR gain K (nu, nx)\n    estimator_gain: GainMatrix       # Kalman gain L (nx, ny)\n    control_cost_to_go: CovarianceMatrix  # Controller Riccati P\n    estimation_error_covariance: CovarianceMatrix  # Estimator Riccati P\n    separation_verified: bool        # Separation principle holds\n    closed_loop_stable: bool         # Overall stability\n    controller_eigenvalues: np.ndarray  # eig(A - BK)\n    estimator_eigenvalues: np.ndarray   # eig(A - LC)\nPole Placement:\nclass PolePlacementResult(TypedDict):\n    \"\"\"Pole placement (eigenvalue assignment) result.\n    \n    Design K such that eig(A - BK) = desired poles\n    \"\"\"\n    gain: GainMatrix                 # State feedback gain K\n    desired_poles: np.ndarray        # Desired eigenvalues\n    achieved_poles: np.ndarray       # Actual eig(A - BK)\n    is_controllable: bool            # Arbitrary placement possible\nLuenberger Observer:\nclass LuenbergerObserverResult(TypedDict):\n    \"\"\"Luenberger observer (deterministic estimator) result.\n    \n    Observer: x̂̇ = Ax̂ + Bu + L(y - Cx̂)\n    Error dynamics: ė = (A - LC)e\n    \"\"\"\n    gain: GainMatrix                 # Observer gain L (nx, ny)\n    desired_poles: np.ndarray        # Desired observer poles\n    achieved_poles: np.ndarray       # Actual eig(A - LC)\n    is_observable: bool              # Arbitrary placement possible\nUsage example:\n\n\nCode\n# Stability analysis (TypedDict provides structure)\nstability: StabilityInfo = system.control.analyze_stability(A, system_type='continuous')\nif stability['is_stable']:\n    print(f\"Stable with spectral radius {stability['spectral_radius']:.3f}\")\n\n# LQR design (clear result structure)\nlqr: LQRResult = system.control.design_lqr(A, B, Q, R, system_type='continuous')\nK = lqr['gain']\nclosed_loop_eigs = lqr['controller_eigenvalues']\n\n# Kalman filter (all fields documented)\nkalman: KalmanFilterResult = system.control.design_kalman(\n    A, C, Q_process, R_measurement, system_type='discrete'\n)\nL = kalman['gain']\n\n# LQG controller (separation principle results)\nlqg: LQGResult = system.control.design_lqg(\n    A, B, C, Q, R, Q_process, R_measurement, system_type='discrete'\n)\nK = lqg['controller_gain']\nL = lqg['estimator_gain']",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-structural-types",
    "href": "architecture/Type_System_Architecture.html#sec-structural-types",
    "title": "Type System Architecture",
    "section": "Structural Types",
    "text": "Structural Types\n\nprotocols.py: Abstract Interfaces\nFile: protocols.py\nThe protocols module defines abstract interfaces via Protocol (structural typing).\nKey categories:\n\nSystem Protocols\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Abstract interface for dynamical systems.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    @property\n    def nu(self) -&gt; int: ...\n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\nclass ContinuousSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Continuous-time system interface.\"\"\"\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable,\n        t_span: TimeSpan\n    ) -&gt; IntegrationResult: ...\n\nclass DiscreteSystemProtocol(DynamicalSystemProtocol, Protocol):\n    \"\"\"Discrete-time system interface.\"\"\"\n    @property\n    def dt(self) -&gt; float: ...\n    def step(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\nclass StochasticSystemProtocol(Protocol):\n    \"\"\"Stochastic system interface.\"\"\"\n    @property\n    def nw(self) -&gt; int: ...\n    def drift(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n    def diffusion(self, x: StateVector, u: ControlVector) -&gt; DiffusionMatrix: ...\n\n\nController Protocols\nclass ControllerProtocol(Protocol):\n    \"\"\"Controller interface.\"\"\"\n    def compute_control(self, x: StateVector) -&gt; ControlVector: ...\n\nclass FeedbackControllerProtocol(ControllerProtocol, Protocol):\n    \"\"\"Linear feedback controller.\"\"\"\n    @property\n    def K(self) -&gt; GainMatrix: ...\n\n\nObserver Protocols\nclass ObserverProtocol(Protocol):\n    \"\"\"State observer interface.\"\"\"\n    def observe(self, x: StateVector) -&gt; OutputVector: ...\n    def estimate(self, y: OutputVector, u: ControlVector) -&gt; StateVector: ...\nWhy Protocol:\n\n\nCode\n# No inheritance needed - structural typing\nclass MyCustomSystem:\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property  \n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally (duck typing with type safety)\nsystem: DynamicalSystemProtocol = MyCustomSystem()  # ✓ Type checker approves!\n\n\n\n\n\nutilities.py: Helper Types\nFile: utilities.py\nThe utilities module provides helper types, type guards, and performance tracking.\nKey categories:\n\nType Guards\ndef is_numpy(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is NumPy.\"\"\"\n    return isinstance(arr, np.ndarray)\n\ndef is_torch(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is PyTorch.\"\"\"\n    return hasattr(arr, '__module__') and 'torch' in arr.__module__\n\ndef is_jax(arr: ArrayLike) -&gt; bool:\n    \"\"\"Check if array is JAX.\"\"\"\n    return hasattr(arr, '__module__') and 'jax' in arr.__module__\n\n\nShape Utilities\ndef is_batched(arr: ArrayLike, expected_dims: int = 1) -&gt; bool:\n    \"\"\"Check if array is batched.\"\"\"\n    return arr.ndim &gt; expected_dims\n\ndef get_batch_size(arr: ArrayLike) -&gt; Optional[int]:\n    \"\"\"Get batch size if batched.\"\"\"\n    return arr.shape[0] if is_batched(arr) else None\n\ndef get_state_dim(x: StateVector) -&gt; int:\n    \"\"\"Get state dimension.\"\"\"\n    return x.shape[-1] if x.ndim &gt; 0 else 1\n\n\nPerformance Types\nclass ExecutionStats(TypedDict):\n    \"\"\"Performance statistics.\"\"\"\n    count: int              # Number of calls\n    total_time: float       # Total time (seconds)\n    avg_time: float         # Average time\n    min_time: float         # Fastest call\n    max_time: float         # Slowest call\n\n\nValidation Types\nclass ValidationResult(TypedDict):\n    \"\"\"Validation result.\"\"\"\n    valid: bool\n    errors: List[str]\n    warnings: List[str]\n    info: Dict[str, Any]",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-design-principles",
    "href": "architecture/Type_System_Architecture.html#sec-design-principles",
    "title": "Type System Architecture",
    "section": "Design Principles",
    "text": "Design Principles\n\n1. Semantic Over Structural\nPrinciple: Names convey mathematical meaning, not implementation details.\n\n\nCode\n# ✗ Structural (what it is)\ndef compute(arr1: np.ndarray, arr2: np.ndarray) -&gt; np.ndarray:\n    return arr1 @ arr2\n\n# ✓ Semantic (what it means)\ndef compute_control(x: StateVector, K: GainMatrix) -&gt; ControlVector:\n    \"\"\"u = -Kx\"\"\"\n    return -K @ x\n\n\n\n\n2. Backend Agnosticism\nPrinciple: Same types work with NumPy/PyTorch/JAX.\n\n\nCode\n# Same function signature works for all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # Works with NumPy, PyTorch, JAX\n    return x + u  # Backend detected from input\n\n# Works with all backends\ndx_np = dynamics(np.array([1.0, 0.0]), np.array([0.0]))\ndx_torch = dynamics(torch.tensor([1.0, 0.0]), torch.tensor([0.0]))\ndx_jax = dynamics(jnp.array([1.0, 0.0]), jnp.array([0.0]))\n\nprint(\"✓ Backend-agnostic types\")\n\n\n\n\n3. TypedDict for Structured Results\nPrinciple: Never return plain dictionaries—use TypedDict for structure and safety.\n\n\nCode\n# ✗ Plain dict (no IDE support, no type checking)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# ✓ TypedDict (type-safe, self-documenting)\ndef integrate() -&gt; IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\n\n\n\n\n4. Optional Fields with total=False\nPrinciple: Use total=False for optional fields in TypedDict.\nclass IntegrationResult(TypedDict, total=False):\n    # Required fields (always present)\n    t: TimePoints\n    x: StateTrajectory\n    success: bool\n    \n    # Optional fields (may not be present)\n    njev: int  # Only adaptive methods\n    sol: Any   # Dense output (optional)\n\n\n5. Polymorphic Types via Union\nPrinciple: Use Union for polymorphic return types.\nLinearizationResult = Union[\n    Tuple[StateMatrix, InputMatrix],           # Deterministic\n    Tuple[StateMatrix, InputMatrix, DiffusionMatrix]  # Stochastic\n]\n\n# Single function handles both\ndef analyze(result: LinearizationResult):\n    A, B = result[0], result[1]\n    if len(result) == 3:\n        G = result[2]  # Stochastic\n\n\n6. Protocol for Interfaces\nPrinciple: Define interfaces via Protocol (structural typing) not inheritance.\n\n\nCode\n# No inheritance needed - structural typing\nclass MySystem:\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies DynamicalSystemProtocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # ✓ Type checker approves!",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-usage-throughout-framework",
    "href": "architecture/Type_System_Architecture.html#sec-usage-throughout-framework",
    "title": "Type System Architecture",
    "section": "Usage Throughout Framework",
    "text": "Usage Throughout Framework\n\nIn UI Framework\nclass ContinuousSymbolicSystem(SymbolicSystemBase, ContinuousSystemBase):\n    def __call__(\n        self, \n        x: StateVector, \n        u: Optional[ControlVector] = None\n    ) -&gt; StateVector:\n        \"\"\"Evaluate dynamics (types guide implementation).\"\"\"\n        return self._dynamics.evaluate(x, u, backend=self.backend.default_backend)\n    \n    def linearize(\n        self,\n        x_eq: EquilibriumState,\n        u_eq: EquilibriumControl,\n        backend: Backend = \"numpy\"\n    ) -&gt; DeterministicLinearization:\n        \"\"\"Compute linearization (return type documents structure).\"\"\"\n        return self._linearization.linearize_continuous(x_eq, u_eq, backend)\n\n\nIn Delegation Layer\nclass DynamicsEvaluator:\n    def evaluate(\n        self,\n        x: StateVector,\n        u: Optional[ControlVector],\n        backend: Backend\n    ) -&gt; StateVector:\n        \"\"\"Evaluate forward dynamics (types ensure correctness).\"\"\"\n        f_func: DynamicsFunction = self.code_gen.generate_dynamics(backend)\n        return f_func(x, u)\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        \"\"\"Get performance statistics (TypedDict result).\"\"\"\n        return {\n            'count': self._call_count,\n            'total_time': self._total_time,\n            'avg_time': self._total_time / self._call_count,\n            'min_time': self._min_time,\n            'max_time': self._max_time\n        }\n\n\nIn Integration Framework\nclass ScipyIntegrator(IntegratorBase):\n    def integrate(\n        self,\n        x0: StateVector,\n        u_func: Callable[[ScalarLike, StateVector], Optional[ControlVector]],\n        t_span: TimeSpan,\n        t_eval: Optional[TimePoints] = None\n    ) -&gt; IntegrationResult:\n        \"\"\"Integrate using scipy (TypedDict ensures complete result).\"\"\"\n        # ... implementation ...\n        \n        result: IntegrationResult = {\n            't': sol.t,\n            'x': sol.y.T,\n            'success': sol.success,\n            'message': sol.message,\n            'nfev': sol.nfev,\n            'nsteps': sol.nfev,\n            'integration_time': elapsed,\n            'solver': self.name\n        }\n        \n        # Optional fields (type system allows this)\n        if hasattr(sol, 'njev'):\n            result['njev'] = sol.njev\n        \n        return result",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-type-statistics",
    "href": "architecture/Type_System_Architecture.html#sec-type-statistics",
    "title": "Type System Architecture",
    "section": "Type Statistics",
    "text": "Type Statistics\n\nType Distribution\n\n\n\n\n\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nVector Types\n15+\nStateVector, ControlVector, OutputVector\n\n\nMatrix Types\n30+\nStateMatrix, GainMatrix, CovarianceMatrix\n\n\nFunction Types\n10+\nDynamicsFunction, ControlPolicy\n\n\nBackend Types\n20+\nBackend, Device, NoiseType\n\n\nTrajectory Types\n15+\nStateTrajectory, IntegrationResult\n\n\nLinearization Types\n15+\nDeterministicLinearization\n\n\nSymbolic Types\n10+\nSymbolicExpression, DynamicsExpression\n\n\nProtocol Types\n20+\nDynamicalSystemProtocol\n\n\nUtility Types\n20+\nExecutionStats, ValidationResult\n\n\nTypedDict Results\n15+\nIntegrationResult, LQRResult, StabilityInfo\n\n\nTOTAL\n200+\nComplete type system",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#sec-key-strengths",
    "href": "architecture/Type_System_Architecture.html#sec-key-strengths",
    "title": "Type System Architecture",
    "section": "Key Strengths",
    "text": "Key Strengths\n\n\n\n\n\n\nTipType System Benefits\n\n\n\n\nSemantic Clarity - Names convey mathematical meaning\nType Safety - Static checking prevents errors\nIDE Support - Autocomplete and inline documentation\nBackend Agnostic - Works with NumPy/PyTorch/JAX transparently\nStructured Results - TypedDict not plain dict\nSelf-Documenting - Types encode constraints and invariants\nComposition - Types compose naturally\nExtensible - Easy to add new types\nConsistent - Same conventions throughout framework\nTestable - Type-driven testing patterns",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/Type_System_Architecture.html#summary",
    "href": "architecture/Type_System_Architecture.html#summary",
    "title": "Type System Architecture",
    "section": "Summary",
    "text": "Summary\nThe type system is the foundational layer that enables clean, type-safe architecture throughout ControlDESymulation. By providing semantic types, structured results, and protocol-based interfaces, it supports:\n\nType-driven development - Types guide implementation\nStatic verification - Catch errors before runtime\nMulti-backend support - Transparent backend switching\nClear contracts - Function signatures document expectations\nMaintainability - Types make code self-documenting\n\nThe type system is infrastructure—users benefit from it without needing to understand it. This documentation is provided for framework developers and advanced users who need to understand the internal type architecture.",
    "crumbs": [
      "Framework Design",
      "Type System Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html",
    "href": "architecture/cdesym_Design_Philosophy.html",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic specification and multi-backend simulation of nonlinear dynamical systems. It embodies a type-driven, composition-based architecture that achieves three seemingly contradictory goals simultaneously:\n\nMathematical Rigor - Proper control theory, stochastic processes, and linearization\nSoftware Engineering Excellence - Clean architecture, zero duplication, extensive testing\nMulti-Backend Performance - Seamless NumPy/PyTorch/JAX with GPU/XLA support\n\n\n\n\n\n\n\nNoteLibrary Overview\n\n\n\nThe library consists of 39 core files organized into 4 architectural layers, serving researchers in control theory, robotics, and machine learning.\n\n\n\n\n\n\n\n\nImportantUser Interface Levels\n\n\n\nMost users should interact with the framework at two levels:\n\nBuilt-in Systems (cdesym.systems.builtin.*)\nfrom cdesym import Pendulum, CartPole, LorenzSystem\n\nsystem = Pendulum()\nresult = system.simulate(x0, u=None, t_span=(0, 10))\nUI Framework (Define your own systems)\nfrom cdesym import ContinuousSymbolicSystem\nimport sympy as sp\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        # Define symbolic system\n        pass\n\nLower layers (Type System, Delegation Layer, Integration Framework) are internal implementation details. Users should NOT directly instantiate:\n\nBackendManager, CodeGenerator, DynamicsEvaluator (Delegation Layer)\nIntegratorFactory, ScipyIntegrator, etc. (Integration Framework)\nTypedDict classes from Type System\n\nThe UI framework automatically composes these internal components and exposes their functionality through clean, user-facing methods. This document explains the internal architecture for framework developers and advanced users who need to understand how the framework works.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-executive-summary",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-executive-summary",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "",
    "text": "ControlDESymulation is a Python library for symbolic specification and multi-backend simulation of nonlinear dynamical systems. It embodies a type-driven, composition-based architecture that achieves three seemingly contradictory goals simultaneously:\n\nMathematical Rigor - Proper control theory, stochastic processes, and linearization\nSoftware Engineering Excellence - Clean architecture, zero duplication, extensive testing\nMulti-Backend Performance - Seamless NumPy/PyTorch/JAX with GPU/XLA support\n\n\n\n\n\n\n\nNoteLibrary Overview\n\n\n\nThe library consists of 39 core files organized into 4 architectural layers, serving researchers in control theory, robotics, and machine learning.\n\n\n\n\n\n\n\n\nImportantUser Interface Levels\n\n\n\nMost users should interact with the framework at two levels:\n\nBuilt-in Systems (cdesym.systems.builtin.*)\nfrom cdesym import Pendulum, CartPole, LorenzSystem\n\nsystem = Pendulum()\nresult = system.simulate(x0, u=None, t_span=(0, 10))\nUI Framework (Define your own systems)\nfrom cdesym import ContinuousSymbolicSystem\nimport sympy as sp\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        # Define symbolic system\n        pass\n\nLower layers (Type System, Delegation Layer, Integration Framework) are internal implementation details. Users should NOT directly instantiate:\n\nBackendManager, CodeGenerator, DynamicsEvaluator (Delegation Layer)\nIntegratorFactory, ScipyIntegrator, etc. (Integration Framework)\nTypedDict classes from Type System\n\nThe UI framework automatically composes these internal components and exposes their functionality through clean, user-facing methods. This document explains the internal architecture for framework developers and advanced users who need to understand how the framework works.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-user-interaction",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-user-interaction",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "User Interaction Model",
    "text": "User Interaction Model\n\nThe Right Way to Use the Framework\nThe framework is designed with clear user-facing and internal boundaries:\n✓ User-Facing APIs (Use These):\n# Level 1: Use built-in systems\nfrom cdesym import Pendulum, VanDerPol, LangevinDynamics\n\nsystem = Pendulum()\nresult = system.simulate(x0, controller, t_span=(0, 10))\nA, B = system.linearize(x_eq, u_eq)\n\n# Level 2: Define custom systems\nfrom cdesym import ContinuousSymbolicSystem\n\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, **params):\n        # Your symbolic definition\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n\nsystem = MySystem()  # Framework handles all internal composition\n✗ Internal APIs (Don’t Use These Directly):\n# ❌ WRONG: Direct delegation layer access\nfrom cdesym.systems.base.utils.backend_manager import BackendManager\nfrom cdesym.systems.base.utils.code_generator import CodeGenerator\nfrom cdesym.systems.base.utils.dynamics_evaluator import DynamicsEvaluator\n\nbackend = BackendManager()  # Don't do this!\ncode_gen = CodeGenerator(system)  # Framework creates these automatically\ndynamics = DynamicsEvaluator(system, code_gen, backend)  # Internal!\n\n# ❌ WRONG: Direct integrator instantiation\nfrom cdesym.systems.base.numerical_integration.scipy_integrator import ScipyIntegrator\n\nintegrator = ScipyIntegrator(system, method='RK45')  # Don't do this!\n\n# ✓ CORRECT: Use system interface\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='RK45')\n# Framework creates appropriate integrator internally\n\n\nWhy This Separation Matters\nUser-Facing Benefits:\n\nSimple, consistent interface across all systems\nNo need to understand internal architecture\nFramework handles complexity automatically\nChanges to internals don’t break user code\n\nFramework Developer Benefits:\n\nCan refactor internal components freely\nClear separation of concerns\nEasier to maintain and test\nWell-defined extension points\n\n\n\nWhen You Might Need Internal APIs\nThe only time to directly use internal components:\n\nFramework Extension - Adding new system types, integrators, or utilities\nAdvanced Debugging - Diagnosing framework issues\nPerformance Optimization - Custom integration workflows\nResearch Purposes - Experimenting with new numerical methods\n\nFor these advanced use cases, refer to the architecture documentation for each layer.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-core-design-philosophy",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-core-design-philosophy",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Core Design Philosophy",
    "text": "Core Design Philosophy\n\n1. Type-Driven Design\nPrinciple: Types are not just annotations—they are the architecture.\nThe entire framework is built on a foundational type system (200+ types) that provides:\n\nSemantic Clarity: StateVector, GainMatrix instead of np.ndarray\nType Safety: Static checking via mypy/pyright catches errors before runtime\nIDE Support: Autocomplete knows result['t'] exists and is TimePoints\nSelf-Documentation: Type signatures encode mathematical constraints\n\nExample comparison:\n# ❌ Bad: Unclear types and semantics\ndef bad(x, u):  # What are these? What dimensions? What backend?\n    return x + u\n\n# ✓ Good: Clear semantics and constraints\ndef good(x: StateVector, u: ControlVector) -&gt; StateVector:\n    \"\"\"Clear: state in, control in, state out. Works with any backend.\"\"\"\n    return x + u\nImpact: Every function signature is a mini-specification. New developers understand code by reading types.\n\n\n2. Composition Over Inheritance\nPrinciple: Systems compose specialized utilities rather than inheriting monolithic bases.\nTraditional OOP would create deep inheritance hierarchies. We rejected this in favor of composition via delegation:\n# ❌ NOT this (deep inheritance):\nclass System(BackendManager, CodeGenerator, DynamicsEvaluator, ...):\n    pass  # 50 methods, unclear responsibilities\n\n# ✓ YES this (composition):\nclass System:\n    def __init__(self):\n        self.backend = BackendManager()       # Multi-backend support\n        self._code_gen = CodeGenerator()      # Symbolic → numerical\n        self._dynamics = DynamicsEvaluator()  # Forward evaluation\n        self._linearization = LinearizationEngine()  # Jacobians\n        self.equilibria = EquilibriumHandler()  # Named equilibria\nBenefits:\n\n\n\nBenefit\nDescription\n\n\n\n\nSingle Responsibility\nEach utility does one thing well\n\n\nTestability\nTest utilities in isolation\n\n\nReusability\nUse BackendManager anywhere\n\n\nClarity\nExplicit dependencies\n\n\nFlexibility\nEasy to swap implementations\n\n\n\n\n\n\n\n\n\nImportantStrategic Use of Inheritance\n\n\n\nWe DO use cooperative multiple inheritance in the UI framework—but only at the top level where it provides genuine value (avoiding duplication while maintaining clean interfaces).\n\n\n\n\n3. Backend Agnosticism\nPrinciple: Write once, run on NumPy/PyTorch/JAX without code changes.\nSupporting multiple backends is not a feature—it’s a design constraint that forces better architecture:\n# Same code works with all backends\ndef dynamics(x: StateVector, u: ControlVector) -&gt; StateVector:\n    # x can be np.ndarray, torch.Tensor, or jax.Array\n    return -K @ x  # Works with all!\n\n# Backend switching is trivial\nsystem.set_default_backend('torch')\nsystem.to_device('cuda:0')\nArchitectural implications:\n\nArrayLike Union Type: All array types accept Union[np.ndarray, torch.Tensor, jnp.ndarray]\nBackendManager Utility: Centralized backend detection and conversion\nPer-Backend Caching: Code generated once per backend, then cached\nDevice Management: Automatic GPU placement when available\n\nResult: Users can start with NumPy for prototyping, switch to PyTorch for neural ODEs, or JAX for optimization—with zero code changes.\n\n\n4. Zero Code Duplication\nPrinciple: Every line of code should exist in exactly one place.\nWe eliminated ~1,800 lines of duplication between continuous and discrete systems through strategic abstraction:\nBefore refactoring: Continuous and discrete systems each had:\n\nParameter handling\nBackend management\nCode generation\nSymbolic validation\nConfiguration persistence\n\nAfter refactoring: SymbolicSystemBase provides shared functionality:\n\nAll parameter logic: ONE implementation\nAll backend logic: ONE BackendManager\nAll code generation: ONE CodeGenerator\nAll validation: ONE SymbolicValidator\n\nImplementation via cooperative multiple inheritance:\nLayer 0: SymbolicSystemBase (shared foundation)\n         |\n    +----+----+\n    |         |\nLayer 1: ContinuousSystemBase, DiscreteSystemBase (time-domain specific)\n         |                      |\n         +----------+-----------+\n                    |\nLayer 2: ContinuousSymbolicSystem, DiscreteSymbolicSystem\nThis isn’t inheritance for convenience—it’s strategic abstraction to eliminate duplication while maintaining clarity.\n\n\n5. Structured Results via TypedDict\nPrinciple: Never return plain dictionaries—use TypedDict for structure and safety.\n# ❌ BAD: Plain dict (no IDE support, no type checking)\ndef integrate() -&gt; dict:\n    return {'t': t, 'x': x, 'success': True}\n\n# ✓ GOOD: TypedDict (type-safe, self-documenting)\ndef integrate() -&gt; IntegrationResult:\n    return {\n        't': t,              # TimePoints - IDE knows this\n        'x': x,              # StateTrajectory - IDE knows this\n        'success': True,     # bool - IDE knows this\n        'nfev': 100,        # int - Required field\n        'integration_time': 0.5,\n        'solver': 'RK45'\n    }\nBenefits:\n\n✓ Type checker ensures all required fields present\n✓ IDE autocompletes field names\n✓ Documentation embedded in type definition\n✓ Optional fields clearly marked (total=False)\n✓ Refactoring safe (rename propagates)\n\nUsed throughout:\n\n\n\nResult Type\nPurpose\n\n\n\n\nIntegrationResult\nODE integration output\n\n\nSDEIntegrationResult\nSDE integration output\n\n\nExecutionStats\nPerformance metrics\n\n\nValidationResult\nSystem validation status\n\n\nBackendConfig\nConfiguration data\n\n\n\n\n\n6. Protocol-Based Interfaces\nPrinciple: Define interfaces via Protocol (structural typing) not inheritance.\nProtocols enable duck typing with type safety:\nfrom typing import Protocol\n\nclass DynamicalSystemProtocol(Protocol):\n    \"\"\"Any class satisfying this structure is a dynamical system.\"\"\"\n    @property\n    def nx(self) -&gt; int: ...\n    \n    @property\n    def nu(self) -&gt; int: ...\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector: ...\n\n# No inheritance needed!\nclass MySystem:  # Doesn't inherit from anything\n    @property\n    def nx(self) -&gt; int:\n        return 2\n    \n    @property  \n    def nu(self) -&gt; int:\n        return 1\n    \n    def __call__(self, x: StateVector, u: ControlVector) -&gt; StateVector:\n        return x + u\n\n# Satisfies protocol structurally\nsystem: DynamicalSystemProtocol = MySystem()  # ✓ Type checker approves!\nAdvantages:\n\nNo inheritance coupling\nStructural subtyping (like Go interfaces)\nEasy to implement interfaces\nCompose protocols naturally\nThird-party types work automatically\n\n\n\n7. Factory Pattern for Complex Creation\nPrinciple: Hide complexity behind simple factory methods.\nCreating integrators involves choosing backends, methods, and configurations. Factories simplify this:\n# ❌ Instead of this complexity:\nif backend == 'numpy':\n    if method == 'RK45':\n        return ScipyIntegrator(system, method='RK45', rtol=1e-6)\n    elif method == 'Tsit5':\n        return DiffEqPyIntegrator(system, algorithm='Tsit5')\nelif backend == 'torch':\n    return TorchDiffEqIntegrator(system, method='dopri5')\n# ... 50 more cases\n\n# ✓ We provide this simplicity:\nintegrator = IntegratorFactory.auto(system)\n# or\nintegrator = IntegratorFactory.for_production(system)\n# or  \nintegrator = IntegratorFactory.for_neural_ode(system)\nAvailable factory methods:\n\n\n\nMethod\nPurpose\n\n\n\n\nauto()\nBest integrator for system/backend\n\n\nfor_production()\nLSODA/AutoTsit5 for reliability\n\n\nfor_optimization()\nJAX tsit5 for speed\n\n\nfor_neural_ode()\nPyTorch dopri5 with adjoint\n\n\nfor_julia()\nHighest performance\n\n\ncreate()\nFull control when needed\n\n\n\nResult: Simple interface for common cases, full control when needed.\n\n\n8. Semantic Naming\nPrinciple: Names should convey mathematical meaning, not implementation details.\nGood semantic names:\n\n✓ StateVector not ArrayLike - conveys it’s a state\n✓ GainMatrix not Matrix - conveys it’s for feedback control\n✓ DynamicsEvaluator not FunctionCaller - conveys purpose\n✓ LinearizationEngine not JacobianComputer - conveys operation\n\nBad implementation names:\n\n✗ data - what data?\n✗ arr1, arr2 - meaningless\n✗ compute() - compute what?\n✗ process_stuff() - what stuff?\n\nImpact: Code reads like mathematical papers. Control theorists immediately understand.\n\n\n9. Progressive Disclosure of Complexity\nPrinciple: Simple things should be simple, complex things should be possible.\nThe framework provides three levels of interaction, each building on the previous:\nLevel 1 - Beginner (Use Built-in Systems):\nfrom cdesym import Pendulum, CartPole, LorenzSystem\n\n# Use pre-defined systems from cdesym.systems.builtin\nsystem = Pendulum()\nresult = system.simulate(x0, u=np.zeros(1), t_span=(0, 10))\n\n# All internal complexity handled automatically\nLevel 2 - Intermediate (Define Custom Systems):\nfrom cdesym import ContinuousSymbolicSystem\nimport sympy as sp\n\n# Define your own system using UI framework\nclass MySystem(ContinuousSymbolicSystem):\n    def define_system(self, m=1.0, k=10.0):\n        x, v = sp.symbols('x v', real=True)\n        u = sp.symbols('u', real=True)\n        \n        self.state_vars = [x, v]\n        self.control_vars = [u]\n        self._f_sym = sp.Matrix([v, -k*x/m + u/m])\n\nsystem = MySystem(m=2.0)  # Framework composes internals\nresult = system.integrate(x0, u=None, t_span=(0, 10))\nLevel 3 - Expert (Framework Extension):\n# ⚠️ Advanced: Only for framework developers\n# Directly use internal APIs for custom integrators, utilities, etc.\n\n# Custom integrator implementation\nfrom cdesym.systems.base.numerical_integration import IntegratorBase\n\nclass MyCustomIntegrator(IntegratorBase):\n    def step(self, x, u, dt):\n        # Custom integration logic\n        pass\n\n# Custom utility for system composition\nfrom cdesym.systems.base.utils import BackendManager\n\nclass MyUtility:\n    def __init__(self, system, backend_mgr: BackendManager):\n        # Custom utility using internal components\n        pass\n\n\n\n\n\n\nTipRecommended Entry Points\n\n\n\n\nBeginners: Use built-in systems from cdesym.systems.builtin.*\nIntermediate: Subclass ContinuousSymbolicSystem or DiscreteSymbolicSystem\nAdvanced: Only access Layers 0-2 when extending the framework itself\n\n\n\nPrinciple applied:\n\nDefault arguments for common cases\nProgressive power through optional parameters\n\nExpert features available but hidden from typical users\nInternal complexity encapsulated at each level",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-architectural-layers",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-architectural-layers",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Architectural Layers",
    "text": "Architectural Layers\n\n\n\n\n\n\nWarningFor Framework Developers\n\n\n\nThe following sections describe the internal architecture of the framework. Typical users do not need to understand these layers and should not directly instantiate components from Layers 0-2.\nUsers should work with: - Built-in systems from cdesym.systems.builtin.* - UI framework by subclassing ContinuousSymbolicSystem or DiscreteSymbolicSystem\nThe internal layers are documented here for: - Framework contributors and maintainers - Advanced users implementing custom integrators or utilities - Researchers studying the framework architecture\n\n\nThe library consists of 4 distinct architectural layers, each with clear responsibilities:\n\nLayer 0: Type System (Foundation)\nPurpose: Foundational types and structured results\nFiles: 7 modules, 200+ types\nKey components:\n\n\n\nModule\nPurpose\n\n\n\n\ncore.py\nVectors, matrices, functions\n\n\nbackends.py\nBackend enums, configs\n\n\ntrajectories.py\nTime series results\n\n\nlinearization.py\nJacobian types\n\n\nsymbolic.py\nSymPy integration\n\n\nprotocols.py\nAbstract interfaces\n\n\nutilities.py\nType guards, helpers\n\n\n\nDesign principles:\n\nSemantic over structural naming\nBackend-agnostic unions\nTypedDict for all results\nProtocol-based interfaces\n\nImpact: Every layer above uses these types. Changes here propagate everywhere—so we keep them stable and well-designed.\n\n\nLayer 1: Delegation Layer (Services)\nPurpose: Specialized utilities via composition\nFiles: 11 modules\nCore utilities:\n\nBackendManager - Multi-backend support\nCodeGenerator - Symbolic → numerical\nEquilibriumHandler - Named equilibria\nSymbolicValidator - System validation\n\nDeterministic services:\n\nDynamicsEvaluator - Forward dynamics\nLinearizationEngine - Jacobians\nObservationEngine - Output evaluation\n\nStochastic services:\n\nDiffusionHandler - SDE diffusion\nNoiseCharacterizer - Noise analysis\nSDEValidator - SDE validation\n\nLow-level:\n\ncodegen_utils - SymPy code generation\n\nDesign principles:\n\nSingle responsibility per utility\nComposition not inheritance\nDependency injection\nLazy initialization with caching\n\nImpact: UI framework composes these utilities. Each utility is independently testable and reusable.\n\n\nLayer 2: Integration Framework (Numerical Methods)\nPurpose: Multi-backend numerical integration\nFiles: 13 modules\nDeterministic (ODE) integrators:\n\n\n\nIntegrator\nBackend\nPurpose\n\n\n\n\nScipyIntegrator\nNumPy\nscipy.integrate.solve_ivp\n\n\nTorchDiffEqIntegrator\nPyTorch\nGPU acceleration + autograd\n\n\nDiffraxIntegrator\nJAX\nXLA compilation\n\n\nDiffEqPyIntegrator\nJulia\nHighest performance\n\n\nFixedStepIntegrators\nAny\nEuler, RK4, Midpoint\n\n\n\nStochastic (SDE) integrators:\n\n\n\nIntegrator\nBackend\nPurpose\n\n\n\n\nTorchSDEIntegrator\nPyTorch\nGPU SDE integration\n\n\nDiffraxSDEIntegrator\nJAX\nXLA-compiled SDEs\n\n\nDiffEqPySDEIntegrator\nJulia\nProduction-grade SDEs\n\n\nCustomBrownianPath\nJAX\nCustom noise for testing\n\n\n\nDesign principles:\n\nFactory pattern for creation\nUnified result types (TypedDict)\nBackend abstraction\nPerformance tracking\n\nSupported methods: 40+ integration methods across 4 backends\n\n\nLayer 3: UI Framework (User-Facing Systems)\nPurpose: Symbolic system definition and high-level interface\nFiles: 8 modules\nArchitecture hierarchy:\nLayer 0: SymbolicSystemBase\n         └─ Time-agnostic foundation\n         \nLayer 1: Time-domain bases\n         ├─ ContinuousSystemBase\n         └─ DiscreteSystemBase\n         \nLayer 2: Concrete implementations\n         ├─ ContinuousSymbolicSystem\n         └─ DiscreteSymbolicSystem\n         \nLayer 3: Stochastic extensions\n         ├─ ContinuousStochasticSystem\n         └─ DiscreteStochasticSystem\nKey responsibilities:\n\n\n\n\n\n\n\nComponent\nResponsibility\n\n\n\n\nSymbolicSystemBase\nSymbolic variables, parameters, code generation, backend management, equilibria, config\n\n\nContinuousSystemBase\nContinuous-time interface (dx/dt = f)\n\n\nDiscreteSystemBase\nDiscrete-time interface (x[k+1] = f)\n\n\nContinuousSymbolicSystem\nCombine symbolic + continuous\n\n\nDiscreteSymbolicSystem\nCombine symbolic + discrete\n\n\nStochastic Systems\nAdd diffusion handling\n\n\nDiscretizedSystem\nContinuous → discrete conversion\n\n\n\nDesign principles:\n\nCooperative multiple inheritance (strategic use only)\nZero code duplication\nTemplate method pattern\nComposition for utilities",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-design-patterns",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-design-patterns",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Design Patterns Used",
    "text": "Design Patterns Used\n\n1. Template Method Pattern\nWhere: All system base classes\nHow: Base class defines workflow, subclasses fill in details\nclass SymbolicSystemBase(ABC):\n    def __init__(self, *args, **kwargs):\n        # 1. Call user's define_system()\n        self.define_system(*args, **kwargs)\n        \n        # 2. Validate\n        self._validator.validate(self)\n        \n        # 3. Initialize utilities\n        self._setup_utilities()\n        \n        # 4. Compile functions\n        self._compile()\n    \n    @abstractmethod\n    def define_system(self, **params):\n        \"\"\"User implements this.\"\"\"\n        pass\nBenefit: Consistent initialization workflow. Users only implement define_system().\n\n\n2. Factory Method Pattern\nWhere: IntegratorFactory, SDEIntegratorFactory\nHow: Factory methods create appropriate concrete classes\nclass IntegratorFactory:\n    @classmethod\n    def create(cls, system, backend, method, **opts):\n        \"\"\"Create appropriate integrator based on inputs.\"\"\"\n        if backend == 'numpy':\n            if method in SCIPY_METHODS:\n                return ScipyIntegrator(system, method, **opts)\n            elif method in JULIA_METHODS:\n                return DiffEqPyIntegrator(system, method, **opts)\n        elif backend == 'torch':\n            return TorchDiffEqIntegrator(system, method, **opts)\n        # ...\n    \n    @classmethod\n    def auto(cls, system):\n        \"\"\"Best integrator for system.\"\"\"\n        backend = system.backend.default_backend\n        method = cls._BACKEND_DEFAULTS[backend]\n        return cls.create(system, backend, method)\nBenefit: Users get right integrator without knowing details.\n\n\n3. Strategy Pattern\nWhere: Integration methods\nHow: Different algorithms (strategies) with same interface\n# All integrators implement same interface\nclass IntegratorBase(ABC):\n    @abstractmethod\n    def integrate(self, x0, u_func, t_span) -&gt; IntegrationResult:\n        pass\n\n# Different strategies\nintegrator = ScipyIntegrator(system, method='RK45')  # Strategy 1\nintegrator = DiffraxIntegrator(system, method='tsit5')  # Strategy 2\n\n# Same interface\nresult = integrator.integrate(x0, u_func, t_span)\nBenefit: Swap integration methods without code changes.\n\n\n4. Dependency Injection\nWhere: All delegation layer utilities\nHow: Dependencies injected via constructor\nclass DynamicsEvaluator:\n    def __init__(\n        self,\n        system: SymbolicSystemBase,\n        code_gen: CodeGenerator,\n        backend_mgr: BackendManager\n    ):\n        # Dependencies injected, not created internally\n        self.system = system\n        self.code_gen = code_gen\n        self.backend_mgr = backend_mgr\nBenefit: Easy to test (mock dependencies), clear dependencies.\n\n\n5. Lazy Initialization\nWhere: Code generation, function compilation\nHow: Generate/compile on first use, cache result\nclass CodeGenerator:\n    def generate_dynamics(self, backend):\n        # Check cache first\n        if self._f_funcs[backend] is not None:\n            return self._f_funcs[backend]  # Instant\n        \n        # Generate only if needed\n        func = self._compile_dynamics(backend)\n        \n        # Cache for next time\n        self._f_funcs[backend] = func\n        return func\nBenefit: Fast startup, compile only what’s needed.\n\n\n6. Observer Pattern\nWhere: Performance statistics, validation\nHow: Utilities track events and report statistics\nclass DynamicsEvaluator:\n    def evaluate(self, x, u):\n        start = time.time()\n        result = self._f_func(x, u)\n        elapsed = time.time() - start\n        \n        # Update statistics\n        self._stats['calls'] += 1\n        self._stats['total_time'] += elapsed\n        \n        return result\n    \n    def get_stats(self) -&gt; ExecutionStats:\n        return self._stats\nBenefit: Built-in performance monitoring.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-mathematical-rigor",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-mathematical-rigor",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Mathematical Rigor",
    "text": "Mathematical Rigor\n\nControl Theory Foundations\nThe library implements proper control theory:\n1. State-Space Representation\n\\[\n\\begin{aligned}\n\\text{Continuous:} \\quad & \\dot{x} = f(x, u, t) \\\\\n                          & y = h(x, t) \\\\\n\\\\\n\\text{Discrete:} \\quad   & x[k+1] = f(x[k], u[k]) \\\\\n                          & y[k] = h(x[k])\n\\end{aligned}\n\\]\n2. Linearization\n\\[\n\\begin{aligned}\n\\delta\\dot{x} &= A\\cdot\\delta x + B\\cdot\\delta u  && \\text{(continuous)} \\\\\n\\delta x[k+1] &= A_d\\cdot\\delta x[k] + B_d\\cdot\\delta u[k] && \\text{(discrete)}\n\\end{aligned}\n\\]\nwhere: - \\(A = \\frac{\\partial f}{\\partial x}\\) (state Jacobian) - \\(B = \\frac{\\partial f}{\\partial u}\\) (control Jacobian)\n3. Higher-Order Systems\nFor order \\(n\\) system \\(q^{(n)} = f(q, \\dot{q}, \\ldots, q^{(n-1)}, u)\\):\n\\[\n\\text{State: } x = [q, \\dot{q}, \\ldots, q^{(n-1)}]^T \\\\\n\\text{Dynamics: } \\dot{x} = [\\dot{q}, \\ddot{q}, \\ldots, q^{(n)}]^T\n\\]\n4. Stochastic Processes\n\\[\n\\begin{aligned}\n\\text{Itô:} \\quad & dx = f(x,u)dt + g(x,u)dW \\\\\n\\text{Stratonovich:} \\quad & dx = f(x,u)dt + g(x,u)\\circ dW\n\\end{aligned}\n\\]\nNoise types:\n\nAdditive: \\(g(x,u) = G\\) (constant)\nMultiplicative: \\(g\\) depends on \\(x\\) or \\(u\\)\nDiagonal: Independent noise channels\nScalar: Single Wiener process\n\n\n\nNumerical Methods\nODE Solvers (40+ methods):\n\n\n\nCategory\nMethods\n\n\n\n\nExplicit RK\nRK45, Tsit5, Vern9, dopri5\n\n\nImplicit\nRadau, BDF, Rodas5\n\n\nAuto-stiffness\nLSODA, AutoTsit5\n\n\nFixed-step\nEuler, RK4, Midpoint\n\n\n\nSDE Solvers:\n\n\n\nMethod\nConvergence\nNoise Type\n\n\n\n\nEuler-Maruyama\nStrong 0.5\nGeneral\n\n\nMilstein\nStrong 1.0\nDiagonal\n\n\nHeun\nStrong 1.0\nAdditive\n\n\nStochastic RK\nVariable\nGeneral",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-performance",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-performance",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Performance Considerations",
    "text": "Performance Considerations\n\n1. Caching Strategy\nThree-level cache:\n\nSymbolic Cache: Jacobians computed once symbolically\nPer-Backend Cache: Compiled functions per backend\nEquilibrium Cache: Linearizations at equilibria\n\n# First call: symbolic computation + compilation\nA, B = system.linearize(x_eq, u_eq)\n\n# Second call: cached (instant)\nA, B = system.linearize(x_eq, u_eq)\n\n\n2. Backend Optimization\nNumPy:\n\nCommon subexpression elimination (CSE)\nFast numerical modules\nVectorized operations\n\nPyTorch:\n\nSymbolic simplification before codegen\nGPU tensor operations\nAutomatic differentiation\nAdjoint method for memory efficiency\n\nJAX:\n\nJIT compilation via jax.jit\nXLA optimization\nPure functional style\nAutomatic vectorization (vmap)\n\n\n\n3. Batching Support\nAll evaluators support batched operations:\n# Single evaluation\ndx = system(x, u)  # x: (nx,), u: (nu,) → dx: (nx,)\n\n# Batched evaluation (possible 100x speedup over loop)\ndx_batch = system(x_batch, u_batch)  \n# x: (100, nx), u: (100, nu) → dx: (100, nx)\n\n\n4. GPU Acceleration\nPyTorch:\nsystem.set_default_backend('torch')\nsystem.to_device('cuda:0')\n\nx = torch.tensor([[1.0, 0.0]], device='cuda:0')\ndx = system(x, u)  # Computed on GPU\nJAX:\nsystem.set_default_backend('jax')\nsystem.to_device('cuda:0')\n\nx = jnp.array([1.0, 0.0])\ndx = jax.jit(system)(x, u)  # XLA compiled, GPU enabled",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-testing",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-testing",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Testing Philosophy",
    "text": "Testing Philosophy\n\n1. Type-Driven Testing\nTypes guide what to test:\ndef test_dynamics_signature():\n    \"\"\"Type annotations specify contract.\"\"\"\n    x: StateVector = np.array([1.0, 0.0])\n    u: ControlVector = np.array([0.5])\n    \n    dx: StateVector = system(x, u)\n    \n    assert isinstance(dx, np.ndarray)\n    assert dx.shape == (system.nx,)\n\n\n2. Property-Based Testing\nTest mathematical properties:\ndef test_linearization_is_linear():\n    \"\"\"Linearization should be linear in δx and δu.\"\"\"\n    A, B = system.linearize(x_eq, u_eq)\n    \n    δx1, δx2 = np.random.randn(2, nx)\n    \n    # Linearity: f(αx₁ + βx₂) = αf(x₁) + βf(x₂)\n    α, β = 0.3, 0.7\n    \n    lhs = A @ (α*δx1 + β*δx2)\n    rhs = α*(A @ δx1) + β*(A @ δx2)\n    \n    np.testing.assert_allclose(lhs, rhs)\n\n\n3. Multi-Backend Consistency\nSame results across backends:\ndef test_backend_consistency():\n    \"\"\"NumPy, PyTorch, JAX should agree.\"\"\"\n    x_np = np.array([1.0, 0.0])\n    \n    dx_np = system(x_np, backend='numpy')\n    dx_torch = system(torch.tensor(x_np), backend='torch')\n    dx_jax = system(jnp.array(x_np), backend='jax')\n    \n    np.testing.assert_allclose(dx_np, dx_torch.numpy())\n    np.testing.assert_allclose(dx_np, np.array(dx_jax))\n\n\n4. Regression Testing\nCritical numerical values frozen:\ndef test_pendulum_energy_conservation():\n    \"\"\"Known system should have expected behavior.\"\"\"\n    system = Pendulum(m=1.0, l=1.0, g=9.81)\n    \n    # Energy should be conserved (no damping)\n    E0 = compute_energy(x0)\n    x_final = system.simulate(x0, u=None, t_span=(0, 10))[-1]\n    E_final = compute_energy(x_final)\n    \n    np.testing.assert_allclose(E0, E_final, rtol=1e-6)",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-documentation",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-documentation",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Documentation Philosophy",
    "text": "Documentation Philosophy\n\n1. Self-Documenting Code\nCode should be readable without comments:\n# ❌ Bad\ndef f(x, u, m):  # What is this?\n    return x[1], -m*x[0] + u\n\n# ✓ Good  \ndef compute_dynamics(\n    state: StateVector,\n    control: ControlVector,\n    stiffness: float\n) -&gt; StateVector:\n    \"\"\"\n    Compute dynamics for mass-spring system.\n    \n    Parameters\n    ----------\n    state : StateVector\n        [position, velocity]\n    control : ControlVector\n        Applied force\n    stiffness : float\n        Spring constant k\n    \n    Returns\n    -------\n    StateVector\n        [velocity, acceleration]\n    \"\"\"\n    position, velocity = state\n    force = control\n    acceleration = -stiffness * position + force\n    return np.array([velocity, acceleration])\n\n\n2. Examples in Docstrings\nEvery public function has usage examples:\ndef linearize(\n    self,\n    x_eq: EquilibriumState,\n    u_eq: EquilibriumControl\n) -&gt; DeterministicLinearization:\n    \"\"\"\n    Compute linearization at equilibrium.\n    \n    Returns state and control Jacobians (A, B).\n    \n    Examples\n    --------\n    &gt;&gt;&gt; # Linearize at origin\n    &gt;&gt;&gt; A, B = system.linearize(\n    ...     x_eq=np.zeros(2),\n    ...     u_eq=np.zeros(1)\n    ... )\n    &gt;&gt;&gt; print(A.shape)  # (2, 2)\n    &gt;&gt;&gt; print(B.shape)  # (2, 1)\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; # Check stability\n    &gt;&gt;&gt; eigenvalues = np.linalg.eigvals(A)\n    &gt;&gt;&gt; stable = np.all(np.real(eigenvalues) &lt; 0)\n    \"\"\"\n\n\n3. Mathematical Documentation\nExplain theory behind code:\n\"\"\"\nLinearization Engine for Dynamical Systems\n\nMathematical Background\n-----------------------\nFor a nonlinear system:\n    dx/dt = f(x, u)\n\nThe linearization at (x_eq, u_eq) is:\n    δẋ = A·δx + B·δu\n\nwhere:\n    A = ∂f/∂x|(x_eq, u_eq) ∈ ℝ^(nx×nx)  (State Jacobian)\n    B = ∂f/∂u|(x_eq, u_eq) ∈ ℝ^(nx×nu)  (Control Jacobian)\n\nThis enables:\n- Stability analysis via eigenvalues of A\n- LQR controller design\n- Observer design (Kalman filter)\n- Small-signal analysis\n\"\"\"\n\n\n4. Architecture Documents\nHigh-level guides (like this one!) explain design philosophy and patterns.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-error-handling",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-error-handling",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Error Handling Philosophy",
    "text": "Error Handling Philosophy\n\n1. Fail Fast, Fail Clearly\nDetect errors as early as possible with clear messages:\n# ❌ Bad\ndef compute(x):\n    return x[5]  # IndexError: vague\n\n# ✓ Good\ndef compute(state: StateVector) -&gt; float:\n    if len(state) &lt; 6:\n        raise ValueError(\n            f\"State must have at least 6 elements for this computation. \"\n            f\"Got {len(state)} elements: {state}\"\n        )\n    return state[5]\n\n\n2. Validation at Construction\nCatch errors during __init__, not during use:\nclass System(SymbolicSystemBase):\n    def define_system(self):\n        # Bad parameter type\n        self.parameters = {'m': 1.0}  # String key!\n        \n# Validation catches this immediately:\n# ValueError: Parameter keys must be Symbol, not str.\n# Found string key: 'm'\n# Use: m_sym = sp.symbols('m'); parameters = {m_sym: 1.0}\n\n\n3. Type Checking Before Runtime\nUse type annotations + mypy to catch errors before running:\n$ mypy src/\nerror: Argument 1 to \"compute\" has incompatible type \"List[float]\"; \nexpected \"ndarray[Any, dtype[Any]]\"\n\n\n4. Helpful Error Messages\nInclude context and solutions:\nif x.shape[0] != self.nx:\n    raise ValueError(\n        f\"State dimension mismatch.\\n\"\n        f\"Expected: {self.nx} (from system definition)\\n\"\n        f\"Got: {x.shape[0]} (from input)\\n\"\n        f\"State: {x}\\n\"\n        f\"Hint: Check that state vector has correct dimension.\"\n    )",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-extension-points",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-extension-points",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Extension Points",
    "text": "Extension Points\nThe architecture provides clear extension points:\n\n1. Add New System Type\nclass MyCustomSystem(SymbolicSystemBase):\n    \"\"\"Just implement define_system().\"\"\"\n    def define_system(self, **params):\n        # Define symbolic system\n        self.state_vars = [...]\n        self._f_sym = sp.Matrix([...])\n        self.parameters = {...}\n\n    def setup_equilibria(self):\n        \"\"\"Optional: Auto-set equilibria upon instantiation.\"\"\"\n        # Define custom equilibrium setup\n        pass\n\n\n2. Add New Integrator\nclass MyIntegrator(IntegratorBase):\n    \"\"\"Implement abstract methods.\"\"\"\n    def step(self, x, u, dt):\n        # Single step logic\n        pass\n    \n    def integrate(self, x0, u_func, t_span):\n        # Multi-step logic\n        return IntegrationResult(...)\n\n\n3. Add New Utility\nclass MyUtility:\n    \"\"\"Independent utility via composition.\"\"\"\n    def __init__(self, system):\n        self.system = system\n    \n    def my_operation(self):\n        # Custom operation\n        pass\n\n# Use via composition\nsystem._my_utility = MyUtility(system)\n\n\n4. Add New Backend\n# 1. Add to Backend type\nBackend = Literal[\"numpy\", \"torch\", \"jax\", \"my_backend\"]\n\n# 2. Extend BackendManager\nclass BackendManager:\n    def _convert_to_backend(self, arr, backend):\n        if backend == \"my_backend\":\n            return my_backend.array(arr)\n        # ...\n\n# 3. Add to codegen_utils\ndef generate_function(expr, vars, backend):\n    if backend == \"my_backend\":\n        return my_backend.lambdify(...)\n    # ...",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-trade-offs",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-trade-offs",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Trade-offs and Decisions",
    "text": "Trade-offs and Decisions\n\n1. Cooperative Multiple Inheritance\nDecision: Use cooperative multiple inheritance ONLY in UI framework Layer 2\n\n\n\n\n\n\nTipRationale\n\n\n\nPros:\n\nEliminates ~1,800 lines of duplication\nClean interfaces (ContinuousSymbolicSystem has both capabilities)\nPython’s MRO handles it correctly with super()\n\nCons:\n\nCan be confusing if overused\nRequires careful design\n\nWhy limited use: We restrict it to where it provides genuine value—the top-level system classes that need both symbolic machinery and time-domain interfaces.\n\n\n\n\n2. TypedDict vs Dataclass\nDecision: Use TypedDict for results, not dataclass\n\n\n\n\n\n\nTipRationale\n\n\n\nPros:\n\nCompatible with plain dictionaries (gradual typing)\nNo runtime overhead\nWorks with JSON serialization\n\nCons:\n\nNot as pythonic as dataclass\nNo default values (use total=False instead)\n\nWhy TypedDict: Integration results come from external libraries (scipy, etc.) as dictionaries. TypedDict lets us type them without conversion.\n\n\n\n\n3. Backend Support\nDecision: Support NumPy, PyTorch, JAX (not TensorFlow)\n\n\n\nBackend\nRationale\n\n\n\n\nNumPy\nUniversal, stable, CPU\n\n\nPyTorch\nNeural networks, GPU, mature ecosystem\n\n\nJAX\nFunctional, JIT, XLA, research-friendly\n\n\nTensorFlow\n✗ Skipped due to complexity, declining use in research\n\n\n\nWhy these three: Cover 95% of use cases with minimal complexity.\n\n\n4. Symbolic Engine\nDecision: Use SymPy (not custom symbolic engine)\nRationale:\n\n✓ Mature, well-tested symbolic math\n✓ Excellent documentation\n✓ Large community\n✗ Can be slow for very large systems\n✗ Limited control over simplification\n\nWhy SymPy: Reinventing symbolic math is not our value proposition. SymPy is battle-tested.\n\n\n5. Testing Framework\nDecision: pytest (not unittest)\nRationale:\n\n✓ Less boilerplate\n✓ Better fixtures\n✓ Parametrized tests\n✓ Better assertions\n\nWhy pytest: Industry standard, developer-friendly.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-future",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-future",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Future Directions",
    "text": "Future Directions\n\nActive Development\nFeatures being implemented prior to release:\n\nClassical Control Theory\n\nStability, controllability, and observability metrics\nKalman Filter, Luenberger Observer design\nLinear Quadratic (Gaussian) Regulator control design\nCallable controllers\n\nVisualization\n\nPlotly-based interactive plotting\nTrajectory visualization across all variables\nPhase portrait visualization in 2D and 3D\n\n\n\n\nPlanned Features\n\nRL Environment Synthesis\n\nGymnasium library interface compatibility\nExport of Gymnasium environments from symbolic dynamics\n\nSynthetic Data Generation\n\nClasses and methods for generating synthetic physical data\nExport in standard formats\n\nParameter and Uncertainty Estimation\n\nSystem identification\nBayesian inference\nAdaptive control\nConformal methods\nSobol indices\nMorris screening\n\nNeural Controller Design\n\nProtocol interface for backend-agnostic functionality\nNeural controller training\nNeural certificate function construction and verification\n\nLyapunov, barrier, contraction metric\n\nForward and backward reachability analysis\n\nModel Predictive Control (MPC)\n\nReceding horizon optimization\nConstraint handling\nReal-time capable\nIntegration with do-mpc, CasADi, acados\n\nAdvanced Stochastic\n\nParticle filters\nStochastic MPC\nNoisy measurement models\nOther robust and/or stochastic control\n\nSystem Composition\n\nConnector protocol interfaces to couple multiple subsystems\n\n\n\n\nPotential Future Extensions\nLong-term possibilities:\n\nHybrid Systems\n\nSwitched dynamics\nHybrid automata\nJump/flow dynamics\n\nDistributed Systems\n\nMulti-agent dynamics\nNetwork topology\nConsensus protocols\n\nDelay Systems\n\nTime-delayed feedback\nDDE integration\nDelayed stability analysis\n\nPDE Systems\n\nSpatiotemporal dynamics\nFinite/discrete element methods\nSpectral methods",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-conclusion",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-conclusion",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Conclusion",
    "text": "Conclusion\nControlDESymulation demonstrates that mathematical rigor, software engineering excellence, and multi-backend performance are not competing goals—they are mutually reinforcing when built on a foundation of:\n\n\n\n\n\n\nImportantCore Design Principles\n\n\n\n\nType-Driven Design - Types are architecture\nComposition Over Inheritance - Build with utilities\nBackend Agnosticism - Write once, run anywhere\nZero Duplication - Strategic abstraction\nStructured Results - TypedDict everywhere\nProtocol Interfaces - Duck typing with safety\nFactory Patterns - Hide complexity\nSemantic Naming - Code reads like math\nProgressive Disclosure - Simple to complex\n\n\n\nThe result is a library where:\n\nControl theorists find familiar mathematics\nSoftware engineers find clean architecture\nML researchers find GPU acceleration\nStudents find gentle learning curves\nExperts find power and flexibility\n\nCode organized into 4 architectural layers, implementing 200+ types and 40+ integration methods—all serving a single vision: symbolic dynamical systems done right.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "architecture/cdesym_Design_Philosophy.html#sec-appendix",
    "href": "architecture/cdesym_Design_Philosophy.html#sec-appendix",
    "title": "ControlDESymulation: Design Philosophy and Architecture",
    "section": "Appendix: Statistics Summary",
    "text": "Appendix: Statistics Summary\n\nType Distribution\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nVector Types\n15+\nStateVector, ControlVector\n\n\nMatrix Types\n30+\nStateMatrix, GainMatrix\n\n\nFunction Types\n10+\nDynamicsFunction, ControlPolicy\n\n\nBackend Types\n20+\nBackend, Device, NoiseType\n\n\nTrajectory Types\n15+\nStateTrajectory, IntegrationResult\n\n\nLinearization Types\n15+\nDeterministicLinearization\n\n\nSymbolic Types\n10+\nSymbolicExpression\n\n\nProtocol Types\n20+\nDynamicalSystemProtocol\n\n\nUtility Types\n20+\nExecutionStats, TypeGuards\n\n\nTypedDict Results\n15+\nIntegrationResult\n\n\nTOTAL\n200+\nComplete type system\n\n\n\n\n\nIntegration Methods\n\n\n\nCategory\nCount\nExamples\n\n\n\n\nNumPy (scipy)\n6\nRK45, LSODA, BDF, Radau\n\n\nNumPy (Julia)\n20+\nTsit5, Vern9, Rodas5, AutoTsit5\n\n\nPyTorch\n8\ndopri5, dopri8, adaptive_heun\n\n\nJAX\n8\ntsit5, dopri5, heun, ralston\n\n\nFixed-step\n3\neuler, midpoint, rk4\n\n\nSDE Methods\n10+\neuler-maruyama, milstein, heun\n\n\nTOTAL\n55+\nComprehensive coverage\n\n\n\n\n\nDesign Patterns\n\n\n\nPattern\nCount\nWhere Used\n\n\n\n\nTemplate Method\n8\nAll system base classes\n\n\nFactory Method\n2\nIntegrator/SDE factories\n\n\nStrategy\n55+\nAll integration methods\n\n\nDependency Injection\n11\nAll delegation utilities\n\n\nLazy Initialization\n7\nCode generation, caching\n\n\nObserver\n5\nPerformance statistics\n\n\nProtocol\n20+\nAll structural interfaces\n\n\n\n\nThe numbers tell the story: a comprehensive, well-architected library built on solid design principles.",
    "crumbs": [
      "Framework Design",
      "ControlDESymulation: Design Philosophy and Architecture"
    ]
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-actual-problem",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-actual-problem",
    "title": "",
    "section": "The Actual Problem",
    "text": "The Actual Problem\nThe root cause was NOT in TorchSDEIntegrator - it was in dynamics_evaluator.py!\n\nError Message\nAttributeError: 'numpy.ndarray' object has no attribute 'unsqueeze'\nFile: dynamics_evaluator.py, line 364\n\n\nRoot Cause\nWhen using PyTorch or JAX backends with SDE integration:\n\nThe SDE wrapper’s f() method calls u_func(t, x) which returns:\n\nNone for autonomous systems\nnp.ndarray for controlled systems (from user’s control function)\n\nThis gets passed to sde_system.drift(x, u, backend='torch')\nWhich eventually calls _evaluate_torch(x, u)\nBut _evaluate_torch() expected u to already be a torch.Tensor!\nWhen it tried u.unsqueeze(0) on a numpy array → CRASH"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-fix",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#the-fix",
    "title": "",
    "section": "The Fix",
    "text": "The Fix\nAdded automatic type conversion at the start of _evaluate_torch() and _evaluate_jax():\n\nFor PyTorch (_evaluate_torch)\n# CRITICAL FIX: Convert inputs to torch tensors if needed\nimport torch\nimport numpy as np\n\n# Convert x if it's a numpy array\nif isinstance(x, np.ndarray):\n    x = torch.from_numpy(x).float()\n\n# Convert u if it's a numpy array, or create empty tensor if None\nif u is None:\n    # Autonomous system: create empty tensor\n    u = torch.tensor([], dtype=x.dtype, device=x.device)\nelif isinstance(u, np.ndarray):\n    # Convert numpy array to torch tensor with same dtype and device as x\n    u = torch.from_numpy(u).to(dtype=x.dtype, device=x.device)\n\n\nFor JAX (_evaluate_jax)\n# CRITICAL FIX: Convert inputs to jax arrays if needed\nimport jax.numpy as jnp\nimport numpy as np\n\nif isinstance(x, np.ndarray):\n    x = jnp.array(x)\n\n# Convert u if it's a numpy array, or create empty array if None\nif u is None:\n    # Autonomous system: create empty array\n    u = jnp.array([])\nelif isinstance(u, np.ndarray):\n    # Convert numpy array to jax array\n    u = jnp.array(u)"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#impact",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#impact",
    "title": "",
    "section": "Impact",
    "text": "Impact\nThis fix makes ALL of the following work correctly: - ✅ PyTorch SDE integration - ✅ JAX SDE integration - ✅ PyTorch ODE integration with numpy control functions - ✅ JAX ODE integration with numpy control functions - ✅ Autonomous systems (u=None) - ✅ Controlled systems with numpy arrays - ✅ Mixed backend workflows"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#why-this-happened",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#why-this-happened",
    "title": "",
    "section": "Why This Happened",
    "text": "Why This Happened\nThe code assumed that if backend='torch' was specified, then ALL inputs would already be torch tensors. But in practice:\n\nControl functions often return numpy arrays (natural for users)\nAutonomous systems pass None for control\nThe conversion from None → empty tensor was happening in evaluate() but not reaching _evaluate_torch() in all code paths"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#files-changed",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#files-changed",
    "title": "",
    "section": "Files Changed",
    "text": "Files Changed\ndynamics_evaluator.py: - Line ~315: Added type conversion for _evaluate_torch() - Line ~436: Added type conversion for _evaluate_jax() - Docstring: Added note about automatic type conversion"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#what-was-not-broken",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#what-was-not-broken",
    "title": "",
    "section": "What Was NOT Broken",
    "text": "What Was NOT Broken\n\nTorchSDEIntegrator: Actually works fine once inputs are correct types\nTime grid generation: Was creating 1001 points correctly\ntorchsde library: Works as expected"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#testing-recommendations",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#testing-recommendations",
    "title": "",
    "section": "Testing Recommendations",
    "text": "Testing Recommendations\nAfter applying this fix, test:\n# Test 1: Autonomous SDE with PyTorch\nsystem.set_default_backend('torch')\nresult = system.integrate(x0, u=None, t_span=(0, 10), method='euler', dt=0.01)\nassert result['x'].shape[0] &gt; 100  # Should get full trajectory\n\n# Test 2: Controlled SDE with numpy control function\ndef controller(t, x):\n    return np.array([0.5])  # Returns numpy!\n\nresult = system.integrate(x0, u=controller, t_span=(0, 10), method='euler', dt=0.01)\nassert result['x'].shape[0] &gt; 100\n\n# Test 3: Same tests with JAX backend\nsystem.set_default_backend('jax')\n# ... repeat tests"
  },
  {
    "objectID": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#summary",
    "href": "bug_fix_documentation/dynamics_evaluator_bug_fix_summary.html#summary",
    "title": "",
    "section": "Summary",
    "text": "Summary\nOne type conversion bug in dynamics_evaluator.py was breaking: - All PyTorch SDE integrations - All JAX SDE integrations\n- Any torch/jax usage with numpy control functions\nThe fix: 10 lines of type conversion code in 2 methods.\nResult: Entire PyTorch and JAX backends now work correctly for SDEs!"
  },
  {
    "objectID": "tutorials/core_concepts_continuous/batch_reactor_tutorial.html",
    "href": "tutorials/core_concepts_continuous/batch_reactor_tutorial.html",
    "title": "Anatomy of a Symbolic System",
    "section": "",
    "text": "TODO: add front matter describing the batch reactor system\n\n\nCode\nfrom typing import List, Optional, Tuple\n\nimport numpy as np\nimport sympy as sp\n\nfrom cdesym import ContinuousStochasticSystem\n\nclass ContinuousStochasticBatchReactor(ContinuousStochasticSystem):\n    def define_system(\n        self,\n        k1_val: float = 0.5,\n        k2_val: float = 0.3,\n        E1_val: float = 1000.0,\n        E2_val: float = 1500.0,\n        alpha_val: float = 0.1,\n        T_amb_val: float = 300.0,\n        sigma_A: float = 0.01,\n        sigma_B: float = 0.01,\n        sigma_T: float = 1.0,\n        C_A0: Optional[float] = None,\n        T0: Optional[float] = None,\n    ):\n        # Store initial conditions\n        self.C_A0 = C_A0\n        self.T0 = T0\n\n        # State and control variables\n        C_A, C_B, T = sp.symbols(\"C_A C_B T\", real=True, positive=True)\n        Q = sp.symbols(\"Q\", real=True)\n\n        # Parameters (kinetics and heat transfer)\n        k1, k2, E1, E2, alpha, T_amb = sp.symbols(\n            \"k1 k2 E1 E2 alpha T_amb\",\n            real=True,\n            positive=True,\n        )\n\n        # Noise intensities\n        sigma_A_sym = sp.symbols(\"sigma_A\", real=True, positive=True)\n        sigma_B_sym = sp.symbols(\"sigma_B\", real=True, positive=True)\n        sigma_T_sym = sp.symbols(\"sigma_T\", real=True, positive=True)\n\n        self.parameters = {\n            k1: k1_val,\n            k2: k2_val,\n            E1: E1_val,\n            E2: E2_val,\n            alpha: alpha_val,\n            T_amb: T_amb_val,\n            sigma_A_sym: sigma_A,\n            sigma_B_sym: sigma_B,\n            sigma_T_sym: sigma_T,\n        }\n\n        self.state_vars = [C_A, C_B, T]\n        self.control_vars = [Q]\n        self.output_vars = []\n        self.order = 1\n\n        # Reaction rates (Arrhenius kinetics)\n        r1 = k1 * C_A * sp.exp(-E1 / T)\n        r2 = k2 * C_B * sp.exp(-E2 / T)\n\n        # DRIFT (Deterministic part - same as deterministic reactor)\n        dC_A_dt = -r1\n        dC_B_dt = r1 - r2\n        dT_dt = Q - alpha * (T - T_amb)\n\n        self._f_sym = sp.Matrix([dC_A_dt, dC_B_dt, dT_dt])\n\n        # DIFFUSION (Stochastic part - additive noise)\n        # Diagonal matrix: three independent Wiener processes\n        self.diffusion_expr = sp.Matrix(\n            [\n                [sigma_A_sym, 0, 0],\n                [0, sigma_B_sym, 0],\n                [0, 0, sigma_T_sym],\n            ],\n        )\n\n        # Itô SDE interpretation\n        self.sde_type = \"ito\"\n\n        # Output: Full state measurement (with potential noise in practice)\n        # technically optional\n        self._h_sym = sp.Matrix([C_A, C_B, T])\n\n    def setup_equilibria(self):\n        # Get parameters\n        T_amb = self.parameters[sp.symbols(\"T_amb\")]\n\n        # Complete conversion equilibrium (deterministic part)\n        self.add_equilibrium(\n            \"complete\",\n            x_eq=np.array([0.0, 0.0, T_amb]),\n            u_eq=np.array([0.0]),\n            verify=True,\n            stability=\"stable\",\n            notes=\"Equilibrium of deterministic part (drift). Stochastic trajectories \"\n            \"fluctuate around this point with variance growing over time.\",\n        )\n\n        # Initial condition (if provided)\n        if self.C_A0 is not None and self.T0 is not None:\n            alpha = self.parameters[sp.symbols(\"alpha\")]\n            Q_init = alpha * (self.T0 - T_amb)\n\n            self.add_equilibrium(\n                \"initial\",\n                x_eq=np.array([self.C_A0, 0.0, self.T0]),\n                u_eq=np.array([Q_init]),\n                verify=False,\n                stability=\"unstable\",\n                notes=\"Initial state setpoint (deterministic part). Stochastic trajectories \"\n                \"will fluctuate with std ~ [σ_A·√t, σ_B·√t, σ_T·√t].\",\n            )\n            self.set_default_equilibrium(\"initial\")\n        else:\n            self.set_default_equilibrium(\"complete\")\n\n\nTODO: go stepwise over the definition of define system\nTODO: go over what is optional and what isn’t optional about deterministic systems\nTODO: clarify what output variables actually are, what they semantically mean, and what _h_sym is relative to _f_sym\nTODO: go over the added stochastic system mechanics and clarify that for pure diffusion systems the drift term _f_sym needs to be a zero vector\nTODO: go over Ito versus Stratonovich and types of noise\nTODO: go over the optional setup_equilibria method and why its there\nTODO: go over basic trajectory and phase plotting"
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html",
    "href": "tutorials/getting_started/basic_usage.html",
    "title": "Basic Usage",
    "section": "",
    "text": "This tutorial covers the basics of defining and simulating dynamical systems."
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html#sec-introduction",
    "href": "tutorials/getting_started/basic_usage.html#sec-introduction",
    "title": "Basic Usage",
    "section": "",
    "text": "This tutorial covers the basics of defining and simulating dynamical systems."
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html#sec-setting-up",
    "href": "tutorials/getting_started/basic_usage.html#sec-setting-up",
    "title": "Basic Usage",
    "section": "Setting Up",
    "text": "Setting Up\nFirst, import the necessary modules:\n\nimport numpy as np\nimport sympy as sp\nfrom cdesym import ContinuousSymbolicSystem\n\n# Set random seed for reproducibility\nnp.random.seed(42)"
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html#sec-defining-a-simple-system",
    "href": "tutorials/getting_started/basic_usage.html#sec-defining-a-simple-system",
    "title": "Basic Usage",
    "section": "Defining a Simple System",
    "text": "Defining a Simple System\nLet’s create a simple pendulum:\n\nclass SymbolicPendulum(ContinuousSymbolicSystem):\n    def define_system(\n        self,\n        m_val: float = 1.0,\n        l_val: float = 1.0,\n        beta_val: float = 1.0,\n        g_val: float = 9.81,\n    ):\n        \"\"\"First order model of a pendulum\"\"\"\n        # define the symbolic variables\n        theta, theta_dot = sp.symbols(\"theta theta_dot\", real=True)\n        u = sp.symbols(\"u\", real=True)\n        m, l, beta, g = sp.symbols(\"m l beta g\", real=True, positive=True)\n\n        # add the variables to the system fields properly\n        self.parameters = {m: m_val, l: l_val, beta: beta_val, g: g_val}\n        self.state_vars = [theta, theta_dot]\n        self.control_vars = [u]\n        self.order = 1\n\n        # define the dynamics of the system\n        ml2 = m * l * l\n        self._f_sym = sp.Matrix(\n            [theta_dot, (-beta / ml2) * theta_dot + (g / l) * sp.sin(theta) + u / ml2],\n        )\n        self._h_sym = sp.Matrix([theta])\n\n    def setup_equilibria(self):\n        # method to add equilibria to the system automatically after initialization\n\n        # add the stable equilibrium where the pendulum is hanging down\n        self.add_equilibrium(\n            'downward',\n            x_eq=np.array([0.0, 0.0]),\n            u_eq=np.array([0.0]),\n            verify=True\n            )\n\n        # add the unstable equilibrium where the pendulum is inverted\n        self.add_equilibrium(\n            'inverted',\n            x_eq=np.array([np.pi, 0.0]),\n            u_eq=np.array([0.0]),\n            stability='unstable',\n            notes='Requires active control'\n            )\n\n# Instantiate the system\npendulum = SymbolicPendulum()\n\n# Initial conditions\nx0 = np.array([1.0, 0.0])"
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html#sec-simulation",
    "href": "tutorials/getting_started/basic_usage.html#sec-simulation",
    "title": "Basic Usage",
    "section": "Simulation",
    "text": "Simulation\nNow simulate the system:\n\n# Integrate a trajectory with auto-selection of\n# relevant arguments\npendulum_integration_result = pendulum.integrate(\n        x0=x0,\n        t_span = (0.0, 20.0)\n    )\nfor k, v in pendulum_integration_result.items():\n    if k != \"x\" and k != \"t\":\n        print(k, \" : \", v)\n\nsuccess  :  True\nmessage  :  The solver successfully reached the end of the integration interval.\nnfev  :  1442\nnsteps  :  1442\nintegration_time  :  0.028922319412231445\nsolver  :  scipy.RK45\nnjev  :  0\nnlu  :  0\nstatus  :  0"
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html#sec-visualization",
    "href": "tutorials/getting_started/basic_usage.html#sec-visualization",
    "title": "Basic Usage",
    "section": "Visualization",
    "text": "Visualization\nPlot the trajectory in 2D:\n\nSTATE_NAMES = ['angle', 'angular velocity']\ntrajectory_plot = pendulum.plot(\n    result=pendulum_integration_result,\n    state_names = STATE_NAMES\n)\ntrajectory_plot.show()"
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html#sec-phase-portrait",
    "href": "tutorials/getting_started/basic_usage.html#sec-phase-portrait",
    "title": "Basic Usage",
    "section": "Phase Portrait",
    "text": "Phase Portrait\nPlot the 2D phase portrait\n\nupright_state, _ = pendulum.get_equilibrium('inverted')\ndownward_state, _ = pendulum.get_equilibrium('downward')\nphase_portrait = pendulum.phase_plotter.plot_2d(\n    x=pendulum_integration_result['x'],\n    state_names = STATE_NAMES,\n    show_direction = True,\n    equilibria=[upright_state, \n                downward_state]\n)\nphase_portrait.show()"
  },
  {
    "objectID": "tutorials/getting_started/basic_usage.html#sec-next-steps",
    "href": "tutorials/getting_started/basic_usage.html#sec-next-steps",
    "title": "Basic Usage",
    "section": "Next Steps",
    "text": "Next Steps\n\nLearn about stochastic systems not implemented\nExplore different backends not implemented\nSee advanced examples not implemented"
  }
]